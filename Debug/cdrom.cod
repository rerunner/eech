; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\system\cdrom.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?initialise_cdrom_system@@YGXXZ			; initialise_cdrom_system
PUBLIC	?check_cdrom_file_exists@@YGHPBD@Z		; check_cdrom_file_exists
PUBLIC	?capture_cd_audio_device@@YGHXZ			; capture_cd_audio_device
PUBLIC	?release_cd_audio_device@@YGXXZ			; release_cd_audio_device
PUBLIC	?play_cd_audio_track@@YGXH@Z			; play_cd_audio_track
PUBLIC	?play_one_shot_cd_audio_track@@YGXH@Z		; play_one_shot_cd_audio_track
PUBLIC	?pause_cd_audio@@YGXXZ				; pause_cd_audio
PUBLIC	?unpause_cd_audio@@YGXXZ			; unpause_cd_audio
PUBLIC	?stop_cd_audio@@YGXXZ				; stop_cd_audio
PUBLIC	?is_cd_audio_playing@@YGHXZ			; is_cd_audio_playing
PUBLIC	?check_cd_for_80_minutes@@YGHXZ			; check_cd_for_80_minutes
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_06CBKIPFEN@?$CFc?3?2?$CFs@		; `string'
PUBLIC	??_C@_04CGJNICGF@?$CFc?3?2@			; `string'
PUBLIC	??_C@_03CGGPNEOP@?$CFc?3@			; `string'
PUBLIC	??_C@_0BA@MCJBIGAP@CD?5Apache?5Havoc@		; `string'
PUBLIC	??_C@_0BL@KLAMIGIJ@Unable?5to?5capture?5cd?5audio@ ; `string'
PUBLIC	??_C@_0BO@IBIPOFMK@Unable?5to?5set?5cd?5audio?5format@ ; `string'
PUBLIC	??_C@_0BL@PACDEGAN@Unable?5to?5get?5track?5length@ ; `string'
PUBLIC	??_C@_0BC@NKFNPHOL@Unable?5to?5play?5cd@	; `string'
PUBLIC	??_C@_0BD@IDGBHAKB@Unable?5to?5pause?5cd@	; `string'
PUBLIC	??_C@_0BC@DHPJCBKA@Unable?5to?5stop?5cd@	; `string'
PUBLIC	??_C@_0CF@KFCEOGMO@Unable?5to?5get?5number?5of?5tracks?5@ ; `string'
PUBLIC	??_C@_0CM@DKBHJIHK@Unable?5to?5set?5the?5cd?5to?5millise@ ; `string'
PUBLIC	??_C@_0CM@LIKALIKI@Unable?5to?5get?5position?5of?5last?5@ ; `string'
PUBLIC	??_C@_0CK@OFPIJBBP@Unable?5to?5get?5length?5of?5last?5tr@ ; `string'
PUBLIC	??_C@_0DJ@NCPIKHP@Cd?5has?5?$CFd?5tracks?5?9?5last?5one?5sta@ ; `string'
PUBLIC	??_C@_0CL@IDFLCBBA@Unable?5to?5set?5the?5CD?5back?5to?5tr@ ; `string'
PUBLIC	??_C@_0CP@IGAELKBM@I?5figure?5the?5CD?5is?5?$CFd?5minutes?0?5@ ; `string'
PUBLIC	??_C@_0BO@JLMENIEI@Successful?3?5?$CFd?5minute?5long?5CD@ ; `string'
PUBLIC	??_C@_0BL@KPAKPBGP@Failure?3?5?$CFd?5minute?5long?5CD@ ; `string'
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_memset:PROC
EXTRN	__imp__GetDriveTypeA@4:PROC
EXTRN	__imp__mciSendCommandA@16:PROC
EXTRN	?register_exit_function@@YGXP6GXXZ@Z:PROC	; register_exit_function
EXTRN	?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z:PROC ; register_system_message_function
EXTRN	?debug_log@@YAXPBDZZ:PROC			; debug_log
EXTRN	?file_exist@@YGHPBD@Z:PROC			; file_exist
EXTRN	?system_thread_function@@YGHP6GHPAX@Z0@Z:PROC	; system_thread_function
EXTRN	?application_window@@3PAUHWND__@@A:DWORD	; application_window
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?cdrom_finder_initialised@@3HA DD 01H DUP (?)		; cdrom_finder_initialised
?number_of_cdrom_drives@@3HA DD 01H DUP (?)		; number_of_cdrom_drives
?cdrom_track_repeat@@3HA DD 01H DUP (?)			; cdrom_track_repeat
?cdrom_audio_track_playing@@3HA DD 01H DUP (?)		; cdrom_audio_track_playing
?cdrom_drives@@3PAHA DD 020H DUP (?)			; cdrom_drives
?cdrom_device_captured@@3HA DD 01H DUP (?)		; cdrom_device_captured
?cdrom_device_id@@3IA DD 01H DUP (?)			; cdrom_device_id
_BSS	ENDS
;	COMDAT ??_C@_0BL@KPAKPBGP@Failure?3?5?$CFd?5minute?5long?5CD@
CONST	SEGMENT
??_C@_0BL@KPAKPBGP@Failure?3?5?$CFd?5minute?5long?5CD@ DB 'Failure: %d mi'
	DB	'nute long CD', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JLMENIEI@Successful?3?5?$CFd?5minute?5long?5CD@
CONST	SEGMENT
??_C@_0BO@JLMENIEI@Successful?3?5?$CFd?5minute?5long?5CD@ DB 'Successful:'
	DB	' %d minute long CD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IGAELKBM@I?5figure?5the?5CD?5is?5?$CFd?5minutes?0?5@
CONST	SEGMENT
??_C@_0CP@IGAELKBM@I?5figure?5the?5CD?5is?5?$CFd?5minutes?0?5@ DB 'I figu'
	DB	're the CD is %d minutes, %d seconds long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IDFLCBBA@Unable?5to?5set?5the?5CD?5back?5to?5tr@
CONST	SEGMENT
??_C@_0CL@IDFLCBBA@Unable?5to?5set?5the?5CD?5back?5to?5tr@ DB 'Unable to '
	DB	'set the CD back to tracks format', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@NCPIKHP@Cd?5has?5?$CFd?5tracks?5?9?5last?5one?5sta@
CONST	SEGMENT
??_C@_0DJ@NCPIKHP@Cd?5has?5?$CFd?5tracks?5?9?5last?5one?5sta@ DB 'Cd has '
	DB	'%d tracks - last one starts at %d, and is %d long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OFPIJBBP@Unable?5to?5get?5length?5of?5last?5tr@
CONST	SEGMENT
??_C@_0CK@OFPIJBBP@Unable?5to?5get?5length?5of?5last?5tr@ DB 'Unable to g'
	DB	'et length of last track ( %d )', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LIKALIKI@Unable?5to?5get?5position?5of?5last?5@
CONST	SEGMENT
??_C@_0CM@LIKALIKI@Unable?5to?5get?5position?5of?5last?5@ DB 'Unable to g'
	DB	'et position of last track ( %d )', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DKBHJIHK@Unable?5to?5set?5the?5cd?5to?5millise@
CONST	SEGMENT
??_C@_0CM@DKBHJIHK@Unable?5to?5set?5the?5cd?5to?5millise@ DB 'Unable to s'
	DB	'et the cd to milliseconds format', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KFCEOGMO@Unable?5to?5get?5number?5of?5tracks?5@
CONST	SEGMENT
??_C@_0CF@KFCEOGMO@Unable?5to?5get?5number?5of?5tracks?5@ DB 'Unable to g'
	DB	'et number of tracks on CD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DHPJCBKA@Unable?5to?5stop?5cd@
CONST	SEGMENT
??_C@_0BC@DHPJCBKA@Unable?5to?5stop?5cd@ DB 'Unable to stop cd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IDGBHAKB@Unable?5to?5pause?5cd@
CONST	SEGMENT
??_C@_0BD@IDGBHAKB@Unable?5to?5pause?5cd@ DB 'Unable to pause cd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NKFNPHOL@Unable?5to?5play?5cd@
CONST	SEGMENT
??_C@_0BC@NKFNPHOL@Unable?5to?5play?5cd@ DB 'Unable to play cd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PACDEGAN@Unable?5to?5get?5track?5length@
CONST	SEGMENT
??_C@_0BL@PACDEGAN@Unable?5to?5get?5track?5length@ DB 'Unable to get trac'
	DB	'k length', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IBIPOFMK@Unable?5to?5set?5cd?5audio?5format@
CONST	SEGMENT
??_C@_0BO@IBIPOFMK@Unable?5to?5set?5cd?5audio?5format@ DB 'Unable to set '
	DB	'cd audio format', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KLAMIGIJ@Unable?5to?5capture?5cd?5audio@
CONST	SEGMENT
??_C@_0BL@KLAMIGIJ@Unable?5to?5capture?5cd?5audio@ DB 'Unable to capture '
	DB	'cd audio', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MCJBIGAP@CD?5Apache?5Havoc@
CONST	SEGMENT
??_C@_0BA@MCJBIGAP@CD?5Apache?5Havoc@ DB 'CD Apache Havoc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03CGGPNEOP@?$CFc?3@
CONST	SEGMENT
??_C@_03CGGPNEOP@?$CFc?3@ DB '%c:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGJNICGF@?$CFc?3?2@
CONST	SEGMENT
??_C@_04CGJNICGF@?$CFc?3?2@ DB '%c:\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CBKIPFEN@?$CFc?3?2?$CFs@
CONST	SEGMENT
??_C@_06CBKIPFEN@?$CFc?3?2?$CFs@ DB '%c:\%s', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?cdrom_track_playing@@3HA DD 0ffffffffH			; cdrom_track_playing
?cdrom_file_drive_index@@3HA DD 0ffffffffH		; cdrom_file_drive_index
_DATA	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?cdrom_notification_routine@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_frames$1 = -44						; size = 4
_seconds$2 = -40					; size = 4
_minutes$3 = -36					; size = 4
_value$4 = -32						; size = 4
_status_parameters$5 = -28				; size = 16
_play_parameters$6 = -12				; size = 12
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?cdrom_notification_routine@@YGJPAUHWND__@@IIJ@Z PROC	; cdrom_notification_routine, COMDAT

; 532  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 533  : 
; 534  : 	if ( cdrom_track_repeat )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?cdrom_track_repeat@@3HA, 0
  00010	0f 84 b2 00 00
	00		 je	 $LN2@cdrom_noti

; 535  : 	{
; 536  : 
; 537  : 		MCI_PLAY_PARMS
; 538  : 			play_parameters;
; 539  : 
; 540  : 		MCI_STATUS_PARMS
; 541  : 			status_parameters;
; 542  : 
; 543  : 		DWORD
; 544  : 			value;
; 545  : 
; 546  : 		status_parameters.dwItem = MCI_STATUS_LENGTH;

  00016	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _status_parameters$5[ebp+8], 1

; 547  : 		status_parameters.dwTrack = cdrom_track_playing;

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cdrom_track_playing@@3HA
  00022	89 45 f0	 mov	 DWORD PTR _status_parameters$5[ebp+12], eax

; 548  : 
; 549  : 		value = mciSendCommand ( cdrom_device_id, MCI_STATUS, ( MCI_TRACK | MCI_STATUS_ITEM ), ( DWORD ) ( LPVOID ) &status_parameters );

  00025	8d 45 e4	 lea	 eax, DWORD PTR _status_parameters$5[ebp]
  00028	50		 push	 eax
  00029	68 10 01 00 00	 push	 272			; 00000110H
  0002e	68 14 08 00 00	 push	 2068			; 00000814H
  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cdrom_device_id@@3IA
  00039	51		 push	 ecx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  00040	89 45 e0	 mov	 DWORD PTR _value$4[ebp], eax

; 550  : 
; 551  : 		if ( !value )

  00043	83 7d e0 00	 cmp	 DWORD PTR _value$4[ebp], 0
  00047	75 7d		 jne	 SHORT $LN4@cdrom_noti

; 552  : 		{
; 553  : 
; 554  : 			int
; 555  : 				minutes,
; 556  : 				seconds,
; 557  : 				frames;
; 558  : 	
; 559  : 			minutes = MCI_MSF_MINUTE ( status_parameters.dwReturn ),

  00049	0f b6 45 e8	 movzx	 eax, BYTE PTR _status_parameters$5[ebp+4]
  0004d	89 45 dc	 mov	 DWORD PTR _minutes$3[ebp], eax
  00050	0f b7 4d e8	 movzx	 ecx, WORD PTR _status_parameters$5[ebp+4]
  00054	c1 f9 08	 sar	 ecx, 8
  00057	0f b6 d1	 movzx	 edx, cl
  0005a	89 55 d8	 mov	 DWORD PTR _seconds$2[ebp], edx
  0005d	8b 45 e8	 mov	 eax, DWORD PTR _status_parameters$5[ebp+4]
  00060	c1 e8 10	 shr	 eax, 16			; 00000010H
  00063	0f b6 c8	 movzx	 ecx, al
  00066	89 4d d4	 mov	 DWORD PTR _frames$1[ebp], ecx
  00069	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _play_parameters$6[ebp+4], 0

; 560  : 			seconds = MCI_MSF_SECOND ( status_parameters.dwReturn ),
; 561  : 			frames = MCI_MSF_FRAME ( status_parameters.dwReturn ),
; 562  : 	
; 563  : 			play_parameters.dwFrom = 0;
; 564  : 			play_parameters.dwTo = 0;

  00070	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _play_parameters$6[ebp+8], 0

; 565  : 			play_parameters.dwFrom = MCI_MAKE_TMSF ( cdrom_track_playing, 0, 0, 0 );

  00077	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?cdrom_track_playing@@3HA
  0007e	89 45 f8	 mov	 DWORD PTR _play_parameters$6[ebp+4], eax

; 566  : 			play_parameters.dwTo = MCI_MAKE_TMSF ( cdrom_track_playing, minutes, seconds, frames );

  00081	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?cdrom_track_playing@@3HA
  00088	0f b7 4d dc	 movzx	 ecx, WORD PTR _minutes$3[ebp]
  0008c	c1 e1 08	 shl	 ecx, 8
  0008f	0b c1		 or	 eax, ecx
  00091	0f b6 55 d8	 movzx	 edx, BYTE PTR _seconds$2[ebp]
  00095	0f b7 4d d4	 movzx	 ecx, WORD PTR _frames$1[ebp]
  00099	c1 e1 08	 shl	 ecx, 8
  0009c	0b d1		 or	 edx, ecx
  0009e	c1 e2 10	 shl	 edx, 16			; 00000010H
  000a1	0b c2		 or	 eax, edx
  000a3	89 45 fc	 mov	 DWORD PTR _play_parameters$6[ebp+8], eax

; 567  : 			play_parameters.dwCallback = ( DWORD ) application_window;

  000a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  000ab	89 45 f4	 mov	 DWORD PTR _play_parameters$6[ebp], eax

; 568  : 	
; 569  : 			mciSendCommand ( cdrom_device_id, MCI_PLAY, ( MCI_FROM | MCI_TO | MCI_NOTIFY ), ( DWORD ) ( LPVOID ) &play_parameters );

  000ae	8d 45 f4	 lea	 eax, DWORD PTR _play_parameters$6[ebp]
  000b1	50		 push	 eax
  000b2	6a 0d		 push	 13			; 0000000dH
  000b4	68 06 08 00 00	 push	 2054			; 00000806H
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cdrom_device_id@@3IA
  000bf	51		 push	 ecx
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
$LN4@cdrom_noti:

; 570  : 		}
; 571  : 	}
; 572  : 	else

  000c6	eb 0a		 jmp	 SHORT $LN3@cdrom_noti
$LN2@cdrom_noti:

; 573  : 	{
; 574  : 
; 575  : 		cdrom_audio_track_playing = FALSE;

  000c8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?cdrom_audio_track_playing@@3HA, 0
$LN3@cdrom_noti:

; 576  : 	}
; 577  : 
; 578  : 	return ( TRUE );

  000d2	b8 01 00 00 00	 mov	 eax, 1

; 579  : }

  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 10 00	 ret	 16			; 00000010H
?cdrom_notification_routine@@YGJPAUHWND__@@IIJ@Z ENDP	; cdrom_notification_routine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?internal_play_cd_audio_track@@YGHPAX@Z
_TEXT	SEGMENT
_frames$1 = -48						; size = 4
_seconds$2 = -44					; size = 4
_minutes$3 = -40					; size = 4
_value$4 = -36						; size = 4
_status_parameters$5 = -32				; size = 16
_play_parameters$6 = -16				; size = 12
_track$ = -4						; size = 4
_data$ = 8						; size = 4
?internal_play_cd_audio_track@@YGHPAX@Z PROC		; internal_play_cd_audio_track, COMDAT

; 342  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 343  : 
; 344  : 	int
; 345  : 		track;
; 346  : 
; 347  : 	track = *( ( int * ) data );

  00009	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _track$[ebp], ecx

; 348  : 
; 349  : 	if ( cdrom_device_captured )

  00011	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?cdrom_device_captured@@3HA, 0
  00018	0f 84 e1 00 00
	00		 je	 $LN2@internal_p

; 350  : 	{
; 351  : 
; 352  : 		MCI_PLAY_PARMS
; 353  : 			play_parameters;
; 354  : 
; 355  : 		MCI_STATUS_PARMS
; 356  : 			status_parameters;
; 357  : 
; 358  : 		DWORD
; 359  : 			value;
; 360  : 
; 361  : 		status_parameters.dwItem = MCI_STATUS_LENGTH;

  0001e	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _status_parameters$5[ebp+8], 1

; 362  : 		status_parameters.dwTrack = track;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _track$[ebp]
  00028	89 45 ec	 mov	 DWORD PTR _status_parameters$5[ebp+12], eax

; 363  : 
; 364  : 		value = mciSendCommand ( cdrom_device_id, MCI_STATUS, ( MCI_TRACK | MCI_STATUS_ITEM ), ( DWORD ) ( LPVOID ) &status_parameters );

  0002b	8d 45 e0	 lea	 eax, DWORD PTR _status_parameters$5[ebp]
  0002e	50		 push	 eax
  0002f	68 10 01 00 00	 push	 272			; 00000110H
  00034	68 14 08 00 00	 push	 2068			; 00000814H
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cdrom_device_id@@3IA
  0003f	51		 push	 ecx
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  00046	89 45 dc	 mov	 DWORD PTR _value$4[ebp], eax

; 365  : 
; 366  : 		if ( value )

  00049	83 7d dc 00	 cmp	 DWORD PTR _value$4[ebp], 0
  0004d	74 12		 je	 SHORT $LN3@internal_p

; 367  : 		{
; 368  : 
; 369  : 			debug_log ( "Unable to get track length" );

  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@PACDEGAN@Unable?5to?5get?5track?5length@
  00054	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00059	83 c4 04	 add	 esp, 4

; 370  : 		}
; 371  : 		else

  0005c	e9 9e 00 00 00	 jmp	 $LN2@internal_p
$LN3@internal_p:

; 372  : 		{
; 373  : 
; 374  : 			int
; 375  : 				minutes,
; 376  : 				seconds,
; 377  : 				frames;
; 378  : 	
; 379  : 			minutes = MCI_MSF_MINUTE ( status_parameters.dwReturn ),

  00061	0f b6 45 e4	 movzx	 eax, BYTE PTR _status_parameters$5[ebp+4]
  00065	89 45 d8	 mov	 DWORD PTR _minutes$3[ebp], eax
  00068	0f b7 4d e4	 movzx	 ecx, WORD PTR _status_parameters$5[ebp+4]
  0006c	c1 f9 08	 sar	 ecx, 8
  0006f	0f b6 d1	 movzx	 edx, cl
  00072	89 55 d4	 mov	 DWORD PTR _seconds$2[ebp], edx
  00075	8b 45 e4	 mov	 eax, DWORD PTR _status_parameters$5[ebp+4]
  00078	c1 e8 10	 shr	 eax, 16			; 00000010H
  0007b	0f b6 c8	 movzx	 ecx, al
  0007e	89 4d d0	 mov	 DWORD PTR _frames$1[ebp], ecx
  00081	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _play_parameters$6[ebp+4], 0

; 380  : 			seconds = MCI_MSF_SECOND ( status_parameters.dwReturn ),
; 381  : 			frames = MCI_MSF_FRAME ( status_parameters.dwReturn ),
; 382  : 	
; 383  : 			play_parameters.dwFrom = 0;
; 384  : 			play_parameters.dwTo = 0;

  00088	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _play_parameters$6[ebp+8], 0

; 385  : 			play_parameters.dwFrom = MCI_MAKE_TMSF ( track, 0, 0, 0 );

  0008f	0f b6 45 fc	 movzx	 eax, BYTE PTR _track$[ebp]
  00093	89 45 f4	 mov	 DWORD PTR _play_parameters$6[ebp+4], eax

; 386  : 			play_parameters.dwTo = MCI_MAKE_TMSF ( track, minutes, seconds, frames );

  00096	0f b6 45 fc	 movzx	 eax, BYTE PTR _track$[ebp]
  0009a	0f b7 4d d8	 movzx	 ecx, WORD PTR _minutes$3[ebp]
  0009e	c1 e1 08	 shl	 ecx, 8
  000a1	0b c1		 or	 eax, ecx
  000a3	0f b6 55 d4	 movzx	 edx, BYTE PTR _seconds$2[ebp]
  000a7	0f b7 4d d0	 movzx	 ecx, WORD PTR _frames$1[ebp]
  000ab	c1 e1 08	 shl	 ecx, 8
  000ae	0b d1		 or	 edx, ecx
  000b0	c1 e2 10	 shl	 edx, 16			; 00000010H
  000b3	0b c2		 or	 eax, edx
  000b5	89 45 f8	 mov	 DWORD PTR _play_parameters$6[ebp+8], eax

; 387  : 			play_parameters.dwCallback = ( DWORD ) application_window;

  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  000bd	89 45 f0	 mov	 DWORD PTR _play_parameters$6[ebp], eax

; 388  : 	
; 389  : 			value = mciSendCommand ( cdrom_device_id, MCI_PLAY, ( MCI_FROM | MCI_TO | MCI_NOTIFY ), ( DWORD ) ( LPVOID ) &play_parameters );

  000c0	8d 45 f0	 lea	 eax, DWORD PTR _play_parameters$6[ebp]
  000c3	50		 push	 eax
  000c4	6a 0d		 push	 13			; 0000000dH
  000c6	68 06 08 00 00	 push	 2054			; 00000806H
  000cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cdrom_device_id@@3IA
  000d1	51		 push	 ecx
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  000d8	89 45 dc	 mov	 DWORD PTR _value$4[ebp], eax

; 390  : 	
; 391  : 			if ( value )

  000db	83 7d dc 00	 cmp	 DWORD PTR _value$4[ebp], 0
  000df	74 14		 je	 SHORT $LN5@internal_p

; 392  : 			{
; 393  : 	
; 394  : 				//
; 395  : 				// Ditch the cd player!
; 396  : 				//
; 397  : 	
; 398  : 				debug_log ( "Unable to play cd" );

  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NKFNPHOL@Unable?5to?5play?5cd@
  000e6	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  000eb	83 c4 04	 add	 esp, 4

; 399  : 	
; 400  : 				release_cd_audio_device ();

  000ee	e8 00 00 00 00	 call	 ?release_cd_audio_device@@YGXXZ ; release_cd_audio_device

; 401  : 			}
; 402  : 			else

  000f3	eb 0a		 jmp	 SHORT $LN2@internal_p
$LN5@internal_p:

; 403  : 			{
; 404  : 	
; 405  : 				cdrom_audio_track_playing = TRUE;

  000f5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?cdrom_audio_track_playing@@3HA, 1
$LN2@internal_p:

; 406  : 			}
; 407  : 		}
; 408  : 	}
; 409  : 
; 410  : 	return ( TRUE );

  000ff	b8 01 00 00 00	 mov	 eax, 1

; 411  : }

  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx
  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c2 04 00	 ret	 4
?internal_play_cd_audio_track@@YGHPAX@Z ENDP		; internal_play_cd_audio_track
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?initialise_cdrom_finder@@YGXXZ
_TEXT	SEGMENT
tv71 = -88						; size = 4
_letter$ = -20						; size = 4
_path$ = -16						; size = 16
?initialise_cdrom_finder@@YGXXZ PROC			; initialise_cdrom_finder, COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 148  : 
; 149  : 	char
; 150  : 		path[16];
; 151  : 
; 152  : 	int
; 153  : 		letter;
; 154  : 
; 155  : 	number_of_cdrom_drives = 0;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?number_of_cdrom_drives@@3HA, 0

; 156  : 
; 157  : 	for ( letter = 'A'; letter <= 'Z'; letter++ )

  00013	c7 45 ec 41 00
	00 00		 mov	 DWORD PTR _letter$[ebp], 65 ; 00000041H
  0001a	eb 09		 jmp	 SHORT $LN4@initialise
$LN2@initialise:
  0001c	8b 45 ec	 mov	 eax, DWORD PTR _letter$[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 ec	 mov	 DWORD PTR _letter$[ebp], eax
$LN4@initialise:
  00025	83 7d ec 5a	 cmp	 DWORD PTR _letter$[ebp], 90 ; 0000005aH
  00029	7f 48		 jg	 SHORT $LN3@initialise

; 158  : 	{
; 159  : 
; 160  : 		sprintf ( path, "%c:\\", letter );

  0002b	8b 45 ec	 mov	 eax, DWORD PTR _letter$[ebp]
  0002e	50		 push	 eax
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_04CGJNICGF@?$CFc?3?2@
  00034	8d 4d f0	 lea	 ecx, DWORD PTR _path$[ebp]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _sprintf
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 
; 162  : 		switch ( GetDriveType ( path ) )

  00040	8d 45 f0	 lea	 eax, DWORD PTR _path$[ebp]
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDriveTypeA@4
  0004a	89 45 a8	 mov	 DWORD PTR tv71[ebp], eax
  0004d	83 7d a8 05	 cmp	 DWORD PTR tv71[ebp], 5
  00051	74 02		 je	 SHORT $LN7@initialise
  00053	eb 1c		 jmp	 SHORT $LN5@initialise
$LN7@initialise:

; 163  : 		{
; 164  : 
; 165  : 			case DRIVE_CDROM:
; 166  : 			{
; 167  : 
; 168  : 				cdrom_drives[number_of_cdrom_drives] = letter;

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_cdrom_drives@@3HA
  0005a	8b 4d ec	 mov	 ecx, DWORD PTR _letter$[ebp]
  0005d	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?cdrom_drives@@3PAHA[eax*4], ecx

; 169  : 
; 170  : 				number_of_cdrom_drives++;

  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_cdrom_drives@@3HA
  00069	83 c0 01	 add	 eax, 1
  0006c	a3 00 00 00 00	 mov	 DWORD PTR ?number_of_cdrom_drives@@3HA, eax
$LN5@initialise:

; 171  : 
; 172  : 				break;
; 173  : 			}
; 174  : 		}
; 175  : 	}

  00071	eb a9		 jmp	 SHORT $LN2@initialise
$LN3@initialise:

; 176  : 
; 177  : 	cdrom_finder_initialised = TRUE;

  00073	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?cdrom_finder_initialised@@3HA, 1

; 178  : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
?initialise_cdrom_finder@@YGXXZ ENDP			; initialise_cdrom_finder
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?check_cd_for_80_minutes@@YGHXZ
_TEXT	SEGMENT
_set_parameters$1 = -52					; size = 12
_mciStatusParms$2 = -40					; size = 16
_second_cd_length$3 = -24				; size = 4
_minute_cd_length$4 = -20				; size = 4
_total_cd_length$5 = -16				; size = 4
_track_length$6 = -12					; size = 4
_starting_position$7 = -8				; size = 4
_number_of_tracks$8 = -4				; size = 4
?check_cd_for_80_minutes@@YGHXZ PROC			; check_cd_for_80_minutes, COMDAT

; 586  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 587  : 
; 588  : 	if ( cdrom_device_captured )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?cdrom_device_captured@@3HA, 0
  00010	0f 84 d7 01 00
	00		 je	 $LN2@check_cd_f

; 589  : 	{
; 590  : 
; 591  : 		int
; 592  : 			number_of_tracks,
; 593  : 			starting_position,
; 594  : 			track_length,
; 595  : 			total_cd_length,
; 596  : 			minute_cd_length,
; 597  : 			second_cd_length;
; 598  : 
; 599  : 		MCI_STATUS_PARMS
; 600  : 			mciStatusParms;
; 601  : 
; 602  : 		MCI_SET_PARMS
; 603  : 			set_parameters;
; 604  : 	
; 605  : 		//
; 606  : 		// Get the number of tracks; 
; 607  : 		//
; 608  : 
; 609  : 		mciStatusParms.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;

  00016	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _mciStatusParms$2[ebp+8], 3

; 610  : 
; 611  : 		if ( mciSendCommand ( cdrom_device_id, MCI_STATUS, MCI_STATUS_ITEM, (DWORD) (LPVOID) &mciStatusParms ) )

  0001d	8d 45 d8	 lea	 eax, DWORD PTR _mciStatusParms$2[ebp]
  00020	50		 push	 eax
  00021	68 00 01 00 00	 push	 256			; 00000100H
  00026	68 14 08 00 00	 push	 2068			; 00000814H
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cdrom_device_id@@3IA
  00031	51		 push	 ecx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  00038	85 c0		 test	 eax, eax
  0003a	74 14		 je	 SHORT $LN4@check_cd_f

; 612  : 		{
; 613  : 
; 614  : 			debug_log ( "Unable to get number of tracks on CD" );

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@KFCEOGMO@Unable?5to?5get?5number?5of?5tracks?5@
  00041	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00046	83 c4 04	 add	 esp, 4

; 615  : 
; 616  : 			return ( FALSE );

  00049	33 c0		 xor	 eax, eax
  0004b	e9 9f 01 00 00	 jmp	 $LN1@check_cd_f
$LN4@check_cd_f:

; 617  : 		}
; 618  : 
; 619  : 		number_of_tracks = mciStatusParms.dwReturn;

  00050	8b 45 dc	 mov	 eax, DWORD PTR _mciStatusParms$2[ebp+4]
  00053	89 45 fc	 mov	 DWORD PTR _number_of_tracks$8[ebp], eax

; 620  : 
; 621  : 		//
; 622  : 		// Now change the format of the CD to milliseconds
; 623  : 		//
; 624  : 
; 625  : 		//
; 626  : 		// Set the cdrom format to tracks/minutes/seconds/frames
; 627  : 		//
; 628  : 
; 629  : 		set_parameters.dwTimeFormat = MCI_FORMAT_MILLISECONDS;

  00056	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _set_parameters$1[ebp+4], 0

; 630  : 
; 631  : 		if ( mciSendCommand ( cdrom_device_id, MCI_SET, MCI_SET_TIME_FORMAT, ( DWORD ) ( LPVOID ) &set_parameters ) )

  0005d	8d 45 cc	 lea	 eax, DWORD PTR _set_parameters$1[ebp]
  00060	50		 push	 eax
  00061	68 00 04 00 00	 push	 1024			; 00000400H
  00066	68 0d 08 00 00	 push	 2061			; 0000080dH
  0006b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cdrom_device_id@@3IA
  00071	51		 push	 ecx
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  00078	85 c0		 test	 eax, eax
  0007a	74 14		 je	 SHORT $LN5@check_cd_f

; 632  : 		{
; 633  : 
; 634  : 			debug_log ( "Unable to set the cd to milliseconds format" );

  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@DKBHJIHK@Unable?5to?5set?5the?5cd?5to?5millise@
  00081	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00086	83 c4 04	 add	 esp, 4

; 635  : 
; 636  : 			return ( FALSE );

  00089	33 c0		 xor	 eax, eax
  0008b	e9 5f 01 00 00	 jmp	 $LN1@check_cd_f
$LN5@check_cd_f:

; 637  : 		}
; 638  : 
; 639  : 		//
; 640  : 		// Get the starting position of the last track
; 641  : 		//
; 642  : 
; 643  : 		mciStatusParms.dwItem = MCI_STATUS_POSITION;

  00090	c7 45 e0 02 00
	00 00		 mov	 DWORD PTR _mciStatusParms$2[ebp+8], 2

; 644  : 
; 645  : 		mciStatusParms.dwTrack = number_of_tracks;

  00097	8b 45 fc	 mov	 eax, DWORD PTR _number_of_tracks$8[ebp]
  0009a	89 45 e4	 mov	 DWORD PTR _mciStatusParms$2[ebp+12], eax

; 646  : 
; 647  : 		if ( mciSendCommand ( cdrom_device_id, MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK, ( DWORD ) ( LPVOID ) &mciStatusParms ) )

  0009d	8d 45 d8	 lea	 eax, DWORD PTR _mciStatusParms$2[ebp]
  000a0	50		 push	 eax
  000a1	68 10 01 00 00	 push	 272			; 00000110H
  000a6	68 14 08 00 00	 push	 2068			; 00000814H
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cdrom_device_id@@3IA
  000b1	51		 push	 ecx
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  000b8	85 c0		 test	 eax, eax
  000ba	74 18		 je	 SHORT $LN6@check_cd_f

; 648  : 		{
; 649  : 
; 650  : 			debug_log ( "Unable to get position of last track ( %d )", number_of_tracks );

  000bc	8b 45 fc	 mov	 eax, DWORD PTR _number_of_tracks$8[ebp]
  000bf	50		 push	 eax
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LIKALIKI@Unable?5to?5get?5position?5of?5last?5@
  000c5	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  000ca	83 c4 08	 add	 esp, 8

; 651  : 
; 652  : 			return ( FALSE );

  000cd	33 c0		 xor	 eax, eax
  000cf	e9 1b 01 00 00	 jmp	 $LN1@check_cd_f
$LN6@check_cd_f:

; 653  : 		}
; 654  : 
; 655  : 		starting_position = mciStatusParms.dwReturn;

  000d4	8b 45 dc	 mov	 eax, DWORD PTR _mciStatusParms$2[ebp+4]
  000d7	89 45 f8	 mov	 DWORD PTR _starting_position$7[ebp], eax

; 656  : 
; 657  : 		//
; 658  : 		// Get the length of the last track
; 659  : 		//
; 660  : 
; 661  : 		mciStatusParms.dwItem = MCI_STATUS_LENGTH;

  000da	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _mciStatusParms$2[ebp+8], 1

; 662  : 
; 663  : 		mciStatusParms.dwTrack = number_of_tracks;

  000e1	8b 45 fc	 mov	 eax, DWORD PTR _number_of_tracks$8[ebp]
  000e4	89 45 e4	 mov	 DWORD PTR _mciStatusParms$2[ebp+12], eax

; 664  : 
; 665  : 		if ( mciSendCommand ( cdrom_device_id, MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK, ( DWORD ) ( LPVOID ) &mciStatusParms ) )

  000e7	8d 45 d8	 lea	 eax, DWORD PTR _mciStatusParms$2[ebp]
  000ea	50		 push	 eax
  000eb	68 10 01 00 00	 push	 272			; 00000110H
  000f0	68 14 08 00 00	 push	 2068			; 00000814H
  000f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cdrom_device_id@@3IA
  000fb	51		 push	 ecx
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  00102	85 c0		 test	 eax, eax
  00104	74 18		 je	 SHORT $LN7@check_cd_f

; 666  : 		{
; 667  : 
; 668  : 			debug_log ( "Unable to get length of last track ( %d )", number_of_tracks );

  00106	8b 45 fc	 mov	 eax, DWORD PTR _number_of_tracks$8[ebp]
  00109	50		 push	 eax
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@OFPIJBBP@Unable?5to?5get?5length?5of?5last?5tr@
  0010f	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00114	83 c4 08	 add	 esp, 8

; 669  : 
; 670  : 			return ( FALSE );

  00117	33 c0		 xor	 eax, eax
  00119	e9 d1 00 00 00	 jmp	 $LN1@check_cd_f
$LN7@check_cd_f:

; 671  : 		}
; 672  : 
; 673  : 		track_length = mciStatusParms.dwReturn;

  0011e	8b 45 dc	 mov	 eax, DWORD PTR _mciStatusParms$2[ebp+4]
  00121	89 45 f4	 mov	 DWORD PTR _track_length$6[ebp], eax

; 674  : 
; 675  : 		debug_log ( "Cd has %d tracks - last one starts at %d, and is %d long", number_of_tracks, starting_position, track_length );

  00124	8b 45 f4	 mov	 eax, DWORD PTR _track_length$6[ebp]
  00127	50		 push	 eax
  00128	8b 4d f8	 mov	 ecx, DWORD PTR _starting_position$7[ebp]
  0012b	51		 push	 ecx
  0012c	8b 55 fc	 mov	 edx, DWORD PTR _number_of_tracks$8[ebp]
  0012f	52		 push	 edx
  00130	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@NCPIKHP@Cd?5has?5?$CFd?5tracks?5?9?5last?5one?5sta@
  00135	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0013a	83 c4 10	 add	 esp, 16			; 00000010H

; 676  : 
; 677  : 		//
; 678  : 		// Set the cdrom format to tracks/minutes/seconds/frames
; 679  : 		//
; 680  : 
; 681  : 		set_parameters.dwTimeFormat = MCI_FORMAT_TMSF;

  0013d	c7 45 d0 0a 00
	00 00		 mov	 DWORD PTR _set_parameters$1[ebp+4], 10 ; 0000000aH

; 682  : 
; 683  : 		if ( mciSendCommand ( cdrom_device_id, MCI_SET, MCI_SET_TIME_FORMAT, ( DWORD ) ( LPVOID ) &set_parameters ) )

  00144	8d 45 cc	 lea	 eax, DWORD PTR _set_parameters$1[ebp]
  00147	50		 push	 eax
  00148	68 00 04 00 00	 push	 1024			; 00000400H
  0014d	68 0d 08 00 00	 push	 2061			; 0000080dH
  00152	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cdrom_device_id@@3IA
  00158	51		 push	 ecx
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  0015f	85 c0		 test	 eax, eax
  00161	74 0d		 je	 SHORT $LN8@check_cd_f

; 684  : 		{
; 685  : 
; 686  : 			debug_log ( "Unable to set the CD back to tracks format" );

  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@IDFLCBBA@Unable?5to?5set?5the?5CD?5back?5to?5tr@
  00168	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0016d	83 c4 04	 add	 esp, 4
$LN8@check_cd_f:

; 687  : 		}
; 688  : 
; 689  : 		//
; 690  : 		// Now calculate the end time of the CD
; 691  : 		//
; 692  : 
; 693  : 		total_cd_length = starting_position + track_length;

  00170	8b 45 f8	 mov	 eax, DWORD PTR _starting_position$7[ebp]
  00173	03 45 f4	 add	 eax, DWORD PTR _track_length$6[ebp]
  00176	89 45 f0	 mov	 DWORD PTR _total_cd_length$5[ebp], eax

; 694  : 
; 695  : 		total_cd_length /= 1000;

  00179	8b 45 f0	 mov	 eax, DWORD PTR _total_cd_length$5[ebp]
  0017c	99		 cdq
  0017d	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00182	f7 f9		 idiv	 ecx
  00184	89 45 f0	 mov	 DWORD PTR _total_cd_length$5[ebp], eax

; 696  : 
; 697  : 		minute_cd_length = total_cd_length / 60;

  00187	8b 45 f0	 mov	 eax, DWORD PTR _total_cd_length$5[ebp]
  0018a	99		 cdq
  0018b	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00190	f7 f9		 idiv	 ecx
  00192	89 45 ec	 mov	 DWORD PTR _minute_cd_length$4[ebp], eax

; 698  : 
; 699  : 		second_cd_length = total_cd_length - ( minute_cd_length * 60 );

  00195	6b 45 ec 3c	 imul	 eax, DWORD PTR _minute_cd_length$4[ebp], 60
  00199	8b 4d f0	 mov	 ecx, DWORD PTR _total_cd_length$5[ebp]
  0019c	2b c8		 sub	 ecx, eax
  0019e	89 4d e8	 mov	 DWORD PTR _second_cd_length$3[ebp], ecx

; 700  : 
; 701  : 		debug_log ( "I figure the CD is %d minutes, %d seconds long", minute_cd_length, second_cd_length );

  001a1	8b 45 e8	 mov	 eax, DWORD PTR _second_cd_length$3[ebp]
  001a4	50		 push	 eax
  001a5	8b 4d ec	 mov	 ecx, DWORD PTR _minute_cd_length$4[ebp]
  001a8	51		 push	 ecx
  001a9	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@IGAELKBM@I?5figure?5the?5CD?5is?5?$CFd?5minutes?0?5@
  001ae	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 702  : 
; 703  : 		if ( minute_cd_length >= 75 )

  001b6	83 7d ec 4b	 cmp	 DWORD PTR _minute_cd_length$4[ebp], 75 ; 0000004bH
  001ba	7c 1a		 jl	 SHORT $LN9@check_cd_f

; 704  : 		{
; 705  : 
; 706  : 			debug_log ( "Successful: %d minute long CD", total_cd_length );

  001bc	8b 45 f0	 mov	 eax, DWORD PTR _total_cd_length$5[ebp]
  001bf	50		 push	 eax
  001c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@JLMENIEI@Successful?3?5?$CFd?5minute?5long?5CD@
  001c5	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  001ca	83 c4 08	 add	 esp, 8

; 707  : 
; 708  : 			return ( TRUE );

  001cd	b8 01 00 00 00	 mov	 eax, 1
  001d2	eb 1b		 jmp	 SHORT $LN1@check_cd_f

; 709  : 		}
; 710  : 		else

  001d4	eb 15		 jmp	 SHORT $LN10@check_cd_f
$LN9@check_cd_f:

; 711  : 		{
; 712  : 	
; 713  : 			debug_log ( "Failure: %d minute long CD", total_cd_length );

  001d6	8b 45 f0	 mov	 eax, DWORD PTR _total_cd_length$5[ebp]
  001d9	50		 push	 eax
  001da	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KPAKPBGP@Failure?3?5?$CFd?5minute?5long?5CD@
  001df	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  001e4	83 c4 08	 add	 esp, 8

; 714  : 
; 715  : 			return ( FALSE );

  001e7	33 c0		 xor	 eax, eax
  001e9	eb 04		 jmp	 SHORT $LN1@check_cd_f
$LN10@check_cd_f:

; 716  : 		}
; 717  : 	}
; 718  : 	else

  001eb	eb 02		 jmp	 SHORT $LN1@check_cd_f
$LN2@check_cd_f:

; 719  : 	{
; 720  : 
; 721  : 		return ( FALSE );

  001ed	33 c0		 xor	 eax, eax
$LN1@check_cd_f:

; 722  : 	}
; 723  : }

  001ef	5f		 pop	 edi
  001f0	5e		 pop	 esi
  001f1	5b		 pop	 ebx
  001f2	8b e5		 mov	 esp, ebp
  001f4	5d		 pop	 ebp
  001f5	c3		 ret	 0
?check_cd_for_80_minutes@@YGHXZ ENDP			; check_cd_for_80_minutes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?is_cd_audio_playing@@YGHXZ
_TEXT	SEGMENT
?is_cd_audio_playing@@YGHXZ PROC			; is_cd_audio_playing, COMDAT

; 522  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 523  : 
; 524  : 	return ( cdrom_audio_track_playing );

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cdrom_audio_track_playing@@3HA

; 525  : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?is_cd_audio_playing@@YGHXZ ENDP			; is_cd_audio_playing
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?stop_cd_audio@@YGXXZ
_TEXT	SEGMENT
_value$1 = -16						; size = 4
_stop_parameters$2 = -12				; size = 12
?stop_cd_audio@@YGXXZ PROC				; stop_cd_audio, COMDAT

; 486  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 487  : 
; 488  : 	if ( cdrom_device_captured )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?cdrom_device_captured@@3HA, 0
  00010	74 44		 je	 SHORT $LN1@stop_cd_au

; 489  : 	{
; 490  : 
; 491  : 		MCI_PLAY_PARMS
; 492  : 			stop_parameters;
; 493  : 
; 494  : 		DWORD
; 495  : 			value;
; 496  : 	
; 497  : 		stop_parameters.dwCallback = 0;

  00012	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _stop_parameters$2[ebp], 0

; 498  : 
; 499  : 		cdrom_track_repeat = FALSE;

  00019	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?cdrom_track_repeat@@3HA, 0

; 500  : 
; 501  : 		value = mciSendCommand ( cdrom_device_id, MCI_PAUSE, 0, ( DWORD ) ( LPVOID ) &stop_parameters );

  00023	8d 45 f4	 lea	 eax, DWORD PTR _stop_parameters$2[ebp]
  00026	50		 push	 eax
  00027	6a 00		 push	 0
  00029	68 09 08 00 00	 push	 2057			; 00000809H
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cdrom_device_id@@3IA
  00034	51		 push	 ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  0003b	89 45 f0	 mov	 DWORD PTR _value$1[ebp], eax

; 502  : 
; 503  : 		if ( value )

  0003e	83 7d f0 00	 cmp	 DWORD PTR _value$1[ebp], 0
  00042	74 12		 je	 SHORT $LN1@stop_cd_au

; 504  : 		{
; 505  : 
; 506  : 			//
; 507  : 			// Ditch the cd player!
; 508  : 			//
; 509  : 
; 510  : 			debug_log ( "Unable to stop cd" );

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DHPJCBKA@Unable?5to?5stop?5cd@
  00049	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0004e	83 c4 04	 add	 esp, 4

; 511  : 
; 512  : 			release_cd_audio_device ();

  00051	e8 00 00 00 00	 call	 ?release_cd_audio_device@@YGXXZ ; release_cd_audio_device
$LN1@stop_cd_au:

; 513  : 		}
; 514  : 	}
; 515  : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?stop_cd_audio@@YGXXZ ENDP				; stop_cd_audio
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?unpause_cd_audio@@YGXXZ
_TEXT	SEGMENT
_value$1 = -16						; size = 4
_pause_parameters$2 = -12				; size = 12
?unpause_cd_audio@@YGXXZ PROC				; unpause_cd_audio, COMDAT

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 453  : 
; 454  : 	if ( cdrom_device_captured )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?cdrom_device_captured@@3HA, 0
  00010	74 3a		 je	 SHORT $LN1@unpause_cd

; 455  : 	{
; 456  : 
; 457  : 		MCI_PLAY_PARMS
; 458  : 			pause_parameters;
; 459  : 
; 460  : 		DWORD
; 461  : 			value;
; 462  : 	
; 463  : 		pause_parameters.dwCallback = 0;

  00012	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pause_parameters$2[ebp], 0

; 464  : 
; 465  : 		value = mciSendCommand ( cdrom_device_id, MCI_PLAY, 0, ( DWORD ) ( LPVOID ) &pause_parameters );

  00019	8d 45 f4	 lea	 eax, DWORD PTR _pause_parameters$2[ebp]
  0001c	50		 push	 eax
  0001d	6a 00		 push	 0
  0001f	68 06 08 00 00	 push	 2054			; 00000806H
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cdrom_device_id@@3IA
  0002a	51		 push	 ecx
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  00031	89 45 f0	 mov	 DWORD PTR _value$1[ebp], eax

; 466  : 
; 467  : 		if ( value )

  00034	83 7d f0 00	 cmp	 DWORD PTR _value$1[ebp], 0
  00038	74 12		 je	 SHORT $LN1@unpause_cd

; 468  : 		{
; 469  : 
; 470  : 			//
; 471  : 			// Ditch the cd player!
; 472  : 			//
; 473  : 
; 474  : 			debug_log ( "Unable to pause cd" );

  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@IDGBHAKB@Unable?5to?5pause?5cd@
  0003f	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00044	83 c4 04	 add	 esp, 4

; 475  : 
; 476  : 			release_cd_audio_device ();

  00047	e8 00 00 00 00	 call	 ?release_cd_audio_device@@YGXXZ ; release_cd_audio_device
$LN1@unpause_cd:

; 477  : 		}
; 478  : 	}
; 479  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?unpause_cd_audio@@YGXXZ ENDP				; unpause_cd_audio
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?pause_cd_audio@@YGXXZ
_TEXT	SEGMENT
_value$1 = -16						; size = 4
_pause_parameters$2 = -12				; size = 12
?pause_cd_audio@@YGXXZ PROC				; pause_cd_audio, COMDAT

; 418  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 419  : 
; 420  : 	if ( cdrom_device_captured )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?cdrom_device_captured@@3HA, 0
  00010	74 3a		 je	 SHORT $LN1@pause_cd_a

; 421  : 	{
; 422  : 
; 423  : 		MCI_PLAY_PARMS
; 424  : 			pause_parameters;
; 425  : 
; 426  : 		DWORD
; 427  : 			value;
; 428  : 	
; 429  : 		pause_parameters.dwCallback = 0;

  00012	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pause_parameters$2[ebp], 0

; 430  : 
; 431  : 		value = mciSendCommand ( cdrom_device_id, MCI_PAUSE, 0, ( DWORD ) ( LPVOID ) &pause_parameters );

  00019	8d 45 f4	 lea	 eax, DWORD PTR _pause_parameters$2[ebp]
  0001c	50		 push	 eax
  0001d	6a 00		 push	 0
  0001f	68 09 08 00 00	 push	 2057			; 00000809H
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cdrom_device_id@@3IA
  0002a	51		 push	 ecx
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  00031	89 45 f0	 mov	 DWORD PTR _value$1[ebp], eax

; 432  : 
; 433  : 		if ( value )

  00034	83 7d f0 00	 cmp	 DWORD PTR _value$1[ebp], 0
  00038	74 12		 je	 SHORT $LN1@pause_cd_a

; 434  : 		{
; 435  : 
; 436  : 			//
; 437  : 			// Ditch the cd player!
; 438  : 			//
; 439  : 
; 440  : 			debug_log ( "Unable to pause cd" );

  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@IDGBHAKB@Unable?5to?5pause?5cd@
  0003f	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00044	83 c4 04	 add	 esp, 4

; 441  : 
; 442  : 			release_cd_audio_device ();

  00047	e8 00 00 00 00	 call	 ?release_cd_audio_device@@YGXXZ ; release_cd_audio_device
$LN1@pause_cd_a:

; 443  : 		}
; 444  : 	}
; 445  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?pause_cd_audio@@YGXXZ ENDP				; pause_cd_audio
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?play_one_shot_cd_audio_track@@YGXH@Z
_TEXT	SEGMENT
_track$ = 8						; size = 4
?play_one_shot_cd_audio_track@@YGXH@Z PROC		; play_one_shot_cd_audio_track, COMDAT

; 326  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 327  : 
; 328  : 	cdrom_track_repeat = FALSE;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?cdrom_track_repeat@@3HA, 0

; 329  : 
; 330  : 	cdrom_track_playing = track;

  00013	8b 45 08	 mov	 eax, DWORD PTR _track$[ebp]
  00016	a3 00 00 00 00	 mov	 DWORD PTR ?cdrom_track_playing@@3HA, eax

; 331  : 
; 332  : 	system_thread_function ( internal_play_cd_audio_track, &track );

  0001b	8d 45 08	 lea	 eax, DWORD PTR _track$[ebp]
  0001e	50		 push	 eax
  0001f	68 00 00 00 00	 push	 OFFSET ?internal_play_cd_audio_track@@YGHPAX@Z ; internal_play_cd_audio_track
  00024	e8 00 00 00 00	 call	 ?system_thread_function@@YGHP6GHPAX@Z0@Z ; system_thread_function

; 333  : 
; 334  : 	cdrom_track_repeat = FALSE;

  00029	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?cdrom_track_repeat@@3HA, 0

; 335  : }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?play_one_shot_cd_audio_track@@YGXH@Z ENDP		; play_one_shot_cd_audio_track
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?play_cd_audio_track@@YGXH@Z
_TEXT	SEGMENT
_track$ = 8						; size = 4
?play_cd_audio_track@@YGXH@Z PROC			; play_cd_audio_track, COMDAT

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 311  : 
; 312  : 	cdrom_track_repeat = FALSE;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?cdrom_track_repeat@@3HA, 0

; 313  : 
; 314  : 	cdrom_track_playing = track;

  00013	8b 45 08	 mov	 eax, DWORD PTR _track$[ebp]
  00016	a3 00 00 00 00	 mov	 DWORD PTR ?cdrom_track_playing@@3HA, eax

; 315  : 
; 316  : 	system_thread_function ( internal_play_cd_audio_track, &track );

  0001b	8d 45 08	 lea	 eax, DWORD PTR _track$[ebp]
  0001e	50		 push	 eax
  0001f	68 00 00 00 00	 push	 OFFSET ?internal_play_cd_audio_track@@YGHPAX@Z ; internal_play_cd_audio_track
  00024	e8 00 00 00 00	 call	 ?system_thread_function@@YGHP6GHPAX@Z0@Z ; system_thread_function

; 317  : 
; 318  : 	cdrom_track_repeat = TRUE;

  00029	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?cdrom_track_repeat@@3HA, 1

; 319  : }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?play_cd_audio_track@@YGXH@Z ENDP			; play_cd_audio_track
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?release_cd_audio_device@@YGXXZ
_TEXT	SEGMENT
?release_cd_audio_device@@YGXXZ PROC			; release_cd_audio_device, COMDAT

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 295  : 
; 296  : 	if ( cdrom_device_captured )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?cdrom_device_captured@@3HA, 0
  00010	74 1f		 je	 SHORT $LN1@release_cd

; 297  : 	{
; 298  : 
; 299  : 		mciSendCommand ( cdrom_device_id, MCI_CLOSE, 0, 0 );

  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	68 04 08 00 00	 push	 2052			; 00000804H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cdrom_device_id@@3IA
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16

; 300  : 
; 301  : 		cdrom_device_captured = FALSE;

  00027	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?cdrom_device_captured@@3HA, 0
$LN1@release_cd:

; 302  : 	}
; 303  : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?release_cd_audio_device@@YGXXZ ENDP			; release_cd_audio_device
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?capture_cd_audio_device@@YGHXZ
_TEXT	SEGMENT
_set_parameters$1 = -44					; size = 12
_open_parameters$ = -32					; size = 20
_dwFlags$ = -12						; size = 4
_cdrom_element_name$ = -8				; size = 4
_value$ = -4						; size = 4
?capture_cd_audio_device@@YGHXZ PROC			; capture_cd_audio_device, COMDAT

; 195  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 196  : 
; 197  : 	DWORD
; 198  : 		value;
; 199  : 
; 200  : 	char
; 201  : 		cdrom_element_name[4];
; 202  : 
; 203  : 	DWORD
; 204  : 		dwFlags;
; 205  : 
; 206  : 	MCI_OPEN_PARMS
; 207  : 		open_parameters;
; 208  : 
; 209  : 	memset ( &open_parameters, 0, sizeof ( MCI_OPEN_PARMS ) );

  00009	6a 14		 push	 20			; 00000014H
  0000b	6a 00		 push	 0
  0000d	8d 45 e0	 lea	 eax, DWORD PTR _open_parameters$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 210  : 
; 211  : 	open_parameters.lpstrDeviceType = ( LPTSTR ) MCI_DEVTYPE_CD_AUDIO;

  00019	c7 45 e8 04 02
	00 00		 mov	 DWORD PTR _open_parameters$[ebp+8], 516 ; 00000204H

; 212  : 
; 213  : 	if ( cdrom_file_drive_index != -1 )

  00020	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?cdrom_file_drive_index@@3HA, -1
  00027	74 34		 je	 SHORT $LN2@capture_cd

; 214  : 	{
; 215  : 
; 216  : 		//
; 217  : 		// We found a CD drive which we want to use for music
; 218  : 		//
; 219  : 
; 220  : 		sprintf ( cdrom_element_name, "%c:", cdrom_drives[cdrom_file_drive_index] );

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cdrom_file_drive_index@@3HA
  0002e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?cdrom_drives@@3PAHA[eax*4]
  00035	51		 push	 ecx
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_03CGGPNEOP@?$CFc?3@
  0003b	8d 55 f8	 lea	 edx, DWORD PTR _cdrom_element_name$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 _sprintf
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 221  : 
; 222  : 		open_parameters.lpstrElementName = cdrom_element_name;

  00047	8d 45 f8	 lea	 eax, DWORD PTR _cdrom_element_name$[ebp]
  0004a	89 45 ec	 mov	 DWORD PTR _open_parameters$[ebp+12], eax

; 223  : 	
; 224  : 		open_parameters.lpstrAlias = "CD Apache Havoc";

  0004d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _open_parameters$[ebp+16], OFFSET ??_C@_0BA@MCJBIGAP@CD?5Apache?5Havoc@

; 225  : 	
; 226  : 		dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_SHAREABLE | MCI_OPEN_ALIAS | MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;

  00054	c7 45 f4 02 37
	00 00		 mov	 DWORD PTR _dwFlags$[ebp], 14082 ; 00003702H

; 227  : 	}
; 228  : 	else

  0005b	eb 07		 jmp	 SHORT $LN3@capture_cd
$LN2@capture_cd:

; 229  : 	{
; 230  : 
; 231  : 		//
; 232  : 		// We haven't looked for a CD drive - just use the standard cdaudio
; 233  : 		//
; 234  : 
; 235  : 		dwFlags = MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_OPEN_SHAREABLE;

  0005d	c7 45 f4 00 31
	00 00		 mov	 DWORD PTR _dwFlags$[ebp], 12544 ; 00003100H
$LN3@capture_cd:

; 236  : 	}
; 237  : 
; 238  : 	value = mciSendCommand ( 0, MCI_OPEN, dwFlags, ( DWORD ) ( LPVOID ) &open_parameters );

  00064	8d 45 e0	 lea	 eax, DWORD PTR _open_parameters$[ebp]
  00067	50		 push	 eax
  00068	8b 4d f4	 mov	 ecx, DWORD PTR _dwFlags$[ebp]
  0006b	51		 push	 ecx
  0006c	68 03 08 00 00	 push	 2051			; 00000803H
  00071	6a 00		 push	 0
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  00079	89 45 fc	 mov	 DWORD PTR _value$[ebp], eax

; 239  : 
; 240  : 	if ( value )

  0007c	83 7d fc 00	 cmp	 DWORD PTR _value$[ebp], 0
  00080	74 13		 je	 SHORT $LN4@capture_cd

; 241  : 	{
; 242  : 
; 243  : 		debug_log ( "Unable to capture cd audio" );

  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KLAMIGIJ@Unable?5to?5capture?5cd?5audio@
  00087	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0008c	83 c4 04	 add	 esp, 4

; 244  : 
; 245  : 		return ( FALSE );

  0008f	33 c0		 xor	 eax, eax
  00091	eb 74		 jmp	 SHORT $LN1@capture_cd

; 246  : 	}
; 247  : 	else

  00093	eb 72		 jmp	 SHORT $LN1@capture_cd
$LN4@capture_cd:

; 248  : 	{
; 249  : 
; 250  : 		MCI_SET_PARMS
; 251  : 			set_parameters;
; 252  : 
; 253  : 		//
; 254  : 		// Get the device ID.
; 255  : 		//
; 256  : 
; 257  : 		cdrom_device_id = open_parameters.wDeviceID;

  00095	8b 45 e4	 mov	 eax, DWORD PTR _open_parameters$[ebp+4]
  00098	a3 00 00 00 00	 mov	 DWORD PTR ?cdrom_device_id@@3IA, eax

; 258  : 
; 259  : 		//
; 260  : 		// Set the cdrom format to tracks/minutes/seconds/frames
; 261  : 		//
; 262  : 
; 263  : 		set_parameters.dwTimeFormat = MCI_FORMAT_TMSF;

  0009d	c7 45 d8 0a 00
	00 00		 mov	 DWORD PTR _set_parameters$1[ebp+4], 10 ; 0000000aH

; 264  : 
; 265  : 		value = mciSendCommand ( cdrom_device_id, MCI_SET, MCI_SET_TIME_FORMAT, ( DWORD ) ( LPVOID ) &set_parameters );

  000a4	8d 45 d4	 lea	 eax, DWORD PTR _set_parameters$1[ebp]
  000a7	50		 push	 eax
  000a8	68 00 04 00 00	 push	 1024			; 00000400H
  000ad	68 0d 08 00 00	 push	 2061			; 0000080dH
  000b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cdrom_device_id@@3IA
  000b8	51		 push	 ecx
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  000bf	89 45 fc	 mov	 DWORD PTR _value$[ebp], eax

; 266  : 
; 267  : 		if ( value )

  000c2	83 7d fc 00	 cmp	 DWORD PTR _value$[ebp], 0
  000c6	74 26		 je	 SHORT $LN6@capture_cd

; 268  : 		{
; 269  : 
; 270  : 			//
; 271  : 			// Release the device - it can't handle us!
; 272  : 			//
; 273  : 
; 274  : 			debug_log ( "Unable to set cd audio format" );

  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IBIPOFMK@Unable?5to?5set?5cd?5audio?5format@
  000cd	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  000d2	83 c4 04	 add	 esp, 4

; 275  : 
; 276  : 			mciSendCommand ( cdrom_device_id, MCI_CLOSE, 0, 0 );

  000d5	6a 00		 push	 0
  000d7	6a 00		 push	 0
  000d9	68 04 08 00 00	 push	 2052			; 00000804H
  000de	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cdrom_device_id@@3IA
  000e3	50		 push	 eax
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16

; 277  : 
; 278  : 			return ( FALSE );

  000ea	33 c0		 xor	 eax, eax
  000ec	eb 19		 jmp	 SHORT $LN1@capture_cd
$LN6@capture_cd:

; 279  : 		}
; 280  : 
; 281  : 		cdrom_device_captured = TRUE;

  000ee	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?cdrom_device_captured@@3HA, 1

; 282  : 
; 283  : 		register_exit_function ( release_cd_audio_device );

  000f8	68 00 00 00 00	 push	 OFFSET ?release_cd_audio_device@@YGXXZ ; release_cd_audio_device
  000fd	e8 00 00 00 00	 call	 ?register_exit_function@@YGXP6GXXZ@Z ; register_exit_function

; 284  : 
; 285  : 		return ( TRUE );

  00102	b8 01 00 00 00	 mov	 eax, 1
$LN1@capture_cd:

; 286  : 	}
; 287  : }

  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
?capture_cd_audio_device@@YGHXZ ENDP			; capture_cd_audio_device
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?check_cdrom_file_exists@@YGHPBD@Z
_TEXT	SEGMENT
_path$ = -1028						; size = 1024
_count$ = -4						; size = 4
_filename$ = 8						; size = 4
?check_cdrom_file_exists@@YGHPBD@Z PROC			; check_cdrom_file_exists, COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 04 00
	00		 sub	 esp, 1220		; 000004c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 108  : 
; 109  : 	int
; 110  : 		count;
; 111  : 
; 112  : 	char
; 113  : 		path[1024];
; 114  : 
; 115  : 	if ( !cdrom_finder_initialised )

  0000c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?cdrom_finder_initialised@@3HA, 0
  00013	75 05		 jne	 SHORT $LN5@check_cdro

; 116  : 	{
; 117  : 
; 118  : 		initialise_cdrom_finder ();

  00015	e8 00 00 00 00	 call	 ?initialise_cdrom_finder@@YGXXZ ; initialise_cdrom_finder
$LN5@check_cdro:

; 119  : 	}
; 120  : 
; 121  : 	for ( count = 0; count < number_of_cdrom_drives; count++ )

  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00021	eb 09		 jmp	 SHORT $LN4@check_cdro
$LN2@check_cdro:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00026	83 c0 01	 add	 eax, 1
  00029	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@check_cdro:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0002f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_cdrom_drives@@3HA
  00035	7d 49		 jge	 SHORT $LN3@check_cdro

; 122  : 	{
; 123  : 
; 124  : 		sprintf ( path, "%c:\\%s", cdrom_drives[count], filename );

  00037	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0003e	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?cdrom_drives@@3PAHA[ecx*4]
  00045	52		 push	 edx
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_06CBKIPFEN@?$CFc?3?2?$CFs@
  0004b	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _sprintf
  00057	83 c4 10	 add	 esp, 16			; 00000010H

; 125  : 
; 126  : 		if ( file_exist ( path ) )

  0005a	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ?file_exist@@YGHPBD@Z	; file_exist
  00066	85 c0		 test	 eax, eax
  00068	74 14		 je	 SHORT $LN6@check_cdro

; 127  : 		{
; 128  : 
; 129  : 			cdrom_file_drive_index = count;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0006d	a3 00 00 00 00	 mov	 DWORD PTR ?cdrom_file_drive_index@@3HA, eax

; 130  : 
; 131  : 			return ( cdrom_drives[count] );

  00072	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00075	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?cdrom_drives@@3PAHA[eax*4]
  0007c	eb 04		 jmp	 SHORT $LN1@check_cdro
$LN6@check_cdro:

; 132  : 		}
; 133  : 	}

  0007e	eb a3		 jmp	 SHORT $LN2@check_cdro
$LN3@check_cdro:

; 134  : 
; 135  : 	return ( FALSE );

  00080	33 c0		 xor	 eax, eax
$LN1@check_cdro:

; 136  : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?check_cdrom_file_exists@@YGHPBD@Z ENDP			; check_cdrom_file_exists
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\cdrom.c
;	COMDAT ?initialise_cdrom_system@@YGXXZ
_TEXT	SEGMENT
?initialise_cdrom_system@@YGXXZ PROC			; initialise_cdrom_system, COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 98   : 
; 99   : 	register_system_message_function ( MM_MCINOTIFY, cdrom_notification_routine );

  00009	68 00 00 00 00	 push	 OFFSET ?cdrom_notification_routine@@YGJPAUHWND__@@IIJ@Z ; cdrom_notification_routine
  0000e	68 b9 03 00 00	 push	 953			; 000003b9H
  00013	e8 00 00 00 00	 call	 ?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z ; register_system_message_function

; 100  : }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?initialise_cdrom_system@@YGXXZ ENDP			; initialise_cdrom_system
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1459 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1460 :         #pragma warning(push)
; 1461 :         #pragma warning(disable: 4996) // Deprecation
; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1463 :         #pragma warning(pop)
; 1464 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH
  00035	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00038	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003c	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003e	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00045	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00047	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  0004a	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004d	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1395 :     }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
