; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\system\files.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?initialise_file_system@@YGHXZ			; initialise_file_system
PUBLIC	?mopen@@YGPAXPBD@Z				; mopen
PUBLIC	?mclose@@YGHPAX@Z				; mclose
PUBLIC	?file_exist@@YGHPBD@Z				; file_exist
PUBLIC	?file_size@@YGHPBD@Z				; file_size
PUBLIC	?reset_safe_memory_mapped_file_counter@@YGXXZ	; reset_safe_memory_mapped_file_counter
PUBLIC	?check_safe_memory_mapped_file_counter@@YGXXZ	; check_safe_memory_mapped_file_counter
PUBLIC	?safe_mopen@@YGPAXPBD@Z				; safe_mopen
PUBLIC	?safe_mclose@@YGHPAX@Z				; safe_mclose
PUBLIC	?safe_fopen@@YGPAU_iobuf@@PBD0@Z		; safe_fopen
PUBLIC	?safe_fclose@@YGHPAU_iobuf@@@Z			; safe_fclose
PUBLIC	?safe_fread@@YGXPAXHHPAU_iobuf@@@Z		; safe_fread
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0DP@FMCGNAEH@Unable?5to?5create?5a?5file?5mapping@ ; `string'
PUBLIC	??_C@_0BN@BONJAOFP@Unable?5to?5memory?5map?5file?5?$CFs@ ; `string'
PUBLIC	??_C@_0BE@KFOBFKHE@?$CF08x?$CF04dFileMapping@	; `string'
PUBLIC	??_C@_0CH@MPCGMOGF@Unable?5to?5create?5memory?5mapped?5@ ; `string'
PUBLIC	??_C@_0DI@NBOFFKMK@Unable?5to?5create?5file?5mapping?5f@ ; `string'
PUBLIC	??_C@_0DD@DHBADLFO@Unable?5to?5locate?5memory?5mapped?5@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_09HGIBBNON@?2cohokum?2@			; `string'
PUBLIC	??_C@_08EMMAHODI@?2common?2@			; `string'
PUBLIC	??_C@_0CL@HFOOAOLN@NOTE?$CB?5Safe?5memory?5mapped?5file?5c@ ; `string'
PUBLIC	??_C@_0DN@MBPEMAOI@WARNING?$CB?5Safe?5memory?5mapped?5fil@ ; `string'
PUBLIC	?__LINE__Var@?0??safe_mopen@@YGPAXPBD@Z@4JA	; `safe_mopen'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@OOMCPCPO@c?3?2users?2nhv90?2projects?2eech?2mo@ ; `string'
PUBLIC	??_C@_08BABJIOEM@filename@			; `string'
PUBLIC	??_C@_0EB@PDDFDECF@Unable?5to?5map?5file?5?$CFs?6?6This?5may@ ; `string'
PUBLIC	??_C@_0BH@ENAANGJH@Unable?5to?5load?5file?5?$CFs@ ; `string'
PUBLIC	?__LINE__Var@?0??safe_mclose@@YGHPAX@Z@4JA	; `safe_mclose'::`1'::__LINE__Var
PUBLIC	??_C@_04PJOLNDGD@data@				; `string'
PUBLIC	??_C@_06KJFADLGN@result@			; `string'
PUBLIC	?__LINE__Var@?0??safe_fopen@@YGPAU_iobuf@@PBD0@Z@4JA ; `safe_fopen'::`1'::__LINE__Var
PUBLIC	??_C@_04GMGOKAFF@mode@				; `string'
PUBLIC	??_C@_0CD@CMFLBBLG@Error?5opening?5file?5for?5reading?3@ ; `string'
PUBLIC	??_C@_0CD@IMCCLFGL@Error?5opening?5file?5for?5writing?3@ ; `string'
PUBLIC	??_C@_0BG@CCPPOKHH@Error?5opening?5file?5?$CFs@	; `string'
PUBLIC	?__LINE__Var@?0??safe_fclose@@YGHPAU_iobuf@@@Z@4JA ; `safe_fclose'::`1'::__LINE__Var
PUBLIC	??_C@_02GDNLOIIJ@fp@				; `string'
PUBLIC	??_C@_0CA@BDJCGPIG@Error?5closing?5file?5?$CIerror?5?$DN?5?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0BG@MCEBCJAI@Read?5past?5end?5of?5file@	; `string'
PUBLIC	??_C@_0BD@KIFMFFOJ@Error?5reading?5file@	; `string'
EXTRN	__imp__fclose:PROC
EXTRN	__imp__feof:PROC
EXTRN	__imp__ferror:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__ftell:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__MapViewOfFile@20:PROC
EXTRN	__imp__UnmapViewOfFile@4:PROC
EXTRN	__imp__CreateFileMappingA@24:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	?process_assert@@YGXPBD0H@Z:PROC		; process_assert
EXTRN	?register_exit_function@@YGXP6GXXZ@Z:PROC	; register_exit_function
EXTRN	?debug_fatal@@YAXPBDZZ:PROC			; debug_fatal
EXTRN	?debug_log@@YAXPBDZZ:PROC			; debug_log
EXTRN	?safe_malloc_memory@@YGPAXI@Z:PROC		; safe_malloc_memory
EXTRN	?comanche_hokum_installation_path@@3PADA:BYTE	; comanche_hokum_installation_path
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?file_maps@@3PAUFILEMAP@@A DD 01H DUP (?)		; file_maps
?safe_memory_mapped_file_counter@@3HA DD 01H DUP (?)	; safe_memory_mapped_file_counter
_BSS	ENDS
;	COMDAT ??_C@_0BD@KIFMFFOJ@Error?5reading?5file@
CONST	SEGMENT
??_C@_0BD@KIFMFFOJ@Error?5reading?5file@ DB 'Error reading file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MCEBCJAI@Read?5past?5end?5of?5file@
CONST	SEGMENT
??_C@_0BG@MCEBCJAI@Read?5past?5end?5of?5file@ DB 'Read past end of file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BDJCGPIG@Error?5closing?5file?5?$CIerror?5?$DN?5?$CFd?$CJ@
CONST	SEGMENT
??_C@_0CA@BDJCGPIG@Error?5closing?5file?5?$CIerror?5?$DN?5?$CFd?$CJ@ DB 'E'
	DB	'rror closing file (error = %d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GDNLOIIJ@fp@
CONST	SEGMENT
??_C@_02GDNLOIIJ@fp@ DB 'fp', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??safe_fclose@@YGHPAU_iobuf@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??safe_fclose@@YGHPAU_iobuf@@@Z@4JA DD 0283H ; `safe_fclose'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BG@CCPPOKHH@Error?5opening?5file?5?$CFs@
CONST	SEGMENT
??_C@_0BG@CCPPOKHH@Error?5opening?5file?5?$CFs@ DB 'Error opening file %s'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IMCCLFGL@Error?5opening?5file?5for?5writing?3@
CONST	SEGMENT
??_C@_0CD@IMCCLFGL@Error?5opening?5file?5for?5writing?3@ DB 'Error openin'
	DB	'g file for writing: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CMFLBBLG@Error?5opening?5file?5for?5reading?3@
CONST	SEGMENT
??_C@_0CD@CMFLBBLG@Error?5opening?5file?5for?5reading?3@ DB 'Error openin'
	DB	'g file for reading: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GMGOKAFF@mode@
CONST	SEGMENT
??_C@_04GMGOKAFF@mode@ DB 'mode', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??safe_fopen@@YGPAU_iobuf@@PBD0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??safe_fopen@@YGPAU_iobuf@@PBD0@Z@4JA DD 0247H ; `safe_fopen'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_06KJFADLGN@result@
CONST	SEGMENT
??_C@_06KJFADLGN@result@ DB 'result', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJOLNDGD@data@
CONST	SEGMENT
??_C@_04PJOLNDGD@data@ DB 'data', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??safe_mclose@@YGHPAX@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??safe_mclose@@YGHPAX@Z@4JA DD 0233H	; `safe_mclose'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BH@ENAANGJH@Unable?5to?5load?5file?5?$CFs@
CONST	SEGMENT
??_C@_0BH@ENAANGJH@Unable?5to?5load?5file?5?$CFs@ DB 'Unable to load file'
	DB	' %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@PDDFDECF@Unable?5to?5map?5file?5?$CFs?6?6This?5may@
CONST	SEGMENT
??_C@_0EB@PDDFDECF@Unable?5to?5map?5file?5?$CFs?6?6This?5may@ DB 'Unable '
	DB	'to map file %s', 0aH, 0aH, 'This may be due to lack of virtua'
	DB	'l memory', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08BABJIOEM@filename@
CONST	SEGMENT
??_C@_08BABJIOEM@filename@ DB 'filename', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OOMCPCPO@c?3?2users?2nhv90?2projects?2eech?2mo@
CONST	SEGMENT
??_C@_0DE@OOMCPCPO@c?3?2users?2nhv90?2projects?2eech?2mo@ DB 'c:\users\nh'
	DB	'v90\projects\eech\modules\system\files.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??safe_mopen@@YGPAXPBD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??safe_mopen@@YGPAXPBD@Z@4JA DD 01fcH	; `safe_mopen'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DN@MBPEMAOI@WARNING?$CB?5Safe?5memory?5mapped?5fil@
CONST	SEGMENT
??_C@_0DN@MBPEMAOI@WARNING?$CB?5Safe?5memory?5mapped?5fil@ DB 'WARNING! S'
	DB	'afe memory mapped file counter != 0 (counter = %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HFOOAOLN@NOTE?$CB?5Safe?5memory?5mapped?5file?5c@
CONST	SEGMENT
??_C@_0CL@HFOOAOLN@NOTE?$CB?5Safe?5memory?5mapped?5file?5c@ DB 'NOTE! Saf'
	DB	'e memory mapped file counter == 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMMAHODI@?2common?2@
CONST	SEGMENT
??_C@_08EMMAHODI@?2common?2@ DB '\common\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HGIBBNON@?2cohokum?2@
CONST	SEGMENT
??_C@_09HGIBBNON@?2cohokum?2@ DB '\cohokum\', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@DHBADLFO@Unable?5to?5locate?5memory?5mapped?5@
CONST	SEGMENT
??_C@_0DD@DHBADLFO@Unable?5to?5locate?5memory?5mapped?5@ DB 'Unable to lo'
	DB	'cate memory mapped file to unmap file.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@NBOFFKMK@Unable?5to?5create?5file?5mapping?5f@
CONST	SEGMENT
??_C@_0DI@NBOFFKMK@Unable?5to?5create?5file?5mapping?5f@ DB 'Unable to cr'
	DB	'eate file mapping for memory mapped file %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MPCGMOGF@Unable?5to?5create?5memory?5mapped?5@
CONST	SEGMENT
??_C@_0CH@MPCGMOGF@Unable?5to?5create?5memory?5mapped?5@ DB 'Unable to cr'
	DB	'eate memory mapped file %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KFOBFKHE@?$CF08x?$CF04dFileMapping@
CONST	SEGMENT
??_C@_0BE@KFOBFKHE@?$CF08x?$CF04dFileMapping@ DB '%08x%04dFileMapping', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BONJAOFP@Unable?5to?5memory?5map?5file?5?$CFs@
CONST	SEGMENT
??_C@_0BN@BONJAOFP@Unable?5to?5memory?5map?5file?5?$CFs@ DB 'Unable to me'
	DB	'mory map file %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@FMCGNAEH@Unable?5to?5create?5a?5file?5mapping@
CONST	SEGMENT
??_C@_0DP@FMCGNAEH@Unable?5to?5create?5a?5file?5mapping@ DB 'Unable to cr'
	DB	'eate a file mapping - maximum files already mapped', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\files.c
;	COMDAT ?deinitialise_file_system@@YGXXZ
_TEXT	SEGMENT
_count$ = -4						; size = 4
?deinitialise_file_system@@YGXXZ PROC			; deinitialise_file_system, COMDAT

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 165  : 
; 166  : 	int
; 167  : 		count;
; 168  : 
; 169  : 	for ( count = 0; count < MAX_NUMBER_FILES; count++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@deinitiali
$LN2@deinitiali:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@deinitiali:
  0001b	81 7d fc 00 04
	00 00		 cmp	 DWORD PTR _count$[ebp], 1024 ; 00000400H
  00022	7d 2a		 jge	 SHORT $LN1@deinitiali

; 170  : 	{
; 171  : 
; 172  : 		if ( file_maps[count].used )

  00024	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00027	c1 e0 04	 shl	 eax, 4
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  00030	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  00034	74 16		 je	 SHORT $LN5@deinitiali

; 173  : 		{
; 174  : 
; 175  : #if DEBUG_MODULE
; 176  : 
; 177  : 			debug_log ( "Memory mapped file %s not closed", file_maps[count].filename );
; 178  : 
; 179  : #endif
; 180  : 			mclose ( file_maps[count].data );

  00036	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00039	c1 e0 04	 shl	 eax, 4
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  00042	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 ?mclose@@YGHPAX@Z	; mclose
$LN5@deinitiali:

; 181  : 		}
; 182  : 	}

  0004c	eb c4		 jmp	 SHORT $LN2@deinitiali
$LN1@deinitiali:

; 183  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?deinitialise_file_system@@YGXXZ ENDP			; deinitialise_file_system
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\files.c
;	COMDAT ?safe_fread@@YGXPAXHHPAU_iobuf@@@Z
_TEXT	SEGMENT
_size_read$ = -4					; size = 4
_data$ = 8						; size = 4
_element_size$ = 12					; size = 4
_number_of_elements$ = 16				; size = 4
_fp$ = 20						; size = 4
?safe_fread@@YGXPAXHHPAU_iobuf@@@Z PROC			; safe_fread, COMDAT

; 664  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 665  : 
; 666  : 	size_t
; 667  : 		size_read;
; 668  : 
; 669  : 	size_read = fread ( data, element_size, number_of_elements, fp );

  00009	8b 45 14	 mov	 eax, DWORD PTR _fp$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _number_of_elements$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR _element_size$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
  00022	89 45 fc	 mov	 DWORD PTR _size_read$[ebp], eax

; 670  : 
; 671  : 	if ( feof ( fp ) )

  00025	8b 45 14	 mov	 eax, DWORD PTR _fp$[ebp]
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__feof
  0002f	83 c4 04	 add	 esp, 4
  00032	85 c0		 test	 eax, eax
  00034	74 0d		 je	 SHORT $LN2@safe_fread

; 672  : 	{
; 673  : 
; 674  : 		debug_fatal ( "Read past end of file" );

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@MCEBCJAI@Read?5past?5end?5of?5file@
  0003b	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  00040	83 c4 04	 add	 esp, 4
$LN2@safe_fread:

; 675  : 	}
; 676  : 
; 677  : 	if ( ferror ( fp ) )

  00043	8b 45 14	 mov	 eax, DWORD PTR _fp$[ebp]
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ferror
  0004d	83 c4 04	 add	 esp, 4
  00050	85 c0		 test	 eax, eax
  00052	74 0d		 je	 SHORT $LN1@safe_fread

; 678  : 	{
; 679  : 
; 680  : 		debug_fatal ( "Error reading file" );

  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KIFMFFOJ@Error?5reading?5file@
  00059	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  0005e	83 c4 04	 add	 esp, 4
$LN1@safe_fread:

; 681  : 	}
; 682  : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 10 00	 ret	 16			; 00000010H
?safe_fread@@YGXPAXHHPAU_iobuf@@@Z ENDP			; safe_fread
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\files.c
;	COMDAT ?safe_fclose@@YGHPAU_iobuf@@@Z
_TEXT	SEGMENT
_error$ = -4						; size = 4
_fp$ = 8						; size = 4
?safe_fclose@@YGHPAU_iobuf@@@Z PROC			; safe_fclose, COMDAT

; 643  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 644  : 	int
; 645  : 		error;
; 646  : 
; 647  : 	ASSERT (fp);

  00009	83 7d 08 00	 cmp	 DWORD PTR _fp$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN2@safe_fclos
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??safe_fclose@@YGHPAU_iobuf@@@Z@4JA
  00014	83 c0 04	 add	 eax, 4
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@OOMCPCPO@c?3?2users?2nhv90?2projects?2eech?2mo@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02GDNLOIIJ@fp@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@safe_fclos:

; 648  : 
; 649  : 	error = fclose (fp);

  00027	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  0002a	50		 push	 eax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00031	83 c4 04	 add	 esp, 4
  00034	89 45 fc	 mov	 DWORD PTR _error$[ebp], eax

; 650  : 
; 651  : 	if (error)

  00037	83 7d fc 00	 cmp	 DWORD PTR _error$[ebp], 0
  0003b	74 11		 je	 SHORT $LN3@safe_fclos

; 652  : 	{
; 653  : 		debug_fatal ("Error closing file (error = %d)", error);

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _error$[ebp]
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@BDJCGPIG@Error?5closing?5file?5?$CIerror?5?$DN?5?$CFd?$CJ@
  00046	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  0004b	83 c4 08	 add	 esp, 8
$LN3@safe_fclos:

; 654  : 	}
; 655  : 
; 656  : 	return (error);

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _error$[ebp]

; 657  : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?safe_fclose@@YGHPAU_iobuf@@@Z ENDP			; safe_fclose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\files.c
;	COMDAT ?safe_fopen@@YGPAU_iobuf@@PBD0@Z
_TEXT	SEGMENT
_fn$1 = -1028						; size = 1024
_fp$ = -4						; size = 4
_filename$ = 8						; size = 4
_mode$ = 12						; size = 4
?safe_fopen@@YGPAU_iobuf@@PBD0@Z PROC			; safe_fopen, COMDAT

; 583  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 04 00
	00		 sub	 esp, 1220		; 000004c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 584  : 	FILE
; 585  : 		*fp;
; 586  : 
; 587  : 	ASSERT (filename);

  0000c	83 7d 08 00	 cmp	 DWORD PTR _filename$[ebp], 0
  00010	75 18		 jne	 SHORT $LN2@safe_fopen
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??safe_fopen@@YGPAU_iobuf@@PBD0@Z@4JA
  00017	83 c0 04	 add	 eax, 4
  0001a	50		 push	 eax
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@OOMCPCPO@c?3?2users?2nhv90?2projects?2eech?2mo@
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_08BABJIOEM@filename@
  00025	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@safe_fopen:

; 588  : 
; 589  : 	ASSERT (mode);

  0002a	83 7d 0c 00	 cmp	 DWORD PTR _mode$[ebp], 0
  0002e	75 18		 jne	 SHORT $LN3@safe_fopen
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??safe_fopen@@YGPAU_iobuf@@PBD0@Z@4JA
  00035	83 c0 06	 add	 eax, 6
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@OOMCPCPO@c?3?2users?2nhv90?2projects?2eech?2mo@
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_04GMGOKAFF@mode@
  00043	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN3@safe_fopen:

; 590  : 
; 591  : 	fp = fopen( filename, mode );

  00048	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _filename$[ebp]
  0004f	51		 push	 ecx
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00056	83 c4 08	 add	 esp, 8
  00059	89 45 fc	 mov	 DWORD PTR _fp$[ebp], eax

; 592  : 
; 593  : 	// JB 030311 Enable running out of separate directories
; 594  : 	if (!fp)

  0005c	83 7d fc 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00060	0f 85 40 01 00
	00		 jne	 $LN4@safe_fopen

; 595  : 	{
; 596  : 		char fn[1024];
; 597  : 		fn[0] = 0;

  00066	b8 01 00 00 00	 mov	 eax, 1
  0006b	6b c8 00	 imul	 ecx, eax, 0
  0006e	c6 84 0d fc fb
	ff ff 00	 mov	 BYTE PTR _fn$1[ebp+ecx], 0

; 598  : 		strcpy(fn, comanche_hokum_installation_path);

  00076	68 00 00 00 00	 push	 OFFSET ?comanche_hokum_installation_path@@3PADA ; comanche_hokum_installation_path
  0007b	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 _strcpy
  00087	83 c4 08	 add	 esp, 8

; 599  : 		strcat(fn, "\\cohokum\\");

  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_09HGIBBNON@?2cohokum?2@
  0008f	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _strcat
  0009b	83 c4 08	 add	 esp, 8

; 600  : 		strcat(fn, filename);

  0009e	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  000a1	50		 push	 eax
  000a2	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _fn$1[ebp]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 _strcat
  000ae	83 c4 08	 add	 esp, 8

; 601  : 
; 602  : 		fp = fopen( fn, mode );

  000b1	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  000b4	50		 push	 eax
  000b5	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _fn$1[ebp]
  000bb	51		 push	 ecx
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  000c2	83 c4 08	 add	 esp, 8
  000c5	89 45 fc	 mov	 DWORD PTR _fp$[ebp], eax

; 603  : 
; 604  : 		if ( !fp )

  000c8	83 7d fc 00	 cmp	 DWORD PTR _fp$[ebp], 0
  000cc	0f 85 d4 00 00
	00		 jne	 $LN4@safe_fopen

; 605  : 		{
; 606  : 			fn[0] = 0;

  000d2	b8 01 00 00 00	 mov	 eax, 1
  000d7	6b c8 00	 imul	 ecx, eax, 0
  000da	c6 84 0d fc fb
	ff ff 00	 mov	 BYTE PTR _fn$1[ebp+ecx], 0

; 607  : 			strcpy(fn, comanche_hokum_installation_path);

  000e2	68 00 00 00 00	 push	 OFFSET ?comanche_hokum_installation_path@@3PADA ; comanche_hokum_installation_path
  000e7	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 _strcpy
  000f3	83 c4 08	 add	 esp, 8

; 608  : 			strcat(fn, "\\common\\");

  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_08EMMAHODI@?2common?2@
  000fb	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _strcat
  00107	83 c4 08	 add	 esp, 8

; 609  : 			strcat(fn, filename);

  0010a	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0010d	50		 push	 eax
  0010e	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _fn$1[ebp]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 _strcat
  0011a	83 c4 08	 add	 esp, 8

; 610  : 
; 611  : 			fp = fopen( fn, mode );

  0011d	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00120	50		 push	 eax
  00121	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _fn$1[ebp]
  00127	51		 push	 ecx
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0012e	83 c4 08	 add	 esp, 8
  00131	89 45 fc	 mov	 DWORD PTR _fp$[ebp], eax

; 612  : 
; 613  : 			if ( !fp )

  00134	83 7d fc 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00138	75 6c		 jne	 SHORT $LN4@safe_fopen

; 614  : 			{
; 615  : 
; 616  : 				if ( ( *mode == 'r' ) || ( *mode == 'R' ) )

  0013a	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  0013d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00140	83 f9 72	 cmp	 ecx, 114		; 00000072H
  00143	74 0b		 je	 SHORT $LN9@safe_fopen
  00145	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00148	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0014b	83 f9 52	 cmp	 ecx, 82			; 00000052H
  0014e	75 16		 jne	 SHORT $LN7@safe_fopen
$LN9@safe_fopen:

; 617  : 				{
; 618  : 			
; 619  : 					debug_fatal("Error opening file for reading: %s", fn );

  00150	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  00156	50		 push	 eax
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@CMFLBBLG@Error?5opening?5file?5for?5reading?3@
  0015c	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  00161	83 c4 08	 add	 esp, 8
  00164	eb 40		 jmp	 SHORT $LN4@safe_fopen
$LN7@safe_fopen:

; 620  : 				}
; 621  : 				else if ( ( *mode == 'w' ) || ( *mode == 'W' ) )

  00166	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00169	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0016c	83 f9 77	 cmp	 ecx, 119		; 00000077H
  0016f	74 0b		 je	 SHORT $LN12@safe_fopen
  00171	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00174	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00177	83 f9 57	 cmp	 ecx, 87			; 00000057H
  0017a	75 16		 jne	 SHORT $LN10@safe_fopen
$LN12@safe_fopen:

; 622  : 				{
; 623  : 			
; 624  : 					debug_fatal("Error opening file for writing: %s", fn );

  0017c	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  00182	50		 push	 eax
  00183	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@IMCCLFGL@Error?5opening?5file?5for?5writing?3@
  00188	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  0018d	83 c4 08	 add	 esp, 8

; 625  : 				}
; 626  : 				else

  00190	eb 14		 jmp	 SHORT $LN4@safe_fopen
$LN10@safe_fopen:

; 627  : 				{
; 628  : 			
; 629  : 					debug_fatal("Error opening file %s", fn );

  00192	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  00198	50		 push	 eax
  00199	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CCPPOKHH@Error?5opening?5file?5?$CFs@
  0019e	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  001a3	83 c4 08	 add	 esp, 8
$LN4@safe_fopen:

; 630  : 				}
; 631  : 			}
; 632  : 		}
; 633  : 	}
; 634  : 
; 635  : 	return fp;

  001a6	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]

; 636  : }

  001a9	5f		 pop	 edi
  001aa	5e		 pop	 esi
  001ab	5b		 pop	 ebx
  001ac	8b e5		 mov	 esp, ebp
  001ae	5d		 pop	 ebp
  001af	c2 08 00	 ret	 8
?safe_fopen@@YGPAU_iobuf@@PBD0@Z ENDP			; safe_fopen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\files.c
;	COMDAT ?safe_mclose@@YGHPAX@Z
_TEXT	SEGMENT
_result$ = -4						; size = 4
_data$ = 8						; size = 4
?safe_mclose@@YGHPAX@Z PROC				; safe_mclose, COMDAT

; 563  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 564  : 	BOOL
; 565  : 		result;
; 566  : 
; 567  : 	ASSERT (data);

  00009	83 7d 08 00	 cmp	 DWORD PTR _data$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN2@safe_mclos
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??safe_mclose@@YGHPAX@Z@4JA
  00014	83 c0 04	 add	 eax, 4
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@OOMCPCPO@c?3?2users?2nhv90?2projects?2eech?2mo@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_04PJOLNDGD@data@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@safe_mclos:

; 568  : 
; 569  : 	result = mclose (data);

  00027	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?mclose@@YGHPAX@Z	; mclose
  00030	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax

; 570  : 
; 571  : 	ASSERT (result);

  00033	83 7d fc 00	 cmp	 DWORD PTR _result$[ebp], 0
  00037	75 18		 jne	 SHORT $LN3@safe_mclos
  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??safe_mclose@@YGHPAX@Z@4JA
  0003e	83 c0 08	 add	 eax, 8
  00041	50		 push	 eax
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@OOMCPCPO@c?3?2users?2nhv90?2projects?2eech?2mo@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_06KJFADLGN@result@
  0004c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN3@safe_mclos:

; 572  : 
; 573  : 	safe_memory_mapped_file_counter--;

  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR ?safe_memory_mapped_file_counter@@3HA
  00056	83 e8 01	 sub	 eax, 1
  00059	a3 00 00 00 00	 mov	 DWORD PTR ?safe_memory_mapped_file_counter@@3HA, eax

; 574  : 
; 575  : 	return (result);

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]

; 576  : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?safe_mclose@@YGHPAX@Z ENDP				; safe_mclose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\files.c
;	COMDAT ?safe_mopen@@YGPAXPBD@Z
_TEXT	SEGMENT
_fn$1 = -1028						; size = 1024
_ptr$ = -4						; size = 4
_filename$ = 8						; size = 4
?safe_mopen@@YGPAXPBD@Z PROC				; safe_mopen, COMDAT

; 508  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 04 00
	00		 sub	 esp, 1220		; 000004c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 509  : 	void
; 510  : 		*ptr;
; 511  : 
; 512  : 	ASSERT (filename);

  0000c	83 7d 08 00	 cmp	 DWORD PTR _filename$[ebp], 0
  00010	75 18		 jne	 SHORT $LN2@safe_mopen
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??safe_mopen@@YGPAXPBD@Z@4JA
  00017	83 c0 04	 add	 eax, 4
  0001a	50		 push	 eax
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@OOMCPCPO@c?3?2users?2nhv90?2projects?2eech?2mo@
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_08BABJIOEM@filename@
  00025	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@safe_mopen:

; 513  : 
; 514  : 	ptr = mopen (filename);

  0002a	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?mopen@@YGPAXPBD@Z	; mopen
  00033	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 515  : 
; 516  : 	// JB 030311 Enable running out of separate directories
; 517  : 	if (!ptr)

  00036	83 7d fc 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  0003a	0f 85 fe 00 00
	00		 jne	 $LN3@safe_mopen

; 518  : 	{
; 519  : 		char fn[1024];
; 520  : 		fn[0] = 0;

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	6b c8 00	 imul	 ecx, eax, 0
  00048	c6 84 0d fc fb
	ff ff 00	 mov	 BYTE PTR _fn$1[ebp+ecx], 0

; 521  : 		strcpy(fn, comanche_hokum_installation_path);

  00050	68 00 00 00 00	 push	 OFFSET ?comanche_hokum_installation_path@@3PADA ; comanche_hokum_installation_path
  00055	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _strcpy
  00061	83 c4 08	 add	 esp, 8

; 522  : 		strcat(fn, "\\cohokum\\");

  00064	68 00 00 00 00	 push	 OFFSET ??_C@_09HGIBBNON@?2cohokum?2@
  00069	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _strcat
  00075	83 c4 08	 add	 esp, 8

; 523  : 		strcat(fn, filename);

  00078	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0007b	50		 push	 eax
  0007c	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _fn$1[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _strcat
  00088	83 c4 08	 add	 esp, 8

; 524  : 
; 525  : 		ptr = mopen (fn);

  0008b	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?mopen@@YGPAXPBD@Z	; mopen
  00097	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 526  : 
; 527  : 		if ( !ptr )

  0009a	83 7d fc 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  0009e	0f 85 9a 00 00
	00		 jne	 $LN3@safe_mopen

; 528  : 		{
; 529  : 			fn[0] = 0;

  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	6b c8 00	 imul	 ecx, eax, 0
  000ac	c6 84 0d fc fb
	ff ff 00	 mov	 BYTE PTR _fn$1[ebp+ecx], 0

; 530  : 			strcpy(fn, comanche_hokum_installation_path);

  000b4	68 00 00 00 00	 push	 OFFSET ?comanche_hokum_installation_path@@3PADA ; comanche_hokum_installation_path
  000b9	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 _strcpy
  000c5	83 c4 08	 add	 esp, 8

; 531  : 			strcat(fn, "\\common\\");

  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_08EMMAHODI@?2common?2@
  000cd	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _strcat
  000d9	83 c4 08	 add	 esp, 8

; 532  : 			strcat(fn, filename);

  000dc	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  000df	50		 push	 eax
  000e0	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _fn$1[ebp]
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 _strcat
  000ec	83 c4 08	 add	 esp, 8

; 533  : 
; 534  : 			ptr = mopen (fn);

  000ef	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ?mopen@@YGPAXPBD@Z	; mopen
  000fb	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 535  : 
; 536  : 			if ( !ptr )

  000fe	83 7d fc 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  00102	75 3a		 jne	 SHORT $LN3@safe_mopen

; 537  : 			{
; 538  : 
; 539  : 				if ( file_exist ( fn ) )

  00104	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 ?file_exist@@YGHPBD@Z	; file_exist
  00110	85 c0		 test	 eax, eax
  00112	74 16		 je	 SHORT $LN6@safe_mopen

; 540  : 				{
; 541  : 			
; 542  : 					debug_fatal ( "Unable to map file %s\n\nThis may be due to lack of virtual memory", fn );

  00114	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  0011a	50		 push	 eax
  0011b	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@PDDFDECF@Unable?5to?5map?5file?5?$CFs?6?6This?5may@
  00120	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  00125	83 c4 08	 add	 esp, 8

; 543  : 				}
; 544  : 				else

  00128	eb 14		 jmp	 SHORT $LN3@safe_mopen
$LN6@safe_mopen:

; 545  : 				{
; 546  : 
; 547  : 					debug_fatal ( "Unable to load file %s", fn );

  0012a	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _fn$1[ebp]
  00130	50		 push	 eax
  00131	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@ENAANGJH@Unable?5to?5load?5file?5?$CFs@
  00136	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  0013b	83 c4 08	 add	 esp, 8
$LN3@safe_mopen:

; 548  : 				}
; 549  : 			}
; 550  : 		}
; 551  : 	}
; 552  : 
; 553  : 	safe_memory_mapped_file_counter++;

  0013e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?safe_memory_mapped_file_counter@@3HA
  00143	83 c0 01	 add	 eax, 1
  00146	a3 00 00 00 00	 mov	 DWORD PTR ?safe_memory_mapped_file_counter@@3HA, eax

; 554  : 
; 555  : 	return (ptr);

  0014b	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]

; 556  : }

  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	5b		 pop	 ebx
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c2 04 00	 ret	 4
?safe_mopen@@YGPAXPBD@Z ENDP				; safe_mopen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\files.c
;	COMDAT ?check_safe_memory_mapped_file_counter@@YGXXZ
_TEXT	SEGMENT
?check_safe_memory_mapped_file_counter@@YGXXZ PROC	; check_safe_memory_mapped_file_counter, COMDAT

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 490  : 	if (safe_memory_mapped_file_counter == 0)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?safe_memory_mapped_file_counter@@3HA, 0
  00010	75 0f		 jne	 SHORT $LN2@check_safe

; 491  : 	{
; 492  : 		debug_log ("NOTE! Safe memory mapped file counter == 0");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@HFOOAOLN@NOTE?$CB?5Safe?5memory?5mapped?5file?5c@
  00017	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0001c	83 c4 04	 add	 esp, 4

; 493  : 	}
; 494  : 	else

  0001f	eb 13		 jmp	 SHORT $LN1@check_safe
$LN2@check_safe:

; 495  : 	{
; 496  : 		debug_log ("WARNING! Safe memory mapped file counter != 0 (counter = %d)", safe_memory_mapped_file_counter);

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?safe_memory_mapped_file_counter@@3HA
  00026	50		 push	 eax
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@MBPEMAOI@WARNING?$CB?5Safe?5memory?5mapped?5fil@
  0002c	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00031	83 c4 08	 add	 esp, 8
$LN1@check_safe:

; 497  : 	}
; 498  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?check_safe_memory_mapped_file_counter@@YGXXZ ENDP	; check_safe_memory_mapped_file_counter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\files.c
;	COMDAT ?reset_safe_memory_mapped_file_counter@@YGXXZ
_TEXT	SEGMENT
?reset_safe_memory_mapped_file_counter@@YGXXZ PROC	; reset_safe_memory_mapped_file_counter, COMDAT

; 478  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 479  : //	debug_log ("NOTE! Safe memory mapped file counter reset");
; 480  : 
; 481  : 	safe_memory_mapped_file_counter = 0;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?safe_memory_mapped_file_counter@@3HA, 0

; 482  : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?reset_safe_memory_mapped_file_counter@@YGXXZ ENDP	; reset_safe_memory_mapped_file_counter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\files.c
;	COMDAT ?file_size@@YGHPBD@Z
_TEXT	SEGMENT
_size$ = -1032						; size = 4
_fp$ = -1028						; size = 4
_fn$ = -1024						; size = 1024
_filename$ = 8						; size = 4
?file_size@@YGHPBD@Z PROC				; file_size, COMDAT

; 415  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 04 00
	00		 sub	 esp, 1224		; 000004c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 416  : 	char fn[1024];
; 417  : 
; 418  : 	FILE
; 419  : 		*fp;
; 420  : 
; 421  : 	int
; 422  : 		size;
; 423  : 
; 424  : 	size = 0;

  0000c	c7 85 f8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _size$[ebp], 0

; 425  : 
; 426  : 	if ( fp = fopen ( filename, "r" ) )

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  0001b	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00025	83 c4 08	 add	 esp, 8
  00028	89 85 fc fb ff
	ff		 mov	 DWORD PTR _fp$[ebp], eax
  0002e	83 bd fc fb ff
	ff 00		 cmp	 DWORD PTR _fp$[ebp], 0
  00035	74 45		 je	 SHORT $LN2@file_size

; 427  : 	{
; 428  : 
; 429  : 		fseek ( fp, 0, SEEK_END );

  00037	6a 02		 push	 2
  00039	6a 00		 push	 0
  0003b	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 430  : 
; 431  : 		size = ftell ( fp );

  0004b	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  00051	50		 push	 eax
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00058	83 c4 04	 add	 esp, 4
  0005b	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _size$[ebp], eax

; 432  : 
; 433  : 		fclose ( fp );

  00061	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  00067	50		 push	 eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0006e	83 c4 04	 add	 esp, 4

; 434  : 		return ( size );

  00071	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00077	e9 67 01 00 00	 jmp	 $LN1@file_size
$LN2@file_size:

; 435  : 	}
; 436  : 
; 437  : 	// JB 030311 Enable running out of separate directories
; 438  : 	fn[0] = 0;

  0007c	b8 01 00 00 00	 mov	 eax, 1
  00081	6b c8 00	 imul	 ecx, eax, 0
  00084	c6 84 0d 00 fc
	ff ff 00	 mov	 BYTE PTR _fn$[ebp+ecx], 0

; 439  : 	strcpy(fn, comanche_hokum_installation_path);

  0008c	68 00 00 00 00	 push	 OFFSET ?comanche_hokum_installation_path@@3PADA ; comanche_hokum_installation_path
  00091	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _fn$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _strcpy
  0009d	83 c4 08	 add	 esp, 8

; 440  : 	strcat(fn, "\\cohokum\\");

  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_09HGIBBNON@?2cohokum?2@
  000a5	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _fn$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _strcat
  000b1	83 c4 08	 add	 esp, 8

; 441  : 	strcat(fn, filename);

  000b4	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  000b7	50		 push	 eax
  000b8	8d 8d 00 fc ff
	ff		 lea	 ecx, DWORD PTR _fn$[ebp]
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 _strcat
  000c4	83 c4 08	 add	 esp, 8

; 442  : 
; 443  : 	if ( fp = fopen ( fn, "r" ) )

  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  000cc	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _fn$[ebp]
  000d2	50		 push	 eax
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  000d9	83 c4 08	 add	 esp, 8
  000dc	89 85 fc fb ff
	ff		 mov	 DWORD PTR _fp$[ebp], eax
  000e2	83 bd fc fb ff
	ff 00		 cmp	 DWORD PTR _fp$[ebp], 0
  000e9	74 45		 je	 SHORT $LN3@file_size

; 444  : 	{
; 445  : 
; 446  : 		fseek ( fp, 0, SEEK_END );

  000eb	6a 02		 push	 2
  000ed	6a 00		 push	 0
  000ef	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  000f5	50		 push	 eax
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 447  : 
; 448  : 		size = ftell ( fp );

  000ff	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  00105	50		 push	 eax
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  0010c	83 c4 04	 add	 esp, 4
  0010f	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _size$[ebp], eax

; 449  : 
; 450  : 		fclose ( fp );

  00115	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  0011b	50		 push	 eax
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00122	83 c4 04	 add	 esp, 4

; 451  : 		return ( size );

  00125	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  0012b	e9 b3 00 00 00	 jmp	 $LN1@file_size
$LN3@file_size:

; 452  : 	}
; 453  : 
; 454  : 	fn[0] = 0;

  00130	b8 01 00 00 00	 mov	 eax, 1
  00135	6b c8 00	 imul	 ecx, eax, 0
  00138	c6 84 0d 00 fc
	ff ff 00	 mov	 BYTE PTR _fn$[ebp+ecx], 0

; 455  : 	strcpy(fn, comanche_hokum_installation_path);

  00140	68 00 00 00 00	 push	 OFFSET ?comanche_hokum_installation_path@@3PADA ; comanche_hokum_installation_path
  00145	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _fn$[ebp]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 _strcpy
  00151	83 c4 08	 add	 esp, 8

; 456  : 	strcat(fn, "\\common\\");

  00154	68 00 00 00 00	 push	 OFFSET ??_C@_08EMMAHODI@?2common?2@
  00159	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _fn$[ebp]
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 _strcat
  00165	83 c4 08	 add	 esp, 8

; 457  : 	strcat(fn, filename);

  00168	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0016b	50		 push	 eax
  0016c	8d 8d 00 fc ff
	ff		 lea	 ecx, DWORD PTR _fn$[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 _strcat
  00178	83 c4 08	 add	 esp, 8

; 458  : 
; 459  : 	if ( fp = fopen ( fn, "r" ) )

  0017b	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  00180	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _fn$[ebp]
  00186	50		 push	 eax
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0018d	83 c4 08	 add	 esp, 8
  00190	89 85 fc fb ff
	ff		 mov	 DWORD PTR _fp$[ebp], eax
  00196	83 bd fc fb ff
	ff 00		 cmp	 DWORD PTR _fp$[ebp], 0
  0019d	74 42		 je	 SHORT $LN4@file_size

; 460  : 	{
; 461  : 
; 462  : 		fseek ( fp, 0, SEEK_END );

  0019f	6a 02		 push	 2
  001a1	6a 00		 push	 0
  001a3	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  001a9	50		 push	 eax
  001aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  001b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 463  : 
; 464  : 		size = ftell ( fp );

  001b3	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  001b9	50		 push	 eax
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  001c0	83 c4 04	 add	 esp, 4
  001c3	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _size$[ebp], eax

; 465  : 
; 466  : 		fclose ( fp );

  001c9	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  001cf	50		 push	 eax
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  001d6	83 c4 04	 add	 esp, 4

; 467  : 		return ( size );

  001d9	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  001df	eb 02		 jmp	 SHORT $LN1@file_size
$LN4@file_size:

; 468  : 	}
; 469  : 
; 470  : 	return 0;

  001e1	33 c0		 xor	 eax, eax
$LN1@file_size:

; 471  : }

  001e3	5f		 pop	 edi
  001e4	5e		 pop	 esi
  001e5	5b		 pop	 ebx
  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	c2 04 00	 ret	 4
?file_size@@YGHPBD@Z ENDP				; file_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\files.c
;	COMDAT ?file_exist@@YGHPBD@Z
_TEXT	SEGMENT
_file_ptr$ = -1028					; size = 4
_fn$ = -1024						; size = 1024
_filename$ = 8						; size = 4
?file_exist@@YGHPBD@Z PROC				; file_exist, COMDAT

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 04 00
	00		 sub	 esp, 1220		; 000004c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 369  : 	char fn[1024];
; 370  : 
; 371  : 	FILE
; 372  : 		*file_ptr;
; 373  : 
; 374  : 	if (file_ptr = fopen (filename, "r"))

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  00011	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00014	50		 push	 eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0001b	83 c4 08	 add	 esp, 8
  0001e	89 85 fc fb ff
	ff		 mov	 DWORD PTR _file_ptr$[ebp], eax
  00024	83 bd fc fb ff
	ff 00		 cmp	 DWORD PTR _file_ptr$[ebp], 0
  0002b	74 1a		 je	 SHORT $LN2@file_exist

; 375  : 	{
; 376  : 
; 377  : 		fclose (file_ptr);

  0002d	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _file_ptr$[ebp]
  00033	50		 push	 eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0003a	83 c4 04	 add	 esp, 4

; 378  : 
; 379  : 		return TRUE;

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	e9 11 01 00 00	 jmp	 $LN1@file_exist
$LN2@file_exist:

; 380  : 	}
; 381  : 
; 382  : 	// JB 030311 Enable running out of separate directories
; 383  : 	fn[0] = 0;

  00047	b8 01 00 00 00	 mov	 eax, 1
  0004c	6b c8 00	 imul	 ecx, eax, 0
  0004f	c6 84 0d 00 fc
	ff ff 00	 mov	 BYTE PTR _fn$[ebp+ecx], 0

; 384  : 	strcpy(fn, comanche_hokum_installation_path);

  00057	68 00 00 00 00	 push	 OFFSET ?comanche_hokum_installation_path@@3PADA ; comanche_hokum_installation_path
  0005c	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _fn$[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _strcpy
  00068	83 c4 08	 add	 esp, 8

; 385  : 	strcat(fn, "\\cohokum\\");

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_09HGIBBNON@?2cohokum?2@
  00070	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _fn$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _strcat
  0007c	83 c4 08	 add	 esp, 8

; 386  : 	strcat(fn, filename);

  0007f	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00082	50		 push	 eax
  00083	8d 8d 00 fc ff
	ff		 lea	 ecx, DWORD PTR _fn$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 _strcat
  0008f	83 c4 08	 add	 esp, 8

; 387  : 
; 388  : 	if (file_ptr = fopen (fn, "r"))

  00092	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  00097	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _fn$[ebp]
  0009d	50		 push	 eax
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  000a4	83 c4 08	 add	 esp, 8
  000a7	89 85 fc fb ff
	ff		 mov	 DWORD PTR _file_ptr$[ebp], eax
  000ad	83 bd fc fb ff
	ff 00		 cmp	 DWORD PTR _file_ptr$[ebp], 0
  000b4	74 1a		 je	 SHORT $LN3@file_exist

; 389  : 	{
; 390  : 		fclose (file_ptr);

  000b6	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _file_ptr$[ebp]
  000bc	50		 push	 eax
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000c3	83 c4 04	 add	 esp, 4

; 391  : 
; 392  : 		return TRUE;

  000c6	b8 01 00 00 00	 mov	 eax, 1
  000cb	e9 88 00 00 00	 jmp	 $LN1@file_exist
$LN3@file_exist:

; 393  : 	}
; 394  : 
; 395  : 	fn[0] = 0;

  000d0	b8 01 00 00 00	 mov	 eax, 1
  000d5	6b c8 00	 imul	 ecx, eax, 0
  000d8	c6 84 0d 00 fc
	ff ff 00	 mov	 BYTE PTR _fn$[ebp+ecx], 0

; 396  : 	strcpy(fn, comanche_hokum_installation_path);

  000e0	68 00 00 00 00	 push	 OFFSET ?comanche_hokum_installation_path@@3PADA ; comanche_hokum_installation_path
  000e5	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _fn$[ebp]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 _strcpy
  000f1	83 c4 08	 add	 esp, 8

; 397  : 	strcat(fn, "\\common\\");

  000f4	68 00 00 00 00	 push	 OFFSET ??_C@_08EMMAHODI@?2common?2@
  000f9	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _fn$[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _strcat
  00105	83 c4 08	 add	 esp, 8

; 398  : 	strcat(fn, filename);

  00108	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0010b	50		 push	 eax
  0010c	8d 8d 00 fc ff
	ff		 lea	 ecx, DWORD PTR _fn$[ebp]
  00112	51		 push	 ecx
  00113	e8 00 00 00 00	 call	 _strcat
  00118	83 c4 08	 add	 esp, 8

; 399  : 
; 400  : 	if (file_ptr = fopen (fn, "r"))

  0011b	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  00120	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _fn$[ebp]
  00126	50		 push	 eax
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0012d	83 c4 08	 add	 esp, 8
  00130	89 85 fc fb ff
	ff		 mov	 DWORD PTR _file_ptr$[ebp], eax
  00136	83 bd fc fb ff
	ff 00		 cmp	 DWORD PTR _file_ptr$[ebp], 0
  0013d	74 17		 je	 SHORT $LN4@file_exist

; 401  : 	{
; 402  : 		fclose (file_ptr);

  0013f	8b 85 fc fb ff
	ff		 mov	 eax, DWORD PTR _file_ptr$[ebp]
  00145	50		 push	 eax
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0014c	83 c4 04	 add	 esp, 4

; 403  : 
; 404  : 		return TRUE;

  0014f	b8 01 00 00 00	 mov	 eax, 1
  00154	eb 02		 jmp	 SHORT $LN1@file_exist
$LN4@file_exist:

; 405  : 	}
; 406  : 
; 407  : 	return FALSE;

  00156	33 c0		 xor	 eax, eax
$LN1@file_exist:

; 408  : }

  00158	5f		 pop	 edi
  00159	5e		 pop	 esi
  0015a	5b		 pop	 ebx
  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c2 04 00	 ret	 4
?file_exist@@YGHPBD@Z ENDP				; file_exist
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\files.c
;	COMDAT ?mclose@@YGHPAX@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_data$ = 8						; size = 4
?mclose@@YGHPAX@Z PROC					; mclose, COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 318  : 
; 319  : 	int
; 320  : 		count;
; 321  : 
; 322  : 	for ( count=0; ( ( count<MAX_NUMBER_FILES ) && ( file_maps[count].data != data ) ); count++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@mclose
$LN2@mclose:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@mclose:
  0001b	81 7d fc 00 04
	00 00		 cmp	 DWORD PTR _count$[ebp], 1024 ; 00000400H
  00022	7d 17		 jge	 SHORT $LN3@mclose
  00024	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00027	c1 e0 04	 shl	 eax, 4
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  00030	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  00034	3b 55 08	 cmp	 edx, DWORD PTR _data$[ebp]
  00037	74 02		 je	 SHORT $LN3@mclose

; 323  : 	{
; 324  : 	}

  00039	eb d7		 jmp	 SHORT $LN2@mclose
$LN3@mclose:

; 325  : 
; 326  : 	if ( count == MAX_NUMBER_FILES )

  0003b	81 7d fc 00 04
	00 00		 cmp	 DWORD PTR _count$[ebp], 1024 ; 00000400H
  00042	75 14		 jne	 SHORT $LN5@mclose

; 327  : 	{
; 328  : 
; 329  : 		debug_log ( "Unable to locate memory mapped file to unmap file." );

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@DHBADLFO@Unable?5to?5locate?5memory?5mapped?5@
  00049	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0004e	83 c4 04	 add	 esp, 4

; 330  : 
; 331  : 		return ( FALSE );

  00051	33 c0		 xor	 eax, eax
  00053	e9 99 00 00 00	 jmp	 $LN1@mclose
$LN5@mclose:

; 332  : 	}
; 333  : 
; 334  : #ifdef WIN32
; 335  : 	UnmapViewOfFile ( file_maps[count].data );

  00058	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0005b	c1 e0 04	 shl	 eax, 4
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  00064	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  00068	52		 push	 edx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnmapViewOfFile@4

; 336  : 
; 337  : 	CloseHandle ( file_maps[count].hMap );

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00072	c1 e0 04	 shl	 eax, 4
  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  0007b	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  0007f	52		 push	 edx
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 338  : 
; 339  : 	CloseHandle ( file_maps[count].hFile );

  00086	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00089	c1 e0 04	 shl	 eax, 4
  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  00092	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00096	52		 push	 edx
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 340  : #else
; 341  : 	munmap( file_maps[count].data, file_maps[count].length );
; 342  : 
; 343  : 	close( file_maps[count].fd );
; 344  : #endif
; 345  : 
; 346  : 
; 347  : 	file_maps[count].used = FALSE;

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000a0	c1 e0 04	 shl	 eax, 4
  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  000a9	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [ecx+eax], 0

; 348  : #ifdef WIN32
; 349  : 	file_maps[count].hFile = 0;

  000b0	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000b3	c1 e0 04	 shl	 eax, 4
  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  000bc	c7 44 01 04 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+4], 0

; 350  : 	file_maps[count].hMap = 0;

  000c4	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000c7	c1 e0 04	 shl	 eax, 4
  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  000d0	c7 44 01 08 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+8], 0

; 351  : #else
; 352  : 	file_maps[count].fd = 0;
; 353  : 	file_maps[count].length = 0;
; 354  : #endif
; 355  : 	file_maps[count].data = NULL;

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000db	c1 e0 04	 shl	 eax, 4
  000de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  000e4	c7 44 01 0c 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+12], 0

; 356  : 
; 357  : 	return ( TRUE );

  000ec	b8 01 00 00 00	 mov	 eax, 1
$LN1@mclose:

; 358  : }

  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c2 04 00	 ret	 4
?mclose@@YGHPAX@Z ENDP					; mclose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\files.c
;	COMDAT ?mopen@@YGPAXPBD@Z
_TEXT	SEGMENT
_mapping_name$ = -272					; size = 256
_count$ = -16						; size = 4
_data$ = -12						; size = 4
_hMap$ = -8						; size = 4
_hFile$ = -4						; size = 4
_filename$ = 8						; size = 4
?mopen@@YGPAXPBD@Z PROC					; mopen, COMDAT

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 191  : #ifdef WIN32
; 192  : 	HANDLE
; 193  : 		hFile,
; 194  : 		hMap;
; 195  : #else
; 196  : 	int
; 197  : 		fd;
; 198  : 
; 199  : 	long
; 200  : 		length;
; 201  : 
; 202  : 	struct stat filestat;
; 203  : #endif
; 204  : 	
; 205  : 	void
; 206  : 		*data;
; 207  : 
; 208  : 	int
; 209  : 		count;
; 210  : 
; 211  : 	char
; 212  : 		mapping_name[256];
; 213  : 
; 214  : 
; 215  : 	for ( count=0; ( ( count<MAX_NUMBER_FILES ) && ( file_maps[count].used ) ); count++ )

  0000c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@mopen
$LN2@mopen:
  00015	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN4@mopen:
  0001e	81 7d f0 00 04
	00 00		 cmp	 DWORD PTR _count$[ebp], 1024 ; 00000400H
  00025	7d 14		 jge	 SHORT $LN3@mopen
  00027	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  0002a	c1 e0 04	 shl	 eax, 4
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  00033	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  00037	74 02		 je	 SHORT $LN3@mopen

; 216  : 	{
; 217  : 	}

  00039	eb da		 jmp	 SHORT $LN2@mopen
$LN3@mopen:

; 218  : 
; 219  : 	if ( count == MAX_NUMBER_FILES )

  0003b	81 7d f0 00 04
	00 00		 cmp	 DWORD PTR _count$[ebp], 1024 ; 00000400H
  00042	75 19		 jne	 SHORT $LN5@mopen

; 220  : 	{
; 221  : 
; 222  : 		debug_log ( "Unable to create a file mapping - maximum files already mapped" );

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@FMCGNAEH@Unable?5to?5create?5a?5file?5mapping@
  00049	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0004e	83 c4 04	 add	 esp, 4

; 223  : 
; 224  : 		return ( NULL );

  00051	33 c0		 xor	 eax, eax
  00053	e9 38 01 00 00	 jmp	 $LN1@mopen

; 225  : 	}
; 226  : 	else

  00058	e9 33 01 00 00	 jmp	 $LN1@mopen
$LN5@mopen:

; 227  : 	{
; 228  : 
; 229  : #ifdef WIN32
; 230  : 		hFile = CreateFile ( filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

  0005d	6a 00		 push	 0
  0005f	68 80 00 00 00	 push	 128			; 00000080H
  00064	6a 03		 push	 3
  00066	6a 00		 push	 0
  00068	6a 01		 push	 1
  0006a	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0006f	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00072	50		 push	 eax
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00079	89 45 fc	 mov	 DWORD PTR _hFile$[ebp], eax

; 231  : 
; 232  : 		if ( !hFile )

  0007c	83 7d fc 00	 cmp	 DWORD PTR _hFile$[ebp], 0
  00080	75 18		 jne	 SHORT $LN7@mopen

; 233  : 		{
; 234  : 
; 235  : 			debug_log ( "Unable to memory map file %s", filename );

  00082	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00085	50		 push	 eax
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@BONJAOFP@Unable?5to?5memory?5map?5file?5?$CFs@
  0008b	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00090	83 c4 08	 add	 esp, 8

; 236  : 
; 237  : 			return ( NULL );

  00093	33 c0		 xor	 eax, eax
  00095	e9 f6 00 00 00	 jmp	 $LN1@mopen
$LN7@mopen:

; 238  : 		}
; 239  : #else
; 240  : 		fd = open ( filename, O_RDONLY );
; 241  : 
; 242  : 		if ( !fd )
; 243  : 		{
; 244  : 			debug_log ( "Unable to open file %s prior to mmap: %s", filename, strerror(errno) );
; 245  : 
; 246  : 			return ( NULL );
; 247  : 		}
; 248  : #endif
; 249  : 
; 250  : 		sprintf ( mapping_name, "%08x%04dFileMapping", timeGetTime (), count );

  0009a	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  0009d	50		 push	 eax
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  000a4	50		 push	 eax
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KFOBFKHE@?$CF08x?$CF04dFileMapping@
  000aa	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _mapping_name$[ebp]
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 _sprintf
  000b6	83 c4 10	 add	 esp, 16			; 00000010H

; 251  : 
; 252  : #ifdef WIN32
; 253  : 		hMap = CreateFileMapping ( hFile, NULL, PAGE_READONLY, 0, 0, mapping_name );

  000b9	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _mapping_name$[ebp]
  000bf	50		 push	 eax
  000c0	6a 00		 push	 0
  000c2	6a 00		 push	 0
  000c4	6a 02		 push	 2
  000c6	6a 00		 push	 0
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR _hFile$[ebp]
  000cb	51		 push	 ecx
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileMappingA@24
  000d2	89 45 f8	 mov	 DWORD PTR _hMap$[ebp], eax

; 254  : 
; 255  : 		if ( ! hMap )

  000d5	83 7d f8 00	 cmp	 DWORD PTR _hMap$[ebp], 0
  000d9	75 22		 jne	 SHORT $LN8@mopen

; 256  : 		{
; 257  : 
; 258  : 			CloseHandle ( hFile );

  000db	8b 45 fc	 mov	 eax, DWORD PTR _hFile$[ebp]
  000de	50		 push	 eax
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 259  : 
; 260  : 			debug_log ( "Unable to create memory mapped file %s", filename );

  000e5	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  000e8	50		 push	 eax
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MPCGMOGF@Unable?5to?5create?5memory?5mapped?5@
  000ee	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  000f3	83 c4 08	 add	 esp, 8

; 261  : 
; 262  : 			return ( NULL );

  000f6	33 c0		 xor	 eax, eax
  000f8	e9 93 00 00 00	 jmp	 $LN1@mopen
$LN8@mopen:

; 263  : 		}
; 264  : 
; 265  : 		data = MapViewOfFile ( hMap, FILE_MAP_READ, 0, 0, 0 );

  000fd	6a 00		 push	 0
  000ff	6a 00		 push	 0
  00101	6a 00		 push	 0
  00103	6a 04		 push	 4
  00105	8b 45 f8	 mov	 eax, DWORD PTR _hMap$[ebp]
  00108	50		 push	 eax
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapViewOfFile@20
  0010f	89 45 f4	 mov	 DWORD PTR _data$[ebp], eax

; 266  : #else
; 267  : 		// set length to size of file
; 268  : 		fstat( fd, &filestat );
; 269  : 		length = filestat.st_size;
; 270  : 
; 271  : 		data = mmap(0, length, PROT_READ, MAP_SHARED, fd, 0);
; 272  : #endif
; 273  : 		if ( ! data )

  00112	83 7d f4 00	 cmp	 DWORD PTR _data$[ebp], 0
  00116	75 29		 jne	 SHORT $LN9@mopen

; 274  : 		{
; 275  : 
; 276  : #ifdef WIN32
; 277  : 			CloseHandle ( hMap );

  00118	8b 45 f8	 mov	 eax, DWORD PTR _hMap$[ebp]
  0011b	50		 push	 eax
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 278  : 
; 279  : 			CloseHandle ( hFile );

  00122	8b 45 fc	 mov	 eax, DWORD PTR _hFile$[ebp]
  00125	50		 push	 eax
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 280  : 
; 281  : 			debug_log ( "Unable to create file mapping for memory mapped file %s", filename );

  0012c	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0012f	50		 push	 eax
  00130	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@NBOFFKMK@Unable?5to?5create?5file?5mapping?5f@
  00135	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0013a	83 c4 08	 add	 esp, 8

; 282  : #else
; 283  : 			close(fd);
; 284  : 
; 285  : 			debug_log ( "Unable to create file mapping for memory mapped file %s: %s", filename, strerror(errno) );
; 286  : #endif
; 287  : 
; 288  : 			return ( NULL );

  0013d	33 c0		 xor	 eax, eax
  0013f	eb 4f		 jmp	 SHORT $LN1@mopen
$LN9@mopen:

; 289  : 		}
; 290  : 
; 291  : #ifdef WIN32
; 292  : 		file_maps[count].hFile = hFile;

  00141	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  00144	c1 e0 04	 shl	 eax, 4
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  0014d	8b 55 fc	 mov	 edx, DWORD PTR _hFile$[ebp]
  00150	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx

; 293  : 		file_maps[count].hMap = hMap;

  00154	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  00157	c1 e0 04	 shl	 eax, 4
  0015a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  00160	8b 55 f8	 mov	 edx, DWORD PTR _hMap$[ebp]
  00163	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 294  : #else
; 295  : 		file_maps[count].fd = fd;
; 296  : 		file_maps[count].length = length;
; 297  : #endif
; 298  : 		file_maps[count].data = data;

  00167	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  0016a	c1 e0 04	 shl	 eax, 4
  0016d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  00173	8b 55 f4	 mov	 edx, DWORD PTR _data$[ebp]
  00176	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx

; 299  : 
; 300  : #if DEBUG_MODULE
; 301  : 
; 302  : 		strcpy ( file_maps[count].filename, filename );
; 303  : 
; 304  : #endif
; 305  : 
; 306  : 		file_maps[count].used = TRUE;

  0017a	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  0017d	c1 e0 04	 shl	 eax, 4
  00180	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  00186	c7 04 01 01 00
	00 00		 mov	 DWORD PTR [ecx+eax], 1

; 307  : 
; 308  : 		return ( data );

  0018d	8b 45 f4	 mov	 eax, DWORD PTR _data$[ebp]
$LN1@mopen:

; 309  : 	}
; 310  : }

  00190	5f		 pop	 edi
  00191	5e		 pop	 esi
  00192	5b		 pop	 ebx
  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c2 04 00	 ret	 4
?mopen@@YGPAXPBD@Z ENDP					; mopen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\files.c
;	COMDAT ?initialise_file_system@@YGHXZ
_TEXT	SEGMENT
_count$ = -4						; size = 4
?initialise_file_system@@YGHXZ PROC			; initialise_file_system, COMDAT

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 134  : 
; 135  : 	int
; 136  : 		count;
; 137  : 
; 138  : 	file_maps = (filemap *) safe_malloc ( sizeof ( filemap ) * MAX_NUMBER_FILES );

  00009	68 00 40 00 00	 push	 16384			; 00004000H
  0000e	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00013	a3 00 00 00 00	 mov	 DWORD PTR ?file_maps@@3PAUFILEMAP@@A, eax

; 139  : 
; 140  : 	for ( count = 0; count < MAX_NUMBER_FILES; count++ )

  00018	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  0001f	eb 09		 jmp	 SHORT $LN4@initialise
$LN2@initialise:
  00021	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00024	83 c0 01	 add	 eax, 1
  00027	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@initialise:
  0002a	81 7d fc 00 04
	00 00		 cmp	 DWORD PTR _count$[ebp], 1024 ; 00000400H
  00031	7d 51		 jge	 SHORT $LN3@initialise

; 141  : 	{
; 142  : 
; 143  : 		file_maps[count].used = FALSE;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00036	c1 e0 04	 shl	 eax, 4
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  0003f	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [ecx+eax], 0

; 144  : #ifdef WIN32
; 145  : 		file_maps[count].hFile = 0;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00049	c1 e0 04	 shl	 eax, 4
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  00052	c7 44 01 04 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+4], 0

; 146  : 		file_maps[count].hMap = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0005d	c1 e0 04	 shl	 eax, 4
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  00066	c7 44 01 08 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+8], 0

; 147  : #else
; 148  : 		file_maps[count].fd = 0;
; 149  : 		file_maps[count].length = 0;
; 150  : #endif
; 151  : 		file_maps[count].data = NULL;

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00071	c1 e0 04	 shl	 eax, 4
  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_maps@@3PAUFILEMAP@@A
  0007a	c7 44 01 0c 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+12], 0

; 152  : 	}

  00082	eb 9d		 jmp	 SHORT $LN2@initialise
$LN3@initialise:

; 153  : 
; 154  : 	register_exit_function ( deinitialise_file_system );

  00084	68 00 00 00 00	 push	 OFFSET ?deinitialise_file_system@@YGXXZ ; deinitialise_file_system
  00089	e8 00 00 00 00	 call	 ?register_exit_function@@YGXP6GXXZ@Z ; register_exit_function

; 155  : 
; 156  : 	return ( TRUE );

  0008e	b8 01 00 00 00	 mov	 eax, 1

; 157  : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?initialise_file_system@@YGHXZ ENDP			; initialise_file_system
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1459 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1460 :         #pragma warning(push)
; 1461 :         #pragma warning(disable: 4996) // Deprecation
; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1463 :         #pragma warning(pop)
; 1464 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH
  00035	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00038	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003c	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003e	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00045	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00047	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  0004a	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004d	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1395 :     }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
