; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\maths\miscmath.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_fabsf
PUBLIC	?fabs@@YGMM@Z					; fabs
PUBLIC	?dbound@@YGNNNN@Z				; dbound
PUBLIC	?ibound@@YGHHHH@Z				; ibound
PUBLIC	?uibound@@YGIIII@Z				; uibound
PUBLIC	?fast_modf@@YGMMPAM@Z				; fast_modf
PUBLIC	?frac@@YGMM@Z					; frac
PUBLIC	?log_base_2@@YGHH@Z				; log_base_2
PUBLIC	?modify_angle@@YGXPAMMM@Z			; modify_angle
PUBLIC	?__LINE__Var@?0??modify_angle@@YGXPAMMM@Z@4JA	; `modify_angle'::`1'::__LINE__Var
PUBLIC	??_C@_0DG@KJECLMM@c?3?2users?2nhv90?2projects?2eech?2mo@ ; `string'
PUBLIC	??_C@_0N@MKEPPFOC@rate?5?$DO?$DN?50?40f@	; `string'
PUBLIC	__real@00000000
PUBLIC	__real@40c90fdb
EXTRN	_fabs:PROC
EXTRN	?process_assert@@YGXPBD0H@Z:PROC		; process_assert
EXTRN	?convert_float_to_int@@YGXMPAH@Z:PROC		; convert_float_to_int
EXTRN	__fltused:DWORD
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0N@MKEPPFOC@rate?5?$DO?$DN?50?40f@
CONST	SEGMENT
??_C@_0N@MKEPPFOC@rate?5?$DO?$DN?50?40f@ DB 'rate >= 0.0f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KJECLMM@c?3?2users?2nhv90?2projects?2eech?2mo@
CONST	SEGMENT
??_C@_0DG@KJECLMM@c?3?2users?2nhv90?2projects?2eech?2mo@ DB 'c:\users\nhv'
	DB	'90\projects\eech\modules\maths\miscmath.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??modify_angle@@YGXPAMMM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??modify_angle@@YGXPAMMM@Z@4JA DD 0c6H	; `modify_angle'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\maths\miscmath.c
;	COMDAT ?modify_angle@@YGXPAMMM@Z
_TEXT	SEGMENT
tv84 = -80						; size = 4
tv75 = -80						; size = 4
_d$ = -12						; size = 4
_n$ = -8						; size = 4
_l$ = -4						; size = 4
_angle$ = 8						; size = 4
_target$ = 12						; size = 4
_rate$ = 16						; size = 4
?modify_angle@@YGXPAMMM@Z PROC				; modify_angle, COMDAT

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 199  : 	float
; 200  : 		l,
; 201  : 		n,
; 202  : 		d;
; 203  : 
; 204  : 	ASSERT ( rate >= 0.0f );

  00009	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _rate$[ebp]
  0000e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00015	73 18		 jae	 SHORT $LN5@modify_ang
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??modify_angle@@YGXPAMMM@Z@4JA
  0001c	83 c0 06	 add	 eax, 6
  0001f	50		 push	 eax
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@KJECLMM@c?3?2users?2nhv90?2projects?2eech?2mo@
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MKEPPFOC@rate?5?$DO?$DN?50?40f@
  0002a	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN5@modify_ang:

; 205  : 
; 206  : 	for ( l = fabs ( target - *angle ); ; *angle = n, l = d )

  0002f	8b 45 08	 mov	 eax, DWORD PTR _angle$[ebp]
  00032	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _target$[ebp]
  00037	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  0003b	51		 push	 ecx
  0003c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00041	e8 00 00 00 00	 call	 ?fabs@@YGMM@Z		; fabs
  00046	d9 5d fc	 fstp	 DWORD PTR _l$[ebp]
  00049	eb 16		 jmp	 SHORT $LN4@modify_ang
$LN2@modify_ang:
  0004b	8b 45 08	 mov	 eax, DWORD PTR _angle$[ebp]
  0004e	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _n$[ebp]
  00053	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00057	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _d$[ebp]
  0005c	f3 0f 11 45 fc	 movss	 DWORD PTR _l$[ebp], xmm0
$LN4@modify_ang:

; 207  : 	{
; 208  : 		n = *angle < target ? *angle + PI2 : *angle - PI2;

  00061	8b 45 08	 mov	 eax, DWORD PTR _angle$[ebp]
  00064	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _target$[ebp]
  00069	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  0006c	76 16		 jbe	 SHORT $LN9@modify_ang
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _angle$[ebp]
  00071	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00075	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40c90fdb
  0007d	f3 0f 11 45 b0	 movss	 DWORD PTR tv75[ebp], xmm0
  00082	eb 14		 jmp	 SHORT $LN10@modify_ang
$LN9@modify_ang:
  00084	8b 55 08	 mov	 edx, DWORD PTR _angle$[ebp]
  00087	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0008b	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40c90fdb
  00093	f3 0f 11 45 b0	 movss	 DWORD PTR tv75[ebp], xmm0
$LN10@modify_ang:
  00098	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR tv75[ebp]
  0009d	f3 0f 11 45 f8	 movss	 DWORD PTR _n$[ebp], xmm0

; 209  : 		d = fabs ( target - n );

  000a2	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _target$[ebp]
  000a7	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR _n$[ebp]
  000ac	51		 push	 ecx
  000ad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b2	e8 00 00 00 00	 call	 ?fabs@@YGMM@Z		; fabs
  000b7	d9 5d f4	 fstp	 DWORD PTR _d$[ebp]

; 210  : 		if ( d >= l )

  000ba	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _d$[ebp]
  000bf	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR _l$[ebp]
  000c3	72 02		 jb	 SHORT $LN6@modify_ang

; 211  : 		{
; 212  : 			break;

  000c5	eb 02		 jmp	 SHORT $LN3@modify_ang
$LN6@modify_ang:

; 213  : 		}
; 214  : 	}

  000c7	eb 82		 jmp	 SHORT $LN2@modify_ang
$LN3@modify_ang:

; 215  : 
; 216  : 	if ( rate > l )

  000c9	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _rate$[ebp]
  000ce	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR _l$[ebp]
  000d2	76 0a		 jbe	 SHORT $LN7@modify_ang

; 217  : 	{
; 218  : 		rate = l;

  000d4	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _l$[ebp]
  000d9	f3 0f 11 45 10	 movss	 DWORD PTR _rate$[ebp], xmm0
$LN7@modify_ang:

; 219  : 	}
; 220  : 
; 221  : 	*angle = *angle > target ? *angle - rate : *angle + rate;

  000de	8b 45 08	 mov	 eax, DWORD PTR _angle$[ebp]
  000e1	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000e5	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _target$[ebp]
  000e9	76 13		 jbe	 SHORT $LN11@modify_ang
  000eb	8b 4d 08	 mov	 ecx, DWORD PTR _angle$[ebp]
  000ee	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  000f2	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _rate$[ebp]
  000f7	f3 0f 11 45 b0	 movss	 DWORD PTR tv84[ebp], xmm0
  000fc	eb 11		 jmp	 SHORT $LN12@modify_ang
$LN11@modify_ang:
  000fe	8b 55 08	 mov	 edx, DWORD PTR _angle$[ebp]
  00101	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00105	f3 0f 58 45 10	 addss	 xmm0, DWORD PTR _rate$[ebp]
  0010a	f3 0f 11 45 b0	 movss	 DWORD PTR tv84[ebp], xmm0
$LN12@modify_ang:
  0010f	8b 45 08	 mov	 eax, DWORD PTR _angle$[ebp]
  00112	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR tv84[ebp]
  00117	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 222  : }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 0c 00	 ret	 12			; 0000000cH
?modify_angle@@YGXPAMMM@Z ENDP				; modify_angle
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\maths\miscmath.c
;	COMDAT ?log_base_2@@YGHH@Z
_TEXT	SEGMENT
_result$ = -4						; size = 4
_val$ = 8						; size = 4
?log_base_2@@YGHH@Z PROC				; log_base_2, COMDAT

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 176  : 	//
; 177  : 	// if y = 2^x, returns x for given y
; 178  : 	//
; 179  : 
; 180  : 	int
; 181  : 		result;
; 182  : 
; 183  : 	result = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0
$LN2@log_base_2:

; 184  : 
; 185  : 	while (val >>= 1)

  00010	8b 45 08	 mov	 eax, DWORD PTR _val$[ebp]
  00013	d1 f8		 sar	 eax, 1
  00015	89 45 08	 mov	 DWORD PTR _val$[ebp], eax
  00018	74 0b		 je	 SHORT $LN3@log_base_2

; 186  : 	{
; 187  : 		result += 1;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax

; 188  : 	}

  00023	eb eb		 jmp	 SHORT $LN2@log_base_2
$LN3@log_base_2:

; 189  : 
; 190  : 	return result;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]

; 191  : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?log_base_2@@YGHH@Z ENDP				; log_base_2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\maths\miscmath.c
;	COMDAT ?frac@@YGMM@Z
_TEXT	SEGMENT
_dummy$ = -4						; size = 4
_value$ = 8						; size = 4
?frac@@YGMM@Z PROC					; frac, COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 160  : 	//
; 161  : 	// takes a floating point value, and returns only the fractional part
; 162  : 	//
; 163  : 	
; 164  : 	float
; 165  : 		dummy;
; 166  : 
; 167  : 	return fast_modf ( value, &dummy );

  00009	8d 45 fc	 lea	 eax, DWORD PTR _dummy$[ebp]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _value$[ebp]
  00013	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00018	e8 00 00 00 00	 call	 ?fast_modf@@YGMMPAM@Z	; fast_modf

; 168  : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?frac@@YGMM@Z ENDP					; frac
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\maths\miscmath.c
;	COMDAT ?fast_modf@@YGMMPAM@Z
_TEXT	SEGMENT
_whole_value$ = -4					; size = 4
_value$ = 8						; size = 4
_iptr$ = 12						; size = 4
?fast_modf@@YGMMPAM@Z PROC				; fast_modf, COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 141  : 
; 142  : 	int
; 143  : 		whole_value;
; 144  : 
; 145  : 	convert_float_to_int ( value, &whole_value );

  00009	8d 45 fc	 lea	 eax, DWORD PTR _whole_value$[ebp]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _value$[ebp]
  00013	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00018	e8 00 00 00 00	 call	 ?convert_float_to_int@@YGXMPAH@Z ; convert_float_to_int

; 146  : 
; 147  : 	value -= whole_value;

  0001d	f3 0f 2a 45 fc	 cvtsi2ss xmm0, DWORD PTR _whole_value$[ebp]
  00022	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _value$[ebp]
  00027	f3 0f 5c c8	 subss	 xmm1, xmm0
  0002b	f3 0f 11 4d 08	 movss	 DWORD PTR _value$[ebp], xmm1

; 148  : 
; 149  : 	*iptr = ( float ) whole_value;

  00030	f3 0f 2a 45 fc	 cvtsi2ss xmm0, DWORD PTR _whole_value$[ebp]
  00035	8b 45 0c	 mov	 eax, DWORD PTR _iptr$[ebp]
  00038	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 150  : 
; 151  : 	return ( value );

  0003c	d9 45 08	 fld	 DWORD PTR _value$[ebp]

; 152  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
?fast_modf@@YGMMPAM@Z ENDP				; fast_modf
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\maths\miscmath.c
;	COMDAT ?uibound@@YGIIII@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_min$ = 12						; size = 4
_max$ = 16						; size = 4
?uibound@@YGIIII@Z PROC					; uibound, COMDAT

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 119  : 
; 120  : 	if ( value < min )

  00009	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0000c	3b 45 0c	 cmp	 eax, DWORD PTR _min$[ebp]
  0000f	73 05		 jae	 SHORT $LN2@uibound

; 121  : 	{
; 122  : 
; 123  : 		return ( min );

  00011	8b 45 0c	 mov	 eax, DWORD PTR _min$[ebp]
  00014	eb 10		 jmp	 SHORT $LN1@uibound
$LN2@uibound:

; 124  : 	}
; 125  : 
; 126  : 	if ( value > max )

  00016	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00019	3b 45 10	 cmp	 eax, DWORD PTR _max$[ebp]
  0001c	76 05		 jbe	 SHORT $LN3@uibound

; 127  : 	{
; 128  : 
; 129  : 		return ( max );

  0001e	8b 45 10	 mov	 eax, DWORD PTR _max$[ebp]
  00021	eb 03		 jmp	 SHORT $LN1@uibound
$LN3@uibound:

; 130  : 	}
; 131  : 
; 132  : 	return ( value );

  00023	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
$LN1@uibound:

; 133  : }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 0c 00	 ret	 12			; 0000000cH
?uibound@@YGIIII@Z ENDP					; uibound
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\maths\miscmath.c
;	COMDAT ?ibound@@YGHHHH@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_min$ = 12						; size = 4
_max$ = 16						; size = 4
?ibound@@YGHHHH@Z PROC					; ibound, COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 97   : 
; 98   : 	if ( value < min )

  00009	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0000c	3b 45 0c	 cmp	 eax, DWORD PTR _min$[ebp]
  0000f	7d 05		 jge	 SHORT $LN2@ibound

; 99   : 	{
; 100  : 
; 101  : 		return ( min );

  00011	8b 45 0c	 mov	 eax, DWORD PTR _min$[ebp]
  00014	eb 10		 jmp	 SHORT $LN1@ibound
$LN2@ibound:

; 102  : 	}
; 103  : 
; 104  : 	if ( value > max )

  00016	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00019	3b 45 10	 cmp	 eax, DWORD PTR _max$[ebp]
  0001c	7e 05		 jle	 SHORT $LN3@ibound

; 105  : 	{
; 106  : 
; 107  : 		return ( max );

  0001e	8b 45 10	 mov	 eax, DWORD PTR _max$[ebp]
  00021	eb 03		 jmp	 SHORT $LN1@ibound
$LN3@ibound:

; 108  : 	}
; 109  : 
; 110  : 	return ( value );

  00023	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
$LN1@ibound:

; 111  : }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 0c 00	 ret	 12			; 0000000cH
?ibound@@YGHHHH@Z ENDP					; ibound
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\maths\miscmath.c
;	COMDAT ?dbound@@YGNNNN@Z
_TEXT	SEGMENT
_value$ = 8						; size = 8
_min$ = 16						; size = 8
_max$ = 24						; size = 8
?dbound@@YGNNNN@Z PROC					; dbound, COMDAT

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 75   : 
; 76   : 	if ( value < min )

  00009	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _min$[ebp]
  0000e	66 0f 2f 45 08	 comisd	 xmm0, QWORD PTR _value$[ebp]
  00013	76 05		 jbe	 SHORT $LN2@dbound

; 77   : 	{
; 78   : 
; 79   : 		return ( min );

  00015	dd 45 10	 fld	 QWORD PTR _min$[ebp]
  00018	eb 14		 jmp	 SHORT $LN1@dbound
$LN2@dbound:

; 80   : 	}
; 81   : 
; 82   : 	if ( value > max )

  0001a	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _value$[ebp]
  0001f	66 0f 2f 45 18	 comisd	 xmm0, QWORD PTR _max$[ebp]
  00024	76 05		 jbe	 SHORT $LN3@dbound

; 83   : 	{
; 84   : 
; 85   : 		return ( max );

  00026	dd 45 18	 fld	 QWORD PTR _max$[ebp]
  00029	eb 03		 jmp	 SHORT $LN1@dbound
$LN3@dbound:

; 86   : 	}
; 87   : 
; 88   : 	return ( value );

  0002b	dd 45 08	 fld	 QWORD PTR _value$[ebp]
$LN1@dbound:

; 89   : }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 18 00	 ret	 24			; 00000018H
?dbound@@YGNNNN@Z ENDP					; dbound
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?fabs@@YGMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?fabs@@YGMM@Z PROC					; fabs, COMDAT

; 112  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 113  : 	return (_CSTD fabsf(_Xx));

  00009	51		 push	 ecx
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
  0000f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00014	e8 00 00 00 00	 call	 _fabsf
  00019	83 c4 04	 add	 esp, 4

; 114  : 	}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?fabs@@YGMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv71 = -68						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 671  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 672  :             return (float)fabs(_X);

  00009	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0000e	83 ec 08	 sub	 esp, 8
  00011	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00016	e8 00 00 00 00	 call	 _fabs
  0001b	83 c4 08	 add	 esp, 8
  0001e	d9 5d bc	 fstp	 DWORD PTR tv71[ebp]
  00021	d9 45 bc	 fld	 DWORD PTR tv71[ebp]

; 673  :         }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
END
