; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\system\memblock.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?initialise_memory_block_system@@YGXXZ		; initialise_memory_block_system
PUBLIC	?deinitialise_memory_block_system@@YGXXZ	; deinitialise_memory_block_system
PUBLIC	?create_memory_block_configuration@@YGXPAUMEMORY_BLOCK_CONFIGURATION@@H@Z ; create_memory_block_configuration
PUBLIC	?create_memory_blocks@@YGXHH@Z			; create_memory_blocks
PUBLIC	?get_memory_block_system_installed@@YGHXZ	; get_memory_block_system_installed
PUBLIC	?malloc_fast_memory@@YGPAXI@Z			; malloc_fast_memory
PUBLIC	?malloc_heap_memory@@YGPAXI@Z			; malloc_heap_memory
PUBLIC	?free_mem@@YGXPAX@Z				; free_mem
PUBLIC	?display_memory_block_system_statistics@@YGXXZ	; display_memory_block_system_statistics
PUBLIC	??_C@_0DL@HACDABBH@WARNING?$CB?5Memory?5block?5array?5sti@ ; `string'
PUBLIC	?__LINE__Var@?0??create_memory_block_configuration@@YGXPAUMEMORY_BLOCK_CONFIGURATION@@H@Z@4JA ; `create_memory_block_configuration'::`1'::__LINE__Var
PUBLIC	??_C@_0DH@NKPBCGF@c?3?2users?2nhv90?2projects?2eech?2mo@ ; `string'
PUBLIC	??_C@_0BE@DKDLCIDP@memory_block_config@		; `string'
PUBLIC	??_C@_0BA@BEIHKJDI@num_entries?5?$DO?50@	; `string'
PUBLIC	?__LINE__Var@?0??create_memory_blocks@@YGXHH@Z@4JA ; `create_memory_blocks'::`1'::__LINE__Var
PUBLIC	??_C@_0P@JIMOOMN@block_size?5?$DO?50@		; `string'
PUBLIC	??_C@_0P@MCHJJGCE@num_blocks?5?$DO?50@		; `string'
PUBLIC	??_C@_0DM@DENMGBHJ@WARNING?$CB?5Duplicate?5memory?5block@ ; `string'
PUBLIC	?__LINE__Var@?0??malloc_fast_memory@@YGPAXI@Z@4JA ; `malloc_fast_memory'::`1'::__LINE__Var
PUBLIC	??_C@_08DJGDGONI@size?5?$DO?50@			; `string'
PUBLIC	??_C@_0BE@BIKDBOEM@memory_block_arrays@		; `string'
PUBLIC	?__LINE__Var@?0??malloc_heap_memory@@YGPAXI@Z@4JA ; `malloc_heap_memory'::`1'::__LINE__Var
PUBLIC	??_C@_0L@ENBAAPJM@heap_array@			; `string'
PUBLIC	?__LINE__Var@?0??free_mem@@YGXPAX@Z@4JA		; `free_mem'::`1'::__LINE__Var
PUBLIC	??_C@_03PLHFFLIH@ptr@				; `string'
PUBLIC	??_C@_0DI@PCANDKIC@WARNING?$CB?5Memory?5block?5system?5st@ ; `string'
EXTRN	_memset:PROC
EXTRN	?process_assert@@YGXPBD0H@Z:PROC		; process_assert
EXTRN	?debug_log@@YAXPBDZZ:PROC			; debug_log
EXTRN	?safe_malloc_memory@@YGPAXI@Z:PROC		; safe_malloc_memory
EXTRN	?safe_free@@YGXPAX@Z:PROC			; safe_free
_BSS	SEGMENT
?memory_block_system_installed@@3HA DD 01H DUP (?)	; memory_block_system_installed
?memory_block_arrays@@3PAUMEMARRAY@@A DD 01H DUP (?)	; memory_block_arrays
?heap_array@@3PAUMEMARRAY@@A DD 01H DUP (?)		; heap_array
_BSS	ENDS
;	COMDAT ??_C@_0DI@PCANDKIC@WARNING?$CB?5Memory?5block?5system?5st@
CONST	SEGMENT
??_C@_0DI@PCANDKIC@WARNING?$CB?5Memory?5block?5system?5st@ DB 'WARNING! M'
	DB	'emory block system statistics are not enabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PLHFFLIH@ptr@
CONST	SEGMENT
??_C@_03PLHFFLIH@ptr@ DB 'ptr', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??free_mem@@YGXPAX@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??free_mem@@YGXPAX@Z@4JA DD 02e1H	; `free_mem'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0L@ENBAAPJM@heap_array@
CONST	SEGMENT
??_C@_0L@ENBAAPJM@heap_array@ DB 'heap_array', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??malloc_heap_memory@@YGPAXI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??malloc_heap_memory@@YGPAXI@Z@4JA DD 02a2H ; `malloc_heap_memory'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BE@BIKDBOEM@memory_block_arrays@
CONST	SEGMENT
??_C@_0BE@BIKDBOEM@memory_block_arrays@ DB 'memory_block_arrays', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DJGDGONI@size?5?$DO?50@
CONST	SEGMENT
??_C@_08DJGDGONI@size?5?$DO?50@ DB 'size > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??malloc_fast_memory@@YGPAXI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??malloc_fast_memory@@YGPAXI@Z@4JA DD 0253H ; `malloc_fast_memory'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DM@DENMGBHJ@WARNING?$CB?5Duplicate?5memory?5block@
CONST	SEGMENT
??_C@_0DM@DENMGBHJ@WARNING?$CB?5Duplicate?5memory?5block@ DB 'WARNING! Du'
	DB	'plicate memory block size used (block_size = %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MCHJJGCE@num_blocks?5?$DO?50@
CONST	SEGMENT
??_C@_0P@MCHJJGCE@num_blocks?5?$DO?50@ DB 'num_blocks > 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JIMOOMN@block_size?5?$DO?50@
CONST	SEGMENT
??_C@_0P@JIMOOMN@block_size?5?$DO?50@ DB 'block_size > 0', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??create_memory_blocks@@YGXHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??create_memory_blocks@@YGXHH@Z@4JA DD 01c5H ; `create_memory_blocks'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@BEIHKJDI@num_entries?5?$DO?50@
CONST	SEGMENT
??_C@_0BA@BEIHKJDI@num_entries?5?$DO?50@ DB 'num_entries > 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DKDLCIDP@memory_block_config@
CONST	SEGMENT
??_C@_0BE@DKDLCIDP@memory_block_config@ DB 'memory_block_config', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@NKPBCGF@c?3?2users?2nhv90?2projects?2eech?2mo@
CONST	SEGMENT
??_C@_0DH@NKPBCGF@c?3?2users?2nhv90?2projects?2eech?2mo@ DB 'c:\users\nhv'
	DB	'90\projects\eech\modules\system\memblock.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??create_memory_block_configuration@@YGXPAUMEMORY_BLOCK_CONFIGURATION@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??create_memory_block_configuration@@YGXPAUMEMORY_BLOCK_CONFIGURATION@@H@Z@4JA DD 019cH ; `create_memory_block_configuration'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DL@HACDABBH@WARNING?$CB?5Memory?5block?5array?5sti@
CONST	SEGMENT
??_C@_0DL@HACDABBH@WARNING?$CB?5Memory?5block?5array?5sti@ DB 'WARNING! M'
	DB	'emory block array still in use (block_size = %d)', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memblock.c
;	COMDAT ?get_memory_block@@YGPAUMEMBLOCK@@PAUMEMARRAY@@H@Z
_TEXT	SEGMENT
_block$ = -4						; size = 4
_array$ = 8						; size = 4
_size$ = 12						; size = 4
?get_memory_block@@YGPAUMEMBLOCK@@PAUMEMARRAY@@H@Z PROC	; get_memory_block, COMDAT

; 843  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 844  : 	memblock
; 845  : 		*block;
; 846  : 
; 847  : 	if (array->type == MEM_TYPE_FAST)

  00009	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  0000c	83 38 01	 cmp	 DWORD PTR [eax], 1
  0000f	75 79		 jne	 SHORT $LN2@get_memory

; 848  : 	{
; 849  : 		if (size <= array->block_size)

  00011	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  00017	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0001a	7f 65		 jg	 SHORT $LN4@get_memory

; 850  : 		{
; 851  : 			block = array->first_free_block;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  0001f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00022	89 4d fc	 mov	 DWORD PTR _block$[ebp], ecx

; 852  : 
; 853  : 			if (block)

  00025	83 7d fc 00	 cmp	 DWORD PTR _block$[ebp], 0
  00029	74 54		 je	 SHORT $LN6@get_memory

; 854  : 			{
; 855  : 				//
; 856  : 				// unlink block from start of free list
; 857  : 				//
; 858  : 
; 859  : 				array->first_free_block = block->succ;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _block$[ebp]
  00031	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00034	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 860  : 
; 861  : 				if (block->succ)

  00037	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0003a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0003e	74 0d		 je	 SHORT $LN7@get_memory

; 862  : 				{
; 863  : 					block->succ->pred = NULL;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00043	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00046	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
$LN7@get_memory:

; 864  : 				}
; 865  : 
; 866  : 				//
; 867  : 				// link block into start of used list
; 868  : 				//
; 869  : 
; 870  : 				block->succ = array->first_used_block;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _array$[ebp]
  00053	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00056	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 871  : 
; 872  : 				if (block->succ)

  00059	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0005c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00060	74 0c		 je	 SHORT $LN8@get_memory

; 873  : 				{
; 874  : 					block->succ->pred = block;

  00062	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00065	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00068	8b 55 fc	 mov	 edx, DWORD PTR _block$[ebp]
  0006b	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN8@get_memory:

; 875  : 				}
; 876  : 
; 877  : 				array->first_used_block = block;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _block$[ebp]
  00074	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 878  : 
; 879  : 				//
; 880  : 				// memory block details
; 881  : 				//
; 882  : 
; 883  : 				block->size = size;

  00077	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0007a	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0007d	89 08		 mov	 DWORD PTR [eax], ecx
$LN6@get_memory:

; 884  : 
; 885  : 				//
; 886  : 				// update statistics
; 887  : 				//
; 888  : 
; 889  : 				#if DEBUG_MEMBLOCK_MODULE
; 890  : 
; 891  : 				update_array_statistics_malloc (array, block);
; 892  : 
; 893  : 				#endif
; 894  : 			}
; 895  : 		}
; 896  : 		else

  0007f	eb 07		 jmp	 SHORT $LN5@get_memory
$LN4@get_memory:

; 897  : 		{
; 898  : 			block = NULL;

  00081	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _block$[ebp], 0
$LN5@get_memory:

; 899  : 		}
; 900  : 	}
; 901  : 	else

  00088	eb 54		 jmp	 SHORT $LN3@get_memory
$LN2@get_memory:

; 902  : 	{
; 903  : 		block = (memblock *) safe_malloc (sizeof (memblock) + size);

  0008a	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0008d	83 c0 10	 add	 eax, 16			; 00000010H
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00096	89 45 fc	 mov	 DWORD PTR _block$[ebp], eax

; 904  : 
; 905  : 		//
; 906  : 		// link block into start of used list
; 907  : 		//
; 908  : 
; 909  : 		block->succ = array->first_used_block;

  00099	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _array$[ebp]
  0009f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000a2	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 910  : 
; 911  : 		if (block->succ)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  000a8	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000ac	74 0c		 je	 SHORT $LN9@get_memory

; 912  : 		{
; 913  : 			block->succ->pred = block;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  000b1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b4	8b 55 fc	 mov	 edx, DWORD PTR _block$[ebp]
  000b7	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN9@get_memory:

; 914  : 		}
; 915  : 
; 916  : 		block->pred = NULL;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  000bd	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 917  : 
; 918  : 		array->first_used_block = block;

  000c4	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _block$[ebp]
  000ca	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 919  : 
; 920  : 		//
; 921  : 		// memory block details
; 922  : 		//
; 923  : 
; 924  : 		#if MEMBLOCK_INTEGRITY_TEST
; 925  : 
; 926  : 		block->integrity_test = INTEGRITY_TEST_VALUE;
; 927  : 
; 928  : 		#endif
; 929  : 
; 930  : 		block->size = size;

  000cd	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  000d0	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  000d3	89 08		 mov	 DWORD PTR [eax], ecx

; 931  : 
; 932  : 		block->array = array;

  000d5	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _array$[ebp]
  000db	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@get_memory:

; 933  : 
; 934  : 		//
; 935  : 		// update statistics
; 936  : 		//
; 937  : 
; 938  : 		#if DEBUG_MEMBLOCK_MODULE
; 939  : 
; 940  : 		update_array_statistics_malloc (array, block);
; 941  : 
; 942  : 		#endif
; 943  : 	}
; 944  : 
; 945  : 	return (block);

  000de	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]

; 946  : }

  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 08 00	 ret	 8
?get_memory_block@@YGPAUMEMBLOCK@@PAUMEMARRAY@@H@Z ENDP	; get_memory_block
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memblock.c
;	COMDAT ?display_memory_block_system_statistics@@YGXXZ
_TEXT	SEGMENT
?display_memory_block_system_statistics@@YGXXZ PROC	; display_memory_block_system_statistics, COMDAT

; 1182 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1183 : 	debug_log ("WARNING! Memory block system statistics are not enabled");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@PCANDKIC@WARNING?$CB?5Memory?5block?5system?5st@
  0000e	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00013	83 c4 04	 add	 esp, 4

; 1184 : }

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?display_memory_block_system_statistics@@YGXXZ ENDP	; display_memory_block_system_statistics
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memblock.c
;	COMDAT ?free_mem@@YGXPAX@Z
_TEXT	SEGMENT
_array$ = -8						; size = 4
_block$ = -4						; size = 4
_ptr$ = 8						; size = 4
?free_mem@@YGXPAX@Z PROC				; free_mem, COMDAT

; 737  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 738  : 	memblock
; 739  : 		*block;
; 740  : 
; 741  : 	memarray
; 742  : 		*array;
; 743  : 
; 744  : 	ASSERT (ptr);

  00009	83 7d 08 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN2@free_mem
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??free_mem@@YGXPAX@Z@4JA
  00014	83 c0 07	 add	 eax, 7
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@NKPBCGF@c?3?2users?2nhv90?2projects?2eech?2mo@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_03PLHFFLIH@ptr@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@free_mem:

; 745  : 
; 746  : 	//
; 747  : 	// get pointer to block header
; 748  : 	//
; 749  : 
; 750  : 	block = (memblock *) ((char *) ptr - sizeof (memblock));

  00027	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0002a	83 e8 10	 sub	 eax, 16			; 00000010H
  0002d	89 45 fc	 mov	 DWORD PTR _block$[ebp], eax

; 751  : 
; 752  : 	#if DEBUG_MEMBLOCK_MODULE
; 753  : 
; 754  : 	debug_log ("FREE MEMORY: %s", block->create_location);
; 755  : 
; 756  : 	//
; 757  : 	// this safe_free catches attempts to free the same memory twice
; 758  : 	//
; 759  : 
; 760  : 	safe_free (block->create_location);
; 761  : 
; 762  : 	block->create_location = NULL;
; 763  : 
; 764  : 	#endif
; 765  : 
; 766  : 	#if DEBUG_MEMBLOCK_MODULE
; 767  : 	{
; 768  : 		int
; 769  : 			index;
; 770  : 
; 771  : 		index = min (block->size, MAX_REQUESTED_MEMORY_SIZE - 1);
; 772  : 
; 773  : 		ASSERT (requested_memory_size_count[index] > 0);
; 774  : 
; 775  : 		requested_memory_size_count[index]--;
; 776  : 	}
; 777  : 	#endif
; 778  : 
; 779  : 	//
; 780  : 	// get pointer to array data
; 781  : 	//
; 782  : 
; 783  : 	array = block->array;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	89 4d f8	 mov	 DWORD PTR _array$[ebp], ecx

; 784  : 
; 785  : 	#if DEBUG_MEMBLOCK_MODULE
; 786  : 
; 787  : 	update_array_statistics_free (array, block);
; 788  : 
; 789  : 	#endif
; 790  : 
; 791  : 	//
; 792  : 	// unlink block from used list
; 793  : 	//
; 794  : 
; 795  : 	if (block->pred)

  00039	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0003c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00040	74 11		 je	 SHORT $LN3@free_mem

; 796  : 	{
; 797  : 		block->pred->succ = block->succ;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00045	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00048	8b 55 fc	 mov	 edx, DWORD PTR _block$[ebp]
  0004b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 798  : 	}
; 799  : 	else

  00051	eb 0c		 jmp	 SHORT $LN4@free_mem
$LN3@free_mem:

; 800  : 	{
; 801  : 		array->first_used_block = block->succ;

  00053	8b 45 f8	 mov	 eax, DWORD PTR _array$[ebp]
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _block$[ebp]
  00059	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0005c	89 50 1c	 mov	 DWORD PTR [eax+28], edx
$LN4@free_mem:

; 802  : 	}
; 803  : 
; 804  : 	if (block->succ)

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00062	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00066	74 0f		 je	 SHORT $LN5@free_mem

; 805  : 	{
; 806  : 		block->succ->pred = block->pred;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0006b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006e	8b 55 fc	 mov	 edx, DWORD PTR _block$[ebp]
  00071	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00074	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN5@free_mem:

; 807  : 	}
; 808  : 
; 809  : 	if (array->type == MEM_TYPE_FAST)

  00077	8b 45 f8	 mov	 eax, DWORD PTR _array$[ebp]
  0007a	83 38 01	 cmp	 DWORD PTR [eax], 1
  0007d	75 3f		 jne	 SHORT $LN6@free_mem

; 810  : 	{
; 811  : 		//
; 812  : 		// link block into start of free list
; 813  : 		//
; 814  : 
; 815  : 		block->succ = array->first_free_block;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00082	8b 4d f8	 mov	 ecx, DWORD PTR _array$[ebp]
  00085	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00088	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 816  : 
; 817  : 		if (block->succ)

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0008e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00092	74 0c		 je	 SHORT $LN8@free_mem

; 818  : 		{
; 819  : 			block->succ->pred = block;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00097	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0009a	8b 55 fc	 mov	 edx, DWORD PTR _block$[ebp]
  0009d	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN8@free_mem:

; 820  : 		}
; 821  : 
; 822  : 		block->pred = NULL;

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  000a3	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 823  : 
; 824  : 		array->first_free_block = block;

  000aa	8b 45 f8	 mov	 eax, DWORD PTR _array$[ebp]
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _block$[ebp]
  000b0	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 825  : 
; 826  : 		//
; 827  : 		// clean up
; 828  : 		//
; 829  : 
; 830  : 		block->size = 0;

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  000b6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 831  : 	}
; 832  : 	else

  000bc	eb 09		 jmp	 SHORT $LN1@free_mem
$LN6@free_mem:

; 833  : 	{
; 834  : 		safe_free (block);

  000be	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free
$LN1@free_mem:

; 835  : 	}
; 836  : }

  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c2 04 00	 ret	 4
?free_mem@@YGXPAX@Z ENDP				; free_mem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memblock.c
;	COMDAT ?malloc_heap_memory@@YGPAXI@Z
_TEXT	SEGMENT
_block$ = -4						; size = 4
_size$ = 8						; size = 4
?malloc_heap_memory@@YGPAXI@Z PROC			; malloc_heap_memory, COMDAT

; 674  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 675  : 	memblock
; 676  : 		*block;
; 677  : 
; 678  : 	ASSERT (size > 0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _size$[ebp], 0
  0000d	77 18		 ja	 SHORT $LN2@malloc_hea
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??malloc_heap_memory@@YGPAXI@Z@4JA
  00014	83 c0 04	 add	 eax, 4
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@NKPBCGF@c?3?2users?2nhv90?2projects?2eech?2mo@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_08DJGDGONI@size?5?$DO?50@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@malloc_hea:

; 679  : 
; 680  : 	#if DEBUG_MEMBLOCK_MODULE
; 681  : 
; 682  : 	ASSERT (file);
; 683  : 
; 684  : 	#endif
; 685  : 
; 686  : 	#if DEBUG_MEMBLOCK_MODULE
; 687  : 	{
; 688  : 		int
; 689  : 			index;
; 690  : 
; 691  : 		index = min (size, MAX_REQUESTED_MEMORY_SIZE - 1);
; 692  : 
; 693  : 		requested_memory_size_total[index]++;
; 694  : 
; 695  : 		requested_memory_size_count[index]++;
; 696  : 
; 697  : 		requested_memory_size_peak_count[index] = max (requested_memory_size_peak_count[index], requested_memory_size_count[index]);
; 698  : 	}
; 699  : 	#endif
; 700  : 
; 701  : 	ASSERT (heap_array);

  00027	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?heap_array@@3PAUMEMARRAY@@A, 0
  0002e	75 18		 jne	 SHORT $LN3@malloc_hea
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??malloc_heap_memory@@YGPAXI@Z@4JA
  00035	83 c0 1b	 add	 eax, 27			; 0000001bH
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@NKPBCGF@c?3?2users?2nhv90?2projects?2eech?2mo@
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@ENBAAPJM@heap_array@
  00043	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN3@malloc_hea:

; 702  : 
; 703  : 	block = get_memory_block (heap_array, size);

  00048	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0004b	50		 push	 eax
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?heap_array@@3PAUMEMARRAY@@A
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ?get_memory_block@@YGPAUMEMBLOCK@@PAUMEMARRAY@@H@Z ; get_memory_block
  00058	89 45 fc	 mov	 DWORD PTR _block$[ebp], eax

; 704  : 
; 705  : 	#if DEBUG_MEMBLOCK_MODULE
; 706  : 	{
; 707  : 		char
; 708  : 			s[200];
; 709  : 
; 710  : 		int
; 711  : 			length;
; 712  : 
; 713  : 		sprintf (s, "%s[%d]", file, line);
; 714  : 
; 715  : 		length = strlen (s);
; 716  : 
; 717  : 		block->create_location = (char *) safe_malloc (length + 1);
; 718  : 
; 719  : 		strcpy (block->create_location, s);
; 720  : 
; 721  : 		debug_log ("MALLOC HEAP MEMORY: %s (size = %d)", s, size);
; 722  : 	}
; 723  : 	#endif
; 724  : 
; 725  : 	//
; 726  : 	// return pointer to memory block (ignore header)
; 727  : 	//
; 728  : 
; 729  : 	return ((void *) ((char *) block + sizeof (memblock)));

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0005e	83 c0 10	 add	 eax, 16			; 00000010H

; 730  : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?malloc_heap_memory@@YGPAXI@Z ENDP			; malloc_heap_memory
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memblock.c
;	COMDAT ?malloc_fast_memory@@YGPAXI@Z
_TEXT	SEGMENT
_array$ = -8						; size = 4
_block$ = -4						; size = 4
_size$ = 8						; size = 4
?malloc_fast_memory@@YGPAXI@Z PROC			; malloc_fast_memory, COMDAT

; 595  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 596  : 	memblock
; 597  : 		*block;
; 598  : 
; 599  : 	memarray
; 600  : 		*array;
; 601  : 
; 602  : 	ASSERT (size > 0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _size$[ebp], 0
  0000d	77 18		 ja	 SHORT $LN4@malloc_fas
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??malloc_fast_memory@@YGPAXI@Z@4JA
  00014	83 c0 07	 add	 eax, 7
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@NKPBCGF@c?3?2users?2nhv90?2projects?2eech?2mo@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_08DJGDGONI@size?5?$DO?50@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN4@malloc_fas:

; 603  : 
; 604  : 	#if DEBUG_MEMBLOCK_MODULE
; 605  : 
; 606  : 	ASSERT (file);
; 607  : 
; 608  : 	#endif
; 609  : 
; 610  : 	#if DEBUG_MEMBLOCK_MODULE
; 611  : 	{
; 612  : 		int
; 613  : 			index;
; 614  : 
; 615  : 		index = min (size, MAX_REQUESTED_MEMORY_SIZE - 1);
; 616  : 
; 617  : 		requested_memory_size_total[index]++;
; 618  : 
; 619  : 		requested_memory_size_count[index]++;
; 620  : 
; 621  : 		requested_memory_size_peak_count[index] = max (requested_memory_size_peak_count[index], requested_memory_size_count[index]);
; 622  : 	}
; 623  : 	#endif
; 624  : 
; 625  : 	ASSERT (memory_block_arrays);

  00027	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?memory_block_arrays@@3PAUMEMARRAY@@A, 0
  0002e	75 18		 jne	 SHORT $LN5@malloc_fas
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??malloc_fast_memory@@YGPAXI@Z@4JA
  00035	83 c0 1e	 add	 eax, 30			; 0000001eH
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@NKPBCGF@c?3?2users?2nhv90?2projects?2eech?2mo@
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BIKDBOEM@memory_block_arrays@
  00043	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN5@malloc_fas:

; 626  : 
; 627  : 	array = memory_block_arrays;

  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR ?memory_block_arrays@@3PAUMEMARRAY@@A
  0004d	89 45 f8	 mov	 DWORD PTR _array$[ebp], eax
$LN2@malloc_fas:

; 628  : 
; 629  : 	while (!(block = get_memory_block (array, size)))

  00050	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00053	50		 push	 eax
  00054	8b 4d f8	 mov	 ecx, DWORD PTR _array$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ?get_memory_block@@YGPAUMEMBLOCK@@PAUMEMARRAY@@H@Z ; get_memory_block
  0005d	89 45 fc	 mov	 DWORD PTR _block$[ebp], eax
  00060	83 7d fc 00	 cmp	 DWORD PTR _block$[ebp], 0
  00064	75 0b		 jne	 SHORT $LN3@malloc_fas

; 630  : 	{
; 631  : 		array = array->succ;

  00066	8b 45 f8	 mov	 eax, DWORD PTR _array$[ebp]
  00069	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006c	89 4d f8	 mov	 DWORD PTR _array$[ebp], ecx

; 632  : 	}

  0006f	eb df		 jmp	 SHORT $LN2@malloc_fas
$LN3@malloc_fas:

; 633  : 
; 634  : 	#if DEBUG_MEMBLOCK_MODULE
; 635  : 	{
; 636  : 		char
; 637  : 			s[200];
; 638  : 
; 639  : 		int
; 640  : 			length;
; 641  : 
; 642  : 		sprintf (s, "%s[%d]", file, line);
; 643  : 
; 644  : 		length = strlen (s);
; 645  : 
; 646  : 		block->create_location = (char *) safe_malloc (length + 1);
; 647  : 
; 648  : 		strcpy (block->create_location, s);
; 649  : 
; 650  : 		debug_log ("MALLOC FAST MEMORY: %s (size = %d)", s, size);
; 651  : 	}
; 652  : 	#endif
; 653  : 
; 654  : 	//
; 655  : 	// return pointer to memory block (ignore header)
; 656  : 	//
; 657  : 
; 658  : 	return ((void *) ((char *) block + sizeof (memblock)));

  00071	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00074	83 c0 10	 add	 eax, 16			; 00000010H

; 659  : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
?malloc_fast_memory@@YGPAXI@Z ENDP			; malloc_fast_memory
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memblock.c
;	COMDAT ?get_memory_block_system_installed@@YGHXZ
_TEXT	SEGMENT
?get_memory_block_system_installed@@YGHXZ PROC		; get_memory_block_system_installed, COMDAT

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 579  : 	return (memory_block_system_installed);

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?memory_block_system_installed@@3HA

; 580  : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?get_memory_block_system_installed@@YGHXZ ENDP		; get_memory_block_system_installed
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memblock.c
;	COMDAT ?create_memory_blocks@@YGXHH@Z
_TEXT	SEGMENT
_array$ = -24						; size = 4
_new_array$ = -20					; size = 4
_block$ = -16						; size = 4
_i$ = -12						; size = 4
_array_size$ = -8					; size = 4
_hdr_and_block_size$ = -4				; size = 4
_block_size$ = 8					; size = 4
_num_blocks$ = 12					; size = 4
?create_memory_blocks@@YGXHH@Z PROC			; create_memory_blocks, COMDAT

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 454  : 	int
; 455  : 		hdr_and_block_size,
; 456  : 		array_size,
; 457  : 		i;
; 458  : 
; 459  : 	memblock
; 460  : 		*block;
; 461  : 
; 462  : 	memarray
; 463  : 		*new_array,
; 464  : 		*array;
; 465  : 
; 466  : 	ASSERT (block_size > 0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _block_size$[ebp], 0
  0000d	7f 18		 jg	 SHORT $LN7@create_mem
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??create_memory_blocks@@YGXHH@Z@4JA
  00014	83 c0 0d	 add	 eax, 13			; 0000000dH
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@NKPBCGF@c?3?2users?2nhv90?2projects?2eech?2mo@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JIMOOMN@block_size?5?$DO?50@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN7@create_mem:

; 467  : 
; 468  : 	ASSERT (num_blocks > 0);

  00027	83 7d 0c 00	 cmp	 DWORD PTR _num_blocks$[ebp], 0
  0002b	7f 18		 jg	 SHORT $LN8@create_mem
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??create_memory_blocks@@YGXHH@Z@4JA
  00032	83 c0 0f	 add	 eax, 15			; 0000000fH
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@NKPBCGF@c?3?2users?2nhv90?2projects?2eech?2mo@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MCHJJGCE@num_blocks?5?$DO?50@
  00040	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN8@create_mem:

; 469  : 
; 470  : 	#if DEBUG_MEMBLOCK_MODULE
; 471  : 
; 472  : 	total_block_memory_allocated += block_size * num_blocks;
; 473  : 
; 474  : 	#endif
; 475  : 
; 476  : 	//
; 477  : 	// initialise memory block array
; 478  : 	//
; 479  : 
; 480  : 	new_array = (memarray*) safe_malloc (sizeof (memarray));

  00045	6a 20		 push	 32			; 00000020H
  00047	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  0004c	89 45 ec	 mov	 DWORD PTR _new_array$[ebp], eax

; 481  : 
; 482  : 	new_array->type = MEM_TYPE_FAST;

  0004f	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  00052	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 483  : 
; 484  : 	new_array->block_size = block_size;

  00058	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _block_size$[ebp]
  0005e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 485  : 	new_array->num_blocks = num_blocks;

  00061	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _num_blocks$[ebp]
  00067	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 486  : 
; 487  : 	new_array->succ = NULL;

  0006a	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  0006d	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 488  : 	new_array->pred = NULL;

  00074	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  00077	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 489  : 
; 490  : 	hdr_and_block_size = sizeof (memblock) + new_array->block_size;

  0007e	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  00081	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00084	83 c1 10	 add	 ecx, 16			; 00000010H
  00087	89 4d fc	 mov	 DWORD PTR _hdr_and_block_size$[ebp], ecx

; 491  : 
; 492  : 	array_size = new_array->num_blocks * hdr_and_block_size;

  0008a	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  0008d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00090	0f af 4d fc	 imul	 ecx, DWORD PTR _hdr_and_block_size$[ebp]
  00094	89 4d f8	 mov	 DWORD PTR _array_size$[ebp], ecx

; 493  : 
; 494  : 	block = (memblock *) safe_malloc (array_size);

  00097	8b 45 f8	 mov	 eax, DWORD PTR _array_size$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  000a0	89 45 f0	 mov	 DWORD PTR _block$[ebp], eax

; 495  : 
; 496  : 	new_array->base = block;

  000a3	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  000a6	8b 4d f0	 mov	 ecx, DWORD PTR _block$[ebp]
  000a9	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 497  : 	new_array->first_free_block = block;

  000ac	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  000af	8b 4d f0	 mov	 ecx, DWORD PTR _block$[ebp]
  000b2	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 498  : 	new_array->first_used_block = NULL;

  000b5	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  000b8	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 499  : 
; 500  : 	#if DEBUG_MEMBLOCK_MODULE
; 501  : 
; 502  : 	initialise_array_statistics (new_array);
; 503  : 
; 504  : 	#endif
; 505  : 
; 506  : 	//
; 507  : 	// initialise memory blocks
; 508  : 	//
; 509  : 
; 510  : 	memset (block, 0, array_size);

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _array_size$[ebp]
  000c2	50		 push	 eax
  000c3	6a 00		 push	 0
  000c5	8b 4d f0	 mov	 ecx, DWORD PTR _block$[ebp]
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 _memset
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 511  : 
; 512  : 	for (i = 0; i < new_array->num_blocks; i++)

  000d1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000d8	eb 09		 jmp	 SHORT $LN4@create_mem
$LN2@create_mem:
  000da	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000dd	83 c0 01	 add	 eax, 1
  000e0	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@create_mem:
  000e3	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  000e6	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000e9	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  000ec	7d 40		 jge	 SHORT $LN3@create_mem

; 513  : 	{
; 514  : 		#if MEMBLOCK_INTEGRITY_TEST
; 515  : 
; 516  : 		block->integrity_test = INTEGRITY_TEST_VALUE;
; 517  : 
; 518  : 		#endif
; 519  : 
; 520  : 		block->array = new_array;

  000ee	8b 45 f0	 mov	 eax, DWORD PTR _block$[ebp]
  000f1	8b 4d ec	 mov	 ecx, DWORD PTR _new_array$[ebp]
  000f4	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 521  : 
; 522  : 		if (i < new_array->num_blocks - 1)

  000f7	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  000fa	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000fd	83 e9 01	 sub	 ecx, 1
  00100	39 4d f4	 cmp	 DWORD PTR _i$[ebp], ecx
  00103	7d 0c		 jge	 SHORT $LN9@create_mem

; 523  : 		{
; 524  : 			block->succ = (memblock *) ((char *) block + hdr_and_block_size);

  00105	8b 45 f0	 mov	 eax, DWORD PTR _block$[ebp]
  00108	03 45 fc	 add	 eax, DWORD PTR _hdr_and_block_size$[ebp]
  0010b	8b 4d f0	 mov	 ecx, DWORD PTR _block$[ebp]
  0010e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN9@create_mem:

; 525  : 		}
; 526  : 
; 527  : 		if (i > 0)

  00111	83 7d f4 00	 cmp	 DWORD PTR _i$[ebp], 0
  00115	7e 0c		 jle	 SHORT $LN10@create_mem

; 528  : 		{
; 529  : 			block->pred = (memblock *) ((char *) block - hdr_and_block_size);

  00117	8b 45 f0	 mov	 eax, DWORD PTR _block$[ebp]
  0011a	2b 45 fc	 sub	 eax, DWORD PTR _hdr_and_block_size$[ebp]
  0011d	8b 4d f0	 mov	 ecx, DWORD PTR _block$[ebp]
  00120	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN10@create_mem:

; 530  : 		}
; 531  : 
; 532  : 		#if DEBUG_MEMBLOCK_MODULE
; 533  : 
; 534  : 		block->create_location = NULL;
; 535  : 
; 536  : 		#endif
; 537  : 
; 538  : 		block = block->succ;

  00123	8b 45 f0	 mov	 eax, DWORD PTR _block$[ebp]
  00126	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00129	89 4d f0	 mov	 DWORD PTR _block$[ebp], ecx

; 539  : 	}

  0012c	eb ac		 jmp	 SHORT $LN2@create_mem
$LN3@create_mem:

; 540  : 
; 541  : 	// insert array into linked list in ascending order of block size
; 542  : 	//
; 543  : 	// linked list always terminated by heap memory array (block_size == INT_MAX)
; 544  : 
; 545  : 	array = memory_block_arrays;

  0012e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?memory_block_arrays@@3PAUMEMARRAY@@A
  00133	89 45 e8	 mov	 DWORD PTR _array$[ebp], eax
$LN5@create_mem:

; 546  : 
; 547  : 	while (new_array->block_size > array->block_size)

  00136	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  00139	8b 4d e8	 mov	 ecx, DWORD PTR _array$[ebp]
  0013c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0013f	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00142	7e 0b		 jle	 SHORT $LN6@create_mem

; 548  : 	{
; 549  : 		array = array->succ;

  00144	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  00147	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0014a	89 4d e8	 mov	 DWORD PTR _array$[ebp], ecx

; 550  : 	}

  0014d	eb e7		 jmp	 SHORT $LN5@create_mem
$LN6@create_mem:

; 551  : 
; 552  : 	if (new_array->block_size == array->block_size)

  0014f	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  00152	8b 4d e8	 mov	 ecx, DWORD PTR _array$[ebp]
  00155	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00158	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0015b	75 14		 jne	 SHORT $LN11@create_mem

; 553  : 	{
; 554  : 		debug_log ("WARNING! Duplicate memory block size used (block_size = %d)", new_array->block_size);

  0015d	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  00160	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00163	51		 push	 ecx
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@DENMGBHJ@WARNING?$CB?5Duplicate?5memory?5block@
  00169	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0016e	83 c4 08	 add	 esp, 8
$LN11@create_mem:

; 555  : 	}
; 556  : 
; 557  : 	new_array->succ = array;

  00171	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  00174	8b 4d e8	 mov	 ecx, DWORD PTR _array$[ebp]
  00177	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 558  : 
; 559  : 	if (array->pred)

  0017a	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  0017d	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00181	74 1a		 je	 SHORT $LN12@create_mem

; 560  : 	{
; 561  : 		array->pred->succ = new_array;

  00183	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  00186	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00189	8b 55 ec	 mov	 edx, DWORD PTR _new_array$[ebp]
  0018c	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 562  : 
; 563  : 		new_array->pred = array->pred;

  0018f	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  00192	8b 4d e8	 mov	 ecx, DWORD PTR _array$[ebp]
  00195	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00198	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 564  : 	}
; 565  : 	else

  0019b	eb 08		 jmp	 SHORT $LN13@create_mem
$LN12@create_mem:

; 566  : 	{
; 567  : 		memory_block_arrays = new_array;

  0019d	8b 45 ec	 mov	 eax, DWORD PTR _new_array$[ebp]
  001a0	a3 00 00 00 00	 mov	 DWORD PTR ?memory_block_arrays@@3PAUMEMARRAY@@A, eax
$LN13@create_mem:

; 568  : 	}
; 569  : 
; 570  : 	array->pred = new_array;

  001a5	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  001a8	8b 4d ec	 mov	 ecx, DWORD PTR _new_array$[ebp]
  001ab	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 571  : }

  001ae	5f		 pop	 edi
  001af	5e		 pop	 esi
  001b0	5b		 pop	 ebx
  001b1	8b e5		 mov	 esp, ebp
  001b3	5d		 pop	 ebp
  001b4	c2 08 00	 ret	 8
?create_memory_blocks@@YGXHH@Z ENDP			; create_memory_blocks
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memblock.c
;	COMDAT ?create_memory_block_configuration@@YGXPAUMEMORY_BLOCK_CONFIGURATION@@H@Z
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_memory_block_config$ = 8				; size = 4
_num_entries$ = 12					; size = 4
?create_memory_block_configuration@@YGXPAUMEMORY_BLOCK_CONFIGURATION@@H@Z PROC ; create_memory_block_configuration, COMDAT

; 412  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 413  : 	int
; 414  : 		i,
; 415  : 		j;
; 416  : 
; 417  : 	ASSERT (memory_block_config);

  00009	83 7d 08 00	 cmp	 DWORD PTR _memory_block_config$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN8@create_mem
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??create_memory_block_configuration@@YGXPAUMEMORY_BLOCK_CONFIGURATION@@H@Z@4JA
  00014	83 c0 05	 add	 eax, 5
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@NKPBCGF@c?3?2users?2nhv90?2projects?2eech?2mo@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@DKDLCIDP@memory_block_config@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN8@create_mem:

; 418  : 
; 419  : 	ASSERT (num_entries > 0);

  00027	83 7d 0c 00	 cmp	 DWORD PTR _num_entries$[ebp], 0
  0002b	7f 18		 jg	 SHORT $LN9@create_mem
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??create_memory_block_configuration@@YGXPAUMEMORY_BLOCK_CONFIGURATION@@H@Z@4JA
  00032	83 c0 07	 add	 eax, 7
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@NKPBCGF@c?3?2users?2nhv90?2projects?2eech?2mo@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BEIHKJDI@num_entries?5?$DO?50@
  00040	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN9@create_mem:

; 420  : 
; 421  : 	for (i = 0; i < num_entries; i++)

  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004c	eb 09		 jmp	 SHORT $LN4@create_mem
$LN2@create_mem:
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00051	83 c0 01	 add	 eax, 1
  00054	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@create_mem:
  00057	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0005a	3b 45 0c	 cmp	 eax, DWORD PTR _num_entries$[ebp]
  0005d	0f 8d a5 00 00
	00		 jge	 $LN1@create_mem

; 422  : 	{
; 423  : 		//
; 424  : 		// combine memory blocks of the same size
; 425  : 		//
; 426  : 
; 427  : 		if (memory_block_config[i].block_size > 0)

  00063	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00066	8b 4d 08	 mov	 ecx, DWORD PTR _memory_block_config$[ebp]
  00069	83 3c c1 00	 cmp	 DWORD PTR [ecx+eax*8], 0
  0006d	0f 8e 90 00 00
	00		 jle	 $LN10@create_mem

; 428  : 		{
; 429  : 			if (i < (num_entries - 1))

  00073	8b 45 0c	 mov	 eax, DWORD PTR _num_entries$[ebp]
  00076	83 e8 01	 sub	 eax, 1
  00079	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  0007c	7d 6b		 jge	 SHORT $LN11@create_mem

; 430  : 			{
; 431  : 				for (j = i + 1; j < num_entries; j++)

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00081	83 c0 01	 add	 eax, 1
  00084	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
  00087	eb 09		 jmp	 SHORT $LN7@create_mem
$LN5@create_mem:
  00089	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN7@create_mem:
  00092	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00095	3b 45 0c	 cmp	 eax, DWORD PTR _num_entries$[ebp]
  00098	7d 4f		 jge	 SHORT $LN11@create_mem

; 432  : 				{
; 433  : 					if (memory_block_config[i].block_size == memory_block_config[j].block_size)

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _memory_block_config$[ebp]
  000a0	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  000a3	8b 75 08	 mov	 esi, DWORD PTR _memory_block_config$[ebp]
  000a6	8b 04 c1	 mov	 eax, DWORD PTR [ecx+eax*8]
  000a9	3b 04 d6	 cmp	 eax, DWORD PTR [esi+edx*8]
  000ac	75 39		 jne	 SHORT $LN12@create_mem

; 434  : 					{
; 435  : 						memory_block_config[i].number_of_blocks += memory_block_config[j].number_of_blocks;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _memory_block_config$[ebp]
  000b4	8b 54 c1 04	 mov	 edx, DWORD PTR [ecx+eax*8+4]
  000b8	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  000bb	8b 4d 08	 mov	 ecx, DWORD PTR _memory_block_config$[ebp]
  000be	03 54 c1 04	 add	 edx, DWORD PTR [ecx+eax*8+4]
  000c2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _memory_block_config$[ebp]
  000c8	89 54 c1 04	 mov	 DWORD PTR [ecx+eax*8+4], edx

; 436  : 
; 437  : 						memory_block_config[j].block_size = 0;

  000cc	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  000cf	8b 4d 08	 mov	 ecx, DWORD PTR _memory_block_config$[ebp]
  000d2	c7 04 c1 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*8], 0

; 438  : 						memory_block_config[j].number_of_blocks = 0;

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _memory_block_config$[ebp]
  000df	c7 44 c1 04 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*8+4], 0
$LN12@create_mem:

; 439  : 					}
; 440  : 				}

  000e7	eb a0		 jmp	 SHORT $LN5@create_mem
$LN11@create_mem:

; 441  : 			}
; 442  : 
; 443  : 			create_memory_blocks (memory_block_config[i].block_size, memory_block_config[i].number_of_blocks);

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ec	8b 4d 08	 mov	 ecx, DWORD PTR _memory_block_config$[ebp]
  000ef	8b 54 c1 04	 mov	 edx, DWORD PTR [ecx+eax*8+4]
  000f3	52		 push	 edx
  000f4	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000f7	8b 4d 08	 mov	 ecx, DWORD PTR _memory_block_config$[ebp]
  000fa	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  000fd	52		 push	 edx
  000fe	e8 00 00 00 00	 call	 ?create_memory_blocks@@YGXHH@Z ; create_memory_blocks
$LN10@create_mem:

; 444  : 		}
; 445  : 	}

  00103	e9 46 ff ff ff	 jmp	 $LN2@create_mem
$LN1@create_mem:

; 446  : }

  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c2 08 00	 ret	 8
?create_memory_block_configuration@@YGXPAUMEMORY_BLOCK_CONFIGURATION@@H@Z ENDP ; create_memory_block_configuration
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memblock.c
;	COMDAT ?deinitialise_memory_block_system@@YGXXZ
_TEXT	SEGMENT
_block_succ$ = -16					; size = 4
_block$ = -12						; size = 4
_array_succ$ = -8					; size = 4
_array$ = -4						; size = 4
?deinitialise_memory_block_system@@YGXXZ PROC		; deinitialise_memory_block_system, COMDAT

; 344  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 345  : 	memarray
; 346  : 		*array,
; 347  : 		*array_succ;
; 348  : 
; 349  : 	memblock
; 350  : 		*block,
; 351  : 		*block_succ;
; 352  : 
; 353  : 	array = memory_block_arrays;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?memory_block_arrays@@3PAUMEMARRAY@@A
  0000e	89 45 fc	 mov	 DWORD PTR _array$[ebp], eax
$LN2@deinitiali:

; 354  : 
; 355  : 	while (array)

  00011	83 7d fc 00	 cmp	 DWORD PTR _array$[ebp], 0
  00015	74 76		 je	 SHORT $LN3@deinitiali

; 356  : 	{
; 357  : 		array_succ = array->succ;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  0001a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0001d	89 4d f8	 mov	 DWORD PTR _array_succ$[ebp], ecx

; 358  : 
; 359  : 		if (array->first_used_block)

  00020	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  00023	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00027	74 14		 je	 SHORT $LN6@deinitiali

; 360  : 		{
; 361  : 			debug_log ("WARNING! Memory block array still in use (block_size = %d)", array->block_size);

  00029	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  0002c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002f	51		 push	 ecx
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@HACDABBH@WARNING?$CB?5Memory?5block?5array?5sti@
  00035	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0003a	83 c4 08	 add	 esp, 8
$LN6@deinitiali:

; 362  : 
; 363  : 			#if DEBUG_MEMBLOCK_MODULE
; 364  : 			{
; 365  : 				block = array->first_used_block;
; 366  : 
; 367  : 				while (block)
; 368  : 				{
; 369  : 					debug_log ("->BLOCK: %s", block->create_location);
; 370  : 
; 371  : 					block = block->succ;
; 372  : 				}
; 373  : 			}
; 374  : 			#endif
; 375  : 		}
; 376  : 
; 377  : 		if (array->type == MEM_TYPE_FAST)

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  00040	83 38 01	 cmp	 DWORD PTR [eax], 1
  00043	75 0e		 jne	 SHORT $LN7@deinitiali

; 378  : 		{
; 379  : 			safe_free (array->base);

  00045	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  00048	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 380  : 		}
; 381  : 		else

  00051	eb 29		 jmp	 SHORT $LN8@deinitiali
$LN7@deinitiali:

; 382  : 		{
; 383  : 			block = array->first_used_block;

  00053	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  00056	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00059	89 4d f4	 mov	 DWORD PTR _block$[ebp], ecx
$LN4@deinitiali:

; 384  : 
; 385  : 			while (block)

  0005c	83 7d f4 00	 cmp	 DWORD PTR _block$[ebp], 0
  00060	74 1a		 je	 SHORT $LN8@deinitiali

; 386  : 			{
; 387  : 				block_succ = block->succ;

  00062	8b 45 f4	 mov	 eax, DWORD PTR _block$[ebp]
  00065	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00068	89 4d f0	 mov	 DWORD PTR _block_succ$[ebp], ecx

; 388  : 
; 389  : 				safe_free (block);

  0006b	8b 45 f4	 mov	 eax, DWORD PTR _block$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 390  : 
; 391  : 				block = block_succ;

  00074	8b 45 f0	 mov	 eax, DWORD PTR _block_succ$[ebp]
  00077	89 45 f4	 mov	 DWORD PTR _block$[ebp], eax

; 392  : 			}

  0007a	eb e0		 jmp	 SHORT $LN4@deinitiali
$LN8@deinitiali:

; 393  : 		}
; 394  : 
; 395  :  		safe_free (array);

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 396  : 
; 397  : 		array = array_succ;

  00085	8b 45 f8	 mov	 eax, DWORD PTR _array_succ$[ebp]
  00088	89 45 fc	 mov	 DWORD PTR _array$[ebp], eax

; 398  : 	}

  0008b	eb 84		 jmp	 SHORT $LN2@deinitiali
$LN3@deinitiali:

; 399  : 
; 400  : 	memory_block_arrays = NULL;

  0008d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?memory_block_arrays@@3PAUMEMARRAY@@A, 0

; 401  : 
; 402  : 	heap_array = NULL;

  00097	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?heap_array@@3PAUMEMARRAY@@A, 0

; 403  : 
; 404  : 	memory_block_system_installed = FALSE;

  000a1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?memory_block_system_installed@@3HA, 0

; 405  : }

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?deinitialise_memory_block_system@@YGXXZ ENDP		; deinitialise_memory_block_system
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memblock.c
;	COMDAT ?initialise_memory_block_system@@YGXXZ
_TEXT	SEGMENT
_array$ = -4						; size = 4
?initialise_memory_block_system@@YGXXZ PROC		; initialise_memory_block_system, COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 289  : 	memarray
; 290  : 		*array;
; 291  : 
; 292  : 	//
; 293  : 	// initialise heap memory array
; 294  : 	//
; 295  : 
; 296  : 	array = (memarray*) safe_malloc (sizeof (memarray));

  00009	6a 20		 push	 32			; 00000020H
  0000b	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00010	89 45 fc	 mov	 DWORD PTR _array$[ebp], eax

; 297  : 
; 298  : 	array->type = MEM_TYPE_HEAP;

  00013	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  00016	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 299  : 
; 300  : 	//
; 301  : 	// block_size = INT_MAX for search end stop
; 302  : 	//
; 303  : 
; 304  : 	array->block_size = INT_MAX;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  0001f	c7 40 04 ff ff
	ff 7f		 mov	 DWORD PTR [eax+4], 2147483647 ; 7fffffffH

; 305  : 	array->num_blocks = 0;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  00029	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 306  : 
; 307  : 	array->succ = NULL;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  00033	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 308  : 	array->pred = NULL;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  0003d	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 309  : 
; 310  : 	array->base = NULL;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  00047	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 311  : 	array->first_free_block = NULL;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  00051	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 312  : 	array->first_used_block = NULL;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  0005b	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 313  : 
; 314  : 	#if DEBUG_MEMBLOCK_MODULE
; 315  : 
; 316  : 	initialise_array_statistics (array);
; 317  : 
; 318  : 	#endif
; 319  : 
; 320  : 	memory_block_arrays = array;

  00062	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  00065	a3 00 00 00 00	 mov	 DWORD PTR ?memory_block_arrays@@3PAUMEMARRAY@@A, eax

; 321  : 
; 322  : 	heap_array = array;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  0006d	a3 00 00 00 00	 mov	 DWORD PTR ?heap_array@@3PAUMEMARRAY@@A, eax

; 323  : 
; 324  : 	memory_block_system_installed = TRUE;

  00072	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?memory_block_system_installed@@3HA, 1

; 325  : 
; 326  : 	#if DEBUG_MEMBLOCK_MODULE
; 327  : 
; 328  : 	total_block_memory_allocated = 0;
; 329  : 
; 330  : 	memset (requested_memory_size_total, 0, sizeof (requested_memory_size_total));
; 331  : 
; 332  : 	memset (requested_memory_size_count, 0, sizeof (requested_memory_size_count));
; 333  : 
; 334  : 	memset (requested_memory_size_peak_count, 0, sizeof (requested_memory_size_peak_count));
; 335  : 
; 336  : 	#endif
; 337  : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?initialise_memory_block_system@@YGXXZ ENDP		; initialise_memory_block_system
_TEXT	ENDS
END
