; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\system\safemem.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?set_report_safe_memory_warnings@@YGXH@Z	; set_report_safe_memory_warnings
PUBLIC	?reset_safe_memory_counter@@YGXXZ		; reset_safe_memory_counter
PUBLIC	?check_safe_memory_counter@@YGXXZ		; check_safe_memory_counter
PUBLIC	?safe_malloc_memory@@YGPAXI@Z			; safe_malloc_memory
PUBLIC	?safe_free@@YGXPAX@Z				; safe_free
PUBLIC	?report_tracked_safe_memory@@YGXXZ		; report_tracked_safe_memory
PUBLIC	?report_total_safe_memory_allocated@@YGXXZ	; report_total_safe_memory_allocated
PUBLIC	??_C@_0CA@LBDCAKM@NOTE?$CB?5Safe?5memory?5counter?5reset@ ; `string'
PUBLIC	??_C@_0CA@IKFDMFMA@Total?5safe?5memory?5allocated?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0CC@KIFGMBMA@Maximum?5safe?5memory?5allocated?3?5@ ; `string'
PUBLIC	??_C@_0BI@OANNOOH@Safe?5memory?5counter?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0BP@OCLLOJMH@NOTE?$CB?5Safe?5memory?5counter?5?$DN?$DN?50@ ; `string'
PUBLIC	??_C@_0DB@GJCJGFFN@WARNING?$CB?5Safe?5memory?5counter?5?$CB?$DN@ ; `string'
PUBLIC	?__LINE__Var@?0??safe_malloc_memory@@YGPAXI@Z@4JA ; `safe_malloc_memory'::`1'::__LINE__Var
PUBLIC	??_C@_0DG@LIDAGLLD@c?3?2users?2nhv90?2projects?2eech?2mo@ ; `string'
PUBLIC	??_C@_08DJGDGONI@size?5?$DO?50@			; `string'
PUBLIC	??_C@_0FG@OOAIPDMP@Unable?5to?5allocate?5memory?5size?5@ ; `string'
PUBLIC	?__LINE__Var@?0??safe_free@@YGXPAX@Z@4JA	; `safe_free'::`1'::__LINE__Var
PUBLIC	??_C@_03PLHFFLIH@ptr@				; `string'
PUBLIC	??_C@_0DM@DAPABKFP@BEGIN?5TRACKED?5MEMORY?5STATUS?5?$CI?5t@ ; `string'
PUBLIC	??_C@_0M@NGOJEHKN@?$CFs?5?$FL?$CFd?$FN?3?5?$CFd@ ; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp___msize:PROC
EXTRN	__imp__GlobalMemoryStatus@4:PROC
EXTRN	?process_assert@@YGXPBD0H@Z:PROC		; process_assert
EXTRN	?debug_fatal@@YAXPBDZZ:PROC			; debug_fatal
EXTRN	?debug_log@@YAXPBDZZ:PROC			; debug_log
EXTRN	?debug_colour_log@@YAXW4DEBUG_COLOURS@@PBDZZ:PROC ; debug_colour_log
EXTRN	?debug_watch@@YGXPBDW4mt_type@@PAX@Z:PROC	; debug_watch
_BSS	SEGMENT
?safe_memory_counter@@3HA DD 01H DUP (?)		; safe_memory_counter
?total_safe_memory_allocated@@3HA DD 01H DUP (?)	; total_safe_memory_allocated
?maximum_safe_memory_allocated@@3HA DD 01H DUP (?)	; maximum_safe_memory_allocated
?safe_memory_tracks@@3PAUSAFE_MEMORY_TRACK@@A DD 01H DUP (?) ; safe_memory_tracks
?old_thousands@?7??safe_malloc_memory@@YGPAXI@Z@4HA DD 01H DUP (?) ; `safe_malloc_memory'::`8'::old_thousands
_BSS	ENDS
;	COMDAT ??_C@_0M@NGOJEHKN@?$CFs?5?$FL?$CFd?$FN?3?5?$CFd@
CONST	SEGMENT
??_C@_0M@NGOJEHKN@?$CFs?5?$FL?$CFd?$FN?3?5?$CFd@ DB '%s [%d]: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@DAPABKFP@BEGIN?5TRACKED?5MEMORY?5STATUS?5?$CI?5t@
CONST	SEGMENT
??_C@_0DM@DAPABKFP@BEGIN?5TRACKED?5MEMORY?5STATUS?5?$CI?5t@ DB 'BEGIN TRA'
	DB	'CKED MEMORY STATUS ( total safemem allocated: %d )', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PLHFFLIH@ptr@
CONST	SEGMENT
??_C@_03PLHFFLIH@ptr@ DB 'ptr', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??safe_free@@YGXPAX@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??safe_free@@YGXPAX@Z@4JA DD 0166H	; `safe_free'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0FG@OOAIPDMP@Unable?5to?5allocate?5memory?5size?5@
CONST	SEGMENT
??_C@_0FG@OOAIPDMP@Unable?5to?5allocate?5memory?5size?5@ DB 'Unable to al'
	DB	'locate memory size %d - Windows reports there is only %d memo'
	DB	'ry available', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08DJGDGONI@size?5?$DO?50@
CONST	SEGMENT
??_C@_08DJGDGONI@size?5?$DO?50@ DB 'size > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@LIDAGLLD@c?3?2users?2nhv90?2projects?2eech?2mo@
CONST	SEGMENT
??_C@_0DG@LIDAGLLD@c?3?2users?2nhv90?2projects?2eech?2mo@ DB 'c:\users\nh'
	DB	'v90\projects\eech\modules\system\safemem.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??safe_malloc_memory@@YGPAXI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??safe_malloc_memory@@YGPAXI@Z@4JA DD 0109H ; `safe_malloc_memory'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DB@GJCJGFFN@WARNING?$CB?5Safe?5memory?5counter?5?$CB?$DN@
CONST	SEGMENT
??_C@_0DB@GJCJGFFN@WARNING?$CB?5Safe?5memory?5counter?5?$CB?$DN@ DB 'WARN'
	DB	'ING! Safe memory counter != 0 (counter = %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OCLLOJMH@NOTE?$CB?5Safe?5memory?5counter?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0BP@OCLLOJMH@NOTE?$CB?5Safe?5memory?5counter?5?$DN?$DN?50@ DB 'NOTE'
	DB	'! Safe memory counter == 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OANNOOH@Safe?5memory?5counter?3?5?$CFd@
CONST	SEGMENT
??_C@_0BI@OANNOOH@Safe?5memory?5counter?3?5?$CFd@ DB 'Safe memory counter'
	DB	': %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KIFGMBMA@Maximum?5safe?5memory?5allocated?3?5@
CONST	SEGMENT
??_C@_0CC@KIFGMBMA@Maximum?5safe?5memory?5allocated?3?5@ DB 'Maximum safe'
	DB	' memory allocated: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IKFDMFMA@Total?5safe?5memory?5allocated?3?5?$CFd@
CONST	SEGMENT
??_C@_0CA@IKFDMFMA@Total?5safe?5memory?5allocated?3?5?$CFd@ DB 'Total saf'
	DB	'e memory allocated: %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LBDCAKM@NOTE?$CB?5Safe?5memory?5counter?5reset@
CONST	SEGMENT
??_C@_0CA@LBDCAKM@NOTE?$CB?5Safe?5memory?5counter?5reset@ DB 'NOTE! Safe '
	DB	'memory counter reset', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?report_safe_memory_warnings@@3HA DD 01H		; report_safe_memory_warnings
_DATA	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\safemem.c
;	COMDAT ?report_total_safe_memory_allocated@@YGXXZ
_TEXT	SEGMENT
?report_total_safe_memory_allocated@@YGXXZ PROC		; report_total_safe_memory_allocated, COMDAT

; 441  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 442  : 	debug_log ("Total safe memory allocated: %d", total_safe_memory_allocated);

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?total_safe_memory_allocated@@3HA
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@IKFDMFMA@Total?5safe?5memory?5allocated?3?5?$CFd@
  00014	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00019	83 c4 08	 add	 esp, 8

; 443  : }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?report_total_safe_memory_allocated@@YGXXZ ENDP		; report_total_safe_memory_allocated
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\safemem.c
;	COMDAT ?report_tracked_safe_memory@@YGXXZ
_TEXT	SEGMENT
_track$ = -4						; size = 4
?report_tracked_safe_memory@@YGXXZ PROC			; report_tracked_safe_memory, COMDAT

; 418  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 419  : 
; 420  : 	safe_memory_track
; 421  : 		*track;
; 422  : 
; 423  : 	debug_log ( "BEGIN TRACKED MEMORY STATUS ( total safemem allocated: %d )", total_safe_memory_allocated );

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?total_safe_memory_allocated@@3HA
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@DAPABKFP@BEGIN?5TRACKED?5MEMORY?5STATUS?5?$CI?5t@
  00014	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00019	83 c4 08	 add	 esp, 8

; 424  : 
; 425  : 	track = safe_memory_tracks;

  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?safe_memory_tracks@@3PAUSAFE_MEMORY_TRACK@@A
  00021	89 45 fc	 mov	 DWORD PTR _track$[ebp], eax
$LN2@report_tra:

; 426  : 
; 427  : 	while ( track )

  00024	83 7d fc 00	 cmp	 DWORD PTR _track$[ebp], 0
  00028	74 2d		 je	 SHORT $LN1@report_tra

; 428  : 	{
; 429  : 
; 430  : 		debug_log ( "%s [%d]: %d", track->file, track->line, track->size );

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _track$[ebp]
  0002d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00030	51		 push	 ecx
  00031	8b 55 fc	 mov	 edx, DWORD PTR _track$[ebp]
  00034	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00037	50		 push	 eax
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _track$[ebp]
  0003b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003e	52		 push	 edx
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NGOJEHKN@?$CFs?5?$FL?$CFd?$FN?3?5?$CFd@
  00044	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00049	83 c4 10	 add	 esp, 16			; 00000010H

; 431  : 
; 432  : 		track = track->succ;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _track$[ebp]
  0004f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00052	89 4d fc	 mov	 DWORD PTR _track$[ebp], ecx

; 433  : 	}

  00055	eb cd		 jmp	 SHORT $LN2@report_tra
$LN1@report_tra:

; 434  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?report_tracked_safe_memory@@YGXXZ ENDP			; report_tracked_safe_memory
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\safemem.c
;	COMDAT ?safe_free@@YGXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
?safe_free@@YGXPAX@Z PROC				; safe_free, COMDAT

; 358  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 359  : 	ASSERT (ptr);

  00009	83 7d 08 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN2@safe_free
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??safe_free@@YGXPAX@Z@4JA
  00014	83 c0 01	 add	 eax, 1
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@LIDAGLLD@c?3?2users?2nhv90?2projects?2eech?2mo@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_03PLHFFLIH@ptr@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@safe_free:

; 360  : 
; 361  : #ifdef LINUX
; 362  : 	total_safe_memory_allocated -= (malloc_usable_size (ptr));
; 363  : #else
; 364  : 	total_safe_memory_allocated -= (_msize (ptr));

  00027	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0002a	50		 push	 eax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___msize
  00031	83 c4 04	 add	 esp, 4
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?total_safe_memory_allocated@@3HA
  0003a	2b c8		 sub	 ecx, eax
  0003c	89 0d 00 00 00
	00		 mov	 DWORD PTR ?total_safe_memory_allocated@@3HA, ecx

; 365  : #endif
; 366  : 	free (ptr);

  00042	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00045	50		 push	 eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0004c	83 c4 04	 add	 esp, 4

; 367  : 
; 368  : 	safe_memory_counter--;

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?safe_memory_counter@@3HA
  00054	83 e8 01	 sub	 eax, 1
  00057	a3 00 00 00 00	 mov	 DWORD PTR ?safe_memory_counter@@3HA, eax

; 369  : 
; 370  : #if SAFE_MEMORY_TRACKING
; 371  : 	{
; 372  : 
; 373  : 		safe_memory_track
; 374  : 			*track;
; 375  : 
; 376  : 		track = safe_memory_tracks;
; 377  : 
; 378  : 		while ( track )
; 379  : 		{
; 380  : 
; 381  : 			if ( track->memory == ptr )
; 382  : 			{
; 383  : 
; 384  : 				free ( track->file );
; 385  : 
; 386  : 				if ( track->succ )
; 387  : 				{
; 388  : 
; 389  : 					track->succ->pred = track->pred;
; 390  : 				}
; 391  : 
; 392  : 				if ( track->pred )
; 393  : 				{
; 394  : 
; 395  : 					track->pred->succ = track->succ;
; 396  : 				}
; 397  : 				else
; 398  : 				{
; 399  : 
; 400  : 					safe_memory_tracks = track->succ;
; 401  : 				}
; 402  : 
; 403  : 				break;
; 404  : 			}
; 405  : 
; 406  : 			track = track->succ;
; 407  : 		}
; 408  : 	}
; 409  : #endif
; 410  : 
; 411  : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?safe_free@@YGXPAX@Z ENDP				; safe_free
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\safemem.c
;	COMDAT ?safe_malloc_memory@@YGPAXI@Z
_TEXT	SEGMENT
_new_thousands$1 = -52					; size = 4
_total_memory_available$2 = -48				; size = 4
_virtual_memory_available$3 = -44			; size = 4
_physical_memory_available$4 = -40			; size = 4
_status$5 = -36						; size = 32
_ptr$ = -4						; size = 4
_size$ = 8						; size = 4
?safe_malloc_memory@@YGPAXI@Z PROC			; safe_malloc_memory, COMDAT

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 266  : 	void
; 267  : 		*ptr;
; 268  : 
; 269  : 	ASSERT (size > 0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _size$[ebp], 0
  0000d	77 18		 ja	 SHORT $LN2@safe_mallo
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??safe_malloc_memory@@YGPAXI@Z@4JA
  00014	83 c0 04	 add	 eax, 4
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@LIDAGLLD@c?3?2users?2nhv90?2projects?2eech?2mo@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_08DJGDGONI@size?5?$DO?50@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@safe_mallo:

; 270  : 
; 271  : 	ptr = malloc (size);

  00027	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0002a	50		 push	 eax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00031	83 c4 04	 add	 esp, 4
  00034	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 272  : 
; 273  : 	if (!ptr)

  00037	83 7d fc 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  0003b	75 41		 jne	 SHORT $LN3@safe_mallo

; 274  : 	{
; 275  : 
; 276  : #ifdef WIN32
; 277  : 		MEMORYSTATUS
; 278  : 			status;
; 279  : 	
; 280  : 		int
; 281  : 			physical_memory_available,
; 282  : 			virtual_memory_available,
; 283  : 			total_memory_available;
; 284  : 	
; 285  : 		status.dwLength = sizeof ( status );

  0003d	c7 45 dc 20 00
	00 00		 mov	 DWORD PTR _status$5[ebp], 32 ; 00000020H

; 286  : 	
; 287  : 		GlobalMemoryStatus ( &status );

  00044	8d 45 dc	 lea	 eax, DWORD PTR _status$5[ebp]
  00047	50		 push	 eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalMemoryStatus@4

; 288  : 	
; 289  : 		physical_memory_available = status.dwTotalPhys - status.dwAvailPhys;

  0004e	8b 45 e4	 mov	 eax, DWORD PTR _status$5[ebp+8]
  00051	2b 45 e8	 sub	 eax, DWORD PTR _status$5[ebp+12]
  00054	89 45 d8	 mov	 DWORD PTR _physical_memory_available$4[ebp], eax

; 290  : 	
; 291  : 		virtual_memory_available = status.dwTotalPageFile - status.dwAvailPageFile;

  00057	8b 45 ec	 mov	 eax, DWORD PTR _status$5[ebp+16]
  0005a	2b 45 f0	 sub	 eax, DWORD PTR _status$5[ebp+20]
  0005d	89 45 d4	 mov	 DWORD PTR _virtual_memory_available$3[ebp], eax

; 292  : 	
; 293  : 		total_memory_available = physical_memory_available + virtual_memory_available;

  00060	8b 45 d8	 mov	 eax, DWORD PTR _physical_memory_available$4[ebp]
  00063	03 45 d4	 add	 eax, DWORD PTR _virtual_memory_available$3[ebp]
  00066	89 45 d0	 mov	 DWORD PTR _total_memory_available$2[ebp], eax

; 294  : 	
; 295  : 		debug_fatal ( "Unable to allocate memory size %d - Windows reports there is only %d memory available", size, total_memory_available );

  00069	8b 45 d0	 mov	 eax, DWORD PTR _total_memory_available$2[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  00070	51		 push	 ecx
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@OOAIPDMP@Unable?5to?5allocate?5memory?5size?5@
  00076	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@safe_mallo:

; 296  : #elif LINUX
; 297  : 		// TODO: print some more useful memory information here.
; 298  : 		//struct mallinfo mallinfo (void)
; 299  : 		debug_fatal ( "Unable to allocate memory size %d - %s", size, strerror(errno) );
; 300  : #endif
; 301  : 	}
; 302  : 
; 303  : 	safe_memory_counter++;

  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?safe_memory_counter@@3HA
  00083	83 c0 01	 add	 eax, 1
  00086	a3 00 00 00 00	 mov	 DWORD PTR ?safe_memory_counter@@3HA, eax

; 304  : 
; 305  : 	//
; 306  : 	// if debugging then report every so often if safe_memory_counter is getting large
; 307  : 	//
; 308  : 
; 309  : 	#ifdef DEBUG
; 310  : 	{
; 311  : 		static int
; 312  : 			old_thousands = 0;
; 313  : 
; 314  : 		int
; 315  : 			new_thousands;
; 316  : 
; 317  : 		new_thousands = safe_memory_counter / 1000;

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?safe_memory_counter@@3HA
  00090	99		 cdq
  00091	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00096	f7 f9		 idiv	 ecx
  00098	89 45 cc	 mov	 DWORD PTR _new_thousands$1[ebp], eax

; 318  : 
; 319  : 		if (report_safe_memory_warnings)

  0009b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?report_safe_memory_warnings@@3HA, 0
  000a2	74 13		 je	 SHORT $LN4@safe_mallo

; 320  : 		{
; 321  : 			if (new_thousands > old_thousands)

  000a4	8b 45 cc	 mov	 eax, DWORD PTR _new_thousands$1[ebp]
  000a7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?old_thousands@?7??safe_malloc_memory@@YGPAXI@Z@4HA
  000ad	7e 08		 jle	 SHORT $LN4@safe_mallo

; 322  : 			{
; 323  : 				old_thousands = new_thousands;

  000af	8b 45 cc	 mov	 eax, DWORD PTR _new_thousands$1[ebp]
  000b2	a3 00 00 00 00	 mov	 DWORD PTR ?old_thousands@?7??safe_malloc_memory@@YGPAXI@Z@4HA, eax
$LN4@safe_mallo:

; 324  : 
; 325  : //				debug_colour_log (DEBUG_COLOUR_AMBER, "WARNING! Safe memory counter exceeded %d000", new_thousands);
; 326  : 			}
; 327  : 		}
; 328  : 
; 329  : 		old_thousands = new_thousands;

  000b7	8b 45 cc	 mov	 eax, DWORD PTR _new_thousands$1[ebp]
  000ba	a3 00 00 00 00	 mov	 DWORD PTR ?old_thousands@?7??safe_malloc_memory@@YGPAXI@Z@4HA, eax

; 330  : 	}
; 331  : 	#endif
; 332  : 
; 333  : 	//
; 334  : 	// Add this to the total safe memory allocated
; 335  : 	//
; 336  : 
; 337  : #ifdef LINUX
; 338  : 	total_safe_memory_allocated += (malloc_usable_size (ptr));
; 339  : #else
; 340  : 	total_safe_memory_allocated += size;

  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?total_safe_memory_allocated@@3HA
  000c4	03 45 08	 add	 eax, DWORD PTR _size$[ebp]
  000c7	a3 00 00 00 00	 mov	 DWORD PTR ?total_safe_memory_allocated@@3HA, eax

; 341  : #endif
; 342  : 
; 343  : 	if (total_safe_memory_allocated > maximum_safe_memory_allocated)

  000cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?total_safe_memory_allocated@@3HA
  000d1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?maximum_safe_memory_allocated@@3HA
  000d7	7e 0a		 jle	 SHORT $LN6@safe_mallo

; 344  : 	{
; 345  : 		maximum_safe_memory_allocated = total_safe_memory_allocated;

  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?total_safe_memory_allocated@@3HA
  000de	a3 00 00 00 00	 mov	 DWORD PTR ?maximum_safe_memory_allocated@@3HA, eax
$LN6@safe_mallo:

; 346  : 	}
; 347  : 
; 348  : 	return (ptr);

  000e3	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]

; 349  : }

  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 04 00	 ret	 4
?safe_malloc_memory@@YGPAXI@Z ENDP			; safe_malloc_memory
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\safemem.c
;	COMDAT ?check_safe_memory_counter@@YGXXZ
_TEXT	SEGMENT
?check_safe_memory_counter@@YGXXZ PROC			; check_safe_memory_counter, COMDAT

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 153  : 	if (report_safe_memory_warnings)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?report_safe_memory_warnings@@3HA, 0
  00010	74 2f		 je	 SHORT $LN1@check_safe

; 154  : 	{
; 155  : 		if (safe_memory_counter == 0)

  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?safe_memory_counter@@3HA, 0
  00019	75 11		 jne	 SHORT $LN3@check_safe

; 156  : 		{
; 157  : 			debug_colour_log (DEBUG_COLOUR_AMBER, "NOTE! Safe memory counter == 0");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OCLLOJMH@NOTE?$CB?5Safe?5memory?5counter?5?$DN?$DN?50@
  00020	6a 17		 push	 23			; 00000017H
  00022	e8 00 00 00 00	 call	 ?debug_colour_log@@YAXW4DEBUG_COLOURS@@PBDZZ ; debug_colour_log
  00027	83 c4 08	 add	 esp, 8

; 158  : 		}
; 159  : 		else

  0002a	eb 15		 jmp	 SHORT $LN1@check_safe
$LN3@check_safe:

; 160  : 		{
; 161  : 			debug_colour_log (DEBUG_COLOUR_AMBER, "WARNING! Safe memory counter != 0 (counter = %d)", safe_memory_counter);

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?safe_memory_counter@@3HA
  00031	50		 push	 eax
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@GJCJGFFN@WARNING?$CB?5Safe?5memory?5counter?5?$CB?$DN@
  00037	6a 17		 push	 23			; 00000017H
  00039	e8 00 00 00 00	 call	 ?debug_colour_log@@YAXW4DEBUG_COLOURS@@PBDZZ ; debug_colour_log
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@check_safe:

; 162  : 		}
; 163  : 	}
; 164  : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?check_safe_memory_counter@@YGXXZ ENDP			; check_safe_memory_counter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\safemem.c
;	COMDAT ?reset_safe_memory_counter@@YGXXZ
_TEXT	SEGMENT
?reset_safe_memory_counter@@YGXXZ PROC			; reset_safe_memory_counter, COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 135  : 	if (report_safe_memory_warnings)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?report_safe_memory_warnings@@3HA, 0
  00010	74 0f		 je	 SHORT $LN2@reset_safe

; 136  : 	{
; 137  : 		debug_colour_log (DEBUG_COLOUR_AMBER, "NOTE! Safe memory counter reset");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@LBDCAKM@NOTE?$CB?5Safe?5memory?5counter?5reset@
  00017	6a 17		 push	 23			; 00000017H
  00019	e8 00 00 00 00	 call	 ?debug_colour_log@@YAXW4DEBUG_COLOURS@@PBDZZ ; debug_colour_log
  0001e	83 c4 08	 add	 esp, 8
$LN2@reset_safe:

; 138  : 	}
; 139  : 
; 140  : 	safe_memory_counter = 0;

  00021	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?safe_memory_counter@@3HA, 0

; 141  : 
; 142  : 	debug_watch ("Total safe memory allocated: %d", MT_INT, &total_safe_memory_allocated);

  0002b	68 00 00 00 00	 push	 OFFSET ?total_safe_memory_allocated@@3HA
  00030	6a 01		 push	 1
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@IKFDMFMA@Total?5safe?5memory?5allocated?3?5?$CFd@
  00037	e8 00 00 00 00	 call	 ?debug_watch@@YGXPBDW4mt_type@@PAX@Z ; debug_watch

; 143  : 	debug_watch ("Maximum safe memory allocated: %d", MT_INT, &maximum_safe_memory_allocated);

  0003c	68 00 00 00 00	 push	 OFFSET ?maximum_safe_memory_allocated@@3HA
  00041	6a 01		 push	 1
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@KIFGMBMA@Maximum?5safe?5memory?5allocated?3?5@
  00048	e8 00 00 00 00	 call	 ?debug_watch@@YGXPBDW4mt_type@@PAX@Z ; debug_watch

; 144  : 	debug_watch ("Safe memory counter: %d", MT_INT, &safe_memory_counter );

  0004d	68 00 00 00 00	 push	 OFFSET ?safe_memory_counter@@3HA
  00052	6a 01		 push	 1
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@OANNOOH@Safe?5memory?5counter?3?5?$CFd@
  00059	e8 00 00 00 00	 call	 ?debug_watch@@YGXPBDW4mt_type@@PAX@Z ; debug_watch

; 145  : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?reset_safe_memory_counter@@YGXXZ ENDP			; reset_safe_memory_counter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\safemem.c
;	COMDAT ?set_report_safe_memory_warnings@@YGXH@Z
_TEXT	SEGMENT
_flag$ = 8						; size = 4
?set_report_safe_memory_warnings@@YGXH@Z PROC		; set_report_safe_memory_warnings, COMDAT

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 126  : 	report_safe_memory_warnings = flag;

  00009	8b 45 08	 mov	 eax, DWORD PTR _flag$[ebp]
  0000c	a3 00 00 00 00	 mov	 DWORD PTR ?report_safe_memory_warnings@@3HA, eax

; 127  : }

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?set_report_safe_memory_warnings@@YGXH@Z ENDP		; set_report_safe_memory_warnings
_TEXT	ENDS
END
