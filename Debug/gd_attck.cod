; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\aphavoc\source\entity\special\guide\gd_attck.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_atanf
PUBLIC	_cosf
PUBLIC	_tanf
PUBLIC	?atan@@YGMM@Z					; atan
PUBLIC	?cos@@YGMM@Z					; cos
PUBLIC	?tan@@YGMM@Z					; tan
PUBLIC	?initialise_attack_guide@@YGXPAUENTITY@@@Z	; initialise_attack_guide
PUBLIC	?calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z ; calculate_attack_guide_intercept_point
PUBLIC	?attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z ; attack_guide_find_best_weapon
PUBLIC	??$max@N@std@@YGABNABN0@Z			; std::max<double>
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA ; `initialise_attack_guide'::`1'::__LINE__Var
PUBLIC	??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@ ; `string'
PUBLIC	??_C@_02LFNMGJAP@en@				; `string'
PUBLIC	??_C@_04GGKLLKOO@task@				; `string'
PUBLIC	??_C@_0FL@FKJNEEAI@get_local_entity_int_value?5?$CItas@ ; `string'
PUBLIC	??_C@_09HKMIOAOH@aggressor@			; `string'
PUBLIC	??_C@_06JJLAMBGK@target@			; `string'
PUBLIC	?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA ; `calculate_attack_guide_intercept_point'::`1'::__LINE__Var
PUBLIC	??_C@_02GIIHKPLE@ip@				; `string'
PUBLIC	??_C@_0BD@LFMGFFAJ@weapon_speed?5?$DO?50?40@	; `string'
PUBLIC	?__LINE__Var@?0??attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z@4JA ; `attack_guide_find_best_weapon'::`1'::__LINE__Var
PUBLIC	??_C@_0BD@FEEMDEPI@invalid?5comparator@		; `string'
PUBLIC	??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@ ; `string'
PUBLIC	??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ ; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@406f400000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	_atan:PROC
EXTRN	_cos:PROC
EXTRN	_tan:PROC
EXTRN	?process_assert@@YGXPBD0H@Z:PROC		; process_assert
EXTRN	?get_2d_range@@YGMPBUVEC3D@@0@Z:PROC		; get_2d_range
EXTRN	?get_ballistic_pitch_deflection@@YGHHMMPAM0HH@Z:PROC ; get_ballistic_pitch_deflection
EXTRN	?get_best_weapon_for_target@@YGHPAUENTITY@@0I@Z:PROC ; get_best_weapon_for_target
EXTRN	?initialise_air_to_ground_attack_guide@@YGXPAUENTITY@@00@Z:PROC ; initialise_air_to_ground_attack_guide
EXTRN	?initialise_air_to_air_attack_guide@@YGXPAUENTITY@@00@Z:PROC ; initialise_air_to_air_attack_guide
EXTRN	?delete_group_member_from_engage_guide@@YGXPAUENTITY@@0H@Z:PROC ; delete_group_member_from_engage_guide
EXTRN	?null_entity_pointer_message@@3PBDB:DWORD	; null_entity_pointer_message
EXTRN	?system_comms_model@@3W4COMMS_MODEL_TYPES@@A:DWORD ; system_comms_model
EXTRN	?overload_invalid_list_type_message@@3PBDB:DWORD ; overload_invalid_list_type_message
EXTRN	?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA:BYTE ; fn_get_local_entity_parent
EXTRN	?overload_invalid_float_type_message@@3PBDB:DWORD ; overload_invalid_float_type_message
EXTRN	?fn_get_local_entity_float_value@@3PAY0KP@P6GMPAUENTITY@@W4FLOAT_TYPES@@@ZA:BYTE ; fn_get_local_entity_float_value
EXTRN	?overload_invalid_int_type_message@@3PBDB:DWORD	; overload_invalid_int_type_message
EXTRN	?fn_set_client_server_entity_int_value@@3PAY1BBH@1P6GXPAUENTITY@@W4INT_TYPES@@H@ZA:BYTE ; fn_set_client_server_entity_int_value
EXTRN	?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA:BYTE ; fn_get_local_entity_int_value
EXTRN	?overload_invalid_ptr_type_message@@3PBDB:DWORD	; overload_invalid_ptr_type_message
EXTRN	?fn_get_local_entity_ptr_value@@3PAY0BE@P6GPAXPAUENTITY@@W4PTR_TYPES@@@ZA:BYTE ; fn_get_local_entity_ptr_value
EXTRN	?overload_invalid_vec3d_type_message@@3PBDB:DWORD ; overload_invalid_vec3d_type_message
EXTRN	?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA:BYTE ; fn_get_local_entity_vec3d_ptr
EXTRN	?weapon_database@@3PAUWEAPON_DATA@@A:BYTE	; weapon_database
EXTRN	?target_point_offsets@@3PAUVEC3D@@A:BYTE	; target_point_offsets
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@406f400000000000
CONST	SEGMENT
__real@406f400000000000 DQ 0406f400000000000r	; 250
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
CONST	SEGMENT
??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@
CONST	SEGMENT
??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@ DB 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'm', 00H, 'a', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 'l', 00H
	DB	'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\algorithm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FEEMDEPI@invalid?5comparator@
CONST	SEGMENT
??_C@_0BD@FEEMDEPI@invalid?5comparator@ DB 'invalid comparator', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z@4JA DD 0f2H ; `attack_guide_find_best_weapon'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BD@LFMGFFAJ@weapon_speed?5?$DO?50?40@
CONST	SEGMENT
??_C@_0BD@LFMGFFAJ@weapon_speed?5?$DO?50?40@ DB 'weapon_speed > 0.0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GIIHKPLE@ip@
CONST	SEGMENT
??_C@_02GIIHKPLE@ip@ DB 'ip', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA DD 08dH ; `calculate_attack_guide_intercept_point'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_06JJLAMBGK@target@
CONST	SEGMENT
??_C@_06JJLAMBGK@target@ DB 'target', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HKMIOAOH@aggressor@
CONST	SEGMENT
??_C@_09HKMIOAOH@aggressor@ DB 'aggressor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@FKJNEEAI@get_local_entity_int_value?5?$CItas@
CONST	SEGMENT
??_C@_0FL@FKJNEEAI@get_local_entity_int_value?5?$CItas@ DB 'get_local_ent'
	DB	'ity_int_value (task, INT_TYPE_ENTITY_SUB_TYPE) == ENTITY_SUB_'
	DB	'TYPE_TASK_ENGAGE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GGKLLKOO@task@
CONST	SEGMENT
??_C@_04GGKLLKOO@task@ DB 'task', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LFNMGJAP@en@
CONST	SEGMENT
??_C@_02LFNMGJAP@en@ DB 'en', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
CONST	SEGMENT
??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@ DB 'c:\users\nh'
	DB	'v90\projects\eech\aphavoc\source\entity\special\guide\gd_attc'
	DB	'k.c', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA DD 050H ; `initialise_attack_guide'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
;	COMDAT ??$max@N@std@@YGABNABN0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@N@std@@YGABNABN0@Z PROC				; std::max<double>, COMDAT

; 5387 : 	{	// return larger of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5388 : 	if (_Left < _Right)

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000f	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00013	66 0f 2f 01	 comisd	 xmm0, QWORD PTR [ecx]
  00017	76 65		 jbe	 SHORT $LN8@max
$LN4@max:

; 5389 : 		{
; 5390 : 		_STL_ASSERT(!(_Right < _Left), "invalid comparator");

  00019	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001f	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00023	66 0f 2f 01	 comisd	 xmm0, QWORD PTR [ecx]
  00027	77 02		 ja	 SHORT $LN9@max
  00029	eb 4a		 jmp	 SHORT $LN6@max
$LN9@max:
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FEEMDEPI@invalid?5comparator@
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00035	6a 00		 push	 0
  00037	68 0e 15 00 00	 push	 5390			; 0000150eH
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00041	6a 02		 push	 2
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00049	83 c4 18	 add	 esp, 24			; 00000018H
  0004c	83 f8 01	 cmp	 eax, 1
  0004f	75 01		 jne	 SHORT $LN12@max
  00051	cc		 int	 3
$LN12@max:
  00052	6a 00		 push	 0
  00054	68 0e 15 00 00	 push	 5390			; 0000150eH
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0006e	83 c4 14	 add	 esp, 20			; 00000014H
  00071	33 c0		 xor	 eax, eax
  00073	75 b6		 jne	 SHORT $LN9@max
$LN6@max:
  00075	33 c0		 xor	 eax, eax
  00077	75 a0		 jne	 SHORT $LN4@max

; 5391 : 		return (_Right);

  00079	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0007c	eb 03		 jmp	 SHORT $LN1@max
$LN8@max:

; 5392 : 		}
; 5393 : 
; 5394 : 	return (_Left);

  0007e	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
$LN1@max:

; 5395 : 	}

  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 08 00	 ret	 8
??$max@N@std@@YGABNABN0@Z ENDP				; std::max<double>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\guide\gd_attck.c
;	COMDAT ?attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z
_TEXT	SEGMENT
tv173 = -84						; size = 4
tv135 = -84						; size = 4
tv78 = -84						; size = 4
tv165 = -80						; size = 4
tv95 = -80						; size = 4
tv70 = -80						; size = 4
_best_weapon$ = -12					; size = 4
_aggressor$ = -8					; size = 4
_target$ = -4						; size = 4
_en$ = 8						; size = 4
?attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z PROC	; attack_guide_find_best_weapon, COMDAT

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 243  : 	entity
; 244  : 		*target,
; 245  : 		*aggressor;
; 246  : 
; 247  : 	entity_sub_types
; 248  : 		best_weapon;
; 249  : 
; 250  : 	//
; 251  : 	// check weapon
; 252  : 	//
; 253  : 
; 254  : 	aggressor = (entity *) get_local_entity_ptr_value (en, PTR_TYPE_TASK_LEADER);

  00009	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  0000d	74 0a		 je	 SHORT $LN7@attack_gui
  0000f	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	89 4d b0	 mov	 DWORD PTR tv70[ebp], ecx
  00017	eb 21		 jmp	 SHORT $LN8@attack_gui
$LN7@attack_gui:
  00019	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z@4JA
  0001f	83 c2 0c	 add	 edx, 12			; 0000000cH
  00022	52		 push	 edx
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00033	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN8@attack_gui:
  0003a	b9 01 00 00 00	 mov	 ecx, 1
  0003f	85 c9		 test	 ecx, ecx
  00041	74 09		 je	 SHORT $LN9@attack_gui
  00043	c7 45 ac 0f 00
	00 00		 mov	 DWORD PTR tv78[ebp], 15	; 0000000fH
  0004a	eb 21		 jmp	 SHORT $LN10@attack_gui
$LN9@attack_gui:
  0004c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z@4JA
  00052	83 c2 0c	 add	 edx, 12			; 0000000cH
  00055	52		 push	 edx
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_ptr_type_message@@3PBDB ; overload_invalid_ptr_type_message
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00066	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN10@attack_gui:
  0006d	6a 0f		 push	 15			; 0000000fH
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  00072	51		 push	 ecx
  00073	6b 55 b0 50	 imul	 edx, DWORD PTR tv70[ebp], 80
  00077	8b 45 ac	 mov	 eax, DWORD PTR tv78[ebp]
  0007a	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_ptr_value@@3PAY0BE@P6GPAXPAUENTITY@@W4PTR_TYPES@@@ZA[edx+eax*4]
  00081	ff d1		 call	 ecx
  00083	89 45 f8	 mov	 DWORD PTR _aggressor$[ebp], eax

; 255  : 
; 256  : 	ASSERT (aggressor);

  00086	83 7d f8 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  0008a	75 18		 jne	 SHORT $LN2@attack_gui
  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z@4JA
  00091	83 c0 0e	 add	 eax, 14			; 0000000eH
  00094	50		 push	 eax
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_09HKMIOAOH@aggressor@
  0009f	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@attack_gui:

; 257  : 
; 258  : 	target = get_local_entity_parent (aggressor, LIST_TYPE_TARGET);

  000a4	83 7d f8 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  000a8	74 0a		 je	 SHORT $LN11@attack_gui
  000aa	8b 45 f8	 mov	 eax, DWORD PTR _aggressor$[ebp]
  000ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  000af	89 4d b0	 mov	 DWORD PTR tv95[ebp], ecx
  000b2	eb 21		 jmp	 SHORT $LN12@attack_gui
$LN11@attack_gui:
  000b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z@4JA
  000ba	83 c2 10	 add	 edx, 16			; 00000010H
  000bd	52		 push	 edx
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  000c3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  000ce	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
$LN12@attack_gui:
  000d5	b9 01 00 00 00	 mov	 ecx, 1
  000da	85 c9		 test	 ecx, ecx
  000dc	74 09		 je	 SHORT $LN13@attack_gui
  000de	c7 45 ac 26 00
	00 00		 mov	 DWORD PTR tv135[ebp], 38 ; 00000026H
  000e5	eb 21		 jmp	 SHORT $LN14@attack_gui
$LN13@attack_gui:
  000e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z@4JA
  000ed	83 c2 10	 add	 edx, 16			; 00000010H
  000f0	52		 push	 edx
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  000f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00101	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv135[ebp], 0
$LN14@attack_gui:
  00108	6a 26		 push	 38			; 00000026H
  0010a	8b 4d f8	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  0010d	51		 push	 ecx
  0010e	69 55 b0 b4 00
	00 00		 imul	 edx, DWORD PTR tv95[ebp], 180
  00115	8b 45 ac	 mov	 eax, DWORD PTR tv135[ebp]
  00118	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  0011f	ff d1		 call	 ecx
  00121	89 45 fc	 mov	 DWORD PTR _target$[ebp], eax

; 259  : 
; 260  : 	ASSERT (target);

  00124	83 7d fc 00	 cmp	 DWORD PTR _target$[ebp], 0
  00128	75 18		 jne	 SHORT $LN3@attack_gui
  0012a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z@4JA
  0012f	83 c0 12	 add	 eax, 18			; 00000012H
  00132	50		 push	 eax
  00133	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00138	68 00 00 00 00	 push	 OFFSET ??_C@_06JJLAMBGK@target@
  0013d	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN3@attack_gui:

; 261  : 
; 262  : 	best_weapon = get_best_weapon_for_target (aggressor, target, BEST_WEAPON_RANGE_CHECK);

  00142	6a 04		 push	 4
  00144	8b 45 fc	 mov	 eax, DWORD PTR _target$[ebp]
  00147	50		 push	 eax
  00148	8b 4d f8	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  0014b	51		 push	 ecx
  0014c	e8 00 00 00 00	 call	 ?get_best_weapon_for_target@@YGHPAUENTITY@@0I@Z ; get_best_weapon_for_target
  00151	89 45 f4	 mov	 DWORD PTR _best_weapon$[ebp], eax

; 263  : 
; 264  : 	if (best_weapon == ENTITY_SUB_TYPE_WEAPON_NO_WEAPON)

  00154	83 7d f4 00	 cmp	 DWORD PTR _best_weapon$[ebp], 0
  00158	75 2e		 jne	 SHORT $LN4@attack_gui

; 265  : 	{
; 266  : 		//
; 267  : 		// No suitable weapon at current range
; 268  : 		//
; 269  : 
; 270  : 		best_weapon = get_best_weapon_for_target (aggressor, target, BEST_WEAPON_CRITERIA_MINIMAL);

  0015a	6a 00		 push	 0
  0015c	8b 45 fc	 mov	 eax, DWORD PTR _target$[ebp]
  0015f	50		 push	 eax
  00160	8b 4d f8	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  00163	51		 push	 ecx
  00164	e8 00 00 00 00	 call	 ?get_best_weapon_for_target@@YGHPAUENTITY@@0I@Z ; get_best_weapon_for_target
  00169	89 45 f4	 mov	 DWORD PTR _best_weapon$[ebp], eax

; 271  : 
; 272  : 		if (best_weapon == ENTITY_SUB_TYPE_WEAPON_NO_WEAPON)

  0016c	83 7d f4 00	 cmp	 DWORD PTR _best_weapon$[ebp], 0
  00170	75 16		 jne	 SHORT $LN4@attack_gui

; 273  : 		{
; 274  : 			//
; 275  : 			// Entity is not capable of destroying the target - abort the attack
; 276  : 			//
; 277  : 
; 278  : 			delete_group_member_from_engage_guide (aggressor, en, TRUE);

  00172	6a 01		 push	 1
  00174	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00177	50		 push	 eax
  00178	8b 4d f8	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  0017b	51		 push	 ecx
  0017c	e8 00 00 00 00	 call	 ?delete_group_member_from_engage_guide@@YGXPAUENTITY@@0H@Z ; delete_group_member_from_engage_guide

; 279  : 
; 280  : 			return FALSE;

  00181	33 c0		 xor	 eax, eax
  00183	e9 91 00 00 00	 jmp	 $LN1@attack_gui
$LN4@attack_gui:

; 281  : 		}
; 282  : 	}
; 283  : 
; 284  : 	set_client_server_entity_int_value (aggressor, INT_TYPE_SELECTED_WEAPON, best_weapon);

  00188	83 7d f8 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  0018c	74 0a		 je	 SHORT $LN15@attack_gui
  0018e	8b 45 f8	 mov	 eax, DWORD PTR _aggressor$[ebp]
  00191	8b 08		 mov	 ecx, DWORD PTR [eax]
  00193	89 4d b0	 mov	 DWORD PTR tv165[ebp], ecx
  00196	eb 21		 jmp	 SHORT $LN16@attack_gui
$LN15@attack_gui:
  00198	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z@4JA
  0019e	83 c2 2a	 add	 edx, 42			; 0000002aH
  001a1	52		 push	 edx
  001a2	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  001a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  001ac	50		 push	 eax
  001ad	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  001b2	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv165[ebp], 0
$LN16@attack_gui:
  001b9	b9 01 00 00 00	 mov	 ecx, 1
  001be	85 c9		 test	 ecx, ecx
  001c0	74 09		 je	 SHORT $LN17@attack_gui
  001c2	c7 45 ac b8 00
	00 00		 mov	 DWORD PTR tv173[ebp], 184 ; 000000b8H
  001c9	eb 21		 jmp	 SHORT $LN18@attack_gui
$LN17@attack_gui:
  001cb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z@4JA
  001d1	83 c2 2a	 add	 edx, 42			; 0000002aH
  001d4	52		 push	 edx
  001d5	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  001da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  001e5	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv173[ebp], 0
$LN18@attack_gui:
  001ec	8b 4d f4	 mov	 ecx, DWORD PTR _best_weapon$[ebp]
  001ef	51		 push	 ecx
  001f0	68 b8 00 00 00	 push	 184			; 000000b8H
  001f5	8b 55 f8	 mov	 edx, DWORD PTR _aggressor$[ebp]
  001f8	52		 push	 edx
  001f9	69 45 b0 b8 08
	00 00		 imul	 eax, DWORD PTR tv165[ebp], 2232
  00200	8b 4d ac	 mov	 ecx, DWORD PTR tv173[ebp]
  00203	8d 94 c8 00 00
	00 00		 lea	 edx, DWORD PTR ?fn_set_client_server_entity_int_value@@3PAY1BBH@1P6GXPAUENTITY@@W4INT_TYPES@@H@ZA[eax+ecx*8]
  0020a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?system_comms_model@@3W4COMMS_MODEL_TYPES@@A ; system_comms_model
  0020f	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00212	ff d1		 call	 ecx

; 285  : 
; 286  : 	return TRUE;

  00214	b8 01 00 00 00	 mov	 eax, 1
$LN1@attack_gui:

; 287  : }

  00219	5f		 pop	 edi
  0021a	5e		 pop	 esi
  0021b	5b		 pop	 ebx
  0021c	8b e5		 mov	 esp, ebp
  0021e	5d		 pop	 ebp
  0021f	c2 04 00	 ret	 4
?attack_guide_find_best_weapon@@YGHPAUENTITY@@@Z ENDP	; attack_guide_find_best_weapon
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\guide\gd_attck.c
;	COMDAT ?calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z
_TEXT	SEGMENT
tv420 = -156						; size = 4
tv441 = -152						; size = 4
tv414 = -152						; size = 4
tv457 = -148						; size = 4
tv455 = -148						; size = 8
tv247 = -148						; size = 4
tv208 = -148						; size = 4
tv188 = -148						; size = 4
tv161 = -148						; size = 4
tv93 = -148						; size = 4
tv435 = -144						; size = 4
tv239 = -144						; size = 4
tv200 = -144						; size = 4
tv180 = -144						; size = 4
tv153 = -144						; size = 4
tv85 = -144						; size = 4
$T1 = -140						; size = 8
$T2 = -132						; size = 8
_projectile_drop$3 = -60				; size = 4
_projectile_drop_angle$4 = -56				; size = 4
_tof$5 = -52						; size = 4
_pitch$6 = -48						; size = 4
_height_diff$7 = -44					; size = 4
_aiming_pitch$8 = -40					; size = 4
_mid_salvo_distance$9 = -36				; size = 4
_burst_length$10 = -32					; size = 4
_velocity$11 = -28					; size = 4
_aggressor_pos$12 = -24					; size = 4
_object_index$ = -20					; size = 4
_weapon_speed$ = -16					; size = 4
_target_speed$ = -12					; size = 4
_distance$ = -8						; size = 4
_time$ = -4						; size = 4
_aggressor$ = 8						; size = 4
_target$ = 12						; size = 4
_selected_weapon$ = 16					; size = 4
_ip$ = 20						; size = 4
?calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z PROC ; calculate_attack_guide_intercept_point, COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 142  : 	float
; 143  : 		time,
; 144  : 		distance,
; 145  : 		target_speed,
; 146  : 		weapon_speed;
; 147  : 
; 148  : 	int
; 149  : 		object_index;
; 150  : 
; 151  : 	ASSERT (aggressor);

  0000c	83 7d 08 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  00010	75 18		 jne	 SHORT $LN2@calculate_
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  00017	83 c0 0a	 add	 eax, 10			; 0000000aH
  0001a	50		 push	 eax
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_09HKMIOAOH@aggressor@
  00025	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@calculate_:

; 152  : 
; 153  : 	ASSERT (target);

  0002a	83 7d 0c 00	 cmp	 DWORD PTR _target$[ebp], 0
  0002e	75 18		 jne	 SHORT $LN3@calculate_
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  00035	83 c0 0c	 add	 eax, 12			; 0000000cH
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_06JJLAMBGK@target@
  00043	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN3@calculate_:

; 154  : 
; 155  : 	ASSERT (ip);

  00048	83 7d 14 00	 cmp	 DWORD PTR _ip$[ebp], 0
  0004c	75 18		 jne	 SHORT $LN4@calculate_
  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  00053	83 c0 0e	 add	 eax, 14			; 0000000eH
  00056	50		 push	 eax
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_02GIIHKPLE@ip@
  00061	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN4@calculate_:

; 156  : 
; 157  : 	//
; 158  : 	// Also uses target point NULL on the object to define offset
; 159  : 	//
; 160  : 
; 161  : 	object_index = get_local_entity_int_value (target, INT_TYPE_OBJECT_3D_SHAPE);

  00066	83 7d 0c 00	 cmp	 DWORD PTR _target$[ebp], 0
  0006a	74 0d		 je	 SHORT $LN12@calculate_
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]
  0006f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00071	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], ecx
  00077	eb 24		 jmp	 SHORT $LN13@calculate_
$LN12@calculate_:
  00079	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  0007f	83 c2 14	 add	 edx, 20			; 00000014H
  00082	52		 push	 edx
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00093	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv85[ebp], 0
$LN13@calculate_:
  0009d	b9 01 00 00 00	 mov	 ecx, 1
  000a2	85 c9		 test	 ecx, ecx
  000a4	74 0c		 je	 SHORT $LN14@calculate_
  000a6	c7 85 6c ff ff
	ff 92 00 00 00	 mov	 DWORD PTR tv93[ebp], 146 ; 00000092H
  000b0	eb 24		 jmp	 SHORT $LN15@calculate_
$LN14@calculate_:
  000b2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  000b8	83 c2 14	 add	 edx, 20			; 00000014H
  000bb	52		 push	 edx
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  000cc	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv93[ebp], 0
$LN15@calculate_:
  000d6	68 92 00 00 00	 push	 146			; 00000092H
  000db	8b 4d 0c	 mov	 ecx, DWORD PTR _target$[ebp]
  000de	51		 push	 ecx
  000df	69 95 70 ff ff
	ff 5c 04 00 00	 imul	 edx, DWORD PTR tv85[ebp], 1116
  000e9	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv93[ebp]
  000ef	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[edx+eax*4]
  000f6	ff d1		 call	 ecx
  000f8	89 45 ec	 mov	 DWORD PTR _object_index$[ebp], eax

; 162  : 
; 163  : 	if (object_index != OBJECT_3D_INVALID_OBJECT_INDEX)

  000fb	83 7d ec 00	 cmp	 DWORD PTR _object_index$[ebp], 0
  000ff	74 31		 je	 SHORT $LN5@calculate_

; 164  : 	{
; 165  : 		ip->x = target_point_offsets [object_index].x;

  00101	6b 45 ec 0c	 imul	 eax, DWORD PTR _object_index$[ebp], 12
  00105	8b 4d 14	 mov	 ecx, DWORD PTR _ip$[ebp]
  00108	8b 90 00 00 00
	00		 mov	 edx, DWORD PTR ?target_point_offsets@@3PAUVEC3D@@A[eax]
  0010e	89 11		 mov	 DWORD PTR [ecx], edx

; 166  : 		ip->y = target_point_offsets [object_index].y;

  00110	6b 45 ec 0c	 imul	 eax, DWORD PTR _object_index$[ebp], 12
  00114	8b 4d 14	 mov	 ecx, DWORD PTR _ip$[ebp]
  00117	8b 90 04 00 00
	00		 mov	 edx, DWORD PTR ?target_point_offsets@@3PAUVEC3D@@A[eax+4]
  0011d	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 167  : 		ip->z = target_point_offsets [object_index].z;

  00120	6b 45 ec 0c	 imul	 eax, DWORD PTR _object_index$[ebp], 12
  00124	8b 4d 14	 mov	 ecx, DWORD PTR _ip$[ebp]
  00127	8b 90 08 00 00
	00		 mov	 edx, DWORD PTR ?target_point_offsets@@3PAUVEC3D@@A[eax+8]
  0012d	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 168  : 	}
; 169  : 	else

  00130	eb 20		 jmp	 SHORT $LN6@calculate_
$LN5@calculate_:

; 170  : 	{
; 171  : 		ip->x = 0.0;

  00132	8b 45 14	 mov	 eax, DWORD PTR _ip$[ebp]
  00135	0f 57 c0	 xorps	 xmm0, xmm0
  00138	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 172  : 		ip->y = 0.0;

  0013c	8b 45 14	 mov	 eax, DWORD PTR _ip$[ebp]
  0013f	0f 57 c0	 xorps	 xmm0, xmm0
  00142	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 173  : 		ip->z = 0.0;

  00147	8b 45 14	 mov	 eax, DWORD PTR _ip$[ebp]
  0014a	0f 57 c0	 xorps	 xmm0, xmm0
  0014d	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
$LN6@calculate_:

; 174  : 	}
; 175  : 
; 176  : 	//
; 177  : 	// check for simple case if target not moving
; 178  : 	//
; 179  : 
; 180  : 	target_speed = get_local_entity_float_value (target, FLOAT_TYPE_VELOCITY);

  00152	83 7d 0c 00	 cmp	 DWORD PTR _target$[ebp], 0
  00156	74 0d		 je	 SHORT $LN16@calculate_
  00158	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]
  0015b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015d	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv153[ebp], ecx
  00163	eb 24		 jmp	 SHORT $LN17@calculate_
$LN16@calculate_:
  00165	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  0016b	83 c2 27	 add	 edx, 39			; 00000027H
  0016e	52		 push	 edx
  0016f	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00174	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0017f	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
$LN17@calculate_:
  00189	b9 01 00 00 00	 mov	 ecx, 1
  0018e	85 c9		 test	 ecx, ecx
  00190	74 0c		 je	 SHORT $LN18@calculate_
  00192	c7 85 6c ff ff
	ff 93 00 00 00	 mov	 DWORD PTR tv161[ebp], 147 ; 00000093H
  0019c	eb 24		 jmp	 SHORT $LN19@calculate_
$LN18@calculate_:
  0019e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  001a4	83 c2 27	 add	 edx, 39			; 00000027H
  001a7	52		 push	 edx
  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  001ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_float_type_message@@3PBDB ; overload_invalid_float_type_message
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  001b8	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv161[ebp], 0
$LN19@calculate_:
  001c2	68 93 00 00 00	 push	 147			; 00000093H
  001c7	8b 4d 0c	 mov	 ecx, DWORD PTR _target$[ebp]
  001ca	51		 push	 ecx
  001cb	69 95 70 ff ff
	ff bc 02 00 00	 imul	 edx, DWORD PTR tv153[ebp], 700
  001d5	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv161[ebp]
  001db	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_float_value@@3PAY0KP@P6GMPAUENTITY@@W4FLOAT_TYPES@@@ZA[edx+eax*4]
  001e2	ff d1		 call	 ecx
  001e4	d9 5d f4	 fstp	 DWORD PTR _target_speed$[ebp]

; 181  : 
; 182  : 	//
; 183  : 	// Assume distance between target and aggressor at fire position will be the weapons effective range
; 184  : 	//
; 185  : 
; 186  : 	distance = weapon_database [selected_weapon].effective_range;

  001e7	69 45 10 e0 00
	00 00		 imul	 eax, DWORD PTR _selected_weapon$[ebp], 224
  001ee	f3 0f 10 80 94
	00 00 00	 movss	 xmm0, DWORD PTR ?weapon_database@@3PAUWEAPON_DATA@@A[eax+148]
  001f6	f3 0f 11 45 f8	 movss	 DWORD PTR _distance$[ebp], xmm0

; 187  : 
; 188  : 	// adjust for weapon drop
; 189  : 	if (weapon_database [selected_weapon].guidance_type == WEAPON_GUIDANCE_TYPE_NONE)

  001fb	69 45 10 e0 00
	00 00		 imul	 eax, DWORD PTR _selected_weapon$[ebp], 224
  00202	83 b8 18 00 00
	00 00		 cmp	 DWORD PTR ?weapon_database@@3PAUWEAPON_DATA@@A[eax+24], 0
  00209	0f 85 24 03 00
	00		 jne	 $LN8@calculate_

; 190  : 	{
; 191  : 		vec3d*
; 192  : 			aggressor_pos = get_local_entity_vec3d_ptr (aggressor, VEC3D_TYPE_POSITION);

  0020f	83 7d 08 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  00213	74 0d		 je	 SHORT $LN20@calculate_
  00215	8b 45 08	 mov	 eax, DWORD PTR _aggressor$[ebp]
  00218	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021a	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv180[ebp], ecx
  00220	eb 24		 jmp	 SHORT $LN21@calculate_
$LN20@calculate_:
  00222	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  00228	83 c2 33	 add	 edx, 51			; 00000033H
  0022b	52		 push	 edx
  0022c	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00231	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00236	50		 push	 eax
  00237	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0023c	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv180[ebp], 0
$LN21@calculate_:
  00246	b9 01 00 00 00	 mov	 ecx, 1
  0024b	85 c9		 test	 ecx, ecx
  0024d	74 0c		 je	 SHORT $LN22@calculate_
  0024f	c7 85 6c ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv188[ebp], 8
  00259	eb 24		 jmp	 SHORT $LN23@calculate_
$LN22@calculate_:
  0025b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  00261	83 c2 33	 add	 edx, 51			; 00000033H
  00264	52		 push	 edx
  00265	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  0026a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  0026f	50		 push	 eax
  00270	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00275	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv188[ebp], 0
$LN23@calculate_:
  0027f	6a 08		 push	 8
  00281	8b 4d 08	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  00284	51		 push	 ecx
  00285	6b 95 70 ff ff
	ff 60		 imul	 edx, DWORD PTR tv180[ebp], 96
  0028c	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv188[ebp]
  00292	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA[edx+eax*4]
  00299	ff d1		 call	 ecx
  0029b	89 45 e8	 mov	 DWORD PTR _aggressor_pos$12[ebp], eax

; 193  : 
; 194  : 		float
; 195  : 			velocity = get_local_entity_float_value (aggressor, FLOAT_TYPE_CRUISE_VELOCITY),

  0029e	83 7d 08 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  002a2	74 0d		 je	 SHORT $LN24@calculate_
  002a4	8b 45 08	 mov	 eax, DWORD PTR _aggressor$[ebp]
  002a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a9	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv200[ebp], ecx
  002af	eb 24		 jmp	 SHORT $LN25@calculate_
$LN24@calculate_:
  002b1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  002b7	83 c2 36	 add	 edx, 54			; 00000036H
  002ba	52		 push	 edx
  002bb	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  002c0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  002c5	50		 push	 eax
  002c6	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  002cb	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv200[ebp], 0
$LN25@calculate_:
  002d5	b9 01 00 00 00	 mov	 ecx, 1
  002da	85 c9		 test	 ecx, ecx
  002dc	74 0c		 je	 SHORT $LN26@calculate_
  002de	c7 85 6c ff ff
	ff 19 00 00 00	 mov	 DWORD PTR tv208[ebp], 25 ; 00000019H
  002e8	eb 24		 jmp	 SHORT $LN27@calculate_
$LN26@calculate_:
  002ea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  002f0	83 c2 36	 add	 edx, 54			; 00000036H
  002f3	52		 push	 edx
  002f4	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  002f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_float_type_message@@3PBDB ; overload_invalid_float_type_message
  002fe	50		 push	 eax
  002ff	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00304	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv208[ebp], 0
$LN27@calculate_:
  0030e	6a 19		 push	 25			; 00000019H
  00310	8b 4d 08	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  00313	51		 push	 ecx
  00314	69 95 70 ff ff
	ff bc 02 00 00	 imul	 edx, DWORD PTR tv200[ebp], 700
  0031e	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv208[ebp]
  00324	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_float_value@@3PAY0KP@P6GMPAUENTITY@@W4FLOAT_TYPES@@@ZA[edx+eax*4]
  0032b	ff d1		 call	 ecx
  0032d	d9 5d e4	 fstp	 DWORD PTR _velocity$11[ebp]

; 196  : 			burst_length = weapon_database[selected_weapon].burst_duration,

  00330	69 45 10 e0 00
	00 00		 imul	 eax, DWORD PTR _selected_weapon$[ebp], 224
  00337	f3 0f 10 80 c4
	00 00 00	 movss	 xmm0, DWORD PTR ?weapon_database@@3PAUWEAPON_DATA@@A[eax+196]
  0033f	f3 0f 11 45 e0	 movss	 DWORD PTR _burst_length$10[ebp], xmm0

; 197  : 			// use distance in the middle of the salve. First rounds will hit short, last long, but should bracket target nicely
; 198  : 			mid_salvo_distance = distance - max(250.0, (0.5 * velocity * burst_length)),

  00344	f3 0f 5a 45 e4	 cvtss2sd xmm0, DWORD PTR _velocity$11[ebp]
  00349	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00351	f3 0f 5a 4d e0	 cvtss2sd xmm1, DWORD PTR _burst_length$10[ebp]
  00356	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0035a	f2 0f 11 85 7c
	ff ff ff	 movsd	 QWORD PTR $T2[ebp], xmm0
  00362	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@406f400000000000
  0036a	f2 0f 11 85 74
	ff ff ff	 movsd	 QWORD PTR $T1[ebp], xmm0
  00372	f3 0f 5a 45 f8	 cvtss2sd xmm0, DWORD PTR _distance$[ebp]
  00377	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0037d	50		 push	 eax
  0037e	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00384	51		 push	 ecx
  00385	f2 0f 11 85 6c
	ff ff ff	 movsd	 QWORD PTR tv455[ebp], xmm0
  0038d	e8 00 00 00 00	 call	 ??$max@N@std@@YGABNABN0@Z ; std::max<double>
  00392	f2 0f 10 85 6c
	ff ff ff	 movsd	 xmm0, QWORD PTR tv455[ebp]
  0039a	f2 0f 5c 00	 subsd	 xmm0, QWORD PTR [eax]
  0039e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  003a2	f3 0f 11 45 dc	 movss	 DWORD PTR _mid_salvo_distance$9[ebp], xmm0

; 199  : 			aiming_pitch,
; 200  : 			height_diff = aggressor_pos->y - ip->y,

  003a7	8b 45 e8	 mov	 eax, DWORD PTR _aggressor_pos$12[ebp]
  003aa	8b 4d 14	 mov	 ecx, DWORD PTR _ip$[ebp]
  003ad	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  003b2	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  003b7	f3 0f 11 45 d4	 movss	 DWORD PTR _height_diff$7[ebp], xmm0

; 201  : 			// current pitch from aggressor to target, it won't be the same at firing point, but close enough
; 202  : 			pitch = -atan(height_diff / get_2d_range(aggressor_pos, get_local_entity_vec3d_ptr(target, VEC3D_TYPE_POSITION))),

  003bc	83 7d 0c 00	 cmp	 DWORD PTR _target$[ebp], 0
  003c0	74 0d		 je	 SHORT $LN28@calculate_
  003c2	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]
  003c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c7	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv239[ebp], ecx
  003cd	eb 24		 jmp	 SHORT $LN29@calculate_
$LN28@calculate_:
  003cf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  003d5	83 c2 3d	 add	 edx, 61			; 0000003dH
  003d8	52		 push	 edx
  003d9	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  003de	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  003e3	50		 push	 eax
  003e4	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  003e9	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv239[ebp], 0
$LN29@calculate_:
  003f3	b9 01 00 00 00	 mov	 ecx, 1
  003f8	85 c9		 test	 ecx, ecx
  003fa	74 0c		 je	 SHORT $LN30@calculate_
  003fc	c7 85 6c ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv247[ebp], 8
  00406	eb 24		 jmp	 SHORT $LN31@calculate_
$LN30@calculate_:
  00408	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  0040e	83 c2 3d	 add	 edx, 61			; 0000003dH
  00411	52		 push	 edx
  00412	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00417	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  0041c	50		 push	 eax
  0041d	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00422	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv247[ebp], 0
$LN31@calculate_:
  0042c	6a 08		 push	 8
  0042e	8b 4d 0c	 mov	 ecx, DWORD PTR _target$[ebp]
  00431	51		 push	 ecx
  00432	6b 95 70 ff ff
	ff 60		 imul	 edx, DWORD PTR tv239[ebp], 96
  00439	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv247[ebp]
  0043f	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA[edx+eax*4]
  00446	ff d1		 call	 ecx
  00448	50		 push	 eax
  00449	8b 55 e8	 mov	 edx, DWORD PTR _aggressor_pos$12[ebp]
  0044c	52		 push	 edx
  0044d	e8 00 00 00 00	 call	 ?get_2d_range@@YGMPBUVEC3D@@0@Z ; get_2d_range
  00452	d9 9d 68 ff ff
	ff		 fstp	 DWORD PTR tv414[ebp]
  00458	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _height_diff$7[ebp]
  0045d	f3 0f 5e 85 68
	ff ff ff	 divss	 xmm0, DWORD PTR tv414[ebp]
  00465	51		 push	 ecx
  00466	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0046b	e8 00 00 00 00	 call	 ?atan@@YGMM@Z		; atan
  00470	d9 9d 64 ff ff
	ff		 fstp	 DWORD PTR tv420[ebp]
  00476	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR tv420[ebp]
  0047e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00485	f3 0f 11 45 d0	 movss	 DWORD PTR _pitch$6[ebp], xmm0

; 203  : 			tof;
; 204  : 
; 205  : 		if (get_ballistic_pitch_deflection(selected_weapon, mid_salvo_distance, pitch, &aiming_pitch, &tof, FALSE, TRUE))

  0048a	6a 01		 push	 1
  0048c	6a 00		 push	 0
  0048e	8d 45 cc	 lea	 eax, DWORD PTR _tof$5[ebp]
  00491	50		 push	 eax
  00492	8d 4d d8	 lea	 ecx, DWORD PTR _aiming_pitch$8[ebp]
  00495	51		 push	 ecx
  00496	51		 push	 ecx
  00497	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _pitch$6[ebp]
  0049c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004a1	51		 push	 ecx
  004a2	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _mid_salvo_distance$9[ebp]
  004a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004ac	8b 55 10	 mov	 edx, DWORD PTR _selected_weapon$[ebp]
  004af	52		 push	 edx
  004b0	e8 00 00 00 00	 call	 ?get_ballistic_pitch_deflection@@YGHHMMPAM0HH@Z ; get_ballistic_pitch_deflection
  004b5	85 c0		 test	 eax, eax
  004b7	74 7a		 je	 SHORT $LN8@calculate_

; 206  : 		{
; 207  : 			float
; 208  : 				projectile_drop_angle = aiming_pitch - pitch,  // aiming pitch is absolute, but we need to figure out how much higher we need to aim

  004b9	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _aiming_pitch$8[ebp]
  004be	f3 0f 5c 45 d0	 subss	 xmm0, DWORD PTR _pitch$6[ebp]
  004c3	f3 0f 11 45 c8	 movss	 DWORD PTR _projectile_drop_angle$4[ebp], xmm0

; 209  : 				projectile_drop = tan(projectile_drop_angle) * mid_salvo_distance * cos(pitch);  // distance projectile will drop, so aim this much above target

  004c8	51		 push	 ecx
  004c9	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _projectile_drop_angle$4[ebp]
  004ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004d3	e8 00 00 00 00	 call	 ?tan@@YGMM@Z		; tan
  004d8	d9 9d 70 ff ff
	ff		 fstp	 DWORD PTR tv435[ebp]
  004de	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR tv435[ebp]
  004e6	f3 0f 59 45 dc	 mulss	 xmm0, DWORD PTR _mid_salvo_distance$9[ebp]
  004eb	51		 push	 ecx
  004ec	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR _pitch$6[ebp]
  004f1	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  004f6	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR tv457[ebp], xmm0
  004fe	e8 00 00 00 00	 call	 ?cos@@YGMM@Z		; cos
  00503	d9 9d 68 ff ff
	ff		 fstp	 DWORD PTR tv441[ebp]
  00509	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR tv457[ebp]
  00511	f3 0f 59 85 68
	ff ff ff	 mulss	 xmm0, DWORD PTR tv441[ebp]
  00519	f3 0f 11 45 c4	 movss	 DWORD PTR _projectile_drop$3[ebp], xmm0

; 210  : 
; 211  : 			ip->y += projectile_drop;

  0051e	8b 45 14	 mov	 eax, DWORD PTR _ip$[ebp]
  00521	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00526	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _projectile_drop$3[ebp]
  0052b	8b 4d 14	 mov	 ecx, DWORD PTR _ip$[ebp]
  0052e	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
$LN8@calculate_:

; 212  : 		}
; 213  : 	}
; 214  : 
; 215  : 	if (target_speed == 0.0)

  00533	f3 0f 5a 45 f4	 cvtss2sd xmm0, DWORD PTR _target_speed$[ebp]
  00538	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00540	9f		 lahf
  00541	f6 c4 44	 test	 ah, 68			; 00000044H
  00544	7a 02		 jp	 SHORT $LN9@calculate_

; 216  : 	{
; 217  : 		return;

  00546	eb 64		 jmp	 SHORT $LN1@calculate_
$LN9@calculate_:

; 218  : 	}
; 219  : 
; 220  : 	//
; 221  : 	// Find time taken for weapon to travel this distance
; 222  : 	//
; 223  : 
; 224  : 	weapon_speed = weapon_database [selected_weapon].cruise_velocity;

  00548	69 45 10 e0 00
	00 00		 imul	 eax, DWORD PTR _selected_weapon$[ebp], 224
  0054f	f3 0f 10 80 ac
	00 00 00	 movss	 xmm0, DWORD PTR ?weapon_database@@3PAUWEAPON_DATA@@A[eax+172]
  00557	f3 0f 11 45 f0	 movss	 DWORD PTR _weapon_speed$[ebp], xmm0

; 225  : 
; 226  : 	ASSERT (weapon_speed > 0.0);

  0055c	f3 0f 5a 45 f0	 cvtss2sd xmm0, DWORD PTR _weapon_speed$[ebp]
  00561	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00569	77 18		 ja	 SHORT $LN10@calculate_
  0056b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z@4JA
  00570	83 c0 55	 add	 eax, 85			; 00000055H
  00573	50		 push	 eax
  00574	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00579	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@LFMGFFAJ@weapon_speed?5?$DO?50?40@
  0057e	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN10@calculate_:

; 227  : 
; 228  : 	time = distance / weapon_speed;

  00583	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _distance$[ebp]
  00588	f3 0f 5e 45 f0	 divss	 xmm0, DWORD PTR _weapon_speed$[ebp]
  0058d	f3 0f 11 45 fc	 movss	 DWORD PTR _time$[ebp], xmm0

; 229  : 
; 230  : 	//
; 231  : 	// calculate lead distance
; 232  : 	//
; 233  : 
; 234  : 	ip->z += target_speed * time;

  00592	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _target_speed$[ebp]
  00597	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR _time$[ebp]
  0059c	8b 45 14	 mov	 eax, DWORD PTR _ip$[ebp]
  0059f	f3 0f 58 40 08	 addss	 xmm0, DWORD PTR [eax+8]
  005a4	8b 4d 14	 mov	 ecx, DWORD PTR _ip$[ebp]
  005a7	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
$LN1@calculate_:

; 235  : }

  005ac	5f		 pop	 edi
  005ad	5e		 pop	 esi
  005ae	5b		 pop	 ebx
  005af	8b e5		 mov	 esp, ebp
  005b1	5d		 pop	 ebp
  005b2	c2 10 00	 ret	 16			; 00000010H
?calculate_attack_guide_intercept_point@@YGXPAUENTITY@@0HPAUVEC3D@@@Z ENDP ; calculate_attack_guide_intercept_point
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\guide\gd_attck.c
;	COMDAT ?initialise_attack_guide@@YGXPAUENTITY@@@Z
_TEXT	SEGMENT
tv258 = -88						; size = 4
tv238 = -88						; size = 4
tv213 = -88						; size = 4
tv190 = -88						; size = 4
tv165 = -88						; size = 4
tv140 = -88						; size = 4
tv83 = -88						; size = 4
tv251 = -84						; size = 4
tv230 = -84						; size = 4
tv206 = -84						; size = 4
tv182 = -84						; size = 4
tv157 = -84						; size = 4
tv132 = -84						; size = 4
tv75 = -84						; size = 4
_best_weapon$1 = -16					; size = 4
_target$ = -12						; size = 4
_aggressor$ = -8					; size = 4
_task$ = -4						; size = 4
_en$ = 8						; size = 4
?initialise_attack_guide@@YGXPAUENTITY@@@Z PROC		; initialise_attack_guide, COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 81   : 	entity
; 82   : 		*task,
; 83   : 		*aggressor,
; 84   : 		*target;
; 85   : 
; 86   : 	ASSERT (en);

  00009	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN2@initialise
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  00014	83 c0 06	 add	 eax, 6
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02LFNMGJAP@en@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@initialise:

; 87   : 
; 88   : 	task = get_local_entity_parent (en, LIST_TYPE_GUIDE);

  00027	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  0002b	74 0a		 je	 SHORT $LN11@initialise
  0002d	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	89 4d ac	 mov	 DWORD PTR tv75[ebp], ecx
  00035	eb 21		 jmp	 SHORT $LN12@initialise
$LN11@initialise:
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  0003d	83 c2 08	 add	 edx, 8
  00040	52		 push	 edx
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00051	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN12@initialise:
  00058	b9 01 00 00 00	 mov	 ecx, 1
  0005d	85 c9		 test	 ecx, ecx
  0005f	74 09		 je	 SHORT $LN13@initialise
  00061	c7 45 a8 10 00
	00 00		 mov	 DWORD PTR tv83[ebp], 16	; 00000010H
  00068	eb 21		 jmp	 SHORT $LN14@initialise
$LN13@initialise:
  0006a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  00070	83 c2 08	 add	 edx, 8
  00073	52		 push	 edx
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00084	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$LN14@initialise:
  0008b	6a 10		 push	 16			; 00000010H
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  00090	51		 push	 ecx
  00091	69 55 ac b4 00
	00 00		 imul	 edx, DWORD PTR tv75[ebp], 180
  00098	8b 45 a8	 mov	 eax, DWORD PTR tv83[ebp]
  0009b	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  000a2	ff d1		 call	 ecx
  000a4	89 45 fc	 mov	 DWORD PTR _task$[ebp], eax

; 89   : 
; 90   : 	ASSERT (task);

  000a7	83 7d fc 00	 cmp	 DWORD PTR _task$[ebp], 0
  000ab	75 18		 jne	 SHORT $LN3@initialise
  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  000b2	83 c0 0a	 add	 eax, 10			; 0000000aH
  000b5	50		 push	 eax
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_04GGKLLKOO@task@
  000c0	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN3@initialise:

; 91   : 
; 92   : 	ASSERT (get_local_entity_int_value (task, INT_TYPE_ENTITY_SUB_TYPE) == ENTITY_SUB_TYPE_TASK_ENGAGE);

  000c5	83 7d fc 00	 cmp	 DWORD PTR _task$[ebp], 0
  000c9	74 0a		 je	 SHORT $LN15@initialise
  000cb	8b 45 fc	 mov	 eax, DWORD PTR _task$[ebp]
  000ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d0	89 4d ac	 mov	 DWORD PTR tv132[ebp], ecx
  000d3	eb 21		 jmp	 SHORT $LN16@initialise
$LN15@initialise:
  000d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  000db	83 c2 0c	 add	 edx, 12			; 0000000cH
  000de	52		 push	 edx
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  000ef	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv132[ebp], 0
$LN16@initialise:
  000f6	b9 01 00 00 00	 mov	 ecx, 1
  000fb	85 c9		 test	 ecx, ecx
  000fd	74 09		 je	 SHORT $LN17@initialise
  000ff	c7 45 a8 34 00
	00 00		 mov	 DWORD PTR tv140[ebp], 52 ; 00000034H
  00106	eb 21		 jmp	 SHORT $LN18@initialise
$LN17@initialise:
  00108	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  0010e	83 c2 0c	 add	 edx, 12			; 0000000cH
  00111	52		 push	 edx
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00117	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00122	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
$LN18@initialise:
  00129	6a 34		 push	 52			; 00000034H
  0012b	8b 4d fc	 mov	 ecx, DWORD PTR _task$[ebp]
  0012e	51		 push	 ecx
  0012f	69 55 ac 5c 04
	00 00		 imul	 edx, DWORD PTR tv132[ebp], 1116
  00136	8b 45 a8	 mov	 eax, DWORD PTR tv140[ebp]
  00139	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[edx+eax*4]
  00140	ff d1		 call	 ecx
  00142	83 f8 09	 cmp	 eax, 9
  00145	74 18		 je	 SHORT $LN4@initialise
  00147	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  0014c	83 c0 0c	 add	 eax, 12			; 0000000cH
  0014f	50		 push	 eax
  00150	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00155	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@FKJNEEAI@get_local_entity_int_value?5?$CItas@
  0015a	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN4@initialise:

; 93   : 
; 94   : 	aggressor = (entity *) get_local_entity_ptr_value (en, PTR_TYPE_TASK_LEADER);

  0015f	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  00163	74 0a		 je	 SHORT $LN19@initialise
  00165	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00168	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016a	89 4d ac	 mov	 DWORD PTR tv157[ebp], ecx
  0016d	eb 21		 jmp	 SHORT $LN20@initialise
$LN19@initialise:
  0016f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  00175	83 c2 0e	 add	 edx, 14			; 0000000eH
  00178	52		 push	 edx
  00179	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  0017e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00189	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv157[ebp], 0
$LN20@initialise:
  00190	b9 01 00 00 00	 mov	 ecx, 1
  00195	85 c9		 test	 ecx, ecx
  00197	74 09		 je	 SHORT $LN21@initialise
  00199	c7 45 a8 0f 00
	00 00		 mov	 DWORD PTR tv165[ebp], 15 ; 0000000fH
  001a0	eb 21		 jmp	 SHORT $LN22@initialise
$LN21@initialise:
  001a2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  001a8	83 c2 0e	 add	 edx, 14			; 0000000eH
  001ab	52		 push	 edx
  001ac	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  001b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_ptr_type_message@@3PBDB ; overload_invalid_ptr_type_message
  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  001bc	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv165[ebp], 0
$LN22@initialise:
  001c3	6a 0f		 push	 15			; 0000000fH
  001c5	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  001c8	51		 push	 ecx
  001c9	6b 55 ac 50	 imul	 edx, DWORD PTR tv157[ebp], 80
  001cd	8b 45 a8	 mov	 eax, DWORD PTR tv165[ebp]
  001d0	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_ptr_value@@3PAY0BE@P6GPAXPAUENTITY@@W4PTR_TYPES@@@ZA[edx+eax*4]
  001d7	ff d1		 call	 ecx
  001d9	89 45 f8	 mov	 DWORD PTR _aggressor$[ebp], eax

; 95   : 
; 96   : 	ASSERT (aggressor);

  001dc	83 7d f8 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  001e0	75 18		 jne	 SHORT $LN5@initialise
  001e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  001e7	83 c0 10	 add	 eax, 16			; 00000010H
  001ea	50		 push	 eax
  001eb	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  001f0	68 00 00 00 00	 push	 OFFSET ??_C@_09HKMIOAOH@aggressor@
  001f5	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN5@initialise:

; 97   : 
; 98   : 	target = get_local_entity_parent (task, LIST_TYPE_TASK_DEPENDENT);

  001fa	83 7d fc 00	 cmp	 DWORD PTR _task$[ebp], 0
  001fe	74 0a		 je	 SHORT $LN23@initialise
  00200	8b 45 fc	 mov	 eax, DWORD PTR _task$[ebp]
  00203	8b 08		 mov	 ecx, DWORD PTR [eax]
  00205	89 4d ac	 mov	 DWORD PTR tv182[ebp], ecx
  00208	eb 21		 jmp	 SHORT $LN24@initialise
$LN23@initialise:
  0020a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  00210	83 c2 12	 add	 edx, 18			; 00000012H
  00213	52		 push	 edx
  00214	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00224	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv182[ebp], 0
$LN24@initialise:
  0022b	b9 01 00 00 00	 mov	 ecx, 1
  00230	85 c9		 test	 ecx, ecx
  00232	74 09		 je	 SHORT $LN25@initialise
  00234	c7 45 a8 27 00
	00 00		 mov	 DWORD PTR tv190[ebp], 39 ; 00000027H
  0023b	eb 21		 jmp	 SHORT $LN26@initialise
$LN25@initialise:
  0023d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  00243	83 c2 12	 add	 edx, 18			; 00000012H
  00246	52		 push	 edx
  00247	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  0024c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  00251	50		 push	 eax
  00252	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00257	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv190[ebp], 0
$LN26@initialise:
  0025e	6a 27		 push	 39			; 00000027H
  00260	8b 4d fc	 mov	 ecx, DWORD PTR _task$[ebp]
  00263	51		 push	 ecx
  00264	69 55 ac b4 00
	00 00		 imul	 edx, DWORD PTR tv182[ebp], 180
  0026b	8b 45 a8	 mov	 eax, DWORD PTR tv190[ebp]
  0026e	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  00275	ff d1		 call	 ecx
  00277	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax

; 99   : 
; 100  : 	ASSERT (target);

  0027a	83 7d f4 00	 cmp	 DWORD PTR _target$[ebp], 0
  0027e	75 18		 jne	 SHORT $LN6@initialise
  00280	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  00285	83 c0 14	 add	 eax, 20			; 00000014H
  00288	50		 push	 eax
  00289	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  0028e	68 00 00 00 00	 push	 OFFSET ??_C@_06JJLAMBGK@target@
  00293	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN6@initialise:

; 101  : 
; 102  : 	if (!get_local_entity_int_value (aggressor, INT_TYPE_IDENTIFY_AIRCRAFT))

  00298	83 7d f8 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  0029c	74 0a		 je	 SHORT $LN27@initialise
  0029e	8b 45 f8	 mov	 eax, DWORD PTR _aggressor$[ebp]
  002a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a3	89 4d ac	 mov	 DWORD PTR tv206[ebp], ecx
  002a6	eb 1a		 jmp	 SHORT $LN28@initialise
$LN27@initialise:
  002a8	6a 66		 push	 102			; 00000066H
  002aa	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  002af	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  002b5	52		 push	 edx
  002b6	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  002bb	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv206[ebp], 0
$LN28@initialise:
  002c2	b8 01 00 00 00	 mov	 eax, 1
  002c7	85 c0		 test	 eax, eax
  002c9	74 09		 je	 SHORT $LN29@initialise
  002cb	c7 45 a8 57 00
	00 00		 mov	 DWORD PTR tv213[ebp], 87 ; 00000057H
  002d2	eb 1a		 jmp	 SHORT $LN30@initialise
$LN29@initialise:
  002d4	6a 66		 push	 102			; 00000066H
  002d6	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  002db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  002e1	51		 push	 ecx
  002e2	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  002e7	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv213[ebp], 0
$LN30@initialise:
  002ee	6a 57		 push	 87			; 00000057H
  002f0	8b 55 f8	 mov	 edx, DWORD PTR _aggressor$[ebp]
  002f3	52		 push	 edx
  002f4	69 45 ac 5c 04
	00 00		 imul	 eax, DWORD PTR tv206[ebp], 1116
  002fb	8b 4d a8	 mov	 ecx, DWORD PTR tv213[ebp]
  002fe	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[eax+ecx*4]
  00305	ff d2		 call	 edx
  00307	85 c0		 test	 eax, eax
  00309	0f 85 a3 00 00
	00		 jne	 $LN7@initialise

; 103  : 	{
; 104  : 		//
; 105  : 		// Surface-Air & Surface-Surface
; 106  : 		//
; 107  : 
; 108  : 		entity_sub_types
; 109  : 			best_weapon;
; 110  : 
; 111  : 		//
; 112  : 		// find best weapon for target
; 113  : 		//
; 114  : 
; 115  : 		best_weapon = get_best_weapon_for_target (aggressor, target, BEST_WEAPON_CRITERIA_ALL);

  0030f	6a 07		 push	 7
  00311	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  00314	50		 push	 eax
  00315	8b 4d f8	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  00318	51		 push	 ecx
  00319	e8 00 00 00 00	 call	 ?get_best_weapon_for_target@@YGHPAUENTITY@@0I@Z ; get_best_weapon_for_target
  0031e	89 45 f0	 mov	 DWORD PTR _best_weapon$1[ebp], eax

; 116  : 
; 117  : 		set_client_server_entity_int_value (aggressor, INT_TYPE_SELECTED_WEAPON, best_weapon);

  00321	83 7d f8 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  00325	74 0a		 je	 SHORT $LN31@initialise
  00327	8b 45 f8	 mov	 eax, DWORD PTR _aggressor$[ebp]
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	89 4d ac	 mov	 DWORD PTR tv230[ebp], ecx
  0032f	eb 21		 jmp	 SHORT $LN32@initialise
$LN31@initialise:
  00331	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  00337	83 c2 25	 add	 edx, 37			; 00000025H
  0033a	52		 push	 edx
  0033b	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00340	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00345	50		 push	 eax
  00346	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0034b	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv230[ebp], 0
$LN32@initialise:
  00352	b9 01 00 00 00	 mov	 ecx, 1
  00357	85 c9		 test	 ecx, ecx
  00359	74 09		 je	 SHORT $LN33@initialise
  0035b	c7 45 a8 b8 00
	00 00		 mov	 DWORD PTR tv238[ebp], 184 ; 000000b8H
  00362	eb 21		 jmp	 SHORT $LN34@initialise
$LN33@initialise:
  00364	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??initialise_attack_guide@@YGXPAUENTITY@@@Z@4JA
  0036a	83 c2 25	 add	 edx, 37			; 00000025H
  0036d	52		 push	 edx
  0036e	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  00373	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  00378	50		 push	 eax
  00379	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0037e	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv238[ebp], 0
$LN34@initialise:
  00385	8b 4d f0	 mov	 ecx, DWORD PTR _best_weapon$1[ebp]
  00388	51		 push	 ecx
  00389	68 b8 00 00 00	 push	 184			; 000000b8H
  0038e	8b 55 f8	 mov	 edx, DWORD PTR _aggressor$[ebp]
  00391	52		 push	 edx
  00392	69 45 ac b8 08
	00 00		 imul	 eax, DWORD PTR tv230[ebp], 2232
  00399	8b 4d a8	 mov	 ecx, DWORD PTR tv238[ebp]
  0039c	8d 94 c8 00 00
	00 00		 lea	 edx, DWORD PTR ?fn_set_client_server_entity_int_value@@3PAY1BBH@1P6GXPAUENTITY@@W4INT_TYPES@@H@ZA[eax+ecx*8]
  003a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?system_comms_model@@3W4COMMS_MODEL_TYPES@@A ; system_comms_model
  003a8	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  003ab	ff d1		 call	 ecx

; 118  : 
; 119  : 		return;

  003ad	e9 97 00 00 00	 jmp	 $LN1@initialise
$LN7@initialise:

; 120  : 	}
; 121  : 
; 122  : 	//
; 123  : 	// Air-Air & Air-Surface
; 124  : 	//
; 125  : 
; 126  : 	if (get_local_entity_int_value (target, INT_TYPE_AIRBORNE_AIRCRAFT))

  003b2	83 7d f4 00	 cmp	 DWORD PTR _target$[ebp], 0
  003b6	74 0a		 je	 SHORT $LN35@initialise
  003b8	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  003bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  003bd	89 4d ac	 mov	 DWORD PTR tv251[ebp], ecx
  003c0	eb 1a		 jmp	 SHORT $LN36@initialise
$LN35@initialise:
  003c2	6a 7e		 push	 126			; 0000007eH
  003c4	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  003c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  003cf	52		 push	 edx
  003d0	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  003d5	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv251[ebp], 0
$LN36@initialise:
  003dc	b8 01 00 00 00	 mov	 eax, 1
  003e1	85 c0		 test	 eax, eax
  003e3	74 09		 je	 SHORT $LN37@initialise
  003e5	c7 45 a8 04 00
	00 00		 mov	 DWORD PTR tv258[ebp], 4
  003ec	eb 1a		 jmp	 SHORT $LN38@initialise
$LN37@initialise:
  003ee	6a 7e		 push	 126			; 0000007eH
  003f0	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@DDNHFILO@c?3?2users?2nhv90?2projects?2eech?2ap@
  003f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  003fb	51		 push	 ecx
  003fc	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00401	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv258[ebp], 0
$LN38@initialise:
  00408	6a 04		 push	 4
  0040a	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  0040d	52		 push	 edx
  0040e	69 45 ac 5c 04
	00 00		 imul	 eax, DWORD PTR tv251[ebp], 1116
  00415	8b 4d a8	 mov	 ecx, DWORD PTR tv258[ebp]
  00418	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[eax+ecx*4]
  0041f	ff d2		 call	 edx
  00421	85 c0		 test	 eax, eax
  00423	74 13		 je	 SHORT $LN8@initialise

; 127  : 	{
; 128  : 		initialise_air_to_air_attack_guide (en, aggressor, target);

  00425	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  00428	50		 push	 eax
  00429	8b 4d f8	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  0042c	51		 push	 ecx
  0042d	8b 55 08	 mov	 edx, DWORD PTR _en$[ebp]
  00430	52		 push	 edx
  00431	e8 00 00 00 00	 call	 ?initialise_air_to_air_attack_guide@@YGXPAUENTITY@@00@Z ; initialise_air_to_air_attack_guide

; 129  : 	}
; 130  : 	else

  00436	eb 11		 jmp	 SHORT $LN1@initialise
$LN8@initialise:

; 131  : 	{
; 132  : 		initialise_air_to_ground_attack_guide (en, aggressor, target);

  00438	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  0043b	50		 push	 eax
  0043c	8b 4d f8	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  0043f	51		 push	 ecx
  00440	8b 55 08	 mov	 edx, DWORD PTR _en$[ebp]
  00443	52		 push	 edx
  00444	e8 00 00 00 00	 call	 ?initialise_air_to_ground_attack_guide@@YGXPAUENTITY@@00@Z ; initialise_air_to_ground_attack_guide
$LN1@initialise:

; 133  : 	}
; 134  : }

  00449	5f		 pop	 edi
  0044a	5e		 pop	 esi
  0044b	5b		 pop	 ebx
  0044c	8b e5		 mov	 esp, ebp
  0044e	5d		 pop	 ebp
  0044f	c2 04 00	 ret	 4
?initialise_attack_guide@@YGXPAUENTITY@@@Z ENDP		; initialise_attack_guide
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?tan@@YGMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?tan@@YGMM@Z PROC					; tan, COMDAT

; 299  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 300  : 	return (_CSTD tanf(_Xx));

  00009	51		 push	 ecx
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
  0000f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00014	e8 00 00 00 00	 call	 _tanf
  00019	83 c4 04	 add	 esp, 4

; 301  : 	}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?tan@@YGMM@Z ENDP					; tan
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?cos@@YGMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?cos@@YGMM@Z PROC					; cos, COMDAT

; 77   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 78   : 	return (_CSTD cosf(_Xx));

  00009	51		 push	 ecx
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
  0000f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00014	e8 00 00 00 00	 call	 _cosf
  00019	83 c4 04	 add	 esp, 4

; 79   : 	}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?cos@@YGMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?atan@@YGMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?atan@@YGMM@Z PROC					; atan, COMDAT

; 46   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 47   : 	return (_CSTD atanf(_Xx));

  00009	51		 push	 ecx
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
  0000f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00014	e8 00 00 00 00	 call	 _atanf
  00019	83 c4 04	 add	 esp, 4

; 48   : 	}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?atan@@YGMM@Z ENDP					; atan
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _tanf
_TEXT	SEGMENT
tv71 = -68						; size = 4
__X$ = 8						; size = 4
_tanf	PROC						; COMDAT

; 764  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 765  :             return (float)tan(_X);

  00009	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0000e	83 ec 08	 sub	 esp, 8
  00011	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00016	e8 00 00 00 00	 call	 _tan
  0001b	83 c4 08	 add	 esp, 8
  0001e	d9 5d bc	 fstp	 DWORD PTR tv71[ebp]
  00021	d9 45 bc	 fld	 DWORD PTR tv71[ebp]

; 766  :         }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_tanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv71 = -68						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 648  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 649  :             return (float)cos(_X);

  00009	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0000e	83 ec 08	 sub	 esp, 8
  00011	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00016	e8 00 00 00 00	 call	 _cos
  0001b	83 c4 08	 add	 esp, 8
  0001e	d9 5d bc	 fstp	 DWORD PTR tv71[ebp]
  00021	d9 45 bc	 fld	 DWORD PTR tv71[ebp]

; 650  :         }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _atanf
_TEXT	SEGMENT
tv71 = -68						; size = 4
__X$ = 8						; size = 4
_atanf	PROC						; COMDAT

; 638  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 639  :             return (float)atan(_X);

  00009	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0000e	83 ec 08	 sub	 esp, 8
  00011	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00016	e8 00 00 00 00	 call	 _atan
  0001b	83 c4 08	 add	 esp, 8
  0001e	d9 5d bc	 fstp	 DWORD PTR tv71[ebp]
  00021	d9 45 bc	 fld	 DWORD PTR tv71[ebp]

; 640  :         }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_atanf	ENDP
_TEXT	ENDS
END
