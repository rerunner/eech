; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\graphics\lbm.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?load_lbm_image@@YGHPBDPAULBM_IMAGE@@@Z		; load_lbm_image
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0CN@OOPGGMBM@Unable?5to?5open?5file?5?$CFs?5during?5l@ ; `string'
PUBLIC	??_C@_0DB@MHMEBHCB@File?5not?5an?5IFF?5file?5in?5load_lb@ ; `string'
PUBLIC	??_C@_0ED@LIAJPLKD@No?5memory?5for?5source?5image?5data@ ; `string'
PUBLIC	??_C@_0CJ@NHMPEKCJ@No?5memory?5for?5lbm?5image?5while?5l@ ; `string'
PUBLIC	??_C@_0CJ@NKDAIBED@No?5memory?5for?5ilbm?5data?5while?5l@ ; `string'
PUBLIC	??_C@_0CP@LHNMPHH@No?5BODY?5data?5in?5load_lbm_image?0@ ; `string'
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fseek:PROC
EXTRN	_memcpy:PROC
EXTRN	?debug_log@@YAXPBDZZ:PROC			; debug_log
EXTRN	?safe_malloc_memory@@YGPAXI@Z:PROC		; safe_malloc_memory
EXTRN	?safe_free@@YGXPAX@Z:PROC			; safe_free
EXTRN	?safe_fopen@@YGPAU_iobuf@@PBD0@Z:PROC		; safe_fopen
EXTRN	?get_iff_type@@YG?AW4IFF_HEADER_TYPES@@PAU_iobuf@@@Z:PROC ; get_iff_type
EXTRN	?iff_int_read@@YGHPAU_iobuf@@@Z:PROC		; iff_int_read
EXTRN	?iff_short_int_read@@YGFPAU_iobuf@@@Z:PROC	; iff_short_int_read
_BSS	SEGMENT
?current_lbm@@3PAULBM_IMAGE@@A DD 01H DUP (?)		; current_lbm
_BSS	ENDS
;	COMDAT ??_C@_0CP@LHNMPHH@No?5BODY?5data?5in?5load_lbm_image?0@
CONST	SEGMENT
??_C@_0CP@LHNMPHH@No?5BODY?5data?5in?5load_lbm_image?0@ DB 'No BODY data '
	DB	'in load_lbm_image, during file %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NKDAIBED@No?5memory?5for?5ilbm?5data?5while?5l@
CONST	SEGMENT
??_C@_0CJ@NKDAIBED@No?5memory?5for?5ilbm?5data?5while?5l@ DB 'No memory f'
	DB	'or ilbm data while loading %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NHMPEKCJ@No?5memory?5for?5lbm?5image?5while?5l@
CONST	SEGMENT
??_C@_0CJ@NHMPEKCJ@No?5memory?5for?5lbm?5image?5while?5l@ DB 'No memory f'
	DB	'or lbm image while loading %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@LIAJPLKD@No?5memory?5for?5source?5image?5data@
CONST	SEGMENT
??_C@_0ED@LIAJPLKD@No?5memory?5for?5source?5image?5data@ DB 'No memory fo'
	DB	'r source image data while loading %s in load_lbm_image', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MHMEBHCB@File?5not?5an?5IFF?5file?5in?5load_lb@
CONST	SEGMENT
??_C@_0DB@MHMEBHCB@File?5not?5an?5IFF?5file?5in?5load_lb@ DB 'File not an'
	DB	' IFF file in load_lbm_image, file: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@OOPGGMBM@Unable?5to?5open?5file?5?$CFs?5during?5l@
CONST	SEGMENT
??_C@_0CN@OOPGGMBM@Unable?5to?5open?5file?5?$CFs?5during?5l@ DB 'Unable t'
	DB	'o open file %s during load_lbm_image', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\lbm.c
;	COMDAT ?ilbm_convert@@YGXPAE0@Z
_TEXT	SEGMENT
_plane7$ = -48						; size = 4
_plane6$ = -44						; size = 4
_plane5$ = -40						; size = 4
_plane4$ = -36						; size = 4
_plane3$ = -32						; size = 4
_plane2$ = -28						; size = 4
_plane1$ = -24						; size = 4
_plane0$ = -20						; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_rounded_width$ = -8					; size = 4
_byte_width$ = -4					; size = 4
_source$ = 8						; size = 4
_destination$ = 12					; size = 4
?ilbm_convert@@YGXPAE0@Z PROC				; ilbm_convert, COMDAT

; 343  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 344  : 	
; 345  : 	int
; 346  : 		byte_width;
; 347  : 
; 348  : 	int
; 349  : 		rounded_width;
; 350  : 
; 351  : 	int
; 352  : 		x,
; 353  : 		y;
; 354  : 		
; 355  : 	unsigned char
; 356  : 		*plane0,
; 357  : 		*plane1,
; 358  : 		*plane2,
; 359  : 		*plane3,
; 360  : 		*plane4,
; 361  : 		*plane5,
; 362  : 		*plane6,
; 363  : 		*plane7;
; 364  : 
; 365  : 	rounded_width = ( ( current_lbm->header.width ) + ( current_lbm->header.width % 8 ) );

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?current_lbm@@3PAULBM_IMAGE@@A
  0000e	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00012	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?current_lbm@@3PAULBM_IMAGE@@A
  00018	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  0001c	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00021	79 05		 jns	 SHORT $LN9@ilbm_conve
  00023	48		 dec	 eax
  00024	83 c8 f8	 or	 eax, -8			; fffffff8H
  00027	40		 inc	 eax
$LN9@ilbm_conve:
  00028	03 c8		 add	 ecx, eax
  0002a	89 4d f8	 mov	 DWORD PTR _rounded_width$[ebp], ecx

; 366  : 
; 367  : 	byte_width = rounded_width / 8;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _rounded_width$[ebp]
  00030	99		 cdq
  00031	83 e2 07	 and	 edx, 7
  00034	03 c2		 add	 eax, edx
  00036	c1 f8 03	 sar	 eax, 3
  00039	89 45 fc	 mov	 DWORD PTR _byte_width$[ebp], eax

; 368  : 
; 369  : 	for ( y = 0; y < current_lbm->header.height; y++ )

  0003c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00043	eb 09		 jmp	 SHORT $LN4@ilbm_conve
$LN2@ilbm_conve:
  00045	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00048	83 c0 01	 add	 eax, 1
  0004b	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
$LN4@ilbm_conve:
  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?current_lbm@@3PAULBM_IMAGE@@A
  00053	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00057	39 4d f0	 cmp	 DWORD PTR _y$[ebp], ecx
  0005a	0f 8d 8d 04 00
	00		 jge	 $LN1@ilbm_conve

; 370  : 	{
; 371  : 		
; 372  : 		plane0 = source + (rounded_width * y);

  00060	8b 45 f8	 mov	 eax, DWORD PTR _rounded_width$[ebp]
  00063	0f af 45 f0	 imul	 eax, DWORD PTR _y$[ebp]
  00067	03 45 08	 add	 eax, DWORD PTR _source$[ebp]
  0006a	89 45 ec	 mov	 DWORD PTR _plane0$[ebp], eax

; 373  : 		
; 374  : 		plane1 = plane0 + byte_width;

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _plane0$[ebp]
  00070	03 45 fc	 add	 eax, DWORD PTR _byte_width$[ebp]
  00073	89 45 e8	 mov	 DWORD PTR _plane1$[ebp], eax

; 375  : 
; 376  : 		plane2 = plane1 + byte_width;

  00076	8b 45 e8	 mov	 eax, DWORD PTR _plane1$[ebp]
  00079	03 45 fc	 add	 eax, DWORD PTR _byte_width$[ebp]
  0007c	89 45 e4	 mov	 DWORD PTR _plane2$[ebp], eax

; 377  : 
; 378  : 		plane3 = plane2 + byte_width;

  0007f	8b 45 e4	 mov	 eax, DWORD PTR _plane2$[ebp]
  00082	03 45 fc	 add	 eax, DWORD PTR _byte_width$[ebp]
  00085	89 45 e0	 mov	 DWORD PTR _plane3$[ebp], eax

; 379  : 
; 380  : 		plane4 = plane3 + byte_width;

  00088	8b 45 e0	 mov	 eax, DWORD PTR _plane3$[ebp]
  0008b	03 45 fc	 add	 eax, DWORD PTR _byte_width$[ebp]
  0008e	89 45 dc	 mov	 DWORD PTR _plane4$[ebp], eax

; 381  : 
; 382  : 		plane5 = plane4 + byte_width;

  00091	8b 45 dc	 mov	 eax, DWORD PTR _plane4$[ebp]
  00094	03 45 fc	 add	 eax, DWORD PTR _byte_width$[ebp]
  00097	89 45 d8	 mov	 DWORD PTR _plane5$[ebp], eax

; 383  : 
; 384  : 		plane6 = plane5 + byte_width;

  0009a	8b 45 d8	 mov	 eax, DWORD PTR _plane5$[ebp]
  0009d	03 45 fc	 add	 eax, DWORD PTR _byte_width$[ebp]
  000a0	89 45 d4	 mov	 DWORD PTR _plane6$[ebp], eax

; 385  : 
; 386  : 		plane7 = plane6 + byte_width;

  000a3	8b 45 d4	 mov	 eax, DWORD PTR _plane6$[ebp]
  000a6	03 45 fc	 add	 eax, DWORD PTR _byte_width$[ebp]
  000a9	89 45 d0	 mov	 DWORD PTR _plane7$[ebp], eax

; 387  : 
; 388  : 		for ( x=0; x < current_lbm->header.width; x+= 8 )

  000ac	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  000b3	eb 09		 jmp	 SHORT $LN7@ilbm_conve
$LN5@ilbm_conve:
  000b5	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  000b8	83 c0 08	 add	 eax, 8
  000bb	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax
$LN7@ilbm_conve:
  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?current_lbm@@3PAULBM_IMAGE@@A
  000c3	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  000c7	39 4d f4	 cmp	 DWORD PTR _x$[ebp], ecx
  000ca	0f 8d 18 04 00
	00		 jge	 $LN6@ilbm_conve

; 389  : 		{
; 390  : 			
; 391  : 			*destination++ = ( ( ( *plane7 & 0x80 ) ) |

  000d0	8b 45 d0	 mov	 eax, DWORD PTR _plane7$[ebp]
  000d3	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000d6	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  000dc	8b 55 d4	 mov	 edx, DWORD PTR _plane6$[ebp]
  000df	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000e2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000e7	d1 f8		 sar	 eax, 1
  000e9	0b c8		 or	 ecx, eax
  000eb	8b 55 d8	 mov	 edx, DWORD PTR _plane5$[ebp]
  000ee	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000f1	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000f6	c1 f8 02	 sar	 eax, 2
  000f9	0b c8		 or	 ecx, eax
  000fb	8b 55 dc	 mov	 edx, DWORD PTR _plane4$[ebp]
  000fe	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00101	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00106	c1 f8 03	 sar	 eax, 3
  00109	0b c8		 or	 ecx, eax
  0010b	8b 55 e0	 mov	 edx, DWORD PTR _plane3$[ebp]
  0010e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00111	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00116	c1 f8 04	 sar	 eax, 4
  00119	0b c8		 or	 ecx, eax
  0011b	8b 55 e4	 mov	 edx, DWORD PTR _plane2$[ebp]
  0011e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00121	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00126	c1 f8 05	 sar	 eax, 5
  00129	0b c8		 or	 ecx, eax
  0012b	8b 55 e8	 mov	 edx, DWORD PTR _plane1$[ebp]
  0012e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00131	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00136	c1 f8 06	 sar	 eax, 6
  00139	0b c8		 or	 ecx, eax
  0013b	8b 55 ec	 mov	 edx, DWORD PTR _plane0$[ebp]
  0013e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00141	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00146	c1 f8 07	 sar	 eax, 7
  00149	0b c8		 or	 ecx, eax
  0014b	8b 55 0c	 mov	 edx, DWORD PTR _destination$[ebp]
  0014e	88 0a		 mov	 BYTE PTR [edx], cl
  00150	8b 45 0c	 mov	 eax, DWORD PTR _destination$[ebp]
  00153	83 c0 01	 add	 eax, 1
  00156	89 45 0c	 mov	 DWORD PTR _destination$[ebp], eax

; 392  : 									 ( ( *plane6 & 0x80 ) >> 1 ) |
; 393  : 									 ( ( *plane5 & 0x80 ) >> 2 ) |
; 394  : 									 ( ( *plane4 & 0x80 ) >> 3 ) |
; 395  : 									 ( ( *plane3 & 0x80 ) >> 4 ) |
; 396  : 									 ( ( *plane2 & 0x80 ) >> 5 ) |
; 397  : 									 ( ( *plane1 & 0x80 ) >> 6 ) |
; 398  : 									 ( ( *plane0 & 0x80 ) >> 7 ) );
; 399  : 
; 400  : 			*destination++ = ( ( ( *plane7 & 0x40 ) << 1 ) |

  00159	8b 45 d0	 mov	 eax, DWORD PTR _plane7$[ebp]
  0015c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0015f	83 e1 40	 and	 ecx, 64			; 00000040H
  00162	d1 e1		 shl	 ecx, 1
  00164	8b 55 d4	 mov	 edx, DWORD PTR _plane6$[ebp]
  00167	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0016a	83 e0 40	 and	 eax, 64			; 00000040H
  0016d	0b c8		 or	 ecx, eax
  0016f	8b 55 d8	 mov	 edx, DWORD PTR _plane5$[ebp]
  00172	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00175	83 e0 40	 and	 eax, 64			; 00000040H
  00178	d1 f8		 sar	 eax, 1
  0017a	0b c8		 or	 ecx, eax
  0017c	8b 55 dc	 mov	 edx, DWORD PTR _plane4$[ebp]
  0017f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00182	83 e0 40	 and	 eax, 64			; 00000040H
  00185	c1 f8 02	 sar	 eax, 2
  00188	0b c8		 or	 ecx, eax
  0018a	8b 55 e0	 mov	 edx, DWORD PTR _plane3$[ebp]
  0018d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00190	83 e0 40	 and	 eax, 64			; 00000040H
  00193	c1 f8 03	 sar	 eax, 3
  00196	0b c8		 or	 ecx, eax
  00198	8b 55 e4	 mov	 edx, DWORD PTR _plane2$[ebp]
  0019b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0019e	83 e0 40	 and	 eax, 64			; 00000040H
  001a1	c1 f8 04	 sar	 eax, 4
  001a4	0b c8		 or	 ecx, eax
  001a6	8b 55 e8	 mov	 edx, DWORD PTR _plane1$[ebp]
  001a9	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001ac	83 e0 40	 and	 eax, 64			; 00000040H
  001af	c1 f8 05	 sar	 eax, 5
  001b2	0b c8		 or	 ecx, eax
  001b4	8b 55 ec	 mov	 edx, DWORD PTR _plane0$[ebp]
  001b7	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001ba	83 e0 40	 and	 eax, 64			; 00000040H
  001bd	c1 f8 06	 sar	 eax, 6
  001c0	0b c8		 or	 ecx, eax
  001c2	8b 55 0c	 mov	 edx, DWORD PTR _destination$[ebp]
  001c5	88 0a		 mov	 BYTE PTR [edx], cl
  001c7	8b 45 0c	 mov	 eax, DWORD PTR _destination$[ebp]
  001ca	83 c0 01	 add	 eax, 1
  001cd	89 45 0c	 mov	 DWORD PTR _destination$[ebp], eax

; 401  : 									 ( ( *plane6 & 0x40 ) ) |
; 402  : 									 ( ( *plane5 & 0x40 ) >> 1 ) |
; 403  : 									 ( ( *plane4 & 0x40 ) >> 2 ) |
; 404  : 									 ( ( *plane3 & 0x40 ) >> 3 ) |
; 405  : 									 ( ( *plane2 & 0x40 ) >> 4 ) |
; 406  : 									 ( ( *plane1 & 0x40 ) >> 5 ) |
; 407  : 									 ( ( *plane0 & 0x40 ) >> 6 ) );
; 408  : 
; 409  : 			*destination++ = ( ( ( *plane7 & 0x20 ) << 2 ) |

  001d0	8b 45 d0	 mov	 eax, DWORD PTR _plane7$[ebp]
  001d3	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001d6	83 e1 20	 and	 ecx, 32			; 00000020H
  001d9	c1 e1 02	 shl	 ecx, 2
  001dc	8b 55 d4	 mov	 edx, DWORD PTR _plane6$[ebp]
  001df	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001e2	83 e0 20	 and	 eax, 32			; 00000020H
  001e5	d1 e0		 shl	 eax, 1
  001e7	0b c8		 or	 ecx, eax
  001e9	8b 55 d8	 mov	 edx, DWORD PTR _plane5$[ebp]
  001ec	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001ef	83 e0 20	 and	 eax, 32			; 00000020H
  001f2	0b c8		 or	 ecx, eax
  001f4	8b 55 dc	 mov	 edx, DWORD PTR _plane4$[ebp]
  001f7	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001fa	83 e0 20	 and	 eax, 32			; 00000020H
  001fd	d1 f8		 sar	 eax, 1
  001ff	0b c8		 or	 ecx, eax
  00201	8b 55 e0	 mov	 edx, DWORD PTR _plane3$[ebp]
  00204	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00207	83 e0 20	 and	 eax, 32			; 00000020H
  0020a	c1 f8 02	 sar	 eax, 2
  0020d	0b c8		 or	 ecx, eax
  0020f	8b 55 e4	 mov	 edx, DWORD PTR _plane2$[ebp]
  00212	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00215	83 e0 20	 and	 eax, 32			; 00000020H
  00218	c1 f8 03	 sar	 eax, 3
  0021b	0b c8		 or	 ecx, eax
  0021d	8b 55 e8	 mov	 edx, DWORD PTR _plane1$[ebp]
  00220	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00223	83 e0 20	 and	 eax, 32			; 00000020H
  00226	c1 f8 04	 sar	 eax, 4
  00229	0b c8		 or	 ecx, eax
  0022b	8b 55 ec	 mov	 edx, DWORD PTR _plane0$[ebp]
  0022e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00231	83 e0 20	 and	 eax, 32			; 00000020H
  00234	c1 f8 05	 sar	 eax, 5
  00237	0b c8		 or	 ecx, eax
  00239	8b 55 0c	 mov	 edx, DWORD PTR _destination$[ebp]
  0023c	88 0a		 mov	 BYTE PTR [edx], cl
  0023e	8b 45 0c	 mov	 eax, DWORD PTR _destination$[ebp]
  00241	83 c0 01	 add	 eax, 1
  00244	89 45 0c	 mov	 DWORD PTR _destination$[ebp], eax

; 410  : 									 ( ( *plane6 & 0x20 ) << 1 ) |
; 411  : 									 ( ( *plane5 & 0x20 ) ) |
; 412  : 									 ( ( *plane4 & 0x20 ) >> 1 ) |
; 413  : 									 ( ( *plane3 & 0x20 ) >> 2 ) |
; 414  : 									 ( ( *plane2 & 0x20 ) >> 3 ) |
; 415  : 									 ( ( *plane1 & 0x20 ) >> 4 ) |
; 416  : 									 ( ( *plane0 & 0x20 ) >> 5 ) );
; 417  : 
; 418  : 			*destination++ = ( ( ( *plane7 & 0x10 ) << 3 ) |

  00247	8b 45 d0	 mov	 eax, DWORD PTR _plane7$[ebp]
  0024a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0024d	83 e1 10	 and	 ecx, 16			; 00000010H
  00250	c1 e1 03	 shl	 ecx, 3
  00253	8b 55 d4	 mov	 edx, DWORD PTR _plane6$[ebp]
  00256	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00259	83 e0 10	 and	 eax, 16			; 00000010H
  0025c	c1 e0 02	 shl	 eax, 2
  0025f	0b c8		 or	 ecx, eax
  00261	8b 55 d8	 mov	 edx, DWORD PTR _plane5$[ebp]
  00264	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00267	83 e0 10	 and	 eax, 16			; 00000010H
  0026a	d1 e0		 shl	 eax, 1
  0026c	0b c8		 or	 ecx, eax
  0026e	8b 55 dc	 mov	 edx, DWORD PTR _plane4$[ebp]
  00271	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00274	83 e0 10	 and	 eax, 16			; 00000010H
  00277	0b c8		 or	 ecx, eax
  00279	8b 55 e0	 mov	 edx, DWORD PTR _plane3$[ebp]
  0027c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0027f	83 e0 10	 and	 eax, 16			; 00000010H
  00282	d1 f8		 sar	 eax, 1
  00284	0b c8		 or	 ecx, eax
  00286	8b 55 e4	 mov	 edx, DWORD PTR _plane2$[ebp]
  00289	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0028c	83 e0 10	 and	 eax, 16			; 00000010H
  0028f	c1 f8 02	 sar	 eax, 2
  00292	0b c8		 or	 ecx, eax
  00294	8b 55 e8	 mov	 edx, DWORD PTR _plane1$[ebp]
  00297	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0029a	83 e0 10	 and	 eax, 16			; 00000010H
  0029d	c1 f8 03	 sar	 eax, 3
  002a0	0b c8		 or	 ecx, eax
  002a2	8b 55 ec	 mov	 edx, DWORD PTR _plane0$[ebp]
  002a5	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  002a8	83 e0 10	 and	 eax, 16			; 00000010H
  002ab	c1 f8 04	 sar	 eax, 4
  002ae	0b c8		 or	 ecx, eax
  002b0	8b 55 0c	 mov	 edx, DWORD PTR _destination$[ebp]
  002b3	88 0a		 mov	 BYTE PTR [edx], cl
  002b5	8b 45 0c	 mov	 eax, DWORD PTR _destination$[ebp]
  002b8	83 c0 01	 add	 eax, 1
  002bb	89 45 0c	 mov	 DWORD PTR _destination$[ebp], eax

; 419  : 									 ( ( *plane6 & 0x10 ) << 2 ) |
; 420  : 									 ( ( *plane5 & 0x10 ) << 1 ) |
; 421  : 									 ( ( *plane4 & 0x10 ) ) |
; 422  : 									 ( ( *plane3 & 0x10 ) >> 1 ) |
; 423  : 									 ( ( *plane2 & 0x10 ) >> 2 ) |
; 424  : 									 ( ( *plane1 & 0x10 ) >> 3 ) |
; 425  : 									 ( ( *plane0 & 0x10 ) >> 4 ) );
; 426  : 
; 427  : 			*destination++ = ( ( ( *plane7 & 0x08 ) << 4 ) |

  002be	8b 45 d0	 mov	 eax, DWORD PTR _plane7$[ebp]
  002c1	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002c4	83 e1 08	 and	 ecx, 8
  002c7	c1 e1 04	 shl	 ecx, 4
  002ca	8b 55 d4	 mov	 edx, DWORD PTR _plane6$[ebp]
  002cd	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  002d0	83 e0 08	 and	 eax, 8
  002d3	c1 e0 03	 shl	 eax, 3
  002d6	0b c8		 or	 ecx, eax
  002d8	8b 55 d8	 mov	 edx, DWORD PTR _plane5$[ebp]
  002db	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  002de	83 e0 08	 and	 eax, 8
  002e1	c1 e0 02	 shl	 eax, 2
  002e4	0b c8		 or	 ecx, eax
  002e6	8b 55 dc	 mov	 edx, DWORD PTR _plane4$[ebp]
  002e9	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  002ec	83 e0 08	 and	 eax, 8
  002ef	d1 e0		 shl	 eax, 1
  002f1	0b c8		 or	 ecx, eax
  002f3	8b 55 e0	 mov	 edx, DWORD PTR _plane3$[ebp]
  002f6	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  002f9	83 e0 08	 and	 eax, 8
  002fc	0b c8		 or	 ecx, eax
  002fe	8b 55 e4	 mov	 edx, DWORD PTR _plane2$[ebp]
  00301	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00304	83 e0 08	 and	 eax, 8
  00307	d1 f8		 sar	 eax, 1
  00309	0b c8		 or	 ecx, eax
  0030b	8b 55 e8	 mov	 edx, DWORD PTR _plane1$[ebp]
  0030e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00311	83 e0 08	 and	 eax, 8
  00314	c1 f8 02	 sar	 eax, 2
  00317	0b c8		 or	 ecx, eax
  00319	8b 55 ec	 mov	 edx, DWORD PTR _plane0$[ebp]
  0031c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0031f	83 e0 08	 and	 eax, 8
  00322	c1 f8 03	 sar	 eax, 3
  00325	0b c8		 or	 ecx, eax
  00327	8b 55 0c	 mov	 edx, DWORD PTR _destination$[ebp]
  0032a	88 0a		 mov	 BYTE PTR [edx], cl
  0032c	8b 45 0c	 mov	 eax, DWORD PTR _destination$[ebp]
  0032f	83 c0 01	 add	 eax, 1
  00332	89 45 0c	 mov	 DWORD PTR _destination$[ebp], eax

; 428  : 									 ( ( *plane6 & 0x08 ) << 3 ) |
; 429  : 									 ( ( *plane5 & 0x08 ) << 2 ) |
; 430  : 									 ( ( *plane4 & 0x08 ) << 1 ) |
; 431  : 									 ( ( *plane3 & 0x08 ) ) |
; 432  : 									 ( ( *plane2 & 0x08 ) >> 1 ) |
; 433  : 									 ( ( *plane1 & 0x08 ) >> 2 ) |
; 434  : 									 ( ( *plane0 & 0x08 ) >> 3 ) );
; 435  : 
; 436  : 			*destination++ = ( ( ( *plane7 & 0x04 ) << 5 ) |

  00335	8b 45 d0	 mov	 eax, DWORD PTR _plane7$[ebp]
  00338	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0033b	83 e1 04	 and	 ecx, 4
  0033e	c1 e1 05	 shl	 ecx, 5
  00341	8b 55 d4	 mov	 edx, DWORD PTR _plane6$[ebp]
  00344	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00347	83 e0 04	 and	 eax, 4
  0034a	c1 e0 04	 shl	 eax, 4
  0034d	0b c8		 or	 ecx, eax
  0034f	8b 55 d8	 mov	 edx, DWORD PTR _plane5$[ebp]
  00352	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00355	83 e0 04	 and	 eax, 4
  00358	c1 e0 03	 shl	 eax, 3
  0035b	0b c8		 or	 ecx, eax
  0035d	8b 55 dc	 mov	 edx, DWORD PTR _plane4$[ebp]
  00360	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00363	83 e0 04	 and	 eax, 4
  00366	c1 e0 02	 shl	 eax, 2
  00369	0b c8		 or	 ecx, eax
  0036b	8b 55 e0	 mov	 edx, DWORD PTR _plane3$[ebp]
  0036e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00371	83 e0 04	 and	 eax, 4
  00374	d1 e0		 shl	 eax, 1
  00376	0b c8		 or	 ecx, eax
  00378	8b 55 e4	 mov	 edx, DWORD PTR _plane2$[ebp]
  0037b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0037e	83 e0 04	 and	 eax, 4
  00381	0b c8		 or	 ecx, eax
  00383	8b 55 e8	 mov	 edx, DWORD PTR _plane1$[ebp]
  00386	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00389	83 e0 04	 and	 eax, 4
  0038c	d1 f8		 sar	 eax, 1
  0038e	0b c8		 or	 ecx, eax
  00390	8b 55 ec	 mov	 edx, DWORD PTR _plane0$[ebp]
  00393	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00396	83 e0 04	 and	 eax, 4
  00399	c1 f8 02	 sar	 eax, 2
  0039c	0b c8		 or	 ecx, eax
  0039e	8b 55 0c	 mov	 edx, DWORD PTR _destination$[ebp]
  003a1	88 0a		 mov	 BYTE PTR [edx], cl
  003a3	8b 45 0c	 mov	 eax, DWORD PTR _destination$[ebp]
  003a6	83 c0 01	 add	 eax, 1
  003a9	89 45 0c	 mov	 DWORD PTR _destination$[ebp], eax

; 437  : 									 ( ( *plane6 & 0x04 ) << 4 ) |
; 438  : 									 ( ( *plane5 & 0x04 ) << 3 ) |
; 439  : 									 ( ( *plane4 & 0x04 ) << 2 ) |
; 440  : 									 ( ( *plane3 & 0x04 ) << 1 ) |
; 441  : 									 ( ( *plane2 & 0x04 ) ) |
; 442  : 									 ( ( *plane1 & 0x04 ) >> 1 ) |
; 443  : 									 ( ( *plane0 & 0x04 ) >> 2 ) );
; 444  : 
; 445  : 			*destination++ = ( ( ( *plane7 & 0x02 ) << 6 ) |

  003ac	8b 45 d0	 mov	 eax, DWORD PTR _plane7$[ebp]
  003af	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  003b2	83 e1 02	 and	 ecx, 2
  003b5	c1 e1 06	 shl	 ecx, 6
  003b8	8b 55 d4	 mov	 edx, DWORD PTR _plane6$[ebp]
  003bb	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  003be	83 e0 02	 and	 eax, 2
  003c1	c1 e0 05	 shl	 eax, 5
  003c4	0b c8		 or	 ecx, eax
  003c6	8b 55 d8	 mov	 edx, DWORD PTR _plane5$[ebp]
  003c9	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  003cc	83 e0 02	 and	 eax, 2
  003cf	c1 e0 04	 shl	 eax, 4
  003d2	0b c8		 or	 ecx, eax
  003d4	8b 55 dc	 mov	 edx, DWORD PTR _plane4$[ebp]
  003d7	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  003da	83 e0 02	 and	 eax, 2
  003dd	c1 e0 03	 shl	 eax, 3
  003e0	0b c8		 or	 ecx, eax
  003e2	8b 55 e0	 mov	 edx, DWORD PTR _plane3$[ebp]
  003e5	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  003e8	83 e0 02	 and	 eax, 2
  003eb	c1 e0 02	 shl	 eax, 2
  003ee	0b c8		 or	 ecx, eax
  003f0	8b 55 e4	 mov	 edx, DWORD PTR _plane2$[ebp]
  003f3	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  003f6	83 e0 02	 and	 eax, 2
  003f9	d1 e0		 shl	 eax, 1
  003fb	0b c8		 or	 ecx, eax
  003fd	8b 55 e8	 mov	 edx, DWORD PTR _plane1$[ebp]
  00400	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00403	83 e0 02	 and	 eax, 2
  00406	0b c8		 or	 ecx, eax
  00408	8b 55 ec	 mov	 edx, DWORD PTR _plane0$[ebp]
  0040b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0040e	83 e0 02	 and	 eax, 2
  00411	d1 f8		 sar	 eax, 1
  00413	0b c8		 or	 ecx, eax
  00415	8b 55 0c	 mov	 edx, DWORD PTR _destination$[ebp]
  00418	88 0a		 mov	 BYTE PTR [edx], cl
  0041a	8b 45 0c	 mov	 eax, DWORD PTR _destination$[ebp]
  0041d	83 c0 01	 add	 eax, 1
  00420	89 45 0c	 mov	 DWORD PTR _destination$[ebp], eax

; 446  : 									 ( ( *plane6 & 0x02 ) << 5 ) |
; 447  : 									 ( ( *plane5 & 0x02 ) << 4 ) |
; 448  : 									 ( ( *plane4 & 0x02 ) << 3 ) |
; 449  : 									 ( ( *plane3 & 0x02 ) << 2 ) |
; 450  : 									 ( ( *plane2 & 0x02 ) << 1 ) |
; 451  : 									 ( ( *plane1 & 0x02 ) ) |
; 452  : 									 ( ( *plane0 & 0x02 ) >> 1 ) );
; 453  : 
; 454  : 			*destination++ = ( ( ( *plane7 & 0x01 ) << 7) |

  00423	8b 45 d0	 mov	 eax, DWORD PTR _plane7$[ebp]
  00426	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00429	83 e1 01	 and	 ecx, 1
  0042c	c1 e1 07	 shl	 ecx, 7
  0042f	8b 55 d4	 mov	 edx, DWORD PTR _plane6$[ebp]
  00432	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00435	83 e0 01	 and	 eax, 1
  00438	c1 e0 06	 shl	 eax, 6
  0043b	0b c8		 or	 ecx, eax
  0043d	8b 55 d8	 mov	 edx, DWORD PTR _plane5$[ebp]
  00440	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00443	83 e0 01	 and	 eax, 1
  00446	c1 e0 05	 shl	 eax, 5
  00449	0b c8		 or	 ecx, eax
  0044b	8b 55 dc	 mov	 edx, DWORD PTR _plane4$[ebp]
  0044e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00451	83 e0 01	 and	 eax, 1
  00454	c1 e0 04	 shl	 eax, 4
  00457	0b c8		 or	 ecx, eax
  00459	8b 55 e0	 mov	 edx, DWORD PTR _plane3$[ebp]
  0045c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0045f	83 e0 01	 and	 eax, 1
  00462	c1 e0 03	 shl	 eax, 3
  00465	0b c8		 or	 ecx, eax
  00467	8b 55 e4	 mov	 edx, DWORD PTR _plane2$[ebp]
  0046a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0046d	83 e0 01	 and	 eax, 1
  00470	c1 e0 02	 shl	 eax, 2
  00473	0b c8		 or	 ecx, eax
  00475	8b 55 e8	 mov	 edx, DWORD PTR _plane1$[ebp]
  00478	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0047b	83 e0 01	 and	 eax, 1
  0047e	d1 e0		 shl	 eax, 1
  00480	0b c8		 or	 ecx, eax
  00482	8b 55 ec	 mov	 edx, DWORD PTR _plane0$[ebp]
  00485	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00488	83 e0 01	 and	 eax, 1
  0048b	0b c8		 or	 ecx, eax
  0048d	8b 55 0c	 mov	 edx, DWORD PTR _destination$[ebp]
  00490	88 0a		 mov	 BYTE PTR [edx], cl
  00492	8b 45 0c	 mov	 eax, DWORD PTR _destination$[ebp]
  00495	83 c0 01	 add	 eax, 1
  00498	89 45 0c	 mov	 DWORD PTR _destination$[ebp], eax

; 455  : 									 ( ( *plane6 & 0x01 ) << 6) |
; 456  : 									 ( ( *plane5 & 0x01 ) << 5) |
; 457  : 									 ( ( *plane4 & 0x01 ) << 4) |
; 458  : 									 ( ( *plane3 & 0x01 ) << 3) |
; 459  : 									 ( ( *plane2 & 0x01 ) << 2) |
; 460  : 									 ( ( *plane1 & 0x01 ) << 1) |
; 461  : 									 ( ( *plane0 & 0x01 )));
; 462  : 
; 463  : 			plane0 ++;

  0049b	8b 45 ec	 mov	 eax, DWORD PTR _plane0$[ebp]
  0049e	83 c0 01	 add	 eax, 1
  004a1	89 45 ec	 mov	 DWORD PTR _plane0$[ebp], eax

; 464  : 			plane1 ++;

  004a4	8b 45 e8	 mov	 eax, DWORD PTR _plane1$[ebp]
  004a7	83 c0 01	 add	 eax, 1
  004aa	89 45 e8	 mov	 DWORD PTR _plane1$[ebp], eax

; 465  : 			plane2 ++;

  004ad	8b 45 e4	 mov	 eax, DWORD PTR _plane2$[ebp]
  004b0	83 c0 01	 add	 eax, 1
  004b3	89 45 e4	 mov	 DWORD PTR _plane2$[ebp], eax

; 466  : 			plane3 ++;

  004b6	8b 45 e0	 mov	 eax, DWORD PTR _plane3$[ebp]
  004b9	83 c0 01	 add	 eax, 1
  004bc	89 45 e0	 mov	 DWORD PTR _plane3$[ebp], eax

; 467  : 			plane4 ++;

  004bf	8b 45 dc	 mov	 eax, DWORD PTR _plane4$[ebp]
  004c2	83 c0 01	 add	 eax, 1
  004c5	89 45 dc	 mov	 DWORD PTR _plane4$[ebp], eax

; 468  : 			plane5 ++;

  004c8	8b 45 d8	 mov	 eax, DWORD PTR _plane5$[ebp]
  004cb	83 c0 01	 add	 eax, 1
  004ce	89 45 d8	 mov	 DWORD PTR _plane5$[ebp], eax

; 469  : 			plane6 ++;

  004d1	8b 45 d4	 mov	 eax, DWORD PTR _plane6$[ebp]
  004d4	83 c0 01	 add	 eax, 1
  004d7	89 45 d4	 mov	 DWORD PTR _plane6$[ebp], eax

; 470  : 			plane7 ++;

  004da	8b 45 d0	 mov	 eax, DWORD PTR _plane7$[ebp]
  004dd	83 c0 01	 add	 eax, 1
  004e0	89 45 d0	 mov	 DWORD PTR _plane7$[ebp], eax

; 471  : 		}

  004e3	e9 cd fb ff ff	 jmp	 $LN5@ilbm_conve
$LN6@ilbm_conve:

; 472  : 	}

  004e8	e9 58 fb ff ff	 jmp	 $LN2@ilbm_conve
$LN1@ilbm_conve:

; 473  : }

  004ed	5f		 pop	 edi
  004ee	5e		 pop	 esi
  004ef	5b		 pop	 ebx
  004f0	8b e5		 mov	 esp, ebp
  004f2	5d		 pop	 ebp
  004f3	c2 08 00	 ret	 8
?ilbm_convert@@YGXPAE0@Z ENDP				; ilbm_convert
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\lbm.c
;	COMDAT ?pixelise@@YGXPAE0H@Z
_TEXT	SEGMENT
_c$ = -2						; size = 1
_v$ = -1						; size = 1
_pix$ = 8						; size = 4
_p$ = 12						; size = 4
_length$ = 16						; size = 4
?pixelise@@YGXPAE0H@Z PROC				; pixelise, COMDAT

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@pixelise:

; 481  : 
; 482  : 	unsigned char
; 483  : 		v,
; 484  : 		c;
; 485  : 
; 486  : 	while ( length > 0 )

  00009	83 7d 10 00	 cmp	 DWORD PTR _length$[ebp], 0
  0000d	0f 8e b2 00 00
	00		 jle	 $LN1@pixelise

; 487  : 	{
; 488  : 		
; 489  : 		c = *p ++;

  00013	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00016	8a 08		 mov	 cl, BYTE PTR [eax]
  00018	88 4d fe	 mov	 BYTE PTR _c$[ebp], cl
  0001b	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  0001e	83 c2 01	 add	 edx, 1
  00021	89 55 0c	 mov	 DWORD PTR _p$[ebp], edx

; 490  : 		
; 491  : 		length --;

  00024	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  00027	83 e8 01	 sub	 eax, 1
  0002a	89 45 10	 mov	 DWORD PTR _length$[ebp], eax

; 492  : 		
; 493  : 		if ( c >= 128 )

  0002d	0f b6 45 fe	 movzx	 eax, BYTE PTR _c$[ebp]
  00031	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00036	7c 49		 jl	 SHORT $LN8@pixelise

; 494  : 		{
; 495  : 
; 496  : 			c --;

  00038	8a 45 fe	 mov	 al, BYTE PTR _c$[ebp]
  0003b	2c 01		 sub	 al, 1
  0003d	88 45 fe	 mov	 BYTE PTR _c$[ebp], al

; 497  : 
; 498  : 			v = *p;

  00040	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00043	8a 08		 mov	 cl, BYTE PTR [eax]
  00045	88 4d ff	 mov	 BYTE PTR _v$[ebp], cl
$LN4@pixelise:

; 499  : 
; 500  : 			while ( c )

  00048	0f b6 45 fe	 movzx	 eax, BYTE PTR _c$[ebp]
  0004c	85 c0		 test	 eax, eax
  0004e	74 1d		 je	 SHORT $LN5@pixelise

; 501  : 			{
; 502  : 
; 503  : 				c ++;

  00050	8a 45 fe	 mov	 al, BYTE PTR _c$[ebp]
  00053	04 01		 add	 al, 1
  00055	88 45 fe	 mov	 BYTE PTR _c$[ebp], al

; 504  : 
; 505  : 				*pix ++ = *p;

  00058	8b 45 08	 mov	 eax, DWORD PTR _pix$[ebp]
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  0005e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00060	88 10		 mov	 BYTE PTR [eax], dl
  00062	8b 45 08	 mov	 eax, DWORD PTR _pix$[ebp]
  00065	83 c0 01	 add	 eax, 1
  00068	89 45 08	 mov	 DWORD PTR _pix$[ebp], eax

; 506  : 			}

  0006b	eb db		 jmp	 SHORT $LN4@pixelise
$LN5@pixelise:

; 507  : 
; 508  : 			p ++;

  0006d	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00070	83 c0 01	 add	 eax, 1
  00073	89 45 0c	 mov	 DWORD PTR _p$[ebp], eax

; 509  : 
; 510  : 			length --;

  00076	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  00079	83 e8 01	 sub	 eax, 1
  0007c	89 45 10	 mov	 DWORD PTR _length$[ebp], eax

; 511  : 		}
; 512  : 		else

  0007f	eb 3f		 jmp	 SHORT $LN9@pixelise
$LN8@pixelise:

; 513  : 		{	
; 514  : 
; 515  : 			c ++;

  00081	8a 45 fe	 mov	 al, BYTE PTR _c$[ebp]
  00084	04 01		 add	 al, 1
  00086	88 45 fe	 mov	 BYTE PTR _c$[ebp], al
$LN6@pixelise:

; 516  : 			
; 517  : 			while ( c )

  00089	0f b6 45 fe	 movzx	 eax, BYTE PTR _c$[ebp]
  0008d	85 c0		 test	 eax, eax
  0008f	74 2f		 je	 SHORT $LN9@pixelise

; 518  : 			{
; 519  : 
; 520  : 				c --;

  00091	8a 45 fe	 mov	 al, BYTE PTR _c$[ebp]
  00094	2c 01		 sub	 al, 1
  00096	88 45 fe	 mov	 BYTE PTR _c$[ebp], al

; 521  : 
; 522  : 				*pix ++ = *p ++;

  00099	8b 45 08	 mov	 eax, DWORD PTR _pix$[ebp]
  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  0009f	8a 11		 mov	 dl, BYTE PTR [ecx]
  000a1	88 10		 mov	 BYTE PTR [eax], dl
  000a3	8b 45 08	 mov	 eax, DWORD PTR _pix$[ebp]
  000a6	83 c0 01	 add	 eax, 1
  000a9	89 45 08	 mov	 DWORD PTR _pix$[ebp], eax
  000ac	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  000af	83 c1 01	 add	 ecx, 1
  000b2	89 4d 0c	 mov	 DWORD PTR _p$[ebp], ecx

; 523  : 
; 524  : 				length --;

  000b5	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  000b8	83 e8 01	 sub	 eax, 1
  000bb	89 45 10	 mov	 DWORD PTR _length$[ebp], eax

; 525  : 			}

  000be	eb c9		 jmp	 SHORT $LN6@pixelise
$LN9@pixelise:

; 526  : 		}
; 527  : 	}

  000c0	e9 44 ff ff ff	 jmp	 $LN2@pixelise
$LN1@pixelise:

; 528  : }

  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 0c 00	 ret	 12			; 0000000cH
?pixelise@@YGXPAE0H@Z ENDP				; pixelise
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\lbm.c
;	COMDAT ?load_lbm_image@@YGHPBDPAULBM_IMAGE@@@Z
_TEXT	SEGMENT
tv242 = -120						; size = 4
tv82 = -120						; size = 4
_body$ = -52						; size = 4
_ilbm_data$ = -48					; size = 4
_picture_type$ = -44					; size = 4
_block_length$ = -40					; size = 4
_i$ = -36						; size = 4
_colours$ = -32						; size = 4
_cmap_length$ = -28					; size = 4
_body_length$ = -24					; size = 4
_header_length$ = -20					; size = 4
_rounded_width$ = -16					; size = 4
_form_length$ = -12					; size = 4
_type$ = -8						; size = 4
_fp_in$ = -4						; size = 4
_filename$ = 8						; size = 4
_lbm$ = 12						; size = 4
?load_lbm_image@@YGHPBDPAULBM_IMAGE@@@Z PROC		; load_lbm_image, COMDAT

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 104  : 	
; 105  : 	FILE
; 106  : 		*fp_in;
; 107  : 		
; 108  : 	int
; 109  : 		type,
; 110  : 		form_length,
; 111  : 		rounded_width,
; 112  : 		header_length = 0,

  00009	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _header_length$[ebp], 0

; 113  : 		body_length = 0,

  00010	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _body_length$[ebp], 0

; 114  : 		cmap_length = 0,

  00017	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _cmap_length$[ebp], 0

; 115  : 		colours = 0,

  0001e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _colours$[ebp], 0

; 116  : 		i = 0,

  00025	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 117  : 		block_length = 0,

  0002c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _block_length$[ebp], 0

; 118  : 		picture_type = NO_TYPE;

  00033	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _picture_type$[ebp], 0

; 119  : 
; 120  : 	unsigned char
; 121  : 		*ilbm_data = NULL,

  0003a	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _ilbm_data$[ebp], 0

; 122  : 		*body = NULL;

  00041	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _body$[ebp], 0

; 123  : 
; 124  : 	// JB 030311 Enable running out of separate directories
; 125  : 	if ( ( fp_in = safe_fopen ( filename, "rb" ) ) == NULL )

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  0004d	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?safe_fopen@@YGPAU_iobuf@@PBD0@Z ; safe_fopen
  00056	89 45 fc	 mov	 DWORD PTR _fp_in$[ebp], eax
  00059	83 7d fc 00	 cmp	 DWORD PTR _fp_in$[ebp], 0
  0005d	75 18		 jne	 SHORT $LN9@load_lbm_i

; 126  : 	{
; 127  : 
; 128  : 		debug_log ( "Unable to open file %s during load_lbm_image", filename );

  0005f	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00062	50		 push	 eax
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@OOPGGMBM@Unable?5to?5open?5file?5?$CFs?5during?5l@
  00068	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0006d	83 c4 08	 add	 esp, 8

; 129  : 
; 130  : 		return (FALSE);

  00070	33 c0		 xor	 eax, eax
  00072	e9 90 04 00 00	 jmp	 $LN1@load_lbm_i
$LN9@load_lbm_i:

; 131  : 	}
; 132  : 
; 133  : 	if ( ( get_iff_type ( fp_in ) ) != FORM)

  00077	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ?get_iff_type@@YG?AW4IFF_HEADER_TYPES@@PAU_iobuf@@@Z ; get_iff_type
  00080	83 f8 01	 cmp	 eax, 1
  00083	74 25		 je	 SHORT $LN10@load_lbm_i

; 134  : 	{
; 135  : 
; 136  : 		fclose ( fp_in );

  00085	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  00088	50		 push	 eax
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0008f	83 c4 04	 add	 esp, 4

; 137  : 
; 138  : 		debug_log ( "File not an IFF file in load_lbm_image, file: %s", filename );

  00092	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00095	50		 push	 eax
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@MHMEBHCB@File?5not?5an?5IFF?5file?5in?5load_lb@
  0009b	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  000a0	83 c4 08	 add	 esp, 8

; 139  : 		
; 140  : 		return ( FALSE );

  000a3	33 c0		 xor	 eax, eax
  000a5	e9 5d 04 00 00	 jmp	 $LN1@load_lbm_i
$LN10@load_lbm_i:

; 141  : 	}
; 142  : 
; 143  : 	form_length = iff_int_read (fp_in);

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  000b3	89 45 f4	 mov	 DWORD PTR _form_length$[ebp], eax

; 144  : 
; 145  : 	current_lbm = lbm;

  000b6	8b 45 0c	 mov	 eax, DWORD PTR _lbm$[ebp]
  000b9	a3 00 00 00 00	 mov	 DWORD PTR ?current_lbm@@3PAULBM_IMAGE@@A, eax
$LN2@load_lbm_i:

; 146  : 
; 147  : 	while ( ( form_length >0 ) && ( ( type = get_iff_type ( fp_in ) ) != BODY ) )

  000be	83 7d f4 00	 cmp	 DWORD PTR _form_length$[ebp], 0
  000c2	0f 8e 4d 02 00
	00		 jle	 $LN3@load_lbm_i
  000c8	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?get_iff_type@@YG?AW4IFF_HEADER_TYPES@@PAU_iobuf@@@Z ; get_iff_type
  000d1	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax
  000d4	83 7d f8 17	 cmp	 DWORD PTR _type$[ebp], 23 ; 00000017H
  000d8	0f 84 37 02 00
	00		 je	 $LN3@load_lbm_i

; 148  : 	{
; 149  : 		
; 150  : 		switch ( type )

  000de	8b 45 f8	 mov	 eax, DWORD PTR _type$[ebp]
  000e1	89 45 88	 mov	 DWORD PTR tv82[ebp], eax
  000e4	8b 4d 88	 mov	 ecx, DWORD PTR tv82[ebp]
  000e7	83 e9 13	 sub	 ecx, 19			; 00000013H
  000ea	89 4d 88	 mov	 DWORD PTR tv82[ebp], ecx
  000ed	83 7d 88 03	 cmp	 DWORD PTR tv82[ebp], 3
  000f1	0f 87 db 01 00
	00		 ja	 $LN15@load_lbm_i
  000f7	8b 55 88	 mov	 edx, DWORD PTR tv82[ebp]
  000fa	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN30@load_lbm_i[edx*4]
$LN11@load_lbm_i:

; 151  : 		{
; 152  : 			
; 153  : 			case	ILBM:
; 154  : 			{
; 155  : 				
; 156  : 				picture_type = PIC_ILBM;

  00101	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _picture_type$[ebp], 1

; 157  : 				
; 158  : 				break;

  00108	e9 03 02 00 00	 jmp	 $LN4@load_lbm_i
$LN12@load_lbm_i:

; 159  : 			}
; 160  : 
; 161  : 			case	PBM:
; 162  : 			{
; 163  : 				
; 164  : 				picture_type = PIC_PBM;

  0010d	c7 45 d4 02 00
	00 00		 mov	 DWORD PTR _picture_type$[ebp], 2

; 165  : 				
; 166  : 				break;

  00114	e9 f7 01 00 00	 jmp	 $LN4@load_lbm_i
$LN13@load_lbm_i:

; 167  : 			}
; 168  : 
; 169  : 			case	BMHD:
; 170  : 			{
; 171  : 				
; 172  : 				header_length = iff_int_read ( fp_in );

  00119	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  00122	89 45 ec	 mov	 DWORD PTR _header_length$[ebp], eax

; 173  : 				
; 174  : 				lbm->header.width = iff_short_int_read (fp_in);

  00125	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  0012e	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  00131	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 175  : 			
; 176  : 				lbm->header.height = iff_short_int_read (fp_in);

  00135	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  0013e	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  00141	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 177  : 			
; 178  : 				lbm->header.x = iff_short_int_read (fp_in);

  00145	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  0014e	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  00151	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 179  : 			
; 180  : 				lbm->header.y = iff_short_int_read (fp_in);

  00155	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  0015e	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  00161	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 181  : 			
; 182  : 				fread (&lbm->header.nPlanes, 1, 1, fp_in);

  00165	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  00168	50		 push	 eax
  00169	6a 01		 push	 1
  0016b	6a 01		 push	 1
  0016d	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  00170	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00173	51		 push	 ecx
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0017a	83 c4 10	 add	 esp, 16			; 00000010H

; 183  : 			
; 184  : 				fread (&lbm->header.masking, 1, 1, fp_in);

  0017d	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  00180	50		 push	 eax
  00181	6a 01		 push	 1
  00183	6a 01		 push	 1
  00185	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  00188	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0018b	51		 push	 ecx
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00192	83 c4 10	 add	 esp, 16			; 00000010H

; 185  : 			
; 186  : 				fread (&lbm->header.compression, 1, 1, fp_in);

  00195	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  00198	50		 push	 eax
  00199	6a 01		 push	 1
  0019b	6a 01		 push	 1
  0019d	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  001a0	83 c1 0e	 add	 ecx, 14			; 0000000eH
  001a3	51		 push	 ecx
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  001aa	83 c4 10	 add	 esp, 16			; 00000010H

; 187  : 			
; 188  : 				fread (&lbm->header.reserved1, 1, 1, fp_in);

  001ad	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  001b0	50		 push	 eax
  001b1	6a 01		 push	 1
  001b3	6a 01		 push	 1
  001b5	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  001b8	83 c1 0f	 add	 ecx, 15			; 0000000fH
  001bb	51		 push	 ecx
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  001c2	83 c4 10	 add	 esp, 16			; 00000010H

; 189  : 			
; 190  : 				lbm->header.transparentColour = iff_short_int_read (fp_in);

  001c5	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  001ce	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  001d1	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 191  : 			
; 192  : 				fread (&lbm->header.xAspect, 1, 1, fp_in);

  001d5	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  001d8	50		 push	 eax
  001d9	6a 01		 push	 1
  001db	6a 01		 push	 1
  001dd	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  001e0	83 c1 12	 add	 ecx, 18			; 00000012H
  001e3	51		 push	 ecx
  001e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  001ea	83 c4 10	 add	 esp, 16			; 00000010H

; 193  : 			
; 194  : 				fread (&lbm->header.yAspect, 1, 1, fp_in);

  001ed	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  001f0	50		 push	 eax
  001f1	6a 01		 push	 1
  001f3	6a 01		 push	 1
  001f5	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  001f8	83 c1 13	 add	 ecx, 19			; 00000013H
  001fb	51		 push	 ecx
  001fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00202	83 c4 10	 add	 esp, 16			; 00000010H

; 195  : 			
; 196  : 				lbm->header.pageWidth = iff_short_int_read (fp_in);

  00205	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  00208	50		 push	 eax
  00209	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  0020e	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  00211	66 89 41 14	 mov	 WORD PTR [ecx+20], ax

; 197  : 			
; 198  : 				lbm->header.pageHeight = iff_short_int_read (fp_in);

  00215	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  0021e	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  00221	66 89 41 16	 mov	 WORD PTR [ecx+22], ax

; 199  : 
; 200  : 				form_length -= ( header_length + 4 );

  00225	8b 45 ec	 mov	 eax, DWORD PTR _header_length$[ebp]
  00228	83 c0 04	 add	 eax, 4
  0022b	8b 4d f4	 mov	 ecx, DWORD PTR _form_length$[ebp]
  0022e	2b c8		 sub	 ecx, eax
  00230	89 4d f4	 mov	 DWORD PTR _form_length$[ebp], ecx

; 201  : 				
; 202  : 				break;

  00233	e9 d8 00 00 00	 jmp	 $LN4@load_lbm_i
$LN14@load_lbm_i:

; 203  : 			}
; 204  : 
; 205  : 			case	CMAP:
; 206  : 			{
; 207  : 				
; 208  : 				cmap_length = iff_int_read ( fp_in );

  00238	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  00241	89 45 e4	 mov	 DWORD PTR _cmap_length$[ebp], eax

; 209  : 				
; 210  : 				form_length -= ( cmap_length + 4 );

  00244	8b 45 e4	 mov	 eax, DWORD PTR _cmap_length$[ebp]
  00247	83 c0 04	 add	 eax, 4
  0024a	8b 4d f4	 mov	 ecx, DWORD PTR _form_length$[ebp]
  0024d	2b c8		 sub	 ecx, eax
  0024f	89 4d f4	 mov	 DWORD PTR _form_length$[ebp], ecx

; 211  : 
; 212  : 				colours = ( cmap_length / 3 );

  00252	8b 45 e4	 mov	 eax, DWORD PTR _cmap_length$[ebp]
  00255	99		 cdq
  00256	b9 03 00 00 00	 mov	 ecx, 3
  0025b	f7 f9		 idiv	 ecx
  0025d	89 45 e0	 mov	 DWORD PTR _colours$[ebp], eax

; 213  : 				
; 214  : 				for ( i = 0; i < colours; i++ )

  00260	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00267	eb 09		 jmp	 SHORT $LN8@load_lbm_i
$LN6@load_lbm_i:
  00269	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  0026c	83 c0 01	 add	 eax, 1
  0026f	89 45 dc	 mov	 DWORD PTR _i$[ebp], eax
$LN8@load_lbm_i:
  00272	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  00275	3b 45 e0	 cmp	 eax, DWORD PTR _colours$[ebp]
  00278	7d 56		 jge	 SHORT $LN7@load_lbm_i

; 215  : 				{
; 216  : 
; 217  : 					fread ( &lbm->palette[i].peRed, 1, 1, fp_in );

  0027a	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  0027d	50		 push	 eax
  0027e	6a 01		 push	 1
  00280	6a 01		 push	 1
  00282	8b 4d dc	 mov	 ecx, DWORD PTR _i$[ebp]
  00285	8b 55 0c	 mov	 edx, DWORD PTR _lbm$[ebp]
  00288	8d 44 8a 18	 lea	 eax, DWORD PTR [edx+ecx*4+24]
  0028c	50		 push	 eax
  0028d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00293	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 					fread ( &lbm->palette[i].peGreen, 1, 1, fp_in );

  00296	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  00299	50		 push	 eax
  0029a	6a 01		 push	 1
  0029c	6a 01		 push	 1
  0029e	8b 4d dc	 mov	 ecx, DWORD PTR _i$[ebp]
  002a1	8b 55 0c	 mov	 edx, DWORD PTR _lbm$[ebp]
  002a4	8d 44 8a 19	 lea	 eax, DWORD PTR [edx+ecx*4+25]
  002a8	50		 push	 eax
  002a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  002af	83 c4 10	 add	 esp, 16			; 00000010H

; 219  : 					fread ( &lbm->palette[i].peBlue, 1, 1, fp_in );

  002b2	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  002b5	50		 push	 eax
  002b6	6a 01		 push	 1
  002b8	6a 01		 push	 1
  002ba	8b 4d dc	 mov	 ecx, DWORD PTR _i$[ebp]
  002bd	8b 55 0c	 mov	 edx, DWORD PTR _lbm$[ebp]
  002c0	8d 44 8a 1a	 lea	 eax, DWORD PTR [edx+ecx*4+26]
  002c4	50		 push	 eax
  002c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  002cb	83 c4 10	 add	 esp, 16			; 00000010H

; 220  : 				}

  002ce	eb 99		 jmp	 SHORT $LN6@load_lbm_i
$LN7@load_lbm_i:

; 221  : 				
; 222  : 				break;

  002d0	eb 3e		 jmp	 SHORT $LN4@load_lbm_i
$LN15@load_lbm_i:

; 223  : 			}
; 224  : 
; 225  : 			default:
; 226  : 			{
; 227  : 				
; 228  : 				block_length = iff_int_read ( fp_in );

  002d2	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  002d5	50		 push	 eax
  002d6	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  002db	89 45 d8	 mov	 DWORD PTR _block_length$[ebp], eax

; 229  : 				
; 230  : 				if ( ( block_length & 1 ) == 1 )

  002de	8b 45 d8	 mov	 eax, DWORD PTR _block_length$[ebp]
  002e1	83 e0 01	 and	 eax, 1
  002e4	74 09		 je	 SHORT $LN16@load_lbm_i

; 231  : 				{
; 232  : 
; 233  : 					block_length++;

  002e6	8b 45 d8	 mov	 eax, DWORD PTR _block_length$[ebp]
  002e9	83 c0 01	 add	 eax, 1
  002ec	89 45 d8	 mov	 DWORD PTR _block_length$[ebp], eax
$LN16@load_lbm_i:

; 234  : 				}
; 235  : 				
; 236  : 				fseek ( fp_in, block_length, SEEK_CUR );

  002ef	6a 01		 push	 1
  002f1	8b 45 d8	 mov	 eax, DWORD PTR _block_length$[ebp]
  002f4	50		 push	 eax
  002f5	8b 4d fc	 mov	 ecx, DWORD PTR _fp_in$[ebp]
  002f8	51		 push	 ecx
  002f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  002ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 237  : 				
; 238  : 				form_length -= ( block_length + 4 );

  00302	8b 45 d8	 mov	 eax, DWORD PTR _block_length$[ebp]
  00305	83 c0 04	 add	 eax, 4
  00308	8b 4d f4	 mov	 ecx, DWORD PTR _form_length$[ebp]
  0030b	2b c8		 sub	 ecx, eax
  0030d	89 4d f4	 mov	 DWORD PTR _form_length$[ebp], ecx
$LN4@load_lbm_i:

; 239  : 				
; 240  : 				break;
; 241  : 			}
; 242  : 		}
; 243  : 	}

  00310	e9 a9 fd ff ff	 jmp	 $LN2@load_lbm_i
$LN3@load_lbm_i:

; 244  : 
; 245  : 	if ( type == BODY )

  00315	83 7d f8 17	 cmp	 DWORD PTR _type$[ebp], 23 ; 00000017H
  00319	0f 85 b4 01 00
	00		 jne	 $LN17@load_lbm_i

; 246  : 	{
; 247  : 		
; 248  : 		body_length = iff_int_read ( fp_in );

  0031f	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  00322	50		 push	 eax
  00323	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  00328	89 45 e8	 mov	 DWORD PTR _body_length$[ebp], eax

; 249  : 		
; 250  : 		form_length -= ( body_length + 4 );

  0032b	8b 45 e8	 mov	 eax, DWORD PTR _body_length$[ebp]
  0032e	83 c0 04	 add	 eax, 4
  00331	8b 4d f4	 mov	 ecx, DWORD PTR _form_length$[ebp]
  00334	2b c8		 sub	 ecx, eax
  00336	89 4d f4	 mov	 DWORD PTR _form_length$[ebp], ecx

; 251  : 
; 252  : 		if ( ( body = ( unsigned char * ) safe_malloc ( body_length ) ) == NULL )

  00339	8b 45 e8	 mov	 eax, DWORD PTR _body_length$[ebp]
  0033c	50		 push	 eax
  0033d	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00342	89 45 cc	 mov	 DWORD PTR _body$[ebp], eax
  00345	83 7d cc 00	 cmp	 DWORD PTR _body$[ebp], 0
  00349	75 25		 jne	 SHORT $LN19@load_lbm_i

; 253  : 		{
; 254  : 			
; 255  : 			debug_log ( "No memory for source image data while loading %s in load_lbm_image", filename );

  0034b	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0034e	50		 push	 eax
  0034f	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@LIAJPLKD@No?5memory?5for?5source?5image?5data@
  00354	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00359	83 c4 08	 add	 esp, 8

; 256  : 
; 257  : 			fclose ( fp_in );

  0035c	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  0035f	50		 push	 eax
  00360	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00366	83 c4 04	 add	 esp, 4

; 258  : 
; 259  : 			return ( FALSE );

  00369	33 c0		 xor	 eax, eax
  0036b	e9 97 01 00 00	 jmp	 $LN1@load_lbm_i
$LN19@load_lbm_i:

; 260  : 		}
; 261  : 
; 262  : 		fread ( body, body_length, 1, fp_in );

  00370	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  00373	50		 push	 eax
  00374	6a 01		 push	 1
  00376	8b 4d e8	 mov	 ecx, DWORD PTR _body_length$[ebp]
  00379	51		 push	 ecx
  0037a	8b 55 cc	 mov	 edx, DWORD PTR _body$[ebp]
  0037d	52		 push	 edx
  0037e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00384	83 c4 10	 add	 esp, 16			; 00000010H

; 263  : 
; 264  : 		if ( ( lbm->image = ( unsigned char * ) safe_malloc ( lbm->header.width * lbm->header.height ) ) == NULL )

  00387	8b 45 0c	 mov	 eax, DWORD PTR _lbm$[ebp]
  0038a	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  0038e	8b 55 0c	 mov	 edx, DWORD PTR _lbm$[ebp]
  00391	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  00395	0f af c8	 imul	 ecx, eax
  00398	51		 push	 ecx
  00399	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  0039e	89 45 88	 mov	 DWORD PTR tv242[ebp], eax
  003a1	8b 4d 0c	 mov	 ecx, DWORD PTR _lbm$[ebp]
  003a4	8b 55 88	 mov	 edx, DWORD PTR tv242[ebp]
  003a7	89 11		 mov	 DWORD PTR [ecx], edx
  003a9	83 7d 88 00	 cmp	 DWORD PTR tv242[ebp], 0
  003ad	75 25		 jne	 SHORT $LN20@load_lbm_i

; 265  : 		{
; 266  : 
; 267  : 			debug_log ("No memory for lbm image while loading %s", filename );

  003af	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  003b2	50		 push	 eax
  003b3	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@NHMPEKCJ@No?5memory?5for?5lbm?5image?5while?5l@
  003b8	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  003bd	83 c4 08	 add	 esp, 8

; 268  : 
; 269  : 			fclose ( fp_in );

  003c0	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  003c3	50		 push	 eax
  003c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  003ca	83 c4 04	 add	 esp, 4

; 270  : 
; 271  : 			return ( FALSE );

  003cd	33 c0		 xor	 eax, eax
  003cf	e9 33 01 00 00	 jmp	 $LN1@load_lbm_i
$LN20@load_lbm_i:

; 272  : 		}
; 273  : 
; 274  : 		if ( picture_type == PIC_ILBM )

  003d4	83 7d d4 01	 cmp	 DWORD PTR _picture_type$[ebp], 1
  003d8	0f 85 ad 00 00
	00		 jne	 $LN21@load_lbm_i

; 275  : 		{
; 276  : 
; 277  : 			rounded_width = ( lbm->header.width + ( lbm->header.width % 8 ) );

  003de	8b 45 0c	 mov	 eax, DWORD PTR _lbm$[ebp]
  003e1	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  003e5	8b 55 0c	 mov	 edx, DWORD PTR _lbm$[ebp]
  003e8	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  003ec	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  003f1	79 05		 jns	 SHORT $LN29@load_lbm_i
  003f3	48		 dec	 eax
  003f4	83 c8 f8	 or	 eax, -8			; fffffff8H
  003f7	40		 inc	 eax
$LN29@load_lbm_i:
  003f8	03 c8		 add	 ecx, eax
  003fa	89 4d f0	 mov	 DWORD PTR _rounded_width$[ebp], ecx

; 278  : 
; 279  : 			if ( ( ilbm_data = ( unsigned char * ) safe_malloc ( rounded_width * ( lbm->header.height + 16 ) ) ) == NULL )

  003fd	8b 45 0c	 mov	 eax, DWORD PTR _lbm$[ebp]
  00400	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00404	83 c1 10	 add	 ecx, 16			; 00000010H
  00407	0f af 4d f0	 imul	 ecx, DWORD PTR _rounded_width$[ebp]
  0040b	51		 push	 ecx
  0040c	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00411	89 45 d0	 mov	 DWORD PTR _ilbm_data$[ebp], eax
  00414	83 7d d0 00	 cmp	 DWORD PTR _ilbm_data$[ebp], 0
  00418	75 25		 jne	 SHORT $LN23@load_lbm_i

; 280  : 			{
; 281  : 
; 282  : 				debug_log ("No memory for ilbm data while loading %s", filename );

  0041a	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0041d	50		 push	 eax
  0041e	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@NKDAIBED@No?5memory?5for?5ilbm?5data?5while?5l@
  00423	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00428	83 c4 08	 add	 esp, 8

; 283  : 
; 284  : 				fclose ( fp_in );

  0042b	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  0042e	50		 push	 eax
  0042f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00435	83 c4 04	 add	 esp, 4

; 285  : 
; 286  : 				return ( FALSE );

  00438	33 c0		 xor	 eax, eax
  0043a	e9 c8 00 00 00	 jmp	 $LN1@load_lbm_i
$LN23@load_lbm_i:

; 287  : 			}
; 288  : 
; 289  : 			if ( lbm->header.compression )

  0043f	8b 45 0c	 mov	 eax, DWORD PTR _lbm$[ebp]
  00442	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  00446	85 c9		 test	 ecx, ecx
  00448	74 13		 je	 SHORT $LN24@load_lbm_i

; 290  : 			{
; 291  : 
; 292  : 				pixelise ( ilbm_data, body, body_length );

  0044a	8b 45 e8	 mov	 eax, DWORD PTR _body_length$[ebp]
  0044d	50		 push	 eax
  0044e	8b 4d cc	 mov	 ecx, DWORD PTR _body$[ebp]
  00451	51		 push	 ecx
  00452	8b 55 d0	 mov	 edx, DWORD PTR _ilbm_data$[ebp]
  00455	52		 push	 edx
  00456	e8 00 00 00 00	 call	 ?pixelise@@YGXPAE0H@Z	; pixelise

; 293  : 			}
; 294  : 			else

  0045b	eb 14		 jmp	 SHORT $LN25@load_lbm_i
$LN24@load_lbm_i:

; 295  : 			{
; 296  : 
; 297  : 				memcpy ( ilbm_data, body, body_length );

  0045d	8b 45 e8	 mov	 eax, DWORD PTR _body_length$[ebp]
  00460	50		 push	 eax
  00461	8b 4d cc	 mov	 ecx, DWORD PTR _body$[ebp]
  00464	51		 push	 ecx
  00465	8b 55 d0	 mov	 edx, DWORD PTR _ilbm_data$[ebp]
  00468	52		 push	 edx
  00469	e8 00 00 00 00	 call	 _memcpy
  0046e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@load_lbm_i:

; 298  : 			}
; 299  : 
; 300  : 			ilbm_convert ( ilbm_data, lbm->image );

  00471	8b 45 0c	 mov	 eax, DWORD PTR _lbm$[ebp]
  00474	8b 08		 mov	 ecx, DWORD PTR [eax]
  00476	51		 push	 ecx
  00477	8b 55 d0	 mov	 edx, DWORD PTR _ilbm_data$[ebp]
  0047a	52		 push	 edx
  0047b	e8 00 00 00 00	 call	 ?ilbm_convert@@YGXPAE0@Z ; ilbm_convert

; 301  : 
; 302  : 			safe_free ( ilbm_data );

  00480	8b 45 d0	 mov	 eax, DWORD PTR _ilbm_data$[ebp]
  00483	50		 push	 eax
  00484	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 303  : 		}
; 304  : 		else

  00489	eb 36		 jmp	 SHORT $LN22@load_lbm_i
$LN21@load_lbm_i:

; 305  : 		{
; 306  : 			
; 307  : 			if ( lbm->header.compression )

  0048b	8b 45 0c	 mov	 eax, DWORD PTR _lbm$[ebp]
  0048e	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  00492	85 c9		 test	 ecx, ecx
  00494	74 15		 je	 SHORT $LN26@load_lbm_i

; 308  : 			{
; 309  : 
; 310  : 				pixelise ( lbm->image, body, body_length );

  00496	8b 45 e8	 mov	 eax, DWORD PTR _body_length$[ebp]
  00499	50		 push	 eax
  0049a	8b 4d cc	 mov	 ecx, DWORD PTR _body$[ebp]
  0049d	51		 push	 ecx
  0049e	8b 55 0c	 mov	 edx, DWORD PTR _lbm$[ebp]
  004a1	8b 02		 mov	 eax, DWORD PTR [edx]
  004a3	50		 push	 eax
  004a4	e8 00 00 00 00	 call	 ?pixelise@@YGXPAE0H@Z	; pixelise

; 311  : 			}
; 312  : 			else

  004a9	eb 16		 jmp	 SHORT $LN22@load_lbm_i
$LN26@load_lbm_i:

; 313  : 			{
; 314  : 
; 315  : 				memcpy ( lbm->image, body, body_length );

  004ab	8b 45 e8	 mov	 eax, DWORD PTR _body_length$[ebp]
  004ae	50		 push	 eax
  004af	8b 4d cc	 mov	 ecx, DWORD PTR _body$[ebp]
  004b2	51		 push	 ecx
  004b3	8b 55 0c	 mov	 edx, DWORD PTR _lbm$[ebp]
  004b6	8b 02		 mov	 eax, DWORD PTR [edx]
  004b8	50		 push	 eax
  004b9	e8 00 00 00 00	 call	 _memcpy
  004be	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@load_lbm_i:

; 316  : 			}
; 317  : 		}
; 318  : 
; 319  : 		safe_free ( body );

  004c1	8b 45 cc	 mov	 eax, DWORD PTR _body$[ebp]
  004c4	50		 push	 eax
  004c5	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 320  : 
; 321  : 		body = NULL;

  004ca	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _body$[ebp], 0

; 322  : 	}
; 323  : 	else

  004d1	eb 22		 jmp	 SHORT $LN18@load_lbm_i
$LN17@load_lbm_i:

; 324  : 	{
; 325  : 
; 326  : 		debug_log ( "No BODY data in load_lbm_image, during file %s", filename );

  004d3	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  004d6	50		 push	 eax
  004d7	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@LHNMPHH@No?5BODY?5data?5in?5load_lbm_image?0@
  004dc	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  004e1	83 c4 08	 add	 esp, 8

; 327  : 
; 328  : 		fclose ( fp_in );

  004e4	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  004e7	50		 push	 eax
  004e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  004ee	83 c4 04	 add	 esp, 4

; 329  : 	
; 330  : 		return ( FALSE );

  004f1	33 c0		 xor	 eax, eax
  004f3	eb 12		 jmp	 SHORT $LN1@load_lbm_i
$LN18@load_lbm_i:

; 331  : 	}
; 332  : 
; 333  : 	fclose ( fp_in );

  004f5	8b 45 fc	 mov	 eax, DWORD PTR _fp_in$[ebp]
  004f8	50		 push	 eax
  004f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  004ff	83 c4 04	 add	 esp, 4

; 334  : 
; 335  : 	return ( TRUE );

  00502	b8 01 00 00 00	 mov	 eax, 1
$LN1@load_lbm_i:

; 336  : }

  00507	5f		 pop	 edi
  00508	5e		 pop	 esi
  00509	5b		 pop	 ebx
  0050a	8b e5		 mov	 esp, ebp
  0050c	5d		 pop	 ebp
  0050d	c2 08 00	 ret	 8
$LN30@load_lbm_i:
  00510	00 00 00 00	 DD	 $LN11@load_lbm_i
  00514	00 00 00 00	 DD	 $LN12@load_lbm_i
  00518	00 00 00 00	 DD	 $LN13@load_lbm_i
  0051c	00 00 00 00	 DD	 $LN14@load_lbm_i
?load_lbm_image@@YGHPBDPAULBM_IMAGE@@@Z ENDP		; load_lbm_image
_TEXT	ENDS
END
