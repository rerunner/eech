; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\misc\iff.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?iff_headers@@3PAUIFF_HEADER@@A			; iff_headers
PUBLIC	??_C@_04HPGCGPG@FORM@				; `string'
PUBLIC	??_C@_04ELINGNML@LWOB@				; `string'
PUBLIC	??_C@_04IACGGANM@PNTS@				; `string'
PUBLIC	??_C@_04MCOLIFDF@SRFS@				; `string'
PUBLIC	??_C@_04CKKPPFHB@POLS@				; `string'
PUBLIC	??_C@_04HDKGFADE@SURF@				; `string'
PUBLIC	??_C@_04BEPECJGC@COLR@				; `string'
PUBLIC	??_C@_04PBMMHMLL@FLAG@				; `string'
PUBLIC	??_C@_04KAIGPICN@DIFF@				; `string'
PUBLIC	??_C@_04DALCLIGF@SMAN@				; `string'
PUBLIC	??_C@_04IMIJMLGO@TFLG@				; `string'
PUBLIC	??_C@_04BCOJMCDE@TSIZ@				; `string'
PUBLIC	??_C@_04NFCILBAP@TIMG@				; `string'
PUBLIC	??_C@_04JONHCPIA@TCTR@				; `string'
PUBLIC	??_C@_04HHBHPBHI@TWRP@				; `string'
PUBLIC	??_C@_04PJMLHOEL@TFP0@				; `string'
PUBLIC	??_C@_04OANAEPAK@TFP1@				; `string'
PUBLIC	??_C@_04GGNCCKPJ@CTEX@				; `string'
PUBLIC	??_C@_04ILDFLNLJ@ILBM@				; `string'
PUBLIC	??_C@_04NNBFGNKO@PBM?5@				; `string'
PUBLIC	??_C@_04JIAMNFFC@BMHD@				; `string'
PUBLIC	??_C@_04IEBDBADI@CMAP@				; `string'
PUBLIC	??_C@_04MEHDIIKB@BODY@				; `string'
PUBLIC	??_C@_04EDJAKDCP@VDIF@				; `string'
PUBLIC	??_C@_04IKOICDLM@TRAN@				; `string'
PUBLIC	??_C@_04EFDIABGI@TREF@				; `string'
PUBLIC	??_C@_04DHCILHNB@TAAS@				; `string'
PUBLIC	??_C@_04BPEKIOF@LUMI@				; `string'
PUBLIC	??_C@_04MIBKEOMG@IMSQ@				; `string'
PUBLIC	??_C@_04PPBPMNDN@REFL@				; `string'
PUBLIC	??_C@_04EFGDDALE@EDGE@				; `string'
PUBLIC	??_C@_04NEPCPGOJ@DTEX@				; `string'
PUBLIC	??_C@_04GDCLNHL@STEX@				; `string'
PUBLIC	??_C@_04DLFCJEML@RTEX@				; `string'
PUBLIC	??_C@_04LEBCGBGL@TTEX@				; `string'
PUBLIC	??_C@_04OEICLNCI@LTEX@				; `string'
PUBLIC	??_C@_04FLLCADEJ@BTEX@				; `string'
PUBLIC	??_C@_04OANOKALD@VSPC@				; `string'
PUBLIC	??_C@_01LOCGONAA@?$AA@				; `string'
;	COMDAT ??_C@_01LOCGONAA@?$AA@
CONST	SEGMENT
??_C@_01LOCGONAA@?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OANOKALD@VSPC@
CONST	SEGMENT
??_C@_04OANOKALD@VSPC@ DB 'VSPC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FLLCADEJ@BTEX@
CONST	SEGMENT
??_C@_04FLLCADEJ@BTEX@ DB 'BTEX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OEICLNCI@LTEX@
CONST	SEGMENT
??_C@_04OEICLNCI@LTEX@ DB 'LTEX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LEBCGBGL@TTEX@
CONST	SEGMENT
??_C@_04LEBCGBGL@TTEX@ DB 'TTEX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DLFCJEML@RTEX@
CONST	SEGMENT
??_C@_04DLFCJEML@RTEX@ DB 'RTEX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GDCLNHL@STEX@
CONST	SEGMENT
??_C@_04GDCLNHL@STEX@ DB 'STEX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEPCPGOJ@DTEX@
CONST	SEGMENT
??_C@_04NEPCPGOJ@DTEX@ DB 'DTEX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EFGDDALE@EDGE@
CONST	SEGMENT
??_C@_04EFGDDALE@EDGE@ DB 'EDGE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PPBPMNDN@REFL@
CONST	SEGMENT
??_C@_04PPBPMNDN@REFL@ DB 'REFL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MIBKEOMG@IMSQ@
CONST	SEGMENT
??_C@_04MIBKEOMG@IMSQ@ DB 'IMSQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BPEKIOF@LUMI@
CONST	SEGMENT
??_C@_04BPEKIOF@LUMI@ DB 'LUMI', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DHCILHNB@TAAS@
CONST	SEGMENT
??_C@_04DHCILHNB@TAAS@ DB 'TAAS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EFDIABGI@TREF@
CONST	SEGMENT
??_C@_04EFDIABGI@TREF@ DB 'TREF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IKOICDLM@TRAN@
CONST	SEGMENT
??_C@_04IKOICDLM@TRAN@ DB 'TRAN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDJAKDCP@VDIF@
CONST	SEGMENT
??_C@_04EDJAKDCP@VDIF@ DB 'VDIF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEHDIIKB@BODY@
CONST	SEGMENT
??_C@_04MEHDIIKB@BODY@ DB 'BODY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IEBDBADI@CMAP@
CONST	SEGMENT
??_C@_04IEBDBADI@CMAP@ DB 'CMAP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JIAMNFFC@BMHD@
CONST	SEGMENT
??_C@_04JIAMNFFC@BMHD@ DB 'BMHD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NNBFGNKO@PBM?5@
CONST	SEGMENT
??_C@_04NNBFGNKO@PBM?5@ DB 'PBM ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ILDFLNLJ@ILBM@
CONST	SEGMENT
??_C@_04ILDFLNLJ@ILBM@ DB 'ILBM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GGNCCKPJ@CTEX@
CONST	SEGMENT
??_C@_04GGNCCKPJ@CTEX@ DB 'CTEX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OANAEPAK@TFP1@
CONST	SEGMENT
??_C@_04OANAEPAK@TFP1@ DB 'TFP1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJMLHOEL@TFP0@
CONST	SEGMENT
??_C@_04PJMLHOEL@TFP0@ DB 'TFP0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HHBHPBHI@TWRP@
CONST	SEGMENT
??_C@_04HHBHPBHI@TWRP@ DB 'TWRP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JONHCPIA@TCTR@
CONST	SEGMENT
??_C@_04JONHCPIA@TCTR@ DB 'TCTR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NFCILBAP@TIMG@
CONST	SEGMENT
??_C@_04NFCILBAP@TIMG@ DB 'TIMG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BCOJMCDE@TSIZ@
CONST	SEGMENT
??_C@_04BCOJMCDE@TSIZ@ DB 'TSIZ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IMIJMLGO@TFLG@
CONST	SEGMENT
??_C@_04IMIJMLGO@TFLG@ DB 'TFLG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DALCLIGF@SMAN@
CONST	SEGMENT
??_C@_04DALCLIGF@SMAN@ DB 'SMAN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KAIGPICN@DIFF@
CONST	SEGMENT
??_C@_04KAIGPICN@DIFF@ DB 'DIFF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PBMMHMLL@FLAG@
CONST	SEGMENT
??_C@_04PBMMHMLL@FLAG@ DB 'FLAG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BEPECJGC@COLR@
CONST	SEGMENT
??_C@_04BEPECJGC@COLR@ DB 'COLR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDKGFADE@SURF@
CONST	SEGMENT
??_C@_04HDKGFADE@SURF@ DB 'SURF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CKKPPFHB@POLS@
CONST	SEGMENT
??_C@_04CKKPPFHB@POLS@ DB 'POLS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MCOLIFDF@SRFS@
CONST	SEGMENT
??_C@_04MCOLIFDF@SRFS@ DB 'SRFS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IACGGANM@PNTS@
CONST	SEGMENT
??_C@_04IACGGANM@PNTS@ DB 'PNTS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ELINGNML@LWOB@
CONST	SEGMENT
??_C@_04ELINGNML@LWOB@ DB 'LWOB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPGCGPG@FORM@
CONST	SEGMENT
??_C@_04HPGCGPG@FORM@ DB 'FORM', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?iff_headers@@3PAUIFF_HEADER@@A DD FLAT:??_C@_04HPGCGPG@FORM@ ; iff_headers
	DD	01H
	DD	FLAT:??_C@_04ELINGNML@LWOB@
	DD	02H
	DD	FLAT:??_C@_04IACGGANM@PNTS@
	DD	03H
	DD	FLAT:??_C@_04MCOLIFDF@SRFS@
	DD	04H
	DD	FLAT:??_C@_04CKKPPFHB@POLS@
	DD	05H
	DD	FLAT:??_C@_04HDKGFADE@SURF@
	DD	06H
	DD	FLAT:??_C@_04BEPECJGC@COLR@
	DD	07H
	DD	FLAT:??_C@_04PBMMHMLL@FLAG@
	DD	0aH
	DD	FLAT:??_C@_04KAIGPICN@DIFF@
	DD	08H
	DD	FLAT:??_C@_04DALCLIGF@SMAN@
	DD	09H
	DD	FLAT:??_C@_04IMIJMLGO@TFLG@
	DD	0bH
	DD	FLAT:??_C@_04BCOJMCDE@TSIZ@
	DD	0cH
	DD	FLAT:??_C@_04NFCILBAP@TIMG@
	DD	0dH
	DD	FLAT:??_C@_04JONHCPIA@TCTR@
	DD	0eH
	DD	FLAT:??_C@_04HHBHPBHI@TWRP@
	DD	0fH
	DD	FLAT:??_C@_04PJMLHOEL@TFP0@
	DD	010H
	DD	FLAT:??_C@_04OANAEPAK@TFP1@
	DD	011H
	DD	FLAT:??_C@_04GGNCCKPJ@CTEX@
	DD	012H
	DD	FLAT:??_C@_04ILDFLNLJ@ILBM@
	DD	013H
	DD	FLAT:??_C@_04NNBFGNKO@PBM?5@
	DD	014H
	DD	FLAT:??_C@_04JIAMNFFC@BMHD@
	DD	015H
	DD	FLAT:??_C@_04IEBDBADI@CMAP@
	DD	016H
	DD	FLAT:??_C@_04MEHDIIKB@BODY@
	DD	017H
	DD	FLAT:??_C@_04EDJAKDCP@VDIF@
	DD	018H
	DD	FLAT:??_C@_04IKOICDLM@TRAN@
	DD	019H
	DD	FLAT:??_C@_04EFDIABGI@TREF@
	DD	01aH
	DD	FLAT:??_C@_04DHCILHNB@TAAS@
	DD	01bH
	DD	FLAT:??_C@_04BPEKIOF@LUMI@
	DD	01cH
	DD	FLAT:??_C@_04MIBKEOMG@IMSQ@
	DD	01dH
	DD	FLAT:??_C@_04PPBPMNDN@REFL@
	DD	01eH
	DD	FLAT:??_C@_04EFGDDALE@EDGE@
	DD	01fH
	DD	FLAT:??_C@_04NEPCPGOJ@DTEX@
	DD	020H
	DD	FLAT:??_C@_04GDCLNHL@STEX@
	DD	021H
	DD	FLAT:??_C@_04DLFCJEML@RTEX@
	DD	022H
	DD	FLAT:??_C@_04LEBCGBGL@TTEX@
	DD	023H
	DD	FLAT:??_C@_04OEICLNCI@LTEX@
	DD	024H
	DD	FLAT:??_C@_04FLLCADEJ@BTEX@
	DD	025H
	DD	FLAT:??_C@_04OANOKALD@VSPC@
	DD	026H
	DD	FLAT:??_C@_01LOCGONAA@?$AA@
	DD	00H
_DATA	ENDS
PUBLIC	?get_iff_type@@YG?AW4IFF_HEADER_TYPES@@PAU_iobuf@@@Z ; get_iff_type
PUBLIC	?get_iff_type_from_string@@YG?AW4IFF_HEADER_TYPES@@PAD@Z ; get_iff_type_from_string
PUBLIC	?put_iff_type@@YGXPAU_iobuf@@W4IFF_HEADER_TYPES@@@Z ; put_iff_type
PUBLIC	?iff_float_read@@YGMPAU_iobuf@@@Z		; iff_float_read
PUBLIC	?iff_int_read@@YGHPAU_iobuf@@@Z			; iff_int_read
PUBLIC	?iff_short_int_read@@YGFPAU_iobuf@@@Z		; iff_short_int_read
PUBLIC	?iff_float_write@@YGXMPAU_iobuf@@@Z		; iff_float_write
PUBLIC	?iff_int_write@@YGXHPAU_iobuf@@@Z		; iff_int_write
PUBLIC	?iff_short_int_write@@YGXFPAU_iobuf@@@Z		; iff_short_int_write
PUBLIC	?__LINE__Var@?0??put_iff_type@@YGXPAU_iobuf@@W4IFF_HEADER_TYPES@@@Z@4JA ; `put_iff_type'::`1'::__LINE__Var
PUBLIC	??_C@_0DA@IGJIFDJN@c?3?2users?2nhv90?2projects?2eech?2mo@ ; `string'
PUBLIC	??_C@_02GDNLOIIJ@fp@				; `string'
EXTRN	__imp__fread:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	_strcmp:PROC
EXTRN	?process_assert@@YGXPBD0H@Z:PROC		; process_assert
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_02GDNLOIIJ@fp@
CONST	SEGMENT
??_C@_02GDNLOIIJ@fp@ DB 'fp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@IGJIFDJN@c?3?2users?2nhv90?2projects?2eech?2mo@
CONST	SEGMENT
??_C@_0DA@IGJIFDJN@c?3?2users?2nhv90?2projects?2eech?2mo@ DB 'c:\users\nh'
	DB	'v90\projects\eech\modules\misc\iff.c', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??put_iff_type@@YGXPAU_iobuf@@W4IFF_HEADER_TYPES@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??put_iff_type@@YGXPAU_iobuf@@W4IFF_HEADER_TYPES@@@Z@4JA DD 0beH ; `put_iff_type'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\misc\iff.c
;	COMDAT ?iff_short_int_write@@YGXFPAU_iobuf@@@Z
_TEXT	SEGMENT
_buffer$ = -8						; size = 2
_ptr$ = -4						; size = 4
_value$ = 8						; size = 2
_fp$ = 12						; size = 4
?iff_short_int_write@@YGXFPAU_iobuf@@@Z PROC		; iff_short_int_write, COMDAT

; 346  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 347  : 
; 348  : 	unsigned char
; 349  : 		*ptr,
; 350  : 		buffer[2];
; 351  : 
; 352  : 	ptr = ( unsigned char * ) &value;

  00009	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 353  : 
; 354  : 	buffer[0] = ptr[1];

  0000f	b8 01 00 00 00	 mov	 eax, 1
  00014	c1 e0 00	 shl	 eax, 0
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	6b d1 00	 imul	 edx, ecx, 0
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00022	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  00025	88 44 15 f8	 mov	 BYTE PTR _buffer$[ebp+edx], al

; 355  : 	buffer[1] = ptr[0];

  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	6b c8 00	 imul	 ecx, eax, 0
  00031	ba 01 00 00 00	 mov	 edx, 1
  00036	c1 e2 00	 shl	 edx, 0
  00039	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  0003c	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  0003f	88 4c 15 f8	 mov	 BYTE PTR _buffer$[ebp+edx], cl

; 356  : 
; 357  : 	fwrite ( buffer, 2, 1, fp );

  00043	8b 45 0c	 mov	 eax, DWORD PTR _fp$[ebp]
  00046	50		 push	 eax
  00047	6a 01		 push	 1
  00049	6a 02		 push	 2
  0004b	8d 4d f8	 lea	 ecx, DWORD PTR _buffer$[ebp]
  0004e	51		 push	 ecx
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00055	83 c4 10	 add	 esp, 16			; 00000010H

; 358  : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
?iff_short_int_write@@YGXFPAU_iobuf@@@Z ENDP		; iff_short_int_write
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\misc\iff.c
;	COMDAT ?iff_int_write@@YGXHPAU_iobuf@@@Z
_TEXT	SEGMENT
_buffer$ = -8						; size = 4
_ptr$ = -4						; size = 4
_value$ = 8						; size = 4
_fp$ = 12						; size = 4
?iff_int_write@@YGXHPAU_iobuf@@@Z PROC			; iff_int_write, COMDAT

; 325  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 326  : 
; 327  : 	unsigned char
; 328  : 		*ptr,
; 329  : 		buffer[4];
; 330  : 
; 331  : 	ptr = ( unsigned char * ) &value;

  00009	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 332  : 
; 333  : 	buffer[0] = ptr[3];

  0000f	b8 01 00 00 00	 mov	 eax, 1
  00014	6b c8 03	 imul	 ecx, eax, 3
  00017	ba 01 00 00 00	 mov	 edx, 1
  0001c	6b c2 00	 imul	 eax, edx, 0
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00022	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  00025	88 4c 05 f8	 mov	 BYTE PTR _buffer$[ebp+eax], cl

; 334  : 	buffer[1] = ptr[2];

  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	d1 e0		 shl	 eax, 1
  00030	b9 01 00 00 00	 mov	 ecx, 1
  00035	c1 e1 00	 shl	 ecx, 0
  00038	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  0003b	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  0003e	88 44 0d f8	 mov	 BYTE PTR _buffer$[ebp+ecx], al

; 335  : 	buffer[2] = ptr[1];

  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	c1 e0 00	 shl	 eax, 0
  0004a	b9 01 00 00 00	 mov	 ecx, 1
  0004f	d1 e1		 shl	 ecx, 1
  00051	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00054	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00057	88 44 0d f8	 mov	 BYTE PTR _buffer$[ebp+ecx], al

; 336  : 	buffer[3] = ptr[0];

  0005b	b8 01 00 00 00	 mov	 eax, 1
  00060	6b c8 00	 imul	 ecx, eax, 0
  00063	ba 01 00 00 00	 mov	 edx, 1
  00068	6b c2 03	 imul	 eax, edx, 3
  0006b	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  0006e	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  00071	88 4c 05 f8	 mov	 BYTE PTR _buffer$[ebp+eax], cl

; 337  : 
; 338  : 	fwrite ( buffer, 4, 1, fp );

  00075	8b 45 0c	 mov	 eax, DWORD PTR _fp$[ebp]
  00078	50		 push	 eax
  00079	6a 01		 push	 1
  0007b	6a 04		 push	 4
  0007d	8d 4d f8	 lea	 ecx, DWORD PTR _buffer$[ebp]
  00080	51		 push	 ecx
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00087	83 c4 10	 add	 esp, 16			; 00000010H

; 339  : }

  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 08 00	 ret	 8
?iff_int_write@@YGXHPAU_iobuf@@@Z ENDP			; iff_int_write
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\misc\iff.c
;	COMDAT ?iff_float_write@@YGXMPAU_iobuf@@@Z
_TEXT	SEGMENT
_buffer$ = -8						; size = 4
_ptr$ = -4						; size = 4
_value$ = 8						; size = 4
_fp$ = 12						; size = 4
?iff_float_write@@YGXMPAU_iobuf@@@Z PROC		; iff_float_write, COMDAT

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 305  : 
; 306  : 	unsigned char
; 307  : 		*ptr,
; 308  : 		buffer[4];
; 309  : 
; 310  : 	ptr = ( unsigned char * ) &value;

  00009	8d 45 08	 lea	 eax, DWORD PTR _value$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 311  : 
; 312  : 	buffer[0] = ptr[3];

  0000f	b8 01 00 00 00	 mov	 eax, 1
  00014	6b c8 03	 imul	 ecx, eax, 3
  00017	ba 01 00 00 00	 mov	 edx, 1
  0001c	6b c2 00	 imul	 eax, edx, 0
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00022	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  00025	88 4c 05 f8	 mov	 BYTE PTR _buffer$[ebp+eax], cl

; 313  : 	buffer[1] = ptr[2];

  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	d1 e0		 shl	 eax, 1
  00030	b9 01 00 00 00	 mov	 ecx, 1
  00035	c1 e1 00	 shl	 ecx, 0
  00038	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  0003b	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  0003e	88 44 0d f8	 mov	 BYTE PTR _buffer$[ebp+ecx], al

; 314  : 	buffer[2] = ptr[1];

  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	c1 e0 00	 shl	 eax, 0
  0004a	b9 01 00 00 00	 mov	 ecx, 1
  0004f	d1 e1		 shl	 ecx, 1
  00051	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00054	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00057	88 44 0d f8	 mov	 BYTE PTR _buffer$[ebp+ecx], al

; 315  : 	buffer[3] = ptr[0];

  0005b	b8 01 00 00 00	 mov	 eax, 1
  00060	6b c8 00	 imul	 ecx, eax, 0
  00063	ba 01 00 00 00	 mov	 edx, 1
  00068	6b c2 03	 imul	 eax, edx, 3
  0006b	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  0006e	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  00071	88 4c 05 f8	 mov	 BYTE PTR _buffer$[ebp+eax], cl

; 316  : 
; 317  : 	fwrite ( buffer, 4, 1, fp );

  00075	8b 45 0c	 mov	 eax, DWORD PTR _fp$[ebp]
  00078	50		 push	 eax
  00079	6a 01		 push	 1
  0007b	6a 04		 push	 4
  0007d	8d 4d f8	 lea	 ecx, DWORD PTR _buffer$[ebp]
  00080	51		 push	 ecx
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00087	83 c4 10	 add	 esp, 16			; 00000010H

; 318  : }

  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 08 00	 ret	 8
?iff_float_write@@YGXMPAU_iobuf@@@Z ENDP		; iff_float_write
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\misc\iff.c
;	COMDAT ?iff_short_int_read@@YGFPAU_iobuf@@@Z
_TEXT	SEGMENT
_val$ = -5						; size = 1
_value$ = -4						; size = 2
_fp$ = 8						; size = 4
?iff_short_int_read@@YGFPAU_iobuf@@@Z PROC		; iff_short_int_read, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 255  : 
; 256  : 	short int
; 257  : 		value;
; 258  : 
; 259  : 	unsigned char
; 260  : 		val;
; 261  : 
; 262  : 	fread ( &val, 1, 1, fp );

  00009	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	6a 01		 push	 1
  00011	8d 4d fb	 lea	 ecx, DWORD PTR _val$[ebp]
  00014	51		 push	 ecx
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 263  : 	value = ( val<<8 );

  0001e	0f b6 45 fb	 movzx	 eax, BYTE PTR _val$[ebp]
  00022	c1 e0 08	 shl	 eax, 8
  00025	66 89 45 fc	 mov	 WORD PTR _value$[ebp], ax

; 264  : 
; 265  : 	fread ( &val, 1, 1, fp );

  00029	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	6a 01		 push	 1
  00031	8d 4d fb	 lea	 ecx, DWORD PTR _val$[ebp]
  00034	51		 push	 ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0003b	83 c4 10	 add	 esp, 16			; 00000010H

; 266  : 	value |= ( val );

  0003e	0f b6 45 fb	 movzx	 eax, BYTE PTR _val$[ebp]
  00042	0f bf 4d fc	 movsx	 ecx, WORD PTR _value$[ebp]
  00046	0b c8		 or	 ecx, eax
  00048	66 89 4d fc	 mov	 WORD PTR _value$[ebp], cx

; 267  : 
; 268  : 	return ( value );

  0004c	66 8b 45 fc	 mov	 ax, WORD PTR _value$[ebp]

; 269  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?iff_short_int_read@@YGFPAU_iobuf@@@Z ENDP		; iff_short_int_read
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\misc\iff.c
;	COMDAT ?iff_int_read@@YGHPAU_iobuf@@@Z
_TEXT	SEGMENT
_val$ = -5						; size = 1
_value$ = -4						; size = 4
_fp$ = 8						; size = 4
?iff_int_read@@YGHPAU_iobuf@@@Z PROC			; iff_int_read, COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 227  : 
; 228  : 	unsigned int
; 229  : 		value;
; 230  : 
; 231  : 	unsigned char
; 232  : 		val;
; 233  : 
; 234  : 	fread ( &val, 1, 1, fp );

  00009	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	6a 01		 push	 1
  00011	8d 4d fb	 lea	 ecx, DWORD PTR _val$[ebp]
  00014	51		 push	 ecx
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 235  : 	value = ( val<<24 );

  0001e	0f b6 45 fb	 movzx	 eax, BYTE PTR _val$[ebp]
  00022	c1 e0 18	 shl	 eax, 24			; 00000018H
  00025	89 45 fc	 mov	 DWORD PTR _value$[ebp], eax

; 236  : 
; 237  : 	fread ( &val, 1, 1, fp );

  00028	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  0002b	50		 push	 eax
  0002c	6a 01		 push	 1
  0002e	6a 01		 push	 1
  00030	8d 4d fb	 lea	 ecx, DWORD PTR _val$[ebp]
  00033	51		 push	 ecx
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0003a	83 c4 10	 add	 esp, 16			; 00000010H

; 238  : 	value += ( val<<16 );

  0003d	0f b6 45 fb	 movzx	 eax, BYTE PTR _val$[ebp]
  00041	c1 e0 10	 shl	 eax, 16			; 00000010H
  00044	03 45 fc	 add	 eax, DWORD PTR _value$[ebp]
  00047	89 45 fc	 mov	 DWORD PTR _value$[ebp], eax

; 239  : 
; 240  : 	fread ( &val, 1, 1, fp );

  0004a	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  0004d	50		 push	 eax
  0004e	6a 01		 push	 1
  00050	6a 01		 push	 1
  00052	8d 4d fb	 lea	 ecx, DWORD PTR _val$[ebp]
  00055	51		 push	 ecx
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0005c	83 c4 10	 add	 esp, 16			; 00000010H

; 241  : 	value += ( val<<8 );

  0005f	0f b6 45 fb	 movzx	 eax, BYTE PTR _val$[ebp]
  00063	c1 e0 08	 shl	 eax, 8
  00066	03 45 fc	 add	 eax, DWORD PTR _value$[ebp]
  00069	89 45 fc	 mov	 DWORD PTR _value$[ebp], eax

; 242  : 
; 243  : 	fread ( &val, 1, 1, fp );

  0006c	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  0006f	50		 push	 eax
  00070	6a 01		 push	 1
  00072	6a 01		 push	 1
  00074	8d 4d fb	 lea	 ecx, DWORD PTR _val$[ebp]
  00077	51		 push	 ecx
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0007e	83 c4 10	 add	 esp, 16			; 00000010H

; 244  : 	value += ( val );

  00081	0f b6 45 fb	 movzx	 eax, BYTE PTR _val$[ebp]
  00085	03 45 fc	 add	 eax, DWORD PTR _value$[ebp]
  00088	89 45 fc	 mov	 DWORD PTR _value$[ebp], eax

; 245  : 
; 246  : 	return ( value );

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 247  : }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 04 00	 ret	 4
?iff_int_read@@YGHPAU_iobuf@@@Z ENDP			; iff_int_read
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\misc\iff.c
;	COMDAT ?iff_float_read@@YGMPAU_iobuf@@@Z
_TEXT	SEGMENT
_result$ = -12						; size = 4
_buffer2$ = -8						; size = 4
_buffer1$ = -4						; size = 4
_fp$ = 8						; size = 4
?iff_float_read@@YGMPAU_iobuf@@@Z PROC			; iff_float_read, COMDAT

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 277  : 
; 278  : 	unsigned char
; 279  : 		buffer1[4];
; 280  : 
; 281  : 	unsigned char
; 282  : 		buffer2[4];
; 283  : 
; 284  : 	float
; 285  : 		*result;
; 286  : 
; 287  : 	fread ( buffer1, 4, 1, fp );

  00009	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	6a 04		 push	 4
  00011	8d 4d fc	 lea	 ecx, DWORD PTR _buffer1$[ebp]
  00014	51		 push	 ecx
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 288  : 
; 289  : 	buffer2[0] = buffer1[3];

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	6b c8 03	 imul	 ecx, eax, 3
  00026	ba 01 00 00 00	 mov	 edx, 1
  0002b	6b c2 00	 imul	 eax, edx, 0
  0002e	8a 4c 0d fc	 mov	 cl, BYTE PTR _buffer1$[ebp+ecx]
  00032	88 4c 05 f8	 mov	 BYTE PTR _buffer2$[ebp+eax], cl

; 290  : 	buffer2[1] = buffer1[2];

  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	d1 e0		 shl	 eax, 1
  0003d	b9 01 00 00 00	 mov	 ecx, 1
  00042	c1 e1 00	 shl	 ecx, 0
  00045	8a 54 05 fc	 mov	 dl, BYTE PTR _buffer1$[ebp+eax]
  00049	88 54 0d f8	 mov	 BYTE PTR _buffer2$[ebp+ecx], dl

; 291  : 	buffer2[2] = buffer1[1];

  0004d	b8 01 00 00 00	 mov	 eax, 1
  00052	c1 e0 00	 shl	 eax, 0
  00055	b9 01 00 00 00	 mov	 ecx, 1
  0005a	d1 e1		 shl	 ecx, 1
  0005c	8a 54 05 fc	 mov	 dl, BYTE PTR _buffer1$[ebp+eax]
  00060	88 54 0d f8	 mov	 BYTE PTR _buffer2$[ebp+ecx], dl

; 292  : 	buffer2[3] = buffer1[0];

  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	6b c8 00	 imul	 ecx, eax, 0
  0006c	ba 01 00 00 00	 mov	 edx, 1
  00071	6b c2 03	 imul	 eax, edx, 3
  00074	8a 4c 0d fc	 mov	 cl, BYTE PTR _buffer1$[ebp+ecx]
  00078	88 4c 05 f8	 mov	 BYTE PTR _buffer2$[ebp+eax], cl

; 293  : 
; 294  : 	result = ( float * ) buffer2;

  0007c	8d 45 f8	 lea	 eax, DWORD PTR _buffer2$[ebp]
  0007f	89 45 f4	 mov	 DWORD PTR _result$[ebp], eax

; 295  : 
; 296  : 	return ( *result );

  00082	8b 45 f4	 mov	 eax, DWORD PTR _result$[ebp]
  00085	d9 00		 fld	 DWORD PTR [eax]

; 297  : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
?iff_float_read@@YGMPAU_iobuf@@@Z ENDP			; iff_float_read
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\misc\iff.c
;	COMDAT ?put_iff_type@@YGXPAU_iobuf@@W4IFF_HEADER_TYPES@@@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_fp$ = 8						; size = 4
_type$ = 12						; size = 4
?put_iff_type@@YGXPAU_iobuf@@W4IFF_HEADER_TYPES@@@Z PROC ; put_iff_type, COMDAT

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 191  : 
; 192  : 	int
; 193  : 		i;
; 194  : 
; 195  : 	ASSERT ( fp );

  00009	83 7d 08 00	 cmp	 DWORD PTR _fp$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN4@put_iff_ty
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??put_iff_type@@YGXPAU_iobuf@@W4IFF_HEADER_TYPES@@@Z@4JA
  00014	83 c0 05	 add	 eax, 5
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IGJIFDJN@c?3?2users?2nhv90?2projects?2eech?2mo@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02GDNLOIIJ@fp@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN4@put_iff_ty:

; 196  : 
; 197  : 	i = 0;

  00027	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN2@put_iff_ty:

; 198  : 
; 199  : 	while ( TRUE )

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	74 2b		 je	 SHORT $LN3@put_iff_ty

; 200  : 	{
; 201  : 
; 202  : 		if ( ( iff_headers[i].id == NOT_RECOGNISED ) || ( iff_headers[i].id == type ) )

  00037	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003a	83 3c c5 04 00
	00 00 00	 cmp	 DWORD PTR ?iff_headers@@3PAUIFF_HEADER@@A[eax*8+4], 0
  00042	74 0f		 je	 SHORT $LN7@put_iff_ty
  00044	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00047	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR ?iff_headers@@3PAUIFF_HEADER@@A[eax*8+4]
  0004e	3b 4d 0c	 cmp	 ecx, DWORD PTR _type$[ebp]
  00051	75 04		 jne	 SHORT $LN5@put_iff_ty
$LN7@put_iff_ty:

; 203  : 		{
; 204  : 
; 205  : 			break;

  00053	eb 0d		 jmp	 SHORT $LN3@put_iff_ty

; 206  : 		}
; 207  : 		else

  00055	eb 09		 jmp	 SHORT $LN6@put_iff_ty
$LN5@put_iff_ty:

; 208  : 		{
; 209  : 
; 210  : 			i++;

  00057	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0005a	83 c0 01	 add	 eax, 1
  0005d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@put_iff_ty:

; 211  : 		}
; 212  : 	}

  00060	eb cc		 jmp	 SHORT $LN2@put_iff_ty
$LN3@put_iff_ty:

; 213  : 
; 214  : 	if ( iff_headers[i].id == type )

  00062	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00065	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR ?iff_headers@@3PAUIFF_HEADER@@A[eax*8+4]
  0006c	3b 4d 0c	 cmp	 ecx, DWORD PTR _type$[ebp]
  0006f	75 1c		 jne	 SHORT $LN1@put_iff_ty

; 215  : 	{
; 216  : 
; 217  : 		fwrite ( iff_headers[i].name, 4, 1, fp );

  00071	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00074	50		 push	 eax
  00075	6a 01		 push	 1
  00077	6a 04		 push	 4
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0007c	8b 14 cd 00 00
	00 00		 mov	 edx, DWORD PTR ?iff_headers@@3PAUIFF_HEADER@@A[ecx*8]
  00083	52		 push	 edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0008a	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@put_iff_ty:

; 218  : 	}
; 219  : }

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 08 00	 ret	 8
?put_iff_type@@YGXPAU_iobuf@@W4IFF_HEADER_TYPES@@@Z ENDP ; put_iff_type
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\misc\iff.c
;	COMDAT ?get_iff_type_from_string@@YG?AW4IFF_HEADER_TYPES@@PAD@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_type$ = -8						; size = 4
_recognised$ = -4					; size = 4
_buf$ = 8						; size = 4
?get_iff_type_from_string@@YG?AW4IFF_HEADER_TYPES@@PAD@Z PROC ; get_iff_type_from_string, COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 146  : 
; 147  : 	int
; 148  : 		recognised,
; 149  : 		type,
; 150  : 		i;
; 151  : 
; 152  : 	type = NOT_RECOGNISED;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _type$[ebp], 0

; 153  : 
; 154  : 	recognised = FALSE;

  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _recognised$[ebp], 0

; 155  : 
; 156  : 	i = 0;

  00017	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN2@get_iff_ty:

; 157  : 
; 158  : 	while ( !recognised )

  0001e	83 7d fc 00	 cmp	 DWORD PTR _recognised$[ebp], 0
  00022	75 54		 jne	 SHORT $LN3@get_iff_ty

; 159  : 	{
; 160  : 
; 161  : 		if ( iff_headers[i].id == NOT_RECOGNISED )

  00024	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00027	83 3c c5 04 00
	00 00 00	 cmp	 DWORD PTR ?iff_headers@@3PAUIFF_HEADER@@A[eax*8+4], 0
  0002f	75 0b		 jne	 SHORT $LN4@get_iff_ty

; 162  : 		{
; 163  : 
; 164  : 			recognised = TRUE;

  00031	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _recognised$[ebp], 1

; 165  : 
; 166  : 			break;

  00038	eb 3e		 jmp	 SHORT $LN3@get_iff_ty
  0003a	eb 3a		 jmp	 SHORT $LN5@get_iff_ty
$LN4@get_iff_ty:

; 167  : 		}
; 168  : 		else if ( ( strcmp ( buf, iff_headers[i].name ) ) == 0 )

  0003c	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0003f	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR ?iff_headers@@3PAUIFF_HEADER@@A[eax*8]
  00046	51		 push	 ecx
  00047	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  0004a	52		 push	 edx
  0004b	e8 00 00 00 00	 call	 _strcmp
  00050	83 c4 08	 add	 esp, 8
  00053	85 c0		 test	 eax, eax
  00055	75 16		 jne	 SHORT $LN6@get_iff_ty

; 169  : 		{
; 170  : 
; 171  : 			recognised = TRUE;

  00057	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _recognised$[ebp], 1

; 172  : 
; 173  : 			type = iff_headers[i].id;

  0005e	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00061	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR ?iff_headers@@3PAUIFF_HEADER@@A[eax*8+4]
  00068	89 4d f8	 mov	 DWORD PTR _type$[ebp], ecx

; 174  : 		}
; 175  : 		else

  0006b	eb 09		 jmp	 SHORT $LN5@get_iff_ty
$LN6@get_iff_ty:

; 176  : 		{
; 177  : 
; 178  : 			i++;

  0006d	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00070	83 c0 01	 add	 eax, 1
  00073	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN5@get_iff_ty:

; 179  : 		}
; 180  : 	}

  00076	eb a6		 jmp	 SHORT $LN2@get_iff_ty
$LN3@get_iff_ty:

; 181  : 
; 182  : 	return ( iff_header_types ) ( type );

  00078	8b 45 f8	 mov	 eax, DWORD PTR _type$[ebp]

; 183  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
?get_iff_type_from_string@@YG?AW4IFF_HEADER_TYPES@@PAD@Z ENDP ; get_iff_type_from_string
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\misc\iff.c
;	COMDAT ?get_iff_type@@YG?AW4IFF_HEADER_TYPES@@PAU_iobuf@@@Z
_TEXT	SEGMENT
_buf$ = -8						; size = 5
_fp$ = 8						; size = 4
?get_iff_type@@YG?AW4IFF_HEADER_TYPES@@PAU_iobuf@@@Z PROC ; get_iff_type, COMDAT

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 123  : 
; 124  : 	char
; 125  : 		buf[5];
; 126  : 
; 127  : 	if ( !fp )

  00009	83 7d 08 00	 cmp	 DWORD PTR _fp$[ebp], 0
  0000d	75 04		 jne	 SHORT $LN2@get_iff_ty

; 128  : 	{
; 129  : 
; 130  : 		return ( NOT_RECOGNISED );

  0000f	33 c0		 xor	 eax, eax
  00011	eb 2b		 jmp	 SHORT $LN1@get_iff_ty
$LN2@get_iff_ty:

; 131  : 	}
; 132  : 
; 133  : 	fread ( buf, 4, 1, fp );

  00013	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00016	50		 push	 eax
  00017	6a 01		 push	 1
  00019	6a 04		 push	 4
  0001b	8d 4d f8	 lea	 ecx, DWORD PTR _buf$[ebp]
  0001e	51		 push	 ecx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00025	83 c4 10	 add	 esp, 16			; 00000010H

; 134  : 
; 135  : 	buf[4] = '\0';

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	c1 e0 02	 shl	 eax, 2
  00030	c6 44 05 f8 00	 mov	 BYTE PTR _buf$[ebp+eax], 0

; 136  : 
; 137  : 	return ( get_iff_type_from_string ( buf ) );

  00035	8d 45 f8	 lea	 eax, DWORD PTR _buf$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?get_iff_type_from_string@@YG?AW4IFF_HEADER_TYPES@@PAD@Z ; get_iff_type_from_string
$LN1@get_iff_ty:

; 138  : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?get_iff_type@@YG?AW4IFF_HEADER_TYPES@@PAU_iobuf@@@Z ENDP ; get_iff_type
_TEXT	ENDS
END
