; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\system\event.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?button_state_names@@3PAPBDA			; button_state_names
PUBLIC	?modifier_type_names@@3PAPBDA			; modifier_type_names
PUBLIC	?registered_events@@3PAY08UREGISTERED_EVENT_TYPE@@A ; registered_events
PUBLIC	?current_modifier_states@@3HA			; current_modifier_states
PUBLIC	?last_key_event_time@@3HA			; last_key_event_time
PUBLIC	?last_joystick_event_time@@3HA			; last_joystick_event_time
PUBLIC	?last_mouse_event_time@@3HA			; last_mouse_event_time
PUBLIC	??_C@_0O@KNPKLENJ@STATE_INVALID@		; `string'
PUBLIC	??_C@_08CFJHCGDA@STATE_UP@			; `string'
PUBLIC	??_C@_0L@FPLIDFNM@STATE_DOWN@			; `string'
PUBLIC	??_C@_0N@JHAHKMNA@STATE_EITHER@			; `string'
PUBLIC	??_C@_0O@MGFOBHKO@MODIFIER_NONE@		; `string'
PUBLIC	??_C@_0BE@HAHJJNNA@MODIFIER_LEFT_SHIFT@		; `string'
PUBLIC	??_C@_0BG@LDNODEEI@MODIFIER_LEFT_CONTROL@	; `string'
PUBLIC	??_C@_0BC@JIANOMDN@MODIFIER_LEFT_ALT@		; `string'
PUBLIC	??_C@_0BF@JLALIPOF@MODIFIER_RIGHT_SHIFT@	; `string'
PUBLIC	??_C@_0BH@OCFGGMME@MODIFIER_RIGHT_CONTROL@	; `string'
PUBLIC	??_C@_0BD@GAOIJOPD@MODIFIER_RIGHT_ALT@		; `string'
PUBLIC	??_C@_0BL@KEGEHLHG@MODIFIER_MOUSE_LEFT_BUTTON@	; `string'
PUBLIC	??_C@_0BM@OKNLPKNP@MODIFIER_MOUSE_RIGHT_BUTTON@	; `string'
PUBLIC	??_C@_0BD@PACEKJAN@NUM_MODIFIER_TYPES@		; `string'
_BSS	SEGMENT
?registered_events@@3PAY08UREGISTERED_EVENT_TYPE@@A DQ 0a8cH DUP (?) ; registered_events
?current_modifier_states@@3HA DD 01H DUP (?)		; current_modifier_states
?last_key_event_time@@3HA DD 01H DUP (?)		; last_key_event_time
?last_joystick_event_time@@3HA DD 01H DUP (?)		; last_joystick_event_time
?last_mouse_event_time@@3HA DD 01H DUP (?)		; last_mouse_event_time
_BSS	ENDS
;	COMDAT ??_C@_0BD@PACEKJAN@NUM_MODIFIER_TYPES@
CONST	SEGMENT
??_C@_0BD@PACEKJAN@NUM_MODIFIER_TYPES@ DB 'NUM_MODIFIER_TYPES', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OKNLPKNP@MODIFIER_MOUSE_RIGHT_BUTTON@
CONST	SEGMENT
??_C@_0BM@OKNLPKNP@MODIFIER_MOUSE_RIGHT_BUTTON@ DB 'MODIFIER_MOUSE_RIGHT_'
	DB	'BUTTON', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KEGEHLHG@MODIFIER_MOUSE_LEFT_BUTTON@
CONST	SEGMENT
??_C@_0BL@KEGEHLHG@MODIFIER_MOUSE_LEFT_BUTTON@ DB 'MODIFIER_MOUSE_LEFT_BU'
	DB	'TTON', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GAOIJOPD@MODIFIER_RIGHT_ALT@
CONST	SEGMENT
??_C@_0BD@GAOIJOPD@MODIFIER_RIGHT_ALT@ DB 'MODIFIER_RIGHT_ALT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OCFGGMME@MODIFIER_RIGHT_CONTROL@
CONST	SEGMENT
??_C@_0BH@OCFGGMME@MODIFIER_RIGHT_CONTROL@ DB 'MODIFIER_RIGHT_CONTROL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JLALIPOF@MODIFIER_RIGHT_SHIFT@
CONST	SEGMENT
??_C@_0BF@JLALIPOF@MODIFIER_RIGHT_SHIFT@ DB 'MODIFIER_RIGHT_SHIFT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JIANOMDN@MODIFIER_LEFT_ALT@
CONST	SEGMENT
??_C@_0BC@JIANOMDN@MODIFIER_LEFT_ALT@ DB 'MODIFIER_LEFT_ALT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LDNODEEI@MODIFIER_LEFT_CONTROL@
CONST	SEGMENT
??_C@_0BG@LDNODEEI@MODIFIER_LEFT_CONTROL@ DB 'MODIFIER_LEFT_CONTROL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HAHJJNNA@MODIFIER_LEFT_SHIFT@
CONST	SEGMENT
??_C@_0BE@HAHJJNNA@MODIFIER_LEFT_SHIFT@ DB 'MODIFIER_LEFT_SHIFT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MGFOBHKO@MODIFIER_NONE@
CONST	SEGMENT
??_C@_0O@MGFOBHKO@MODIFIER_NONE@ DB 'MODIFIER_NONE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JHAHKMNA@STATE_EITHER@
CONST	SEGMENT
??_C@_0N@JHAHKMNA@STATE_EITHER@ DB 'STATE_EITHER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FPLIDFNM@STATE_DOWN@
CONST	SEGMENT
??_C@_0L@FPLIDFNM@STATE_DOWN@ DB 'STATE_DOWN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CFJHCGDA@STATE_UP@
CONST	SEGMENT
??_C@_08CFJHCGDA@STATE_UP@ DB 'STATE_UP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KNPKLENJ@STATE_INVALID@
CONST	SEGMENT
??_C@_0O@KNPKLENJ@STATE_INVALID@ DB 'STATE_INVALID', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?button_state_names@@3PAPBDA DD FLAT:??_C@_0O@KNPKLENJ@STATE_INVALID@ ; button_state_names
	DD	FLAT:??_C@_08CFJHCGDA@STATE_UP@
	DD	FLAT:??_C@_0L@FPLIDFNM@STATE_DOWN@
	DD	FLAT:??_C@_0N@JHAHKMNA@STATE_EITHER@
?modifier_type_names@@3PAPBDA DD FLAT:??_C@_0O@MGFOBHKO@MODIFIER_NONE@ ; modifier_type_names
	DD	FLAT:??_C@_0BE@HAHJJNNA@MODIFIER_LEFT_SHIFT@
	DD	FLAT:??_C@_0BG@LDNODEEI@MODIFIER_LEFT_CONTROL@
	DD	FLAT:??_C@_0BC@JIANOMDN@MODIFIER_LEFT_ALT@
	DD	FLAT:??_C@_0BF@JLALIPOF@MODIFIER_RIGHT_SHIFT@
	DD	FLAT:??_C@_0BH@OCFGGMME@MODIFIER_RIGHT_CONTROL@
	DD	FLAT:??_C@_0BD@GAOIJOPD@MODIFIER_RIGHT_ALT@
	DD	FLAT:??_C@_0BL@KEGEHLHG@MODIFIER_MOUSE_LEFT_BUTTON@
	DD	FLAT:??_C@_0BM@OKNLPKNP@MODIFIER_MOUSE_RIGHT_BUTTON@
	DD	FLAT:??_C@_0BD@PACEKJAN@NUM_MODIFIER_TYPES@
_DATA	ENDS
PUBLIC	?initialise_event_system@@YGHXZ			; initialise_event_system
PUBLIC	?clear_events@@YGXXZ				; clear_events
PUBLIC	?reset_event_key@@YGXH@Z			; reset_event_key
PUBLIC	?reset_events@@YGXXZ				; reset_events
PUBLIC	?create_joystick_event@@YGXHHW4BUTTON_STATES@@@Z ; create_joystick_event
PUBLIC	?create_key_event@@YGXHW4KEY_STATES@@@Z		; create_key_event
PUBLIC	?create_mouse_button_event@@YGXW4DEVICE_EVENTS@@W4BUTTON_STATES@@@Z ; create_mouse_button_event
PUBLIC	?create_mouse_move_event@@YGXHHH@Z		; create_mouse_move_event
PUBLIC	?get_event@@YGHPAUEVENT@@@Z			; get_event
PUBLIC	?set_event@@YGXHHHP6GXPAUEVENT@@@Z@Z		; set_event
PUBLIC	?process_events@@YGXXZ				; process_events
PUBLIC	?__LINE__Var@?0??initialise_event_system@@YGHXZ@4JA ; `initialise_event_system'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@DMNDEBFK@c?3?2users?2nhv90?2projects?2eech?2mo@ ; `string'
PUBLIC	??_C@_05IGMCOAJJ@mutex@				; `string'
PUBLIC	?__LINE__Var@?0??get_event@@YGHPAUEVENT@@@Z@4JA	; `get_event'::`1'::__LINE__Var
PUBLIC	??_C@_02DHMHPBFG@ev@				; `string'
PUBLIC	?__LINE__Var@?0??set_event@@YGXHHHP6GXPAUEVENT@@@Z@Z@4JA ; `set_event'::`1'::__LINE__Var
PUBLIC	??_C@_0DP@FENKMJKK@?$CImodifier?5?$DO?$DN?5MODIFIER_NONE?$CJ?5?$CG?$CG?5@ ; `string'
PUBLIC	??_C@_0DB@FKKAHHAC@EVENT?3?5Error?5in?5process_events?0@ ; `string'
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	?process_assert@@YGXPBD0H@Z:PROC		; process_assert
EXTRN	?debug_fatal@@YAXPBDZZ:PROC			; debug_fatal
EXTRN	?process_mouse_event@@YGHPAUEVENT@@@Z:PROC	; process_mouse_event
EXTRN	?get_mouse_on@@YGHXZ:PROC			; get_mouse_on
EXTRN	?process_joystick_event@@YGHPAUEVENT@@@Z:PROC	; process_joystick_event
EXTRN	?process_key_event@@YGHPAUEVENT@@@Z:PROC	; process_key_event
EXTRN	?get_system_time@@YGIXZ:PROC			; get_system_time
_BSS	SEGMENT
?event_input@@3HA DD 01H DUP (?)			; event_input
?event_output@@3HA DD 01H DUP (?)			; event_output
?event_list_size@@3HA DD 01H DUP (?)			; event_list_size
?mutex@@3PAXA DD 01H DUP (?)				; mutex
?event_list@@3PAUEVENT@@A DB 01400H DUP (?)		; event_list
_BSS	ENDS
;	COMDAT ??_C@_0DB@FKKAHHAC@EVENT?3?5Error?5in?5process_events?0@
CONST	SEGMENT
??_C@_0DB@FKKAHHAC@EVENT?3?5Error?5in?5process_events?0@ DB 'EVENT: Error'
	DB	' in process_events, unknown event %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@FENKMJKK@?$CImodifier?5?$DO?$DN?5MODIFIER_NONE?$CJ?5?$CG?$CG?5@
CONST	SEGMENT
??_C@_0DP@FENKMJKK@?$CImodifier?5?$DO?$DN?5MODIFIER_NONE?$CJ?5?$CG?$CG?5@ DB '('
	DB	'modifier >= MODIFIER_NONE) && (modifier < NUM_MODIFIER_TYPES)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??set_event@@YGXHHHP6GXPAUEVENT@@@Z@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??set_event@@YGXHHHP6GXPAUEVENT@@@Z@Z@4JA DD 01ddH ; `set_event'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02DHMHPBFG@ev@
CONST	SEGMENT
??_C@_02DHMHPBFG@ev@ DB 'ev', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??get_event@@YGHPAUEVENT@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??get_event@@YGHPAUEVENT@@@Z@4JA DD 01b8H ; `get_event'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_05IGMCOAJJ@mutex@
CONST	SEGMENT
??_C@_05IGMCOAJJ@mutex@ DB 'mutex', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@DMNDEBFK@c?3?2users?2nhv90?2projects?2eech?2mo@
CONST	SEGMENT
??_C@_0DE@DMNDEBFK@c?3?2users?2nhv90?2projects?2eech?2mo@ DB 'c:\users\nh'
	DB	'v90\projects\eech\modules\system\event.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??initialise_event_system@@YGHXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??initialise_event_system@@YGHXZ@4JA DD 090H ; `initialise_event_system'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\event.c
;	COMDAT ?process_events@@YGXXZ
_TEXT	SEGMENT
tv67 = -88						; size = 4
_current_event$ = -20					; size = 20
?process_events@@YGXXZ PROC				; process_events, COMDAT

; 508  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@process_ev:

; 509  : 
; 510  : 	event
; 511  : 		current_event;
; 512  : 
; 513  : 	while (get_event (&current_event))

  00009	8d 45 ec	 lea	 eax, DWORD PTR _current_event$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?get_event@@YGHPAUEVENT@@@Z ; get_event
  00012	85 c0		 test	 eax, eax
  00014	74 7f		 je	 SHORT $LN1@process_ev

; 514  : 	{
; 515  : 
; 516  : 		switch (current_event.type)

  00016	8b 45 ec	 mov	 eax, DWORD PTR _current_event$[ebp]
  00019	89 45 a8	 mov	 DWORD PTR tv67[ebp], eax
  0001c	8b 4d a8	 mov	 ecx, DWORD PTR tv67[ebp]
  0001f	83 e9 01	 sub	 ecx, 1
  00022	89 4d a8	 mov	 DWORD PTR tv67[ebp], ecx
  00025	83 7d a8 05	 cmp	 DWORD PTR tv67[ebp], 5
  00029	77 54		 ja	 SHORT $LN12@process_ev
  0002b	8b 55 a8	 mov	 edx, DWORD PTR tv67[ebp]
  0002e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN14@process_ev[edx*4]
$LN6@process_ev:

; 517  : 		{
; 518  : 
; 519  : 			case EVENT_TYPE_KEY:
; 520  : 			{
; 521  : 
; 522  : 				#if EVENT_DEBUG
; 523  : 
; 524  : 				debug_log ("EVENT: process event: KEY %d", current_event.key);
; 525  : 
; 526  : 				#endif
; 527  : 
; 528  : 				last_key_event_time = get_system_time ();

  00035	e8 00 00 00 00	 call	 ?get_system_time@@YGIXZ	; get_system_time
  0003a	a3 00 00 00 00	 mov	 DWORD PTR ?last_key_event_time@@3HA, eax ; last_key_event_time

; 529  : 
; 530  : 				process_key_event (&current_event);

  0003f	8d 45 ec	 lea	 eax, DWORD PTR _current_event$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?process_key_event@@YGHPAUEVENT@@@Z ; process_key_event

; 531  : 
; 532  : 				break;

  00048	eb 46		 jmp	 SHORT $LN4@process_ev
$LN7@process_ev:

; 533  : 			}
; 534  : 
; 535  : 			case EVENT_TYPE_JOYSTICK_BUTTON:
; 536  : 			case EVENT_TYPE_JOYSTICK_MOVE:
; 537  : 			{
; 538  : 
; 539  : 				#if EVENT_DEBUG
; 540  : 
; 541  : 				debug_log ("EVENT: process event: JOYSTICK button %d", current_event.button);
; 542  : 
; 543  : 				#endif
; 544  : 
; 545  : 				last_joystick_event_time = get_system_time ();

  0004a	e8 00 00 00 00	 call	 ?get_system_time@@YGIXZ	; get_system_time
  0004f	a3 00 00 00 00	 mov	 DWORD PTR ?last_joystick_event_time@@3HA, eax ; last_joystick_event_time

; 546  : 
; 547  : 				process_joystick_event (&current_event);

  00054	8d 45 ec	 lea	 eax, DWORD PTR _current_event$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ?process_joystick_event@@YGHPAUEVENT@@@Z ; process_joystick_event

; 548  : 
; 549  : 				break;

  0005d	eb 31		 jmp	 SHORT $LN4@process_ev
$LN8@process_ev:

; 550  : 			}
; 551  : 
; 552  : 			case EVENT_TYPE_TIMER:
; 553  : 			{
; 554  : 
; 555  : 				#if EVENT_DEBUG
; 556  : 
; 557  : 				debug_log ("EVENT: process event: TIMER %d", current_event.key);
; 558  : 
; 559  : 				#endif
; 560  : 
; 561  : 				break;

  0005f	eb 2f		 jmp	 SHORT $LN4@process_ev
$LN9@process_ev:

; 562  : 			}
; 563  : 
; 564  : 			case EVENT_TYPE_MOUSE_BUTTON:
; 565  : 			case EVENT_TYPE_MOUSE_MOVE:
; 566  : 			{
; 567  : 
; 568  : 				if (get_mouse_on ())

  00061	e8 00 00 00 00	 call	 ?get_mouse_on@@YGHXZ	; get_mouse_on
  00066	85 c0		 test	 eax, eax
  00068	74 13		 je	 SHORT $LN11@process_ev

; 569  : 				{
; 570  : 
; 571  : 					#if EVENT_DEBUG
; 572  : 
; 573  : 					debug_log ("EVENT: process mouse: mouse dx %d, dy %d, button %d, state %d", current_event.dx, current_event.dy, current_event.button, current_event.state);
; 574  : 
; 575  : 					#endif
; 576  : 
; 577  : 					last_mouse_event_time = get_system_time ();

  0006a	e8 00 00 00 00	 call	 ?get_system_time@@YGIXZ	; get_system_time
  0006f	a3 00 00 00 00	 mov	 DWORD PTR ?last_mouse_event_time@@3HA, eax ; last_mouse_event_time

; 578  : 
; 579  : 					process_mouse_event (&current_event);

  00074	8d 45 ec	 lea	 eax, DWORD PTR _current_event$[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?process_mouse_event@@YGHPAUEVENT@@@Z ; process_mouse_event
$LN11@process_ev:

; 580  : 				}
; 581  : 				else
; 582  : 				{
; 583  : 
; 584  : 					#if EVENT_DEBUG
; 585  : 
; 586  : 					debug_log ("EVENT: MOUSE OFF NOT processing mouse: mouse dx %d, dy %d, button %d, state %d", current_event.dx, current_event.dy, current_event.button, current_event.state);
; 587  : 
; 588  : 					#endif
; 589  : 				}
; 590  : 
; 591  : 				break;

  0007d	eb 11		 jmp	 SHORT $LN4@process_ev
$LN12@process_ev:

; 592  : 			}
; 593  : 
; 594  : 			// add new events here !
; 595  : 
; 596  : 			default:
; 597  : 			{
; 598  : 
; 599  : 				debug_fatal ("EVENT: Error in process_events, unknown event %d", current_event.type);

  0007f	8b 45 ec	 mov	 eax, DWORD PTR _current_event$[ebp]
  00082	50		 push	 eax
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@FKKAHHAC@EVENT?3?5Error?5in?5process_events?0@
  00088	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  0008d	83 c4 08	 add	 esp, 8
$LN4@process_ev:

; 600  : 
; 601  : 				break;
; 602  : 			}
; 603  : 		}
; 604  : 	}

  00090	e9 74 ff ff ff	 jmp	 $LN2@process_ev
$LN1@process_ev:

; 605  : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
$LN14@process_ev:
  0009c	00 00 00 00	 DD	 $LN6@process_ev
  000a0	00 00 00 00	 DD	 $LN9@process_ev
  000a4	00 00 00 00	 DD	 $LN9@process_ev
  000a8	00 00 00 00	 DD	 $LN7@process_ev
  000ac	00 00 00 00	 DD	 $LN7@process_ev
  000b0	00 00 00 00	 DD	 $LN8@process_ev
?process_events@@YGXXZ ENDP				; process_events
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\event.c
;	COMDAT ?set_event@@YGXHHHP6GXPAUEVENT@@@Z@Z
_TEXT	SEGMENT
_event$ = 8						; size = 4
_modifier$ = 12						; size = 4
_notify_state$ = 16					; size = 4
_func$ = 20						; size = 4
?set_event@@YGXHHHP6GXPAUEVENT@@@Z@Z PROC		; set_event, COMDAT

; 477  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 478  : 
; 479  : 	ASSERT ((modifier >= MODIFIER_NONE) && (modifier < NUM_MODIFIER_TYPES));

  00009	83 7d 0c 00	 cmp	 DWORD PTR _modifier$[ebp], 0
  0000d	7c 06		 jl	 SHORT $LN3@set_event
  0000f	83 7d 0c 09	 cmp	 DWORD PTR _modifier$[ebp], 9
  00013	7c 18		 jl	 SHORT $LN2@set_event
$LN3@set_event:
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??set_event@@YGXHHHP6GXPAUEVENT@@@Z@Z@4JA
  0001a	83 c0 02	 add	 eax, 2
  0001d	50		 push	 eax
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@DMNDEBFK@c?3?2users?2nhv90?2projects?2eech?2mo@
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@FENKMJKK@?$CImodifier?5?$DO?$DN?5MODIFIER_NONE?$CJ?5?$CG?$CG?5@
  00028	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@set_event:

; 480  : 
; 481  : 	#if EVENT_DEBUG
; 482  : 
; 483  : 	debug_log ("EVENT: SET EVENT: event %d, modifier %d, notify_state %d, function %d", event, modifier, notify_state, func);
; 484  : 
; 485  : 
; 486  : 	if (registered_events [event][modifier].in_use == TRUE)
; 487  : 	{
; 488  : 
; 489  : 		debug_log ("SET EVENT WARNING: event %d (%c) modifier %s is already in use", event, dinput_to_ascii (event), modifier_type_names [modifier]);
; 490  : 	}
; 491  : 
; 492  : 	#endif
; 493  : 
; 494  : 	registered_events [event][modifier].in_use = TRUE;

  0002d	6b 45 08 48	 imul	 eax, DWORD PTR _event$[ebp], 72
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _modifier$[ebp]
  00034	c6 84 c8 00 00
	00 00 01	 mov	 BYTE PTR ?registered_events@@3PAY08UREGISTERED_EVENT_TYPE@@A[eax+ecx*8], 1

; 495  : 
; 496  : 	registered_events [event][modifier].current_state = KEY_STATE_UP;

  0003c	6b 45 08 48	 imul	 eax, DWORD PTR _event$[ebp], 72
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _modifier$[ebp]
  00043	c6 84 c8 01 00
	00 00 01	 mov	 BYTE PTR ?registered_events@@3PAY08UREGISTERED_EVENT_TYPE@@A[eax+ecx*8+1], 1

; 497  : 
; 498  : 	registered_events [event][modifier].notify_state = notify_state;

  0004b	6b 45 08 48	 imul	 eax, DWORD PTR _event$[ebp], 72
  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _modifier$[ebp]
  00052	8a 55 10	 mov	 dl, BYTE PTR _notify_state$[ebp]
  00055	88 94 c8 02 00
	00 00		 mov	 BYTE PTR ?registered_events@@3PAY08UREGISTERED_EVENT_TYPE@@A[eax+ecx*8+2], dl

; 499  : 
; 500  : 	registered_events [event][modifier].function = func;

  0005c	6b 45 08 48	 imul	 eax, DWORD PTR _event$[ebp], 72
  00060	8b 4d 0c	 mov	 ecx, DWORD PTR _modifier$[ebp]
  00063	8b 55 14	 mov	 edx, DWORD PTR _func$[ebp]
  00066	89 94 c8 04 00
	00 00		 mov	 DWORD PTR ?registered_events@@3PAY08UREGISTERED_EVENT_TYPE@@A[eax+ecx*8+4], edx

; 501  : }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 10 00	 ret	 16			; 00000010H
?set_event@@YGXHHHP6GXPAUEVENT@@@Z@Z ENDP		; set_event
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\event.c
;	COMDAT ?get_event@@YGHPAUEVENT@@@Z
_TEXT	SEGMENT
_ev$ = 8						; size = 4
?get_event@@YGHPAUEVENT@@@Z PROC			; get_event, COMDAT

; 440  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 441  : 	ASSERT ( ev );

  00009	83 7d 08 00	 cmp	 DWORD PTR _ev$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN2@get_event
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??get_event@@YGHPAUEVENT@@@Z@4JA
  00014	83 c0 01	 add	 eax, 1
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@DMNDEBFK@c?3?2users?2nhv90?2projects?2eech?2mo@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02DHMHPBFG@ev@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@get_event:

; 442  : 
; 443  : 	WaitForSingleObject ( mutex, INFINITE );

  00027	6a ff		 push	 -1
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  0002e	50		 push	 eax
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 444  : 
; 445  : 	if ( event_list_size )

  00035	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?event_list_size@@3HA, 0
  0003c	74 60		 je	 SHORT $LN3@get_event

; 446  : 	{
; 447  : 
; 448  : 		memcpy ( ev, &event_list[event_output], sizeof ( event ) );

  0003e	6a 14		 push	 20			; 00000014H
  00040	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_output@@3HA, 20
  00047	05 00 00 00 00	 add	 eax, OFFSET ?event_list@@3PAUEVENT@@A
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _ev$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 _memcpy
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 449  : 
; 450  : 		event_output++;

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR ?event_output@@3HA
  0005e	83 c0 01	 add	 eax, 1
  00061	a3 00 00 00 00	 mov	 DWORD PTR ?event_output@@3HA, eax

; 451  : 
; 452  : 		if ( event_output == MAX_NUMBER_EVENTS )

  00066	81 3d 00 00 00
	00 00 01 00 00	 cmp	 DWORD PTR ?event_output@@3HA, 256 ; 00000100H
  00070	75 0a		 jne	 SHORT $LN5@get_event

; 453  : 		{
; 454  : 
; 455  : 			event_output = 0;

  00072	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?event_output@@3HA, 0
$LN5@get_event:

; 456  : 		}
; 457  : 
; 458  : 		event_list_size --;

  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?event_list_size@@3HA
  00081	83 e8 01	 sub	 eax, 1
  00084	a3 00 00 00 00	 mov	 DWORD PTR ?event_list_size@@3HA, eax

; 459  : 
; 460  : 		ReleaseMutex ( mutex );

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  0008e	50		 push	 eax
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 461  : 
; 462  : 		return ( TRUE );

  00095	b8 01 00 00 00	 mov	 eax, 1
  0009a	eb 10		 jmp	 SHORT $LN1@get_event

; 463  : 	}
; 464  : 	else

  0009c	eb 0e		 jmp	 SHORT $LN1@get_event
$LN3@get_event:

; 465  : 	{
; 466  : 		ReleaseMutex ( mutex );

  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  000a3	50		 push	 eax
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 467  : 
; 468  : 		return ( FALSE );

  000aa	33 c0		 xor	 eax, eax
$LN1@get_event:

; 469  : 	}
; 470  : }

  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
?get_event@@YGHPAUEVENT@@@Z ENDP			; get_event
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\event.c
;	COMDAT ?create_mouse_move_event@@YGXHHH@Z
_TEXT	SEGMENT
_last_event_index$ = -4					; size = 4
_dx$ = 8						; size = 4
_dy$ = 12						; size = 4
_dz$ = 16						; size = 4
?create_mouse_move_event@@YGXHHH@Z PROC			; create_mouse_move_event, COMDAT

; 382  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 383  : 	int
; 384  : 		last_event_index;
; 385  : 
; 386  : 	WaitForSingleObject ( mutex, INFINITE );

  00009	6a ff		 push	 -1
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 387  : 
; 388  : 	if ( event_list_size == MAX_NUMBER_EVENTS )

  00017	81 3d 00 00 00
	00 00 01 00 00	 cmp	 DWORD PTR ?event_list_size@@3HA, 256 ; 00000100H
  00021	75 11		 jne	 SHORT $LN2@create_mou

; 389  : 	{
; 390  : 		ReleaseMutex ( mutex );

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 391  : 
; 392  : 		return;

  0002f	e9 16 01 00 00	 jmp	 $LN1@create_mou
$LN2@create_mou:

; 393  : 	}
; 394  : 
; 395  : 	last_event_index = event_input - 1;

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?event_input@@3HA
  00039	83 e8 01	 sub	 eax, 1
  0003c	89 45 fc	 mov	 DWORD PTR _last_event_index$[ebp], eax

; 396  : 
; 397  : 	if ( last_event_index < 0 )

  0003f	79 07		 jns	 SHORT $LN3@create_mou

; 398  : 	{
; 399  : 
; 400  : 		last_event_index = MAX_NUMBER_EVENTS - 1;

  00041	c7 45 fc ff 00
	00 00		 mov	 DWORD PTR _last_event_index$[ebp], 255 ; 000000ffH
$LN3@create_mou:

; 401  : 	}
; 402  : 
; 403  : 	if ( ( event_list_size ) && ( event_list[last_event_index].type == EVENT_TYPE_MOUSE_MOVE ) )

  00048	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?event_list_size@@3HA, 0
  0004f	74 5d		 je	 SHORT $LN4@create_mou
  00051	6b 45 fc 14	 imul	 eax, DWORD PTR _last_event_index$[ebp], 20
  00055	83 b8 00 00 00
	00 03		 cmp	 DWORD PTR ?event_list@@3PAUEVENT@@A[eax], 3
  0005c	75 50		 jne	 SHORT $LN4@create_mou

; 404  : 	{
; 405  : 
; 406  : 		event_list[last_event_index].dx += dx;

  0005e	6b 45 fc 14	 imul	 eax, DWORD PTR _last_event_index$[ebp], 20
  00062	0f bf 88 0c 00
	00 00		 movsx	 ecx, WORD PTR ?event_list@@3PAUEVENT@@A[eax+12]
  00069	03 4d 08	 add	 ecx, DWORD PTR _dx$[ebp]
  0006c	6b 55 fc 14	 imul	 edx, DWORD PTR _last_event_index$[ebp], 20
  00070	66 89 8a 0c 00
	00 00		 mov	 WORD PTR ?event_list@@3PAUEVENT@@A[edx+12], cx

; 407  : 		event_list[last_event_index].dy += dy;

  00077	6b 45 fc 14	 imul	 eax, DWORD PTR _last_event_index$[ebp], 20
  0007b	0f bf 88 0e 00
	00 00		 movsx	 ecx, WORD PTR ?event_list@@3PAUEVENT@@A[eax+14]
  00082	03 4d 0c	 add	 ecx, DWORD PTR _dy$[ebp]
  00085	6b 55 fc 14	 imul	 edx, DWORD PTR _last_event_index$[ebp], 20
  00089	66 89 8a 0e 00
	00 00		 mov	 WORD PTR ?event_list@@3PAUEVENT@@A[edx+14], cx

; 408  : 		event_list[last_event_index].dz += dz;

  00090	6b 45 fc 14	 imul	 eax, DWORD PTR _last_event_index$[ebp], 20
  00094	0f bf 88 10 00
	00 00		 movsx	 ecx, WORD PTR ?event_list@@3PAUEVENT@@A[eax+16]
  0009b	03 4d 10	 add	 ecx, DWORD PTR _dz$[ebp]
  0009e	6b 55 fc 14	 imul	 edx, DWORD PTR _last_event_index$[ebp], 20
  000a2	66 89 8a 10 00
	00 00		 mov	 WORD PTR ?event_list@@3PAUEVENT@@A[edx+16], cx

; 409  : 	}
; 410  : 	else

  000a9	e9 90 00 00 00	 jmp	 $LN5@create_mou
$LN4@create_mou:

; 411  : 	{
; 412  : 
; 413  : 		memset (&event_list [event_input], 0, sizeof (event));

  000ae	6a 14		 push	 20			; 00000014H
  000b0	6a 00		 push	 0
  000b2	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  000b9	05 00 00 00 00	 add	 eax, OFFSET ?event_list@@3PAUEVENT@@A
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _memset
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 414  : 
; 415  : 		event_list[event_input].type = EVENT_TYPE_MOUSE_MOVE;

  000c7	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  000ce	c7 80 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?event_list@@3PAUEVENT@@A[eax], 3

; 416  : 
; 417  : 		event_list[event_input].dx = dx;

  000d8	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  000df	66 8b 4d 08	 mov	 cx, WORD PTR _dx$[ebp]
  000e3	66 89 88 0c 00
	00 00		 mov	 WORD PTR ?event_list@@3PAUEVENT@@A[eax+12], cx

; 418  : 		event_list[event_input].dy = dy;

  000ea	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  000f1	66 8b 4d 0c	 mov	 cx, WORD PTR _dy$[ebp]
  000f5	66 89 88 0e 00
	00 00		 mov	 WORD PTR ?event_list@@3PAUEVENT@@A[eax+14], cx

; 419  : 		event_list[event_input].dz = dz;

  000fc	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  00103	66 8b 4d 10	 mov	 cx, WORD PTR _dz$[ebp]
  00107	66 89 88 10 00
	00 00		 mov	 WORD PTR ?event_list@@3PAUEVENT@@A[eax+16], cx

; 420  : 
; 421  : 		event_input++;

  0010e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?event_input@@3HA
  00113	83 c0 01	 add	 eax, 1
  00116	a3 00 00 00 00	 mov	 DWORD PTR ?event_input@@3HA, eax

; 422  : 
; 423  : 		if ( event_input == MAX_NUMBER_EVENTS )

  0011b	81 3d 00 00 00
	00 00 01 00 00	 cmp	 DWORD PTR ?event_input@@3HA, 256 ; 00000100H
  00125	75 0a		 jne	 SHORT $LN6@create_mou

; 424  : 		{
; 425  : 
; 426  : 			event_input = 0;

  00127	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?event_input@@3HA, 0
$LN6@create_mou:

; 427  : 		}
; 428  : 
; 429  : 		event_list_size++;

  00131	a1 00 00 00 00	 mov	 eax, DWORD PTR ?event_list_size@@3HA
  00136	83 c0 01	 add	 eax, 1
  00139	a3 00 00 00 00	 mov	 DWORD PTR ?event_list_size@@3HA, eax
$LN5@create_mou:

; 430  : 	}
; 431  : 
; 432  : 	ReleaseMutex ( mutex );

  0013e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  00143	50		 push	 eax
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
$LN1@create_mou:

; 433  : }

  0014a	5f		 pop	 edi
  0014b	5e		 pop	 esi
  0014c	5b		 pop	 ebx
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 0c 00	 ret	 12			; 0000000cH
?create_mouse_move_event@@YGXHHH@Z ENDP			; create_mouse_move_event
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\event.c
;	COMDAT ?create_mouse_button_event@@YGXW4DEVICE_EVENTS@@W4BUTTON_STATES@@@Z
_TEXT	SEGMENT
_button$ = 8						; size = 4
_state$ = 12						; size = 4
?create_mouse_button_event@@YGXW4DEVICE_EVENTS@@W4BUTTON_STATES@@@Z PROC ; create_mouse_button_event, COMDAT

; 346  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 347  : 	WaitForSingleObject ( mutex, INFINITE );

  00009	6a ff		 push	 -1
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 348  : 
; 349  : 	if ( event_list_size == MAX_NUMBER_EVENTS )

  00017	81 3d 00 00 00
	00 00 01 00 00	 cmp	 DWORD PTR ?event_list_size@@3HA, 256 ; 00000100H
  00021	75 11		 jne	 SHORT $LN2@create_mou

; 350  : 	{
; 351  : 		ReleaseMutex ( mutex );

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 352  : 
; 353  : 		return;

  0002f	e9 8a 00 00 00	 jmp	 $LN1@create_mou
$LN2@create_mou:

; 354  : 	}
; 355  : 
; 356  : 	memset (&event_list [event_input], 0, sizeof (event));

  00034	6a 14		 push	 20			; 00000014H
  00036	6a 00		 push	 0
  00038	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  0003f	05 00 00 00 00	 add	 eax, OFFSET ?event_list@@3PAUEVENT@@A
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _memset
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 357  : 
; 358  : 	event_list[event_input].type = EVENT_TYPE_MOUSE_BUTTON;

  0004d	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  00054	c7 80 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?event_list@@3PAUEVENT@@A[eax], 2

; 359  : 
; 360  : 	event_list[event_input].button = button;

  0005e	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  00065	66 8b 4d 08	 mov	 cx, WORD PTR _button$[ebp]
  00069	66 89 88 0a 00
	00 00		 mov	 WORD PTR ?event_list@@3PAUEVENT@@A[eax+10], cx

; 361  : 
; 362  : 	event_list[event_input].state = state;

  00070	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  00077	66 8b 4d 0c	 mov	 cx, WORD PTR _state$[ebp]
  0007b	66 89 88 08 00
	00 00		 mov	 WORD PTR ?event_list@@3PAUEVENT@@A[eax+8], cx

; 363  : 
; 364  : 	event_input++;

  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR ?event_input@@3HA
  00087	83 c0 01	 add	 eax, 1
  0008a	a3 00 00 00 00	 mov	 DWORD PTR ?event_input@@3HA, eax

; 365  : 
; 366  : 	if ( event_input == MAX_NUMBER_EVENTS )

  0008f	81 3d 00 00 00
	00 00 01 00 00	 cmp	 DWORD PTR ?event_input@@3HA, 256 ; 00000100H
  00099	75 0a		 jne	 SHORT $LN3@create_mou

; 367  : 	{
; 368  : 
; 369  : 		event_input = 0;

  0009b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?event_input@@3HA, 0
$LN3@create_mou:

; 370  : 	}
; 371  : 
; 372  : 	event_list_size++;

  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?event_list_size@@3HA
  000aa	83 c0 01	 add	 eax, 1
  000ad	a3 00 00 00 00	 mov	 DWORD PTR ?event_list_size@@3HA, eax

; 373  : 
; 374  : 	ReleaseMutex ( mutex );

  000b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  000b7	50		 push	 eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
$LN1@create_mou:

; 375  : }

  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 08 00	 ret	 8
?create_mouse_button_event@@YGXW4DEVICE_EVENTS@@W4BUTTON_STATES@@@Z ENDP ; create_mouse_button_event
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\event.c
;	COMDAT ?create_key_event@@YGXHW4KEY_STATES@@@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_state$ = 12						; size = 4
?create_key_event@@YGXHW4KEY_STATES@@@Z PROC		; create_key_event, COMDAT

; 278  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 279  : 	WaitForSingleObject ( mutex, INFINITE );

  00009	6a ff		 push	 -1
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 280  : 
; 281  : 	if ( event_list_size == MAX_NUMBER_EVENTS )

  00017	81 3d 00 00 00
	00 00 01 00 00	 cmp	 DWORD PTR ?event_list_size@@3HA, 256 ; 00000100H
  00021	75 11		 jne	 SHORT $LN2@create_key

; 282  : 	{
; 283  : 		ReleaseMutex ( mutex );

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 284  : 
; 285  : 		return;

  0002f	e9 88 00 00 00	 jmp	 $LN1@create_key
$LN2@create_key:

; 286  : 	}
; 287  : 
; 288  : #ifdef COMMERCIAL
; 289  : 
; 290  : 	switch ( key )
; 291  : 	{
; 292  : 
; 293  : 		case DIK_RSHIFT:
; 294  : 		{
; 295  : 
; 296  : 			key = DIK_LSHIFT;
; 297  : 
; 298  : 			break;
; 299  : 		}
; 300  : 
; 301  : 		case DIK_RCONTROL:
; 302  : 		{
; 303  : 
; 304  : 			key = DIK_LCONTROL;
; 305  : 
; 306  : 			break;
; 307  : 		}
; 308  : 
; 309  : 		case DIK_RALT:
; 310  : 		{
; 311  : 
; 312  : 			key = DIK_LALT;
; 313  : 
; 314  : 			break;
; 315  : 		}
; 316  : 	}
; 317  : 
; 318  : #endif
; 319  : 
; 320  : 	memset (&event_list [event_input], 0, sizeof (event));

  00034	6a 14		 push	 20			; 00000014H
  00036	6a 00		 push	 0
  00038	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  0003f	05 00 00 00 00	 add	 eax, OFFSET ?event_list@@3PAUEVENT@@A
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _memset
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 321  : 
; 322  : 	event_list[event_input].type = EVENT_TYPE_KEY;

  0004d	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  00054	c7 80 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?event_list@@3PAUEVENT@@A[eax], 1

; 323  : 
; 324  : 	event_list[event_input].key = key;

  0005e	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  00065	8a 4d 08	 mov	 cl, BYTE PTR _key$[ebp]
  00068	88 88 06 00 00
	00		 mov	 BYTE PTR ?event_list@@3PAUEVENT@@A[eax+6], cl

; 325  : 
; 326  : 	event_list[event_input].state = state;

  0006e	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  00075	66 8b 4d 0c	 mov	 cx, WORD PTR _state$[ebp]
  00079	66 89 88 08 00
	00 00		 mov	 WORD PTR ?event_list@@3PAUEVENT@@A[eax+8], cx

; 327  : 
; 328  : 	event_input++;

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR ?event_input@@3HA
  00085	83 c0 01	 add	 eax, 1
  00088	a3 00 00 00 00	 mov	 DWORD PTR ?event_input@@3HA, eax

; 329  : 
; 330  : 	if ( event_input == MAX_NUMBER_EVENTS )

  0008d	81 3d 00 00 00
	00 00 01 00 00	 cmp	 DWORD PTR ?event_input@@3HA, 256 ; 00000100H
  00097	75 0a		 jne	 SHORT $LN3@create_key

; 331  : 	{
; 332  : 
; 333  : 		event_input = 0;

  00099	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?event_input@@3HA, 0
$LN3@create_key:

; 334  : 	}
; 335  : 
; 336  : 	event_list_size++;

  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?event_list_size@@3HA
  000a8	83 c0 01	 add	 eax, 1
  000ab	a3 00 00 00 00	 mov	 DWORD PTR ?event_list_size@@3HA, eax

; 337  : 
; 338  : 	ReleaseMutex ( mutex );

  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  000b5	50		 push	 eax
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
$LN1@create_key:

; 339  : }

  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 08 00	 ret	 8
?create_key_event@@YGXHW4KEY_STATES@@@Z ENDP		; create_key_event
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\event.c
;	COMDAT ?create_joystick_event@@YGXHHW4BUTTON_STATES@@@Z
_TEXT	SEGMENT
_device_index$ = 8					; size = 4
_button$ = 12						; size = 4
_state$ = 16						; size = 4
?create_joystick_event@@YGXHHW4BUTTON_STATES@@@Z PROC	; create_joystick_event, COMDAT

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 242  : 	WaitForSingleObject ( mutex, INFINITE );

  00009	6a ff		 push	 -1
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 243  : 
; 244  : 	if ( event_list_size == MAX_NUMBER_EVENTS )

  00017	81 3d 00 00 00
	00 00 01 00 00	 cmp	 DWORD PTR ?event_list_size@@3HA, 256 ; 00000100H
  00021	75 11		 jne	 SHORT $LN2@create_joy

; 245  : 	{
; 246  : 		ReleaseMutex ( mutex );

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 247  : 
; 248  : 		return;

  0002f	e9 85 00 00 00	 jmp	 $LN1@create_joy
$LN2@create_joy:

; 249  : 	}
; 250  : 
; 251  : 	event_list[event_input].type = EVENT_TYPE_JOYSTICK_BUTTON;

  00034	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  0003b	c7 80 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?event_list@@3PAUEVENT@@A[eax], 4

; 252  : 
; 253  : 	// button = 0 -> 31. Offset to end of event array
; 254  : 	event_list[event_input].button = button + NUM_DEVICE_EVENTS;

  00045	8b 45 0c	 mov	 eax, DWORD PTR _button$[ebp]
  00048	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  0004d	6b 0d 00 00 00
	00 14		 imul	 ecx, DWORD PTR ?event_input@@3HA, 20
  00054	66 89 81 0a 00
	00 00		 mov	 WORD PTR ?event_list@@3PAUEVENT@@A[ecx+10], ax

; 255  : 
; 256  : 	event_list[event_input].device_index = device_index;

  0005b	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  00062	8a 4d 08	 mov	 cl, BYTE PTR _device_index$[ebp]
  00065	88 88 05 00 00
	00		 mov	 BYTE PTR ?event_list@@3PAUEVENT@@A[eax+5], cl

; 257  : 
; 258  : 	event_list[event_input].state = state;

  0006b	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?event_input@@3HA, 20
  00072	66 8b 4d 10	 mov	 cx, WORD PTR _state$[ebp]
  00076	66 89 88 08 00
	00 00		 mov	 WORD PTR ?event_list@@3PAUEVENT@@A[eax+8], cx

; 259  : 
; 260  : 	event_input++;

  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?event_input@@3HA
  00082	83 c0 01	 add	 eax, 1
  00085	a3 00 00 00 00	 mov	 DWORD PTR ?event_input@@3HA, eax

; 261  : 
; 262  : 	if ( event_input == MAX_NUMBER_EVENTS )

  0008a	81 3d 00 00 00
	00 00 01 00 00	 cmp	 DWORD PTR ?event_input@@3HA, 256 ; 00000100H
  00094	75 0a		 jne	 SHORT $LN3@create_joy

; 263  : 	{
; 264  : 
; 265  : 		event_input = 0;

  00096	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?event_input@@3HA, 0
$LN3@create_joy:

; 266  : 	}
; 267  : 
; 268  : 	event_list_size++;

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?event_list_size@@3HA
  000a5	83 c0 01	 add	 eax, 1
  000a8	a3 00 00 00 00	 mov	 DWORD PTR ?event_list_size@@3HA, eax

; 269  : 
; 270  : 	ReleaseMutex ( mutex );

  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?mutex@@3PAXA
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
$LN1@create_joy:

; 271  : }

  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 0c 00	 ret	 12			; 0000000cH
?create_joystick_event@@YGXHHW4BUTTON_STATES@@@Z ENDP	; create_joystick_event
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\event.c
;	COMDAT ?reset_events@@YGXXZ
_TEXT	SEGMENT
_loop1$ = -4						; size = 4
?reset_events@@YGXXZ PROC				; reset_events, COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 187  : 
; 188  : 	int
; 189  : 		loop1;
; 190  : 
; 191  : 	#if DEBUG_EVENT_
; 192  : 
; 193  : 	debug_log ("EVENT: reset events ");
; 194  : 
; 195  : 	#endif
; 196  : 	for (loop1 = 0; loop1 < MAX_NUMBER_REGISTERED_EVENTS; loop1 ++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _loop1$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@reset_even
$LN2@reset_even:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _loop1$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _loop1$[ebp], eax
$LN4@reset_even:
  0001b	81 7d fc 2c 01
	00 00		 cmp	 DWORD PTR _loop1$[ebp], 300 ; 0000012cH
  00022	7d 0b		 jge	 SHORT $LN1@reset_even

; 197  : 	{
; 198  : 
; 199  : 		reset_event_key (loop1);

  00024	8b 45 fc	 mov	 eax, DWORD PTR _loop1$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?reset_event_key@@YGXH@Z ; reset_event_key

; 200  : 	}

  0002d	eb e3		 jmp	 SHORT $LN2@reset_even
$LN1@reset_even:

; 201  : }

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?reset_events@@YGXXZ ENDP				; reset_events
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\event.c
;	COMDAT ?reset_event_key@@YGXH@Z
_TEXT	SEGMENT
_ev$ = -24						; size = 20
_loop2$ = -4						; size = 4
_dik_code$ = 8						; size = 4
?reset_event_key@@YGXH@Z PROC				; reset_event_key, COMDAT

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 209  : 	int
; 210  : 		loop2;
; 211  : 
; 212  : 	event
; 213  : 		ev;
; 214  : 
; 215  : 	ev.state = KEY_STATE_UP;

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	66 89 45 f0	 mov	 WORD PTR _ev$[ebp+8], ax

; 216  : 
; 217  : 	for (loop2 = 0; loop2 < NUM_MODIFIER_TYPES; loop2 ++)

  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _loop2$[ebp], 0
  00019	eb 09		 jmp	 SHORT $LN4@reset_even
$LN2@reset_even:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _loop2$[ebp]
  0001e	83 c0 01	 add	 eax, 1
  00021	89 45 fc	 mov	 DWORD PTR _loop2$[ebp], eax
$LN4@reset_even:
  00024	83 7d fc 09	 cmp	 DWORD PTR _loop2$[ebp], 9
  00028	7d 77		 jge	 SHORT $LN1@reset_even

; 218  : 	{
; 219  : 
; 220  : 		if ((registered_events [dik_code][loop2].in_use) &&

  0002a	6b 45 08 48	 imul	 eax, DWORD PTR _dik_code$[ebp], 72
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _loop2$[ebp]
  00031	0f b6 94 c8 00
	00 00 00	 movzx	 edx, BYTE PTR ?registered_events@@3PAY08UREGISTERED_EVENT_TYPE@@A[eax+ecx*8]
  00039	85 d2		 test	 edx, edx
  0003b	74 5f		 je	 SHORT $LN5@reset_even
  0003d	6b 45 08 48	 imul	 eax, DWORD PTR _dik_code$[ebp], 72
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _loop2$[ebp]
  00044	0f b6 94 c8 01
	00 00 00	 movzx	 edx, BYTE PTR ?registered_events@@3PAY08UREGISTERED_EVENT_TYPE@@A[eax+ecx*8+1]
  0004c	83 fa 02	 cmp	 edx, 2
  0004f	75 4b		 jne	 SHORT $LN5@reset_even

; 221  : 			(registered_events [dik_code][loop2].current_state == KEY_STATE_DOWN))
; 222  : 
; 223  : 		{
; 224  : 			if ((registered_events [dik_code][loop2].notify_state == BUTTON_STATE_EITHER) ||

  00051	6b 45 08 48	 imul	 eax, DWORD PTR _dik_code$[ebp], 72
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _loop2$[ebp]
  00058	0f b6 94 c8 02
	00 00 00	 movzx	 edx, BYTE PTR ?registered_events@@3PAY08UREGISTERED_EVENT_TYPE@@A[eax+ecx*8+2]
  00060	83 fa 03	 cmp	 edx, 3
  00063	74 14		 je	 SHORT $LN7@reset_even
  00065	6b 45 08 48	 imul	 eax, DWORD PTR _dik_code$[ebp], 72
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _loop2$[ebp]
  0006c	0f b6 94 c8 02
	00 00 00	 movzx	 edx, BYTE PTR ?registered_events@@3PAY08UREGISTERED_EVENT_TYPE@@A[eax+ecx*8+2]
  00074	83 fa 01	 cmp	 edx, 1
  00077	75 23		 jne	 SHORT $LN5@reset_even
$LN7@reset_even:

; 225  : 			(registered_events [dik_code][loop2].notify_state == BUTTON_STATE_UP))
; 226  : 			{
; 227  : 
; 228  : 				registered_events [dik_code][loop2].function (&ev);

  00079	8d 45 e8	 lea	 eax, DWORD PTR _ev$[ebp]
  0007c	50		 push	 eax
  0007d	6b 4d 08 48	 imul	 ecx, DWORD PTR _dik_code$[ebp], 72
  00081	8b 55 fc	 mov	 edx, DWORD PTR _loop2$[ebp]
  00084	8b 84 d1 04 00
	00 00		 mov	 eax, DWORD PTR ?registered_events@@3PAY08UREGISTERED_EVENT_TYPE@@A[ecx+edx*8+4]
  0008b	ff d0		 call	 eax

; 229  : 
; 230  : 				registered_events [dik_code][loop2].current_state = KEY_STATE_INVALID;

  0008d	6b 45 08 48	 imul	 eax, DWORD PTR _dik_code$[ebp], 72
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _loop2$[ebp]
  00094	c6 84 c8 01 00
	00 00 00	 mov	 BYTE PTR ?registered_events@@3PAY08UREGISTERED_EVENT_TYPE@@A[eax+ecx*8+1], 0
$LN5@reset_even:

; 231  : 			}
; 232  : 		}
; 233  : 	}

  0009c	e9 7a ff ff ff	 jmp	 $LN2@reset_even
$LN1@reset_even:

; 234  : }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
?reset_event_key@@YGXH@Z ENDP				; reset_event_key
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\event.c
;	COMDAT ?clear_events@@YGXXZ
_TEXT	SEGMENT
?clear_events@@YGXXZ PROC				; clear_events, COMDAT

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 171  : 
; 172  : 	#if DEBUG_EVENT_
; 173  : 
; 174  : 	debug_log ("EVENT: clear events ");
; 175  : 
; 176  : 	#endif
; 177  : 
; 178  : 	memset (registered_events, 0, sizeof (registered_events));

  00009	68 60 54 00 00	 push	 21600			; 00005460H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET ?registered_events@@3PAY08UREGISTERED_EVENT_TYPE@@A ; registered_events
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 179  : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?clear_events@@YGXXZ ENDP				; clear_events
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\event.c
;	COMDAT ?initialise_event_system@@YGHXZ
_TEXT	SEGMENT
?initialise_event_system@@YGHXZ PROC			; initialise_event_system, COMDAT

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 145  : 	mutex = CreateMutex ( NULL, FALSE, NULL );

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?mutex@@3PAXA, eax

; 146  : 	ASSERT ( mutex );

  0001a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?mutex@@3PAXA, 0
  00021	75 18		 jne	 SHORT $LN2@initialise
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??initialise_event_system@@YGHXZ@4JA
  00028	83 c0 02	 add	 eax, 2
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@DMNDEBFK@c?3?2users?2nhv90?2projects?2eech?2mo@
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_05IGMCOAJJ@mutex@
  00036	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@initialise:

; 147  : 
; 148  : 	event_input = 1;

  0003b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?event_input@@3HA, 1

; 149  : 
; 150  : 	event_output = 1;

  00045	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?event_output@@3HA, 1

; 151  : 
; 152  : 	event_list_size = 0;

  0004f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?event_list_size@@3HA, 0

; 153  : 
; 154  : 	last_key_event_time = 0;

  00059	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?last_key_event_time@@3HA, 0 ; last_key_event_time

; 155  : 
; 156  : 	last_joystick_event_time = 0;

  00063	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?last_joystick_event_time@@3HA, 0 ; last_joystick_event_time

; 157  : 
; 158  : 	last_mouse_event_time = 0;

  0006d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?last_mouse_event_time@@3HA, 0 ; last_mouse_event_time

; 159  : 
; 160  : 	clear_events ();

  00077	e8 00 00 00 00	 call	 ?clear_events@@YGXXZ	; clear_events

; 161  : 
; 162  : 	return ( TRUE );

  0007c	b8 01 00 00 00	 mov	 eax, 1

; 163  : }

  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
?initialise_event_system@@YGHXZ ENDP			; initialise_event_system
_TEXT	ENDS
END
