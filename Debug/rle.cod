; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\graphics\rle.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?convert_tga_to_rle@@YGXPBD0@Z			; convert_tga_to_rle
PUBLIC	?convert_psd_to_rle@@YGXPBD0@Z			; convert_psd_to_rle
PUBLIC	?convert_and_dither_psd_to_rle@@YGXPBD0@Z	; convert_and_dither_psd_to_rle
PUBLIC	?blit_rle_graphic@@YGXPBEHH@Z			; blit_rle_graphic
PUBLIC	?__LINE__Var@?0??convert_tga_to_rle@@YGXPBD0@Z@4JA ; `convert_tga_to_rle'::`1'::__LINE__Var
PUBLIC	??_C@_0DC@OHLBNDJK@?$CFs?5must?5have?532?5bits?1pixel?5for?5@ ; `string'
PUBLIC	??_C@_0DE@EPAEFMM@c?3?2users?2nhv90?2projects?2eech?2mo@ ; `string'
PUBLIC	??_C@_09IBNJLIFC@rle_image@			; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_0DB@EICFDLJD@Unable?5to?5open?5file?5?$CFs?5during?5c@ ; `string'
PUBLIC	??_C@_0DF@OJEINFOA@?$CFs?5must?5have?54?5channels?1pixel?5f@ ; `string'
PUBLIC	??_C@_0DB@JMCOCMMM@Unable?5to?5open?5file?5?$CFs?5during?5c@ ; `string'
PUBLIC	?__LINE__Var@?0??blit_rle_graphic@@YGXPBEHH@Z@4JA ; `blit_rle_graphic'::`1'::__LINE__Var
PUBLIC	??_C@_0M@OAFHCACA@rle_graphic@			; `string'
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	_memcpy:PROC
EXTRN	?process_assert@@YGXPBD0H@Z:PROC		; process_assert
EXTRN	?debug_fatal@@YAXPBDZZ:PROC			; debug_fatal
EXTRN	?safe_malloc_memory@@YGPAXI@Z:PROC		; safe_malloc_memory
EXTRN	?safe_free@@YGXPAX@Z:PROC			; safe_free
EXTRN	?get_screen_data@@YGPAEPAUSCREEN@@@Z:PROC	; get_screen_data
EXTRN	?get_screen_pitch@@YGHPAUSCREEN@@@Z:PROC	; get_screen_pitch
EXTRN	?load_tga_file@@YGPAXPBDPAF1PAH@Z:PROC		; load_tga_file
EXTRN	?load_psd_file@@YGPAXPBDPAH11@Z:PROC		; load_psd_file
EXTRN	?compute_dithered_rgba_image@@YGXHHPAUPSD_RGBA@@PAG@Z:PROC ; compute_dithered_rgba_image
EXTRN	?active_screen@@3PAUSCREEN@@A:DWORD		; active_screen
EXTRN	?active_screen_red_mask@@3HA:DWORD		; active_screen_red_mask
EXTRN	?active_screen_red_shift@@3HA:DWORD		; active_screen_red_shift
EXTRN	?active_screen_green_mask@@3HA:DWORD		; active_screen_green_mask
EXTRN	?active_screen_green_shift@@3HA:DWORD		; active_screen_green_shift
EXTRN	?active_screen_blue_mask@@3HA:DWORD		; active_screen_blue_mask
EXTRN	?active_screen_blue_shift@@3HA:DWORD		; active_screen_blue_shift
EXTRN	?active_screen_alpha_mask@@3HA:DWORD		; active_screen_alpha_mask
EXTRN	?active_screen_alpha_shift@@3HA:DWORD		; active_screen_alpha_shift
;	COMDAT ??_C@_0M@OAFHCACA@rle_graphic@
CONST	SEGMENT
??_C@_0M@OAFHCACA@rle_graphic@ DB 'rle_graphic', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??blit_rle_graphic@@YGXPBEHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??blit_rle_graphic@@YGXPBEHH@Z@4JA DD 02ecH ; `blit_rle_graphic'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DB@JMCOCMMM@Unable?5to?5open?5file?5?$CFs?5during?5c@
CONST	SEGMENT
??_C@_0DB@JMCOCMMM@Unable?5to?5open?5file?5?$CFs?5during?5c@ DB 'Unable t'
	DB	'o open file %s during convert_psd_to_rle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@OJEINFOA@?$CFs?5must?5have?54?5channels?1pixel?5f@
CONST	SEGMENT
??_C@_0DF@OJEINFOA@?$CFs?5must?5have?54?5channels?1pixel?5f@ DB '%s must '
	DB	'have 4 channels/pixel for convert_psd_to_rle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@EICFDLJD@Unable?5to?5open?5file?5?$CFs?5during?5c@
CONST	SEGMENT
??_C@_0DB@EICFDLJD@Unable?5to?5open?5file?5?$CFs?5during?5c@ DB 'Unable t'
	DB	'o open file %s during convert_tga_to_rle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09IBNJLIFC@rle_image@
CONST	SEGMENT
??_C@_09IBNJLIFC@rle_image@ DB 'rle_image', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@EPAEFMM@c?3?2users?2nhv90?2projects?2eech?2mo@
CONST	SEGMENT
??_C@_0DE@EPAEFMM@c?3?2users?2nhv90?2projects?2eech?2mo@ DB 'c:\users\nhv'
	DB	'90\projects\eech\modules\graphics\rle.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@OHLBNDJK@?$CFs?5must?5have?532?5bits?1pixel?5for?5@
CONST	SEGMENT
??_C@_0DC@OHLBNDJK@?$CFs?5must?5have?532?5bits?1pixel?5for?5@ DB '%s must'
	DB	' have 32 bits/pixel for convert_tga_to_rle', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??convert_tga_to_rle@@YGXPBD0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??convert_tga_to_rle@@YGXPBD0@Z@4JA DD 063H ; `convert_tga_to_rle'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\rle.c
;	COMDAT ?blit_rle_graphic@@YGXPBEHH@Z
_TEXT	SEGMENT
_wt$ = -32						; size = 4
_screen_data$ = -28					; size = 4
_rd$ = -24						; size = 4
_x_add$ = -20						; size = 4
_run_length$ = -16					; size = 4
_y_offset$ = -12					; size = 4
_x_offset$ = -8						; size = 4
_screen_pitch$ = -4					; size = 4
_rle_graphic$ = 8					; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?blit_rle_graphic@@YGXPBEHH@Z PROC			; blit_rle_graphic, COMDAT

; 748  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 749  : 	int
; 750  : 		screen_pitch,
; 751  : 		x_offset,
; 752  : 		y_offset,
; 753  : 		run_length,
; 754  : 		x_add;
; 755  : 
; 756  : 	const unsigned char
; 757  : 		*rd;
; 758  : 	unsigned char
; 759  : 		*screen_data,
; 760  : 		*wt;
; 761  : 
; 762  : 	ASSERT (rle_graphic);

  00009	83 7d 08 00	 cmp	 DWORD PTR _rle_graphic$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN6@blit_rle_g
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??blit_rle_graphic@@YGXPBEHH@Z@4JA
  00014	83 c0 0e	 add	 eax, 14			; 0000000eH
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@EPAEFMM@c?3?2users?2nhv90?2projects?2eech?2mo@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OAFHCACA@rle_graphic@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN6@blit_rle_g:

; 763  : 
; 764  : 	screen_pitch = get_screen_pitch (active_screen);

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?active_screen@@3PAUSCREEN@@A ; active_screen
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?get_screen_pitch@@YGHPAUSCREEN@@@Z ; get_screen_pitch
  00032	89 45 fc	 mov	 DWORD PTR _screen_pitch$[ebp], eax

; 765  : 
; 766  : 	screen_data = get_screen_data (active_screen);

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR ?active_screen@@3PAUSCREEN@@A ; active_screen
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?get_screen_data@@YGPAEPAUSCREEN@@@Z ; get_screen_data
  00040	89 45 e4	 mov	 DWORD PTR _screen_data$[ebp], eax

; 767  : 
; 768  : 	rd = rle_graphic;

  00043	8b 45 08	 mov	 eax, DWORD PTR _rle_graphic$[ebp]
  00046	89 45 e8	 mov	 DWORD PTR _rd$[ebp], eax

; 769  : 
; 770  : 	x_offset = get_list_item (rd, unsigned short int);

  00049	8b 45 e8	 mov	 eax, DWORD PTR _rd$[ebp]
  0004c	83 c0 02	 add	 eax, 2
  0004f	89 45 e8	 mov	 DWORD PTR _rd$[ebp], eax
  00052	8b 4d e8	 mov	 ecx, DWORD PTR _rd$[ebp]
  00055	0f b7 51 fe	 movzx	 edx, WORD PTR [ecx-2]
  00059	89 55 f8	 mov	 DWORD PTR _x_offset$[ebp], edx
$LN2@blit_rle_g:

; 771  : 
; 772  : 	while (x_offset != 0xFFFF)

  0005c	81 7d f8 ff ff
	00 00		 cmp	 DWORD PTR _x_offset$[ebp], 65535 ; 0000ffffH
  00063	0f 84 ad 00 00
	00		 je	 $LN1@blit_rle_g

; 773  : 	{
; 774  : 		y_offset = get_list_item (rd, unsigned short int);

  00069	8b 45 e8	 mov	 eax, DWORD PTR _rd$[ebp]
  0006c	83 c0 02	 add	 eax, 2
  0006f	89 45 e8	 mov	 DWORD PTR _rd$[ebp], eax
  00072	8b 4d e8	 mov	 ecx, DWORD PTR _rd$[ebp]
  00075	0f b7 51 fe	 movzx	 edx, WORD PTR [ecx-2]
  00079	89 55 f4	 mov	 DWORD PTR _y_offset$[ebp], edx

; 775  : 
; 776  : 		wt = screen_data + ((x + x_offset) * sizeof (rgb_packed)) + ((y + y_offset) * screen_pitch);

  0007c	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0007f	03 45 f8	 add	 eax, DWORD PTR _x_offset$[ebp]
  00082	8b 4d e4	 mov	 ecx, DWORD PTR _screen_data$[ebp]
  00085	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00088	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0008b	03 45 f4	 add	 eax, DWORD PTR _y_offset$[ebp]
  0008e	0f af 45 fc	 imul	 eax, DWORD PTR _screen_pitch$[ebp]
  00092	03 d0		 add	 edx, eax
  00094	89 55 e0	 mov	 DWORD PTR _wt$[ebp], edx

; 777  : 
; 778  : 		x_add = 0;

  00097	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _x_add$[ebp], 0
$LN4@blit_rle_g:

; 779  : 
; 780  : 		while (x_add != 0xFFFF)

  0009e	81 7d ec ff ff
	00 00		 cmp	 DWORD PTR _x_add$[ebp], 65535 ; 0000ffffH
  000a5	74 57		 je	 SHORT $LN5@blit_rle_g

; 781  : 		{
; 782  : 			wt += x_add;

  000a7	8b 45 e0	 mov	 eax, DWORD PTR _wt$[ebp]
  000aa	03 45 ec	 add	 eax, DWORD PTR _x_add$[ebp]
  000ad	89 45 e0	 mov	 DWORD PTR _wt$[ebp], eax

; 783  : 
; 784  : 			run_length = get_list_item (rd, unsigned short int);

  000b0	8b 45 e8	 mov	 eax, DWORD PTR _rd$[ebp]
  000b3	83 c0 02	 add	 eax, 2
  000b6	89 45 e8	 mov	 DWORD PTR _rd$[ebp], eax
  000b9	8b 4d e8	 mov	 ecx, DWORD PTR _rd$[ebp]
  000bc	0f b7 51 fe	 movzx	 edx, WORD PTR [ecx-2]
  000c0	89 55 f0	 mov	 DWORD PTR _run_length$[ebp], edx

; 785  : 
; 786  : 			memcpy (wt, rd, run_length);

  000c3	8b 45 f0	 mov	 eax, DWORD PTR _run_length$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d e8	 mov	 ecx, DWORD PTR _rd$[ebp]
  000ca	51		 push	 ecx
  000cb	8b 55 e0	 mov	 edx, DWORD PTR _wt$[ebp]
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 787  : 
; 788  : 			rd += run_length;

  000d7	8b 45 e8	 mov	 eax, DWORD PTR _rd$[ebp]
  000da	03 45 f0	 add	 eax, DWORD PTR _run_length$[ebp]
  000dd	89 45 e8	 mov	 DWORD PTR _rd$[ebp], eax

; 789  : 			wt += run_length;

  000e0	8b 45 e0	 mov	 eax, DWORD PTR _wt$[ebp]
  000e3	03 45 f0	 add	 eax, DWORD PTR _run_length$[ebp]
  000e6	89 45 e0	 mov	 DWORD PTR _wt$[ebp], eax

; 790  : 
; 791  : 			x_add = get_list_item (rd, unsigned short int);

  000e9	8b 45 e8	 mov	 eax, DWORD PTR _rd$[ebp]
  000ec	83 c0 02	 add	 eax, 2
  000ef	89 45 e8	 mov	 DWORD PTR _rd$[ebp], eax
  000f2	8b 4d e8	 mov	 ecx, DWORD PTR _rd$[ebp]
  000f5	0f b7 51 fe	 movzx	 edx, WORD PTR [ecx-2]
  000f9	89 55 ec	 mov	 DWORD PTR _x_add$[ebp], edx

; 792  : 		}

  000fc	eb a0		 jmp	 SHORT $LN4@blit_rle_g
$LN5@blit_rle_g:

; 793  : 
; 794  : 		x_offset = get_list_item (rd, unsigned short int);

  000fe	8b 45 e8	 mov	 eax, DWORD PTR _rd$[ebp]
  00101	83 c0 02	 add	 eax, 2
  00104	89 45 e8	 mov	 DWORD PTR _rd$[ebp], eax
  00107	8b 4d e8	 mov	 ecx, DWORD PTR _rd$[ebp]
  0010a	0f b7 51 fe	 movzx	 edx, WORD PTR [ecx-2]
  0010e	89 55 f8	 mov	 DWORD PTR _x_offset$[ebp], edx

; 795  : 	}

  00111	e9 46 ff ff ff	 jmp	 $LN2@blit_rle_g
$LN1@blit_rle_g:

; 796  : }

  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c2 0c 00	 ret	 12			; 0000000cH
?blit_rle_graphic@@YGXPBEHH@Z ENDP			; blit_rle_graphic
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\rle.c
;	COMDAT ?convert_and_dither_psd_to_rle@@YGXPBD0@Z
_TEXT	SEGMENT
tv172 = -164						; size = 4
_destination_ptr$ = -96					; size = 4
_rle_image$ = -92					; size = 4
_number_of_channels$ = -88				; size = 4
_mask$ = -84						; size = 4
_first_run$ = -80					; size = 4
_height$ = -76						; size = 4
_width$ = -72						; size = 4
_end_of_file$ = -68					; size = 2
_end_of_row$ = -64					; size = 2
_run_length_bytes$ = -60				; size = 2
_run_length$ = -56					; size = 2
_x_add$ = -52						; size = 2
_x_end$ = -48						; size = 2
_x_start$ = -44						; size = 2
_y$ = -40						; size = 2
_x$ = -36						; size = 2
_packed_rgb_col$ = -32					; size = 2
_dither_image$ = -28					; size = 4
_rgb_col$ = -24						; size = 4
_run_start$ = -20					; size = 4
_dither_col$ = -16					; size = 4
_psd_ptr$ = -12						; size = 4
_psd_image$ = -8					; size = 4
_rle_file_ptr$ = -4					; size = 4
_psd_filename$ = 8					; size = 4
_rle_filename$ = 12					; size = 4
?convert_and_dither_psd_to_rle@@YGXPBD0@Z PROC		; convert_and_dither_psd_to_rle, COMDAT

; 515  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 516  : 
; 517  : 	FILE
; 518  : 		*rle_file_ptr;
; 519  : 
; 520  : 	psd_rgba
; 521  : 		*psd_image,
; 522  : 		*psd_ptr;
; 523  : 
; 524  : 	rgb_packed
; 525  : 		*dither_col,
; 526  : 		*run_start;
; 527  : 
; 528  : 	rgb_colour
; 529  : 		rgb_col;
; 530  : 
; 531  : 	rgb_packed
; 532  : 		*dither_image,
; 533  : 		packed_rgb_col;
; 534  : 
; 535  : 	unsigned short int
; 536  : 		x,
; 537  : 		y,
; 538  : 		x_start,
; 539  : 		x_end,
; 540  : 		x_add,
; 541  : 		run_length,
; 542  : 		run_length_bytes,
; 543  : 		end_of_row = 0xFFFF,

  0000c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00011	66 89 45 c0	 mov	 WORD PTR _end_of_row$[ebp], ax

; 544  : 		end_of_file = 0xFFFF;

  00015	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0001a	66 89 45 bc	 mov	 WORD PTR _end_of_file$[ebp], ax

; 545  : 
; 546  : 	int
; 547  : 		width,
; 548  : 		height,
; 549  : 		first_run,
; 550  : 		mask,
; 551  : 		number_of_channels;
; 552  : 
; 553  : 	unsigned char
; 554  : 		*rle_image,
; 555  : 		*destination_ptr;
; 556  : 
; 557  : 	//
; 558  : 	// Load PSD file
; 559  : 	//
; 560  : 
; 561  : 	psd_image = ( psd_rgba * ) load_psd_file ( psd_filename, &width, &height, &number_of_channels );

  0001e	8d 45 a8	 lea	 eax, DWORD PTR _number_of_channels$[ebp]
  00021	50		 push	 eax
  00022	8d 4d b4	 lea	 ecx, DWORD PTR _height$[ebp]
  00025	51		 push	 ecx
  00026	8d 55 b8	 lea	 edx, DWORD PTR _width$[ebp]
  00029	52		 push	 edx
  0002a	8b 45 08	 mov	 eax, DWORD PTR _psd_filename$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?load_psd_file@@YGPAXPBDPAH11@Z ; load_psd_file
  00033	89 45 f8	 mov	 DWORD PTR _psd_image$[ebp], eax

; 562  : 
; 563  : 	if ( number_of_channels != 4 )

  00036	83 7d a8 04	 cmp	 DWORD PTR _number_of_channels$[ebp], 4
  0003a	74 11		 je	 SHORT $LN10@convert_an

; 564  : 	{
; 565  : 
; 566  : 		debug_fatal ( "%s must have 4 channels/pixel for convert_psd_to_rle", psd_filename );

  0003c	8b 45 08	 mov	 eax, DWORD PTR _psd_filename$[ebp]
  0003f	50		 push	 eax
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@OJEINFOA@?$CFs?5must?5have?54?5channels?1pixel?5f@
  00045	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  0004a	83 c4 08	 add	 esp, 8
$LN10@convert_an:

; 567  : 	}
; 568  : 
; 569  : 	//
; 570  : 	// Allocate a dither image
; 571  : 	//
; 572  : 
; 573  : 	dither_image = ( rgb_packed * ) safe_malloc ( width * height * sizeof ( rgb_packed ) );

  0004d	8b 45 b8	 mov	 eax, DWORD PTR _width$[ebp]
  00050	0f af 45 b4	 imul	 eax, DWORD PTR _height$[ebp]
  00054	d1 e0		 shl	 eax, 1
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  0005c	89 45 e4	 mov	 DWORD PTR _dither_image$[ebp], eax

; 574  : 
; 575  : 	//
; 576  : 	// Allocate a buffer memory area - must be big enough to hold the worst possible rle case
; 577  : 	//
; 578  : 
; 579  : 	rle_image = ( unsigned char * ) safe_malloc ( width * height * sizeof ( rgb_packed ) * 2 );

  0005f	8b 45 b8	 mov	 eax, DWORD PTR _width$[ebp]
  00062	0f af 45 b4	 imul	 eax, DWORD PTR _height$[ebp]
  00066	d1 e0		 shl	 eax, 1
  00068	d1 e0		 shl	 eax, 1
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00070	89 45 a4	 mov	 DWORD PTR _rle_image$[ebp], eax

; 580  : 
; 581  : 	//
; 582  : 	// Dither the image
; 583  : 	//
; 584  : 
; 585  : 	compute_dithered_rgba_image ( width, height, psd_image, ( rgb_packed * ) dither_image );

  00073	8b 45 e4	 mov	 eax, DWORD PTR _dither_image$[ebp]
  00076	50		 push	 eax
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _psd_image$[ebp]
  0007a	51		 push	 ecx
  0007b	8b 55 b4	 mov	 edx, DWORD PTR _height$[ebp]
  0007e	52		 push	 edx
  0007f	8b 45 b8	 mov	 eax, DWORD PTR _width$[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ?compute_dithered_rgba_image@@YGXHHPAUPSD_RGBA@@PAG@Z ; compute_dithered_rgba_image

; 586  : 
; 587  : 	//
; 588  : 	// Open RLE file
; 589  : 	//
; 590  : 
; 591  : 	if ( ( rle_file_ptr = fopen ( rle_filename, "wb" ) ) == NULL )

  00088	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  0008d	8b 45 0c	 mov	 eax, DWORD PTR _rle_filename$[ebp]
  00090	50		 push	 eax
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00097	83 c4 08	 add	 esp, 8
  0009a	89 45 fc	 mov	 DWORD PTR _rle_file_ptr$[ebp], eax
  0009d	83 7d fc 00	 cmp	 DWORD PTR _rle_file_ptr$[ebp], 0
  000a1	75 11		 jne	 SHORT $LN11@convert_an

; 592  : 	{
; 593  : 
; 594  : 		debug_fatal ( "Unable to open file %s during convert_psd_to_rle", rle_filename );

  000a3	8b 45 0c	 mov	 eax, DWORD PTR _rle_filename$[ebp]
  000a6	50		 push	 eax
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@JMCOCMMM@Unable?5to?5open?5file?5?$CFs?5during?5c@
  000ac	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  000b1	83 c4 08	 add	 esp, 8
$LN11@convert_an:

; 595  : 	}
; 596  : 
; 597  : 	//
; 598  : 	// Write RLE data
; 599  : 	//
; 600  : 
; 601  : 	destination_ptr = rle_image;

  000b4	8b 45 a4	 mov	 eax, DWORD PTR _rle_image$[ebp]
  000b7	89 45 a0	 mov	 DWORD PTR _destination_ptr$[ebp], eax

; 602  : 
; 603  : 	rgb_col.a = 255;

  000ba	c6 45 eb ff	 mov	 BYTE PTR _rgb_col$[ebp+3], 255 ; 000000ffH

; 604  : 
; 605  : 	for ( y = 0; y < height; y++ )

  000be	33 c0		 xor	 eax, eax
  000c0	66 89 45 d8	 mov	 WORD PTR _y$[ebp], ax
  000c4	eb 0c		 jmp	 SHORT $LN4@convert_an
$LN2@convert_an:
  000c6	66 8b 45 d8	 mov	 ax, WORD PTR _y$[ebp]
  000ca	66 83 c0 01	 add	 ax, 1
  000ce	66 89 45 d8	 mov	 WORD PTR _y$[ebp], ax
$LN4@convert_an:
  000d2	0f b7 45 d8	 movzx	 eax, WORD PTR _y$[ebp]
  000d6	3b 45 b4	 cmp	 eax, DWORD PTR _height$[ebp]
  000d9	0f 8d c1 01 00
	00		 jge	 $LN3@convert_an

; 606  : 	{
; 607  : 
; 608  : 		dither_col = dither_image + ( width * y );

  000df	0f b7 45 d8	 movzx	 eax, WORD PTR _y$[ebp]
  000e3	0f af 45 b8	 imul	 eax, DWORD PTR _width$[ebp]
  000e7	8b 4d e4	 mov	 ecx, DWORD PTR _dither_image$[ebp]
  000ea	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  000ed	89 55 f0	 mov	 DWORD PTR _dither_col$[ebp], edx

; 609  : 
; 610  : 		psd_ptr = psd_image + ( width * y );

  000f0	0f b7 45 d8	 movzx	 eax, WORD PTR _y$[ebp]
  000f4	0f af 45 b8	 imul	 eax, DWORD PTR _width$[ebp]
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _psd_image$[ebp]
  000fb	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000fe	89 55 f4	 mov	 DWORD PTR _psd_ptr$[ebp], edx

; 611  : 
; 612  : 		first_run = TRUE;

  00101	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _first_run$[ebp], 1

; 613  : 
; 614  : 		run_start = NULL;

  00108	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _run_start$[ebp], 0

; 615  : 
; 616  : 		x_start = 0;

  0010f	33 c0		 xor	 eax, eax
  00111	66 89 45 d4	 mov	 WORD PTR _x_start$[ebp], ax

; 617  : 
; 618  : 		x_end = 0;

  00115	33 c0		 xor	 eax, eax
  00117	66 89 45 d0	 mov	 WORD PTR _x_end$[ebp], ax

; 619  : 
; 620  : 		for ( x = 0; x <= width; x++ )

  0011b	33 c0		 xor	 eax, eax
  0011d	66 89 45 dc	 mov	 WORD PTR _x$[ebp], ax
  00121	eb 0c		 jmp	 SHORT $LN7@convert_an
$LN5@convert_an:
  00123	66 8b 45 dc	 mov	 ax, WORD PTR _x$[ebp]
  00127	66 83 c0 01	 add	 ax, 1
  0012b	66 89 45 dc	 mov	 WORD PTR _x$[ebp], ax
$LN7@convert_an:
  0012f	0f b7 45 dc	 movzx	 eax, WORD PTR _x$[ebp]
  00133	3b 45 b8	 cmp	 eax, DWORD PTR _width$[ebp]
  00136	0f 8f 45 01 00
	00		 jg	 $LN6@convert_an

; 621  : 		{
; 622  : 			if ( x < width )

  0013c	0f b7 45 dc	 movzx	 eax, WORD PTR _x$[ebp]
  00140	3b 45 b8	 cmp	 eax, DWORD PTR _width$[ebp]
  00143	7d 0c		 jge	 SHORT $LN12@convert_an

; 623  : 			{
; 624  : 
; 625  : 				mask = psd_ptr->a;

  00145	8b 45 f4	 mov	 eax, DWORD PTR _psd_ptr$[ebp]
  00148	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0014c	89 4d ac	 mov	 DWORD PTR _mask$[ebp], ecx

; 626  : 			}
; 627  : 			else

  0014f	eb 07		 jmp	 SHORT $LN13@convert_an
$LN12@convert_an:

; 628  : 			{
; 629  : 
; 630  : 				//
; 631  : 				// Force end of run
; 632  : 				//
; 633  : 
; 634  : 				mask = TRUE;

  00151	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR _mask$[ebp], 1
$LN13@convert_an:

; 635  : 			}
; 636  : 
; 637  : 			if ( !mask )

  00158	83 7d ac 00	 cmp	 DWORD PTR _mask$[ebp], 0
  0015c	75 19		 jne	 SHORT $LN14@convert_an

; 638  : 			{
; 639  : 
; 640  : 				//
; 641  : 				// Check for start run
; 642  : 				//
; 643  : 
; 644  : 				if ( !run_start )

  0015e	83 7d ec 00	 cmp	 DWORD PTR _run_start$[ebp], 0
  00162	75 0e		 jne	 SHORT $LN16@convert_an

; 645  : 				{
; 646  : 
; 647  : 					run_start = dither_col;

  00164	8b 45 f0	 mov	 eax, DWORD PTR _dither_col$[ebp]
  00167	89 45 ec	 mov	 DWORD PTR _run_start$[ebp], eax

; 648  : 
; 649  : 					x_start = x;

  0016a	66 8b 45 dc	 mov	 ax, WORD PTR _x$[ebp]
  0016e	66 89 45 d4	 mov	 WORD PTR _x_start$[ebp], ax
$LN16@convert_an:

; 650  : 				}
; 651  : 			}
; 652  : 			else

  00172	e9 f3 00 00 00	 jmp	 $LN15@convert_an
$LN14@convert_an:

; 653  : 			{
; 654  : 
; 655  : 				//
; 656  : 				// check for end run
; 657  : 				//
; 658  : 
; 659  : 				if ( run_start )

  00177	83 7d ec 00	 cmp	 DWORD PTR _run_start$[ebp], 0
  0017b	0f 84 e9 00 00
	00		 je	 $LN15@convert_an

; 660  : 				{
; 661  : 
; 662  : 					if ( first_run )

  00181	83 7d b0 00	 cmp	 DWORD PTR _first_run$[ebp], 0
  00185	74 31		 je	 SHORT $LN18@convert_an

; 663  : 					{
; 664  : 
; 665  : 						quick_set_list_item ( destination_ptr, unsigned short int, x_start );

  00187	8b 45 a0	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  0018a	83 c0 02	 add	 eax, 2
  0018d	89 45 a0	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  00190	8b 4d a0	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  00193	66 8b 55 d4	 mov	 dx, WORD PTR _x_start$[ebp]
  00197	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx

; 666  : 						quick_set_list_item ( destination_ptr, unsigned short int, y );

  0019b	8b 45 a0	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  0019e	83 c0 02	 add	 eax, 2
  001a1	89 45 a0	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  001a4	8b 4d a0	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  001a7	66 8b 55 d8	 mov	 dx, WORD PTR _y$[ebp]
  001ab	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx

; 667  : 
; 668  : 						first_run = FALSE;

  001af	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _first_run$[ebp], 0

; 669  : 					}
; 670  : 					else

  001b6	eb 26		 jmp	 SHORT $LN19@convert_an
$LN18@convert_an:

; 671  : 					{
; 672  : 
; 673  : 						x_add = ( x_start - x_end - 1 ) * sizeof ( packed_rgb_col );

  001b8	0f b7 45 d4	 movzx	 eax, WORD PTR _x_start$[ebp]
  001bc	0f b7 4d d0	 movzx	 ecx, WORD PTR _x_end$[ebp]
  001c0	2b c1		 sub	 eax, ecx
  001c2	8d 54 00 fe	 lea	 edx, DWORD PTR [eax+eax-2]
  001c6	66 89 55 cc	 mov	 WORD PTR _x_add$[ebp], dx

; 674  : 
; 675  : 						quick_set_list_item ( destination_ptr, unsigned short int, x_add );

  001ca	8b 45 a0	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  001cd	83 c0 02	 add	 eax, 2
  001d0	89 45 a0	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  001d3	8b 4d a0	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  001d6	66 8b 55 cc	 mov	 dx, WORD PTR _x_add$[ebp]
  001da	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx
$LN19@convert_an:

; 676  : 					}
; 677  : 
; 678  : 					x_end = x - 1;

  001de	0f b7 45 dc	 movzx	 eax, WORD PTR _x$[ebp]
  001e2	83 e8 01	 sub	 eax, 1
  001e5	66 89 45 d0	 mov	 WORD PTR _x_end$[ebp], ax

; 679  : 
; 680  : 					run_length = x - x_start;

  001e9	0f b7 45 dc	 movzx	 eax, WORD PTR _x$[ebp]
  001ed	0f b7 4d d4	 movzx	 ecx, WORD PTR _x_start$[ebp]
  001f1	2b c1		 sub	 eax, ecx
  001f3	66 89 45 c8	 mov	 WORD PTR _run_length$[ebp], ax

; 681  : 
; 682  : 					run_length_bytes = run_length * sizeof ( packed_rgb_col );

  001f7	0f b7 45 c8	 movzx	 eax, WORD PTR _run_length$[ebp]
  001fb	d1 e0		 shl	 eax, 1
  001fd	66 89 45 c4	 mov	 WORD PTR _run_length_bytes$[ebp], ax

; 683  : 
; 684  : 					quick_set_list_item ( destination_ptr, unsigned short int, run_length_bytes );

  00201	8b 45 a0	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  00204	83 c0 02	 add	 eax, 2
  00207	89 45 a0	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  0020a	8b 4d a0	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  0020d	66 8b 55 c4	 mov	 dx, WORD PTR _run_length_bytes$[ebp]
  00211	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx
$LN8@convert_an:

; 685  : 
; 686  : 					while ( run_length-- )

  00215	0f b7 45 c8	 movzx	 eax, WORD PTR _run_length$[ebp]
  00219	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv172[ebp], eax
  0021f	66 8b 4d c8	 mov	 cx, WORD PTR _run_length$[ebp]
  00223	66 83 e9 01	 sub	 cx, 1
  00227	66 89 4d c8	 mov	 WORD PTR _run_length$[ebp], cx
  0022b	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR tv172[ebp], 0
  00232	74 29		 je	 SHORT $LN9@convert_an

; 687  : 					{
; 688  : 
; 689  : 						packed_rgb_col = *run_start;

  00234	8b 45 ec	 mov	 eax, DWORD PTR _run_start$[ebp]
  00237	66 8b 08	 mov	 cx, WORD PTR [eax]
  0023a	66 89 4d e0	 mov	 WORD PTR _packed_rgb_col$[ebp], cx

; 690  : 
; 691  : 						quick_set_list_item ( destination_ptr, unsigned short int, packed_rgb_col );

  0023e	8b 45 a0	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  00241	83 c0 02	 add	 eax, 2
  00244	89 45 a0	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  00247	8b 4d a0	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  0024a	66 8b 55 e0	 mov	 dx, WORD PTR _packed_rgb_col$[ebp]
  0024e	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx

; 692  : 
; 693  : 						run_start++;

  00252	8b 45 ec	 mov	 eax, DWORD PTR _run_start$[ebp]
  00255	83 c0 02	 add	 eax, 2
  00258	89 45 ec	 mov	 DWORD PTR _run_start$[ebp], eax

; 694  : 					}

  0025b	eb b8		 jmp	 SHORT $LN8@convert_an
$LN9@convert_an:

; 695  : 
; 696  : 					run_start = NULL;

  0025d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _run_start$[ebp], 0

; 697  : 
; 698  : 					x_start = 0;

  00264	33 c0		 xor	 eax, eax
  00266	66 89 45 d4	 mov	 WORD PTR _x_start$[ebp], ax
$LN15@convert_an:

; 699  : 				}
; 700  : 			}
; 701  : 
; 702  : 			dither_col++;

  0026a	8b 45 f0	 mov	 eax, DWORD PTR _dither_col$[ebp]
  0026d	83 c0 02	 add	 eax, 2
  00270	89 45 f0	 mov	 DWORD PTR _dither_col$[ebp], eax

; 703  : 
; 704  : 			psd_ptr++;

  00273	8b 45 f4	 mov	 eax, DWORD PTR _psd_ptr$[ebp]
  00276	83 c0 04	 add	 eax, 4
  00279	89 45 f4	 mov	 DWORD PTR _psd_ptr$[ebp], eax

; 705  : 		}

  0027c	e9 a2 fe ff ff	 jmp	 $LN5@convert_an
$LN6@convert_an:

; 706  : 
; 707  : 		//
; 708  : 		// write end of row (if row occupied)
; 709  : 		//
; 710  : 
; 711  : 		if ( !first_run )

  00281	83 7d b0 00	 cmp	 DWORD PTR _first_run$[ebp], 0
  00285	75 14		 jne	 SHORT $LN20@convert_an

; 712  : 		{
; 713  : 
; 714  : 			quick_set_list_item ( destination_ptr, unsigned short int, end_of_row );

  00287	8b 45 a0	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  0028a	83 c0 02	 add	 eax, 2
  0028d	89 45 a0	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  00290	8b 4d a0	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  00293	66 8b 55 c0	 mov	 dx, WORD PTR _end_of_row$[ebp]
  00297	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx
$LN20@convert_an:

; 715  : 		}
; 716  : 	}

  0029b	e9 26 fe ff ff	 jmp	 $LN2@convert_an
$LN3@convert_an:

; 717  : 
; 718  : 	//
; 719  : 	// write end of file
; 720  : 	//
; 721  : 
; 722  : 	quick_set_list_item ( destination_ptr, unsigned short int, end_of_file );

  002a0	8b 45 a0	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  002a3	83 c0 02	 add	 eax, 2
  002a6	89 45 a0	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  002a9	8b 4d a0	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  002ac	66 8b 55 bc	 mov	 dx, WORD PTR _end_of_file$[ebp]
  002b0	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx

; 723  : 
; 724  : 	//
; 725  : 	// Write the file out
; 726  : 	//
; 727  : 
; 728  : 	fwrite ( rle_image, ( destination_ptr - rle_image ), 1, rle_file_ptr );

  002b4	8b 45 fc	 mov	 eax, DWORD PTR _rle_file_ptr$[ebp]
  002b7	50		 push	 eax
  002b8	6a 01		 push	 1
  002ba	8b 4d a0	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  002bd	2b 4d a4	 sub	 ecx, DWORD PTR _rle_image$[ebp]
  002c0	51		 push	 ecx
  002c1	8b 55 a4	 mov	 edx, DWORD PTR _rle_image$[ebp]
  002c4	52		 push	 edx
  002c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  002cb	83 c4 10	 add	 esp, 16			; 00000010H

; 729  : 
; 730  : 	//
; 731  : 	// clean up
; 732  : 	//
; 733  : 
; 734  : 	fclose ( rle_file_ptr );

  002ce	8b 45 fc	 mov	 eax, DWORD PTR _rle_file_ptr$[ebp]
  002d1	50		 push	 eax
  002d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  002d8	83 c4 04	 add	 esp, 4

; 735  : 
; 736  : 	safe_free ( rle_image );

  002db	8b 45 a4	 mov	 eax, DWORD PTR _rle_image$[ebp]
  002de	50		 push	 eax
  002df	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 737  : 
; 738  : 	safe_free ( psd_image );

  002e4	8b 45 f8	 mov	 eax, DWORD PTR _psd_image$[ebp]
  002e7	50		 push	 eax
  002e8	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 739  : 
; 740  : 	safe_free ( dither_image );

  002ed	8b 45 e4	 mov	 eax, DWORD PTR _dither_image$[ebp]
  002f0	50		 push	 eax
  002f1	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 741  : }

  002f6	5f		 pop	 edi
  002f7	5e		 pop	 esi
  002f8	5b		 pop	 ebx
  002f9	8b e5		 mov	 esp, ebp
  002fb	5d		 pop	 ebp
  002fc	c2 08 00	 ret	 8
?convert_and_dither_psd_to_rle@@YGXPBD0@Z ENDP		; convert_and_dither_psd_to_rle
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\rle.c
;	COMDAT ?convert_psd_to_rle@@YGXPBD0@Z
_TEXT	SEGMENT
tv160 = -156						; size = 4
_destination_ptr$ = -88					; size = 4
_rle_image$ = -84					; size = 4
_number_of_channels$ = -80				; size = 4
_mask$ = -76						; size = 4
_first_run$ = -72					; size = 4
_height$ = -68						; size = 4
_width$ = -64						; size = 4
_end_of_file$ = -60					; size = 2
_end_of_row$ = -56					; size = 2
_run_length_bytes$ = -52				; size = 2
_run_length$ = -48					; size = 2
_x_add$ = -44						; size = 2
_x_end$ = -40						; size = 2
_x_start$ = -36						; size = 2
_y$ = -32						; size = 2
_x$ = -28						; size = 2
_packed_rgb_col$ = -24					; size = 2
_rgb_col$ = -20						; size = 4
_run_start$ = -16					; size = 4
_psd_col$ = -12						; size = 4
_psd_image$ = -8					; size = 4
_rle_file_ptr$ = -4					; size = 4
_psd_filename$ = 8					; size = 4
_rle_filename$ = 12					; size = 4
?convert_psd_to_rle@@YGXPBD0@Z PROC			; convert_psd_to_rle, COMDAT

; 302  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 303  : 
; 304  : 	FILE
; 305  : 		*rle_file_ptr;
; 306  : 
; 307  : 	psd_rgba
; 308  : 		*psd_image,
; 309  : 		*psd_col,
; 310  : 		*run_start;
; 311  : 
; 312  : 	rgb_colour
; 313  : 		rgb_col;
; 314  : 
; 315  : 	rgb_packed
; 316  : 		packed_rgb_col;
; 317  : 
; 318  : 	unsigned short int
; 319  : 		x,
; 320  : 		y,
; 321  : 		x_start,
; 322  : 		x_end,
; 323  : 		x_add,
; 324  : 		run_length,
; 325  : 		run_length_bytes,
; 326  : 		end_of_row = 0xFFFF,

  0000c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00011	66 89 45 c8	 mov	 WORD PTR _end_of_row$[ebp], ax

; 327  : 		end_of_file = 0xFFFF;

  00015	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0001a	66 89 45 c4	 mov	 WORD PTR _end_of_file$[ebp], ax

; 328  : 
; 329  : 	int
; 330  : 		width,
; 331  : 		height,
; 332  : 		first_run,
; 333  : 		mask,
; 334  : 		number_of_channels;
; 335  : 
; 336  : 	unsigned char
; 337  : 		*rle_image,
; 338  : 		*destination_ptr;
; 339  : 
; 340  : 	//
; 341  : 	// load PSD file
; 342  : 	//
; 343  : 
; 344  : 	psd_image = ( psd_rgba * ) load_psd_file ( psd_filename, &width, &height, &number_of_channels );

  0001e	8d 45 b0	 lea	 eax, DWORD PTR _number_of_channels$[ebp]
  00021	50		 push	 eax
  00022	8d 4d bc	 lea	 ecx, DWORD PTR _height$[ebp]
  00025	51		 push	 ecx
  00026	8d 55 c0	 lea	 edx, DWORD PTR _width$[ebp]
  00029	52		 push	 edx
  0002a	8b 45 08	 mov	 eax, DWORD PTR _psd_filename$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?load_psd_file@@YGPAXPBDPAH11@Z ; load_psd_file
  00033	89 45 f8	 mov	 DWORD PTR _psd_image$[ebp], eax

; 345  : 
; 346  : 	if ( number_of_channels != 4 )

  00036	83 7d b0 04	 cmp	 DWORD PTR _number_of_channels$[ebp], 4
  0003a	74 11		 je	 SHORT $LN10@convert_ps

; 347  : 	{
; 348  : 
; 349  : 		debug_fatal ( "%s must have 4 channels/pixel for convert_psd_to_rle", psd_filename);

  0003c	8b 45 08	 mov	 eax, DWORD PTR _psd_filename$[ebp]
  0003f	50		 push	 eax
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@OJEINFOA@?$CFs?5must?5have?54?5channels?1pixel?5f@
  00045	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  0004a	83 c4 08	 add	 esp, 8
$LN10@convert_ps:

; 350  : 	}
; 351  : 
; 352  : 	//
; 353  : 	// Allocate a buffer memory area - must be big enough to hold the worst possible rle case
; 354  : 	//
; 355  : 
; 356  : 	rle_image = ( unsigned char * ) safe_malloc ( width * height * sizeof ( rgb_packed ) * 2 );

  0004d	8b 45 c0	 mov	 eax, DWORD PTR _width$[ebp]
  00050	0f af 45 bc	 imul	 eax, DWORD PTR _height$[ebp]
  00054	d1 e0		 shl	 eax, 1
  00056	d1 e0		 shl	 eax, 1
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  0005e	89 45 ac	 mov	 DWORD PTR _rle_image$[ebp], eax

; 357  : 
; 358  : 	destination_ptr = rle_image;

  00061	8b 45 ac	 mov	 eax, DWORD PTR _rle_image$[ebp]
  00064	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax

; 359  : 
; 360  : 	//
; 361  : 	// open RLE file
; 362  : 	//
; 363  : 
; 364  : 	if ( ( rle_file_ptr = fopen ( rle_filename, "wb" ) ) == NULL )

  00067	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _rle_filename$[ebp]
  0006f	50		 push	 eax
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00076	83 c4 08	 add	 esp, 8
  00079	89 45 fc	 mov	 DWORD PTR _rle_file_ptr$[ebp], eax
  0007c	83 7d fc 00	 cmp	 DWORD PTR _rle_file_ptr$[ebp], 0
  00080	75 11		 jne	 SHORT $LN11@convert_ps

; 365  : 	{
; 366  : 
; 367  : 		debug_fatal ( "Unable to open file %s during convert_psd_to_rle", rle_filename );

  00082	8b 45 0c	 mov	 eax, DWORD PTR _rle_filename$[ebp]
  00085	50		 push	 eax
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@JMCOCMMM@Unable?5to?5open?5file?5?$CFs?5during?5c@
  0008b	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  00090	83 c4 08	 add	 esp, 8
$LN11@convert_ps:

; 368  : 	}
; 369  : 
; 370  : 	//
; 371  : 	// write RLE data
; 372  : 	//
; 373  : 
; 374  : 	rgb_col.a = 255;

  00093	c6 45 ef ff	 mov	 BYTE PTR _rgb_col$[ebp+3], 255 ; 000000ffH

; 375  : 
; 376  : 	for ( y = 0; y < height; y++ )

  00097	33 c0		 xor	 eax, eax
  00099	66 89 45 e0	 mov	 WORD PTR _y$[ebp], ax
  0009d	eb 0c		 jmp	 SHORT $LN4@convert_ps
$LN2@convert_ps:
  0009f	66 8b 45 e0	 mov	 ax, WORD PTR _y$[ebp]
  000a3	66 83 c0 01	 add	 ax, 1
  000a7	66 89 45 e0	 mov	 WORD PTR _y$[ebp], ax
$LN4@convert_ps:
  000ab	0f b7 45 e0	 movzx	 eax, WORD PTR _y$[ebp]
  000af	3b 45 bc	 cmp	 eax, DWORD PTR _height$[ebp]
  000b2	0f 8d e5 01 00
	00		 jge	 $LN3@convert_ps

; 377  : 	{
; 378  : 
; 379  : 		psd_col = psd_image + ( width * y );

  000b8	0f b7 45 e0	 movzx	 eax, WORD PTR _y$[ebp]
  000bc	0f af 45 c0	 imul	 eax, DWORD PTR _width$[ebp]
  000c0	8b 4d f8	 mov	 ecx, DWORD PTR _psd_image$[ebp]
  000c3	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000c6	89 55 f4	 mov	 DWORD PTR _psd_col$[ebp], edx

; 380  : 
; 381  : 		first_run = TRUE;

  000c9	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR _first_run$[ebp], 1

; 382  : 
; 383  : 		run_start = NULL;

  000d0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _run_start$[ebp], 0

; 384  : 
; 385  : 		x_start = 0;

  000d7	33 c0		 xor	 eax, eax
  000d9	66 89 45 dc	 mov	 WORD PTR _x_start$[ebp], ax

; 386  : 
; 387  : 		x_end = 0;

  000dd	33 c0		 xor	 eax, eax
  000df	66 89 45 d8	 mov	 WORD PTR _x_end$[ebp], ax

; 388  : 
; 389  : 		for ( x = 0; x <= width; x++ )

  000e3	33 c0		 xor	 eax, eax
  000e5	66 89 45 e4	 mov	 WORD PTR _x$[ebp], ax
  000e9	eb 0c		 jmp	 SHORT $LN7@convert_ps
$LN5@convert_ps:
  000eb	66 8b 45 e4	 mov	 ax, WORD PTR _x$[ebp]
  000ef	66 83 c0 01	 add	 ax, 1
  000f3	66 89 45 e4	 mov	 WORD PTR _x$[ebp], ax
$LN7@convert_ps:
  000f7	0f b7 45 e4	 movzx	 eax, WORD PTR _x$[ebp]
  000fb	3b 45 c0	 cmp	 eax, DWORD PTR _width$[ebp]
  000fe	0f 8f 7a 01 00
	00		 jg	 $LN6@convert_ps

; 390  : 		{
; 391  : 			if ( x < width )

  00104	0f b7 45 e4	 movzx	 eax, WORD PTR _x$[ebp]
  00108	3b 45 c0	 cmp	 eax, DWORD PTR _width$[ebp]
  0010b	7d 0c		 jge	 SHORT $LN12@convert_ps

; 392  : 			{
; 393  : 
; 394  : 				mask = psd_col->a;

  0010d	8b 45 f4	 mov	 eax, DWORD PTR _psd_col$[ebp]
  00110	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00114	89 4d b4	 mov	 DWORD PTR _mask$[ebp], ecx

; 395  : 			}
; 396  : 			else

  00117	eb 07		 jmp	 SHORT $LN13@convert_ps
$LN12@convert_ps:

; 397  : 			{
; 398  : 
; 399  : 				//
; 400  : 				// force end of run
; 401  : 				//
; 402  : 
; 403  : 				mask = TRUE;

  00119	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _mask$[ebp], 1
$LN13@convert_ps:

; 404  : 			}
; 405  : 
; 406  : 			if ( !mask )

  00120	83 7d b4 00	 cmp	 DWORD PTR _mask$[ebp], 0
  00124	75 19		 jne	 SHORT $LN14@convert_ps

; 407  : 			{
; 408  : 
; 409  : 				//
; 410  : 				// check for start run
; 411  : 				//
; 412  : 
; 413  : 				if ( !run_start )

  00126	83 7d f0 00	 cmp	 DWORD PTR _run_start$[ebp], 0
  0012a	75 0e		 jne	 SHORT $LN16@convert_ps

; 414  : 				{
; 415  : 
; 416  : 					run_start = psd_col;

  0012c	8b 45 f4	 mov	 eax, DWORD PTR _psd_col$[ebp]
  0012f	89 45 f0	 mov	 DWORD PTR _run_start$[ebp], eax

; 417  : 
; 418  : 					x_start = x;

  00132	66 8b 45 e4	 mov	 ax, WORD PTR _x$[ebp]
  00136	66 89 45 dc	 mov	 WORD PTR _x_start$[ebp], ax
$LN16@convert_ps:

; 419  : 				}
; 420  : 			}
; 421  : 			else

  0013a	e9 31 01 00 00	 jmp	 $LN15@convert_ps
$LN14@convert_ps:

; 422  : 			{
; 423  : 
; 424  : 				//
; 425  : 				// check for end run
; 426  : 				//
; 427  : 
; 428  : 				if ( run_start )

  0013f	83 7d f0 00	 cmp	 DWORD PTR _run_start$[ebp], 0
  00143	0f 84 27 01 00
	00		 je	 $LN15@convert_ps

; 429  : 				{
; 430  : 					if ( first_run )

  00149	83 7d b8 00	 cmp	 DWORD PTR _first_run$[ebp], 0
  0014d	74 31		 je	 SHORT $LN18@convert_ps

; 431  : 					{
; 432  : 
; 433  : 						quick_set_list_item ( destination_ptr, unsigned short int, x_start );

  0014f	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  00152	83 c0 02	 add	 eax, 2
  00155	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  00158	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  0015b	66 8b 55 dc	 mov	 dx, WORD PTR _x_start$[ebp]
  0015f	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx

; 434  : 						quick_set_list_item ( destination_ptr, unsigned short int, y );

  00163	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  00166	83 c0 02	 add	 eax, 2
  00169	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  0016c	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  0016f	66 8b 55 e0	 mov	 dx, WORD PTR _y$[ebp]
  00173	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx

; 435  : 
; 436  : 						first_run = FALSE;

  00177	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _first_run$[ebp], 0

; 437  : 					}
; 438  : 					else

  0017e	eb 26		 jmp	 SHORT $LN19@convert_ps
$LN18@convert_ps:

; 439  : 					{
; 440  : 						x_add = ( x_start - x_end - 1 ) * sizeof ( packed_rgb_col );

  00180	0f b7 45 dc	 movzx	 eax, WORD PTR _x_start$[ebp]
  00184	0f b7 4d d8	 movzx	 ecx, WORD PTR _x_end$[ebp]
  00188	2b c1		 sub	 eax, ecx
  0018a	8d 54 00 fe	 lea	 edx, DWORD PTR [eax+eax-2]
  0018e	66 89 55 d4	 mov	 WORD PTR _x_add$[ebp], dx

; 441  : 
; 442  : 						quick_set_list_item ( destination_ptr, unsigned short int, x_add );

  00192	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  00195	83 c0 02	 add	 eax, 2
  00198	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  0019b	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  0019e	66 8b 55 d4	 mov	 dx, WORD PTR _x_add$[ebp]
  001a2	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx
$LN19@convert_ps:

; 443  : 					}
; 444  : 
; 445  : 					x_end = x - 1;

  001a6	0f b7 45 e4	 movzx	 eax, WORD PTR _x$[ebp]
  001aa	83 e8 01	 sub	 eax, 1
  001ad	66 89 45 d8	 mov	 WORD PTR _x_end$[ebp], ax

; 446  : 
; 447  : 					run_length = x - x_start;

  001b1	0f b7 45 e4	 movzx	 eax, WORD PTR _x$[ebp]
  001b5	0f b7 4d dc	 movzx	 ecx, WORD PTR _x_start$[ebp]
  001b9	2b c1		 sub	 eax, ecx
  001bb	66 89 45 d0	 mov	 WORD PTR _run_length$[ebp], ax

; 448  : 
; 449  : 					run_length_bytes = run_length * sizeof ( packed_rgb_col );

  001bf	0f b7 45 d0	 movzx	 eax, WORD PTR _run_length$[ebp]
  001c3	d1 e0		 shl	 eax, 1
  001c5	66 89 45 cc	 mov	 WORD PTR _run_length_bytes$[ebp], ax

; 450  : 
; 451  : 					quick_set_list_item ( destination_ptr, unsigned short int, run_length_bytes );

  001c9	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  001cc	83 c0 02	 add	 eax, 2
  001cf	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  001d2	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  001d5	66 8b 55 cc	 mov	 dx, WORD PTR _run_length_bytes$[ebp]
  001d9	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx
$LN8@convert_ps:

; 452  : 
; 453  : 					while ( run_length-- )

  001dd	0f b7 45 d0	 movzx	 eax, WORD PTR _run_length$[ebp]
  001e1	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv160[ebp], eax
  001e7	66 8b 4d d0	 mov	 cx, WORD PTR _run_length$[ebp]
  001eb	66 83 e9 01	 sub	 cx, 1
  001ef	66 89 4d d0	 mov	 WORD PTR _run_length$[ebp], cx
  001f3	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR tv160[ebp], 0
  001fa	74 67		 je	 SHORT $LN9@convert_ps

; 454  : 					{
; 455  : 
; 456  : 						rgb_col.r = run_start->r;

  001fc	8b 45 f0	 mov	 eax, DWORD PTR _run_start$[ebp]
  001ff	8a 08		 mov	 cl, BYTE PTR [eax]
  00201	88 4d ee	 mov	 BYTE PTR _rgb_col$[ebp+2], cl

; 457  : 						rgb_col.g = run_start->g;

  00204	8b 45 f0	 mov	 eax, DWORD PTR _run_start$[ebp]
  00207	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0020a	88 4d ed	 mov	 BYTE PTR _rgb_col$[ebp+1], cl

; 458  : 						rgb_col.b = run_start->b;

  0020d	8b 45 f0	 mov	 eax, DWORD PTR _run_start$[ebp]
  00210	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00213	88 4d ec	 mov	 BYTE PTR _rgb_col$[ebp], cl

; 459  : 
; 460  : 						packed_rgb_col = get_general_packed_colour ( rgb_col );

  00216	0f b6 45 ee	 movzx	 eax, BYTE PTR _rgb_col$[ebp+2]
  0021a	c1 e0 08	 shl	 eax, 8
  0021d	25 00 f8 00 00	 and	 eax, 63488		; 0000f800H
  00222	0f b6 4d ed	 movzx	 ecx, BYTE PTR _rgb_col$[ebp+1]
  00226	c1 e1 05	 shl	 ecx, 5
  00229	81 e1 e0 07 00
	00		 and	 ecx, 2016		; 000007e0H
  0022f	0b c1		 or	 eax, ecx
  00231	0f b6 55 ec	 movzx	 edx, BYTE PTR _rgb_col$[ebp]
  00235	c1 ea 03	 shr	 edx, 3
  00238	83 e2 1f	 and	 edx, 31			; 0000001fH
  0023b	0b c2		 or	 eax, edx
  0023d	66 89 45 e8	 mov	 WORD PTR _packed_rgb_col$[ebp], ax

; 461  : 
; 462  : 						quick_set_list_item ( destination_ptr, unsigned short int, packed_rgb_col );

  00241	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  00244	83 c0 02	 add	 eax, 2
  00247	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  0024a	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  0024d	66 8b 55 e8	 mov	 dx, WORD PTR _packed_rgb_col$[ebp]
  00251	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx

; 463  : 
; 464  : 						run_start++;

  00255	8b 45 f0	 mov	 eax, DWORD PTR _run_start$[ebp]
  00258	83 c0 04	 add	 eax, 4
  0025b	89 45 f0	 mov	 DWORD PTR _run_start$[ebp], eax

; 465  : 					}

  0025e	e9 7a ff ff ff	 jmp	 $LN8@convert_ps
$LN9@convert_ps:

; 466  : 
; 467  : 					run_start = NULL;

  00263	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _run_start$[ebp], 0

; 468  : 
; 469  : 					x_start = 0;

  0026a	33 c0		 xor	 eax, eax
  0026c	66 89 45 dc	 mov	 WORD PTR _x_start$[ebp], ax
$LN15@convert_ps:

; 470  : 				}
; 471  : 			}
; 472  : 
; 473  : 			psd_col++;

  00270	8b 45 f4	 mov	 eax, DWORD PTR _psd_col$[ebp]
  00273	83 c0 04	 add	 eax, 4
  00276	89 45 f4	 mov	 DWORD PTR _psd_col$[ebp], eax

; 474  : 		}

  00279	e9 6d fe ff ff	 jmp	 $LN5@convert_ps
$LN6@convert_ps:

; 475  : 
; 476  : 		//
; 477  : 		// write end of row (if row occupied)
; 478  : 		//
; 479  : 
; 480  : 		if ( !first_run )

  0027e	83 7d b8 00	 cmp	 DWORD PTR _first_run$[ebp], 0
  00282	75 14		 jne	 SHORT $LN20@convert_ps

; 481  : 		{
; 482  : 
; 483  : 			quick_set_list_item ( destination_ptr, unsigned short int, end_of_row );

  00284	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  00287	83 c0 02	 add	 eax, 2
  0028a	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  0028d	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  00290	66 8b 55 c8	 mov	 dx, WORD PTR _end_of_row$[ebp]
  00294	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx
$LN20@convert_ps:

; 484  : 		}
; 485  : 	}

  00298	e9 02 fe ff ff	 jmp	 $LN2@convert_ps
$LN3@convert_ps:

; 486  : 
; 487  : 	//
; 488  : 	// write end of file
; 489  : 	//
; 490  : 
; 491  : 	quick_set_list_item ( destination_ptr, unsigned short int, end_of_file );

  0029d	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  002a0	83 c0 02	 add	 eax, 2
  002a3	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  002a6	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  002a9	66 8b 55 c4	 mov	 dx, WORD PTR _end_of_file$[ebp]
  002ad	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx

; 492  : 
; 493  : 	//
; 494  : 	// Write the file out
; 495  : 	//
; 496  : 
; 497  : 	fwrite ( rle_image, ( destination_ptr - rle_image ), 1, rle_file_ptr );

  002b1	8b 45 fc	 mov	 eax, DWORD PTR _rle_file_ptr$[ebp]
  002b4	50		 push	 eax
  002b5	6a 01		 push	 1
  002b7	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  002ba	2b 4d ac	 sub	 ecx, DWORD PTR _rle_image$[ebp]
  002bd	51		 push	 ecx
  002be	8b 55 ac	 mov	 edx, DWORD PTR _rle_image$[ebp]
  002c1	52		 push	 edx
  002c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  002c8	83 c4 10	 add	 esp, 16			; 00000010H

; 498  : 
; 499  : 	//
; 500  : 	// clean up
; 501  : 	//
; 502  : 
; 503  : 	fclose ( rle_file_ptr );

  002cb	8b 45 fc	 mov	 eax, DWORD PTR _rle_file_ptr$[ebp]
  002ce	50		 push	 eax
  002cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  002d5	83 c4 04	 add	 esp, 4

; 504  : 
; 505  : 	safe_free ( rle_image );

  002d8	8b 45 ac	 mov	 eax, DWORD PTR _rle_image$[ebp]
  002db	50		 push	 eax
  002dc	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 506  : 
; 507  : 	safe_free ( psd_image );

  002e1	8b 45 f8	 mov	 eax, DWORD PTR _psd_image$[ebp]
  002e4	50		 push	 eax
  002e5	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 508  : }

  002ea	5f		 pop	 edi
  002eb	5e		 pop	 esi
  002ec	5b		 pop	 ebx
  002ed	8b e5		 mov	 esp, ebp
  002ef	5d		 pop	 ebp
  002f0	c2 08 00	 ret	 8
?convert_psd_to_rle@@YGXPBD0@Z ENDP			; convert_psd_to_rle
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\rle.c
;	COMDAT ?convert_tga_to_rle@@YGXPBD0@Z
_TEXT	SEGMENT
tv174 = -156						; size = 4
_destination_ptr$ = -88					; size = 4
_rle_image$ = -84					; size = 4
_bits_per_pixel$ = -80					; size = 4
_mask$ = -76						; size = 4
_first_run$ = -72					; size = 4
_end_of_file$ = -68					; size = 2
_end_of_row$ = -64					; size = 2
_run_length_bytes$ = -60				; size = 2
_run_length$ = -56					; size = 2
_x_add$ = -52						; size = 2
_x_end$ = -48						; size = 2
_x_start$ = -44						; size = 2
_y$ = -40						; size = 2
_x$ = -36						; size = 2
_height$ = -32						; size = 2
_width$ = -28						; size = 2
_packed_rgb_col$ = -24					; size = 2
_rgb_col$ = -20						; size = 4
_run_start$ = -16					; size = 4
_tga_col$ = -12						; size = 4
_tga_image$ = -8					; size = 4
_rle_file_ptr$ = -4					; size = 4
_tga_filename$ = 8					; size = 4
_rle_filename$ = 12					; size = 4
?convert_tga_to_rle@@YGXPBD0@Z PROC			; convert_tga_to_rle, COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 100  : 	FILE
; 101  : 		*rle_file_ptr;
; 102  : 
; 103  : 	tga_rgba
; 104  : 		*tga_image,
; 105  : 		*tga_col,
; 106  : 		*run_start;
; 107  : 
; 108  : 	rgb_colour
; 109  : 		rgb_col;
; 110  : 
; 111  : 	rgb_packed
; 112  : 		packed_rgb_col;
; 113  : 
; 114  : 	short int
; 115  : 		width,
; 116  : 		height;
; 117  : 
; 118  : 	unsigned short int
; 119  : 		x,
; 120  : 		y,
; 121  : 		x_start,
; 122  : 		x_end,
; 123  : 		x_add,
; 124  : 		run_length,
; 125  : 		run_length_bytes,
; 126  : 		end_of_row = 0xFFFF,

  0000c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00011	66 89 45 c0	 mov	 WORD PTR _end_of_row$[ebp], ax

; 127  : 		end_of_file = 0xFFFF;

  00015	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0001a	66 89 45 bc	 mov	 WORD PTR _end_of_file$[ebp], ax

; 128  : 
; 129  : 	int
; 130  : 		first_run,
; 131  : 		mask,
; 132  : 		bits_per_pixel;
; 133  : 
; 134  : 	unsigned char
; 135  : 		*rle_image,
; 136  : 		*destination_ptr;
; 137  : 
; 138  : 	//
; 139  : 	// load TGA file
; 140  : 	//
; 141  : 
; 142  : 	tga_image = ( tga_rgba * ) load_tga_file (tga_filename, &width, &height, &bits_per_pixel);

  0001e	8d 45 b0	 lea	 eax, DWORD PTR _bits_per_pixel$[ebp]
  00021	50		 push	 eax
  00022	8d 4d e0	 lea	 ecx, DWORD PTR _height$[ebp]
  00025	51		 push	 ecx
  00026	8d 55 e4	 lea	 edx, DWORD PTR _width$[ebp]
  00029	52		 push	 edx
  0002a	8b 45 08	 mov	 eax, DWORD PTR _tga_filename$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?load_tga_file@@YGPAXPBDPAF1PAH@Z ; load_tga_file
  00033	89 45 f8	 mov	 DWORD PTR _tga_image$[ebp], eax

; 143  : 
; 144  : 	if (bits_per_pixel != 32)

  00036	83 7d b0 20	 cmp	 DWORD PTR _bits_per_pixel$[ebp], 32 ; 00000020H
  0003a	74 11		 je	 SHORT $LN10@convert_tg

; 145  : 	{
; 146  : 		debug_fatal ( "%s must have 32 bits/pixel for convert_tga_to_rle", tga_filename);

  0003c	8b 45 08	 mov	 eax, DWORD PTR _tga_filename$[ebp]
  0003f	50		 push	 eax
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@OHLBNDJK@?$CFs?5must?5have?532?5bits?1pixel?5for?5@
  00045	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  0004a	83 c4 08	 add	 esp, 8
$LN10@convert_tg:

; 147  : 	}
; 148  : 
; 149  : 	//
; 150  : 	// Allocate a buffer memory area - must be big enough to hold the worst possible rle case
; 151  : 	//
; 152  : 
; 153  : 	rle_image = ( unsigned char * ) safe_malloc ( width * height * sizeof ( rgb_packed ) * 2 );

  0004d	0f bf 45 e4	 movsx	 eax, WORD PTR _width$[ebp]
  00051	0f bf 4d e0	 movsx	 ecx, WORD PTR _height$[ebp]
  00055	0f af c1	 imul	 eax, ecx
  00058	d1 e0		 shl	 eax, 1
  0005a	d1 e0		 shl	 eax, 1
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00062	89 45 ac	 mov	 DWORD PTR _rle_image$[ebp], eax

; 154  : 
; 155  : 	ASSERT ( rle_image );

  00065	83 7d ac 00	 cmp	 DWORD PTR _rle_image$[ebp], 0
  00069	75 18		 jne	 SHORT $LN11@convert_tg
  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??convert_tga_to_rle@@YGXPBD0@Z@4JA
  00070	83 c0 38	 add	 eax, 56			; 00000038H
  00073	50		 push	 eax
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@EPAEFMM@c?3?2users?2nhv90?2projects?2eech?2mo@
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_09IBNJLIFC@rle_image@
  0007e	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN11@convert_tg:

; 156  : 
; 157  : 	destination_ptr = rle_image;

  00083	8b 45 ac	 mov	 eax, DWORD PTR _rle_image$[ebp]
  00086	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax

; 158  : 
; 159  : 	//
; 160  : 	// open RLE file
; 161  : 	//
; 162  : 
; 163  : 	if ((rle_file_ptr = fopen (rle_filename, "wb")) == NULL)

  00089	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  0008e	8b 45 0c	 mov	 eax, DWORD PTR _rle_filename$[ebp]
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00098	83 c4 08	 add	 esp, 8
  0009b	89 45 fc	 mov	 DWORD PTR _rle_file_ptr$[ebp], eax
  0009e	83 7d fc 00	 cmp	 DWORD PTR _rle_file_ptr$[ebp], 0
  000a2	75 11		 jne	 SHORT $LN12@convert_tg

; 164  : 	{
; 165  : 		debug_fatal ("Unable to open file %s during convert_tga_to_rle", rle_filename);

  000a4	8b 45 0c	 mov	 eax, DWORD PTR _rle_filename$[ebp]
  000a7	50		 push	 eax
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@EICFDLJD@Unable?5to?5open?5file?5?$CFs?5during?5c@
  000ad	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  000b2	83 c4 08	 add	 esp, 8
$LN12@convert_tg:

; 166  : 	}
; 167  : 
; 168  : 	//
; 169  : 	// write RLE data
; 170  : 	//
; 171  : 
; 172  : 	rgb_col.a = 255;

  000b5	c6 45 ef ff	 mov	 BYTE PTR _rgb_col$[ebp+3], 255 ; 000000ffH

; 173  : 
; 174  : 	for (y = 0; y < height; y++)

  000b9	33 c0		 xor	 eax, eax
  000bb	66 89 45 d8	 mov	 WORD PTR _y$[ebp], ax
  000bf	eb 0c		 jmp	 SHORT $LN4@convert_tg
$LN2@convert_tg:
  000c1	66 8b 45 d8	 mov	 ax, WORD PTR _y$[ebp]
  000c5	66 83 c0 01	 add	 ax, 1
  000c9	66 89 45 d8	 mov	 WORD PTR _y$[ebp], ax
$LN4@convert_tg:
  000cd	0f b7 45 d8	 movzx	 eax, WORD PTR _y$[ebp]
  000d1	0f bf 4d e0	 movsx	 ecx, WORD PTR _height$[ebp]
  000d5	3b c1		 cmp	 eax, ecx
  000d7	0f 8d 2e 02 00
	00		 jge	 $LN3@convert_tg

; 175  : 	{
; 176  : 		tga_col = tga_image + (width * (height - 1 - y));

  000dd	0f bf 45 e4	 movsx	 eax, WORD PTR _width$[ebp]
  000e1	0f bf 4d e0	 movsx	 ecx, WORD PTR _height$[ebp]
  000e5	83 e9 01	 sub	 ecx, 1
  000e8	0f b7 55 d8	 movzx	 edx, WORD PTR _y$[ebp]
  000ec	2b ca		 sub	 ecx, edx
  000ee	0f af c1	 imul	 eax, ecx
  000f1	8b 4d f8	 mov	 ecx, DWORD PTR _tga_image$[ebp]
  000f4	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000f7	89 55 f4	 mov	 DWORD PTR _tga_col$[ebp], edx

; 177  : 
; 178  : 		first_run = TRUE;

  000fa	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR _first_run$[ebp], 1

; 179  : 
; 180  : 		run_start = NULL;

  00101	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _run_start$[ebp], 0

; 181  : 
; 182  : 		x_start = 0;

  00108	33 c0		 xor	 eax, eax
  0010a	66 89 45 d4	 mov	 WORD PTR _x_start$[ebp], ax

; 183  : 
; 184  : 		x_end = 0;

  0010e	33 c0		 xor	 eax, eax
  00110	66 89 45 d0	 mov	 WORD PTR _x_end$[ebp], ax

; 185  : 
; 186  : 		for (x = 0; x <= width; x++)

  00114	33 c0		 xor	 eax, eax
  00116	66 89 45 dc	 mov	 WORD PTR _x$[ebp], ax
  0011a	eb 0c		 jmp	 SHORT $LN7@convert_tg
$LN5@convert_tg:
  0011c	66 8b 45 dc	 mov	 ax, WORD PTR _x$[ebp]
  00120	66 83 c0 01	 add	 ax, 1
  00124	66 89 45 dc	 mov	 WORD PTR _x$[ebp], ax
$LN7@convert_tg:
  00128	0f b7 45 dc	 movzx	 eax, WORD PTR _x$[ebp]
  0012c	0f bf 4d e4	 movsx	 ecx, WORD PTR _width$[ebp]
  00130	3b c1		 cmp	 eax, ecx
  00132	0f 8f b4 01 00
	00		 jg	 $LN6@convert_tg

; 187  : 		{
; 188  : 			if (x < width)

  00138	0f b7 45 dc	 movzx	 eax, WORD PTR _x$[ebp]
  0013c	0f bf 4d e4	 movsx	 ecx, WORD PTR _width$[ebp]
  00140	3b c1		 cmp	 eax, ecx
  00142	7d 0c		 jge	 SHORT $LN13@convert_tg

; 189  : 			{
; 190  : 				mask = tga_col->a;

  00144	8b 45 f4	 mov	 eax, DWORD PTR _tga_col$[ebp]
  00147	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0014b	89 4d b4	 mov	 DWORD PTR _mask$[ebp], ecx

; 191  : 			}
; 192  : 			else

  0014e	eb 07		 jmp	 SHORT $LN14@convert_tg
$LN13@convert_tg:

; 193  : 			{
; 194  : 				// force end of run
; 195  : 
; 196  : 				mask = TRUE;

  00150	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _mask$[ebp], 1
$LN14@convert_tg:

; 197  : 			}
; 198  : 
; 199  : 			if (!mask)

  00157	83 7d b4 00	 cmp	 DWORD PTR _mask$[ebp], 0
  0015b	75 19		 jne	 SHORT $LN15@convert_tg

; 200  : 			{
; 201  : 				// check for start run
; 202  : 
; 203  : 				if (!run_start)

  0015d	83 7d f0 00	 cmp	 DWORD PTR _run_start$[ebp], 0
  00161	75 0e		 jne	 SHORT $LN17@convert_tg

; 204  : 				{
; 205  : 					run_start = tga_col;

  00163	8b 45 f4	 mov	 eax, DWORD PTR _tga_col$[ebp]
  00166	89 45 f0	 mov	 DWORD PTR _run_start$[ebp], eax

; 206  : 
; 207  : 					x_start = x;

  00169	66 8b 45 dc	 mov	 ax, WORD PTR _x$[ebp]
  0016d	66 89 45 d4	 mov	 WORD PTR _x_start$[ebp], ax
$LN17@convert_tg:

; 208  : 				}
; 209  : 			}
; 210  : 			else

  00171	e9 68 01 00 00	 jmp	 $LN16@convert_tg
$LN15@convert_tg:

; 211  : 			{
; 212  : 				// check for end run
; 213  : 
; 214  : 				if (run_start)

  00176	83 7d f0 00	 cmp	 DWORD PTR _run_start$[ebp], 0
  0017a	0f 84 5e 01 00
	00		 je	 $LN16@convert_tg

; 215  : 				{
; 216  : 					if (first_run)

  00180	83 7d b8 00	 cmp	 DWORD PTR _first_run$[ebp], 0
  00184	74 31		 je	 SHORT $LN19@convert_tg

; 217  : 					{
; 218  : 
; 219  : 						quick_set_list_item ( destination_ptr, unsigned short int, x_start );

  00186	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  00189	83 c0 02	 add	 eax, 2
  0018c	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  0018f	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  00192	66 8b 55 d4	 mov	 dx, WORD PTR _x_start$[ebp]
  00196	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx

; 220  : 						quick_set_list_item ( destination_ptr, unsigned short int, y );

  0019a	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  0019d	83 c0 02	 add	 eax, 2
  001a0	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  001a3	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  001a6	66 8b 55 d8	 mov	 dx, WORD PTR _y$[ebp]
  001aa	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx

; 221  : 
; 222  : 						first_run = FALSE;

  001ae	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _first_run$[ebp], 0

; 223  : 					}
; 224  : 					else

  001b5	eb 26		 jmp	 SHORT $LN20@convert_tg
$LN19@convert_tg:

; 225  : 					{
; 226  : 						x_add = (x_start - x_end - 1) * sizeof (packed_rgb_col);

  001b7	0f b7 45 d4	 movzx	 eax, WORD PTR _x_start$[ebp]
  001bb	0f b7 4d d0	 movzx	 ecx, WORD PTR _x_end$[ebp]
  001bf	2b c1		 sub	 eax, ecx
  001c1	8d 54 00 fe	 lea	 edx, DWORD PTR [eax+eax-2]
  001c5	66 89 55 cc	 mov	 WORD PTR _x_add$[ebp], dx

; 227  : 
; 228  : 						quick_set_list_item ( destination_ptr, unsigned short int, x_add );

  001c9	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  001cc	83 c0 02	 add	 eax, 2
  001cf	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  001d2	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  001d5	66 8b 55 cc	 mov	 dx, WORD PTR _x_add$[ebp]
  001d9	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx
$LN20@convert_tg:

; 229  : 					}
; 230  : 
; 231  : 					x_end = x - 1;

  001dd	0f b7 45 dc	 movzx	 eax, WORD PTR _x$[ebp]
  001e1	83 e8 01	 sub	 eax, 1
  001e4	66 89 45 d0	 mov	 WORD PTR _x_end$[ebp], ax

; 232  : 
; 233  : 					run_length = x - x_start;

  001e8	0f b7 45 dc	 movzx	 eax, WORD PTR _x$[ebp]
  001ec	0f b7 4d d4	 movzx	 ecx, WORD PTR _x_start$[ebp]
  001f0	2b c1		 sub	 eax, ecx
  001f2	66 89 45 c8	 mov	 WORD PTR _run_length$[ebp], ax

; 234  : 
; 235  : 					run_length_bytes = run_length * sizeof (packed_rgb_col);

  001f6	0f b7 45 c8	 movzx	 eax, WORD PTR _run_length$[ebp]
  001fa	d1 e0		 shl	 eax, 1
  001fc	66 89 45 c4	 mov	 WORD PTR _run_length_bytes$[ebp], ax

; 236  : 
; 237  : 					quick_set_list_item ( destination_ptr, unsigned short int, run_length_bytes );

  00200	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  00203	83 c0 02	 add	 eax, 2
  00206	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  00209	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  0020c	66 8b 55 c4	 mov	 dx, WORD PTR _run_length_bytes$[ebp]
  00210	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx
$LN8@convert_tg:

; 238  : 
; 239  : 					while (run_length--)

  00214	0f b7 45 c8	 movzx	 eax, WORD PTR _run_length$[ebp]
  00218	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv174[ebp], eax
  0021e	66 8b 4d c8	 mov	 cx, WORD PTR _run_length$[ebp]
  00222	66 83 e9 01	 sub	 cx, 1
  00226	66 89 4d c8	 mov	 WORD PTR _run_length$[ebp], cx
  0022a	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR tv174[ebp], 0
  00231	0f 84 9a 00 00
	00		 je	 $LN9@convert_tg

; 240  : 					{
; 241  : 						rgb_col.r = run_start->r;

  00237	8b 45 f0	 mov	 eax, DWORD PTR _run_start$[ebp]
  0023a	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  0023d	88 4d ee	 mov	 BYTE PTR _rgb_col$[ebp+2], cl

; 242  : 
; 243  : 						rgb_col.g = run_start->g;

  00240	8b 45 f0	 mov	 eax, DWORD PTR _run_start$[ebp]
  00243	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00246	88 4d ed	 mov	 BYTE PTR _rgb_col$[ebp+1], cl

; 244  : 
; 245  : 						rgb_col.b = run_start->b;

  00249	8b 45 f0	 mov	 eax, DWORD PTR _run_start$[ebp]
  0024c	8a 08		 mov	 cl, BYTE PTR [eax]
  0024e	88 4d ec	 mov	 BYTE PTR _rgb_col$[ebp], cl

; 246  : 
; 247  : 						packed_rgb_col = get_packed_colour (rgb_col);

  00251	0f b6 45 ee	 movzx	 eax, BYTE PTR _rgb_col$[ebp+2]
  00255	c1 e0 18	 shl	 eax, 24			; 00000018H
  00258	23 05 00 00 00
	00		 and	 eax, DWORD PTR ?active_screen_red_mask@@3HA ; active_screen_red_mask
  0025e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?active_screen_red_shift@@3HA ; active_screen_red_shift
  00264	d3 e8		 shr	 eax, cl
  00266	0f b6 55 ed	 movzx	 edx, BYTE PTR _rgb_col$[ebp+1]
  0026a	c1 e2 18	 shl	 edx, 24			; 00000018H
  0026d	23 15 00 00 00
	00		 and	 edx, DWORD PTR ?active_screen_green_mask@@3HA ; active_screen_green_mask
  00273	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?active_screen_green_shift@@3HA ; active_screen_green_shift
  00279	d3 ea		 shr	 edx, cl
  0027b	0b c2		 or	 eax, edx
  0027d	0f b6 55 ec	 movzx	 edx, BYTE PTR _rgb_col$[ebp]
  00281	c1 e2 18	 shl	 edx, 24			; 00000018H
  00284	23 15 00 00 00
	00		 and	 edx, DWORD PTR ?active_screen_blue_mask@@3HA ; active_screen_blue_mask
  0028a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?active_screen_blue_shift@@3HA ; active_screen_blue_shift
  00290	d3 ea		 shr	 edx, cl
  00292	0b c2		 or	 eax, edx
  00294	0f b6 55 ef	 movzx	 edx, BYTE PTR _rgb_col$[ebp+3]
  00298	c1 e2 18	 shl	 edx, 24			; 00000018H
  0029b	23 15 00 00 00
	00		 and	 edx, DWORD PTR ?active_screen_alpha_mask@@3HA ; active_screen_alpha_mask
  002a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?active_screen_alpha_shift@@3HA ; active_screen_alpha_shift
  002a7	d3 ea		 shr	 edx, cl
  002a9	0b c2		 or	 eax, edx
  002ab	66 89 45 e8	 mov	 WORD PTR _packed_rgb_col$[ebp], ax

; 248  : 
; 249  : 						quick_set_list_item ( destination_ptr, unsigned short int, packed_rgb_col );

  002af	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  002b2	83 c0 02	 add	 eax, 2
  002b5	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  002b8	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  002bb	66 8b 55 e8	 mov	 dx, WORD PTR _packed_rgb_col$[ebp]
  002bf	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx

; 250  : 
; 251  : 						run_start++;

  002c3	8b 45 f0	 mov	 eax, DWORD PTR _run_start$[ebp]
  002c6	83 c0 04	 add	 eax, 4
  002c9	89 45 f0	 mov	 DWORD PTR _run_start$[ebp], eax

; 252  : 					}

  002cc	e9 43 ff ff ff	 jmp	 $LN8@convert_tg
$LN9@convert_tg:

; 253  : 
; 254  : 					run_start = NULL;

  002d1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _run_start$[ebp], 0

; 255  : 
; 256  : 					x_start = 0;

  002d8	33 c0		 xor	 eax, eax
  002da	66 89 45 d4	 mov	 WORD PTR _x_start$[ebp], ax
$LN16@convert_tg:

; 257  : 				}
; 258  : 			}
; 259  : 
; 260  : 			tga_col++;

  002de	8b 45 f4	 mov	 eax, DWORD PTR _tga_col$[ebp]
  002e1	83 c0 04	 add	 eax, 4
  002e4	89 45 f4	 mov	 DWORD PTR _tga_col$[ebp], eax

; 261  : 		}

  002e7	e9 30 fe ff ff	 jmp	 $LN5@convert_tg
$LN6@convert_tg:

; 262  : 
; 263  : 		//
; 264  : 		// write end of row (if row occupied)
; 265  : 		//
; 266  : 
; 267  : 		if (!first_run)

  002ec	83 7d b8 00	 cmp	 DWORD PTR _first_run$[ebp], 0
  002f0	75 14		 jne	 SHORT $LN21@convert_tg

; 268  : 		{
; 269  : 			quick_set_list_item ( destination_ptr, unsigned short int, end_of_row );

  002f2	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  002f5	83 c0 02	 add	 eax, 2
  002f8	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  002fb	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  002fe	66 8b 55 c0	 mov	 dx, WORD PTR _end_of_row$[ebp]
  00302	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx
$LN21@convert_tg:

; 270  : 		}
; 271  : 	}

  00306	e9 b6 fd ff ff	 jmp	 $LN2@convert_tg
$LN3@convert_tg:

; 272  : 
; 273  : 	//
; 274  : 	// write end of file
; 275  : 	//
; 276  : 
; 277  : 	quick_set_list_item ( destination_ptr, unsigned short int, end_of_file );

  0030b	8b 45 a8	 mov	 eax, DWORD PTR _destination_ptr$[ebp]
  0030e	83 c0 02	 add	 eax, 2
  00311	89 45 a8	 mov	 DWORD PTR _destination_ptr$[ebp], eax
  00314	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  00317	66 8b 55 bc	 mov	 dx, WORD PTR _end_of_file$[ebp]
  0031b	66 89 51 fe	 mov	 WORD PTR [ecx-2], dx

; 278  : 
; 279  : 	//
; 280  : 	// Write the file out
; 281  : 	//
; 282  : 
; 283  : 	fwrite ( rle_image, ( destination_ptr - rle_image ), 1, rle_file_ptr );

  0031f	8b 45 fc	 mov	 eax, DWORD PTR _rle_file_ptr$[ebp]
  00322	50		 push	 eax
  00323	6a 01		 push	 1
  00325	8b 4d a8	 mov	 ecx, DWORD PTR _destination_ptr$[ebp]
  00328	2b 4d ac	 sub	 ecx, DWORD PTR _rle_image$[ebp]
  0032b	51		 push	 ecx
  0032c	8b 55 ac	 mov	 edx, DWORD PTR _rle_image$[ebp]
  0032f	52		 push	 edx
  00330	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00336	83 c4 10	 add	 esp, 16			; 00000010H

; 284  : 
; 285  : 	//
; 286  : 	// clean up
; 287  : 	//
; 288  : 
; 289  : 
; 290  : 	fclose (rle_file_ptr);

  00339	8b 45 fc	 mov	 eax, DWORD PTR _rle_file_ptr$[ebp]
  0033c	50		 push	 eax
  0033d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00343	83 c4 04	 add	 esp, 4

; 291  : 
; 292  : 	safe_free ( rle_image );

  00346	8b 45 ac	 mov	 eax, DWORD PTR _rle_image$[ebp]
  00349	50		 push	 eax
  0034a	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 293  : 
; 294  : 	safe_free (tga_image);

  0034f	8b 45 f8	 mov	 eax, DWORD PTR _tga_image$[ebp]
  00352	50		 push	 eax
  00353	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 295  : }

  00358	5f		 pop	 edi
  00359	5e		 pop	 esi
  0035a	5b		 pop	 ebx
  0035b	8b e5		 mov	 esp, ebp
  0035d	5d		 pop	 ebp
  0035e	c2 08 00	 ret	 8
?convert_tga_to_rle@@YGXPBD0@Z ENDP			; convert_tga_to_rle
_TEXT	ENDS
END
