; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\graphics\psdwrite.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?red_channel_line_lengths@@3PAGA		; red_channel_line_lengths
PUBLIC	?green_channel_line_lengths@@3PAGA		; green_channel_line_lengths
PUBLIC	?blue_channel_line_lengths@@3PAGA		; blue_channel_line_lengths
PUBLIC	?channel_compressed_data@@3PAEA			; channel_compressed_data
PUBLIC	?channel_line_data@@3PAEA			; channel_line_data
_BSS	SEGMENT
?red_channel_line_lengths@@3PAGA DD 01H DUP (?)		; red_channel_line_lengths
?green_channel_line_lengths@@3PAGA DD 01H DUP (?)	; green_channel_line_lengths
?blue_channel_line_lengths@@3PAGA DD 01H DUP (?)	; blue_channel_line_lengths
?channel_compressed_data@@3PAEA DD 01H DUP (?)		; channel_compressed_data
?channel_line_data@@3PAEA DD 01H DUP (?)		; channel_line_data
_BSS	ENDS
PUBLIC	?save_psd_screen@@YGXPBD@Z			; save_psd_screen
PUBLIC	?write_psd_screen_file@@YGXPBDHHHPBE@Z		; write_psd_screen_file
PUBLIC	?write_psd_rgb_file@@YGXPBDHHHPBE@Z		; write_psd_rgb_file
PUBLIC	?write_psd_greyscale@@YGXPBDHHHPBE@Z		; write_psd_greyscale
PUBLIC	?write_psd_colourindex_and_alpha@@YGXPBDHHHPBE@Z ; write_psd_colourindex_and_alpha
PUBLIC	?run_length_encode_data@@YGHPBEPAEH@Z		; run_length_encode_data
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_04GELLELDE@8BPS@				; `string'
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__ftell:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	_memset:PROC
EXTRN	?safe_malloc_memory@@YGPAXI@Z:PROC		; safe_malloc_memory
EXTRN	?safe_free@@YGXPAX@Z:PROC			; safe_free
EXTRN	?safe_fopen@@YGPAU_iobuf@@PBD0@Z:PROC		; safe_fopen
EXTRN	?get_screen_data@@YGPAEPAUSCREEN@@@Z:PROC	; get_screen_data
EXTRN	?get_screen_pitch@@YGHPAUSCREEN@@@Z:PROC	; get_screen_pitch
EXTRN	?get_screen_width@@YGHPAUSCREEN@@@Z:PROC	; get_screen_width
EXTRN	?get_screen_height@@YGHPAUSCREEN@@@Z:PROC	; get_screen_height
EXTRN	?get_rgb_colour_value@@YG?AUREAL_COLOUR@@K@Z:PROC ; get_rgb_colour_value
EXTRN	?get_general_colour_value@@YG?AUREAL_COLOUR@@G@Z:PROC ; get_general_colour_value
EXTRN	?iff_int_write@@YGXHPAU_iobuf@@@Z:PROC		; iff_int_write
EXTRN	?iff_short_int_write@@YGXFPAU_iobuf@@@Z:PROC	; iff_short_int_write
EXTRN	?video_screen@@3PAUSCREEN@@A:DWORD		; video_screen
EXTRN	?psd_palette@@3PAUREAL_COLOUR@@A:BYTE		; psd_palette
;	COMDAT ??_C@_04GELLELDE@8BPS@
CONST	SEGMENT
??_C@_04GELLELDE@8BPS@ DB '8BPS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\psdwrite.c
;	COMDAT ?run_length_encode_data@@YGHPBEPAEH@Z
_TEXT	SEGMENT
_run_length$1 = -24					; size = 4
_different$2 = -20					; size = 4
_count$3 = -16						; size = 4
_run_length$4 = -12					; size = 4
_different$5 = -8					; size = 4
_data_written$ = -4					; size = 4
_source_data$ = 8					; size = 4
_result$ = 12						; size = 4
_length$ = 16						; size = 4
?run_length_encode_data@@YGHPBEPAEH@Z PROC		; run_length_encode_data, COMDAT

; 1042 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1043 : 
; 1044 : 	int
; 1045 : 		data_written;
; 1046 : 
; 1047 : 	data_written = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _data_written$[ebp], 0
$LN2@run_length:

; 1048 : 
; 1049 : 	while ( length )

  00010	83 7d 10 00	 cmp	 DWORD PTR _length$[ebp], 0
  00014	0f 84 e1 02 00
	00		 je	 $LN3@run_length

; 1050 : 	{
; 1051 : 
; 1052 : 		if ( length == 1 )

  0001a	83 7d 10 01	 cmp	 DWORD PTR _length$[ebp], 1
  0001e	75 40		 jne	 SHORT $LN11@run_length

; 1053 : 		{
; 1054 : 
; 1055 : 			//
; 1056 : 			// Last pixel - just write it out.
; 1057 : 			//
; 1058 : 
; 1059 : 			*result++ = 0;

  00020	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  00023	c6 00 00	 mov	 BYTE PTR [eax], 0
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _result$[ebp]
  00029	83 c1 01	 add	 ecx, 1
  0002c	89 4d 0c	 mov	 DWORD PTR _result$[ebp], ecx

; 1060 : 			*result++ = ( ( const char * ) source_data )[0];

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	6b c8 00	 imul	 ecx, eax, 0
  00037	8b 55 0c	 mov	 edx, DWORD PTR _result$[ebp]
  0003a	8b 45 08	 mov	 eax, DWORD PTR _source_data$[ebp]
  0003d	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  00040	88 0a		 mov	 BYTE PTR [edx], cl
  00042	8b 55 0c	 mov	 edx, DWORD PTR _result$[ebp]
  00045	83 c2 01	 add	 edx, 1
  00048	89 55 0c	 mov	 DWORD PTR _result$[ebp], edx

; 1061 : 
; 1062 : 			length = 0;

  0004b	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _length$[ebp], 0

; 1063 : 			data_written += 2;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _data_written$[ebp]
  00055	83 c0 02	 add	 eax, 2
  00058	89 45 fc	 mov	 DWORD PTR _data_written$[ebp], eax
  0005b	e9 96 02 00 00	 jmp	 $LN12@run_length
$LN11@run_length:

; 1064 : 		}
; 1065 : 		else if ( length == 2 )

  00060	83 7d 10 02	 cmp	 DWORD PTR _length$[ebp], 2
  00064	0f 85 bb 00 00
	00		 jne	 $LN13@run_length

; 1066 : 		{
; 1067 : 
; 1068 : 			//
; 1069 : 			// Last two pixels - test together
; 1070 : 			//
; 1071 : 
; 1072 : 			if ( source_data[0] == source_data[1] )

  0006a	b8 01 00 00 00	 mov	 eax, 1
  0006f	6b c8 00	 imul	 ecx, eax, 0
  00072	8b 55 08	 mov	 edx, DWORD PTR _source_data$[ebp]
  00075	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00079	b9 01 00 00 00	 mov	 ecx, 1
  0007e	c1 e1 00	 shl	 ecx, 0
  00081	8b 55 08	 mov	 edx, DWORD PTR _source_data$[ebp]
  00084	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00088	3b c1		 cmp	 eax, ecx
  0008a	75 3d		 jne	 SHORT $LN15@run_length

; 1073 : 			{
; 1074 : 
; 1075 : 				*result++ = -1;										// Duplicate next byte twice

  0008c	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  0008f	c6 00 ff	 mov	 BYTE PTR [eax], 255	; 000000ffH
  00092	8b 4d 0c	 mov	 ecx, DWORD PTR _result$[ebp]
  00095	83 c1 01	 add	 ecx, 1
  00098	89 4d 0c	 mov	 DWORD PTR _result$[ebp], ecx

; 1076 : 				*result++ = ( ( const char * ) source_data )[0];

  0009b	b8 01 00 00 00	 mov	 eax, 1
  000a0	6b c8 00	 imul	 ecx, eax, 0
  000a3	8b 55 0c	 mov	 edx, DWORD PTR _result$[ebp]
  000a6	8b 45 08	 mov	 eax, DWORD PTR _source_data$[ebp]
  000a9	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  000ac	88 0a		 mov	 BYTE PTR [edx], cl
  000ae	8b 55 0c	 mov	 edx, DWORD PTR _result$[ebp]
  000b1	83 c2 01	 add	 edx, 1
  000b4	89 55 0c	 mov	 DWORD PTR _result$[ebp], edx

; 1077 : 	
; 1078 : 				length = 0;

  000b7	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _length$[ebp], 0

; 1079 : 				data_written += 2;

  000be	8b 45 fc	 mov	 eax, DWORD PTR _data_written$[ebp]
  000c1	83 c0 02	 add	 eax, 2
  000c4	89 45 fc	 mov	 DWORD PTR _data_written$[ebp], eax

; 1080 : 			}
; 1081 : 			else

  000c7	eb 57		 jmp	 SHORT $LN16@run_length
$LN15@run_length:

; 1082 : 			{
; 1083 : 
; 1084 : 				*result++ = 1;											// Copy the next 2 bytes literally

  000c9	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  000cc	c6 00 01	 mov	 BYTE PTR [eax], 1
  000cf	8b 4d 0c	 mov	 ecx, DWORD PTR _result$[ebp]
  000d2	83 c1 01	 add	 ecx, 1
  000d5	89 4d 0c	 mov	 DWORD PTR _result$[ebp], ecx

; 1085 : 				*result++ = ( ( const char * ) source_data )[0];

  000d8	b8 01 00 00 00	 mov	 eax, 1
  000dd	6b c8 00	 imul	 ecx, eax, 0
  000e0	8b 55 0c	 mov	 edx, DWORD PTR _result$[ebp]
  000e3	8b 45 08	 mov	 eax, DWORD PTR _source_data$[ebp]
  000e6	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  000e9	88 0a		 mov	 BYTE PTR [edx], cl
  000eb	8b 55 0c	 mov	 edx, DWORD PTR _result$[ebp]
  000ee	83 c2 01	 add	 edx, 1
  000f1	89 55 0c	 mov	 DWORD PTR _result$[ebp], edx

; 1086 : 				*result++ = ( ( const char * ) source_data )[1];

  000f4	b8 01 00 00 00	 mov	 eax, 1
  000f9	c1 e0 00	 shl	 eax, 0
  000fc	8b 4d 0c	 mov	 ecx, DWORD PTR _result$[ebp]
  000ff	8b 55 08	 mov	 edx, DWORD PTR _source_data$[ebp]
  00102	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00105	88 01		 mov	 BYTE PTR [ecx], al
  00107	8b 4d 0c	 mov	 ecx, DWORD PTR _result$[ebp]
  0010a	83 c1 01	 add	 ecx, 1
  0010d	89 4d 0c	 mov	 DWORD PTR _result$[ebp], ecx

; 1087 : 
; 1088 : 				length = 0;

  00110	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _length$[ebp], 0

; 1089 : 				data_written += 3;

  00117	8b 45 fc	 mov	 eax, DWORD PTR _data_written$[ebp]
  0011a	83 c0 03	 add	 eax, 3
  0011d	89 45 fc	 mov	 DWORD PTR _data_written$[ebp], eax
$LN16@run_length:

; 1090 : 			}
; 1091 : 		}
; 1092 : 		else

  00120	e9 d1 01 00 00	 jmp	 $LN12@run_length
$LN13@run_length:

; 1093 : 		{
; 1094 : 
; 1095 : 			//
; 1096 : 			// There are 3 or more pixels left
; 1097 : 			//
; 1098 : 
; 1099 : 			if ( source_data[0] == source_data[1] )

  00125	b8 01 00 00 00	 mov	 eax, 1
  0012a	6b c8 00	 imul	 ecx, eax, 0
  0012d	8b 55 08	 mov	 edx, DWORD PTR _source_data$[ebp]
  00130	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00134	b9 01 00 00 00	 mov	 ecx, 1
  00139	c1 e1 00	 shl	 ecx, 0
  0013c	8b 55 08	 mov	 edx, DWORD PTR _source_data$[ebp]
  0013f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00143	3b c1		 cmp	 eax, ecx
  00145	0f 85 a7 00 00
	00		 jne	 $LN17@run_length

; 1100 : 			{
; 1101 : 
; 1102 : 				int
; 1103 : 					different,
; 1104 : 					run_length;
; 1105 : 
; 1106 : 				//
; 1107 : 				// Write out a run of the same pixel value
; 1108 : 				//
; 1109 : 
; 1110 : 				different = FALSE;

  0014b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _different$5[ebp], 0

; 1111 : 
; 1112 : 				run_length = 2;

  00152	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _run_length$4[ebp], 2
$LN4@run_length:

; 1113 : 
; 1114 : 				while ( ( !different ) && ( run_length < length ) && ( run_length < 128 ) )

  00159	83 7d f8 00	 cmp	 DWORD PTR _different$5[ebp], 0
  0015d	75 41		 jne	 SHORT $LN5@run_length
  0015f	8b 45 f4	 mov	 eax, DWORD PTR _run_length$4[ebp]
  00162	3b 45 10	 cmp	 eax, DWORD PTR _length$[ebp]
  00165	7d 39		 jge	 SHORT $LN5@run_length
  00167	81 7d f4 80 00
	00 00		 cmp	 DWORD PTR _run_length$4[ebp], 128 ; 00000080H
  0016e	7d 30		 jge	 SHORT $LN5@run_length

; 1115 : 				{
; 1116 : 
; 1117 : 					if ( source_data[run_length] == source_data[0] )

  00170	8b 45 08	 mov	 eax, DWORD PTR _source_data$[ebp]
  00173	03 45 f4	 add	 eax, DWORD PTR _run_length$4[ebp]
  00176	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00179	ba 01 00 00 00	 mov	 edx, 1
  0017e	6b c2 00	 imul	 eax, edx, 0
  00181	8b 55 08	 mov	 edx, DWORD PTR _source_data$[ebp]
  00184	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  00188	3b c8		 cmp	 ecx, eax
  0018a	75 0b		 jne	 SHORT $LN19@run_length

; 1118 : 					{
; 1119 : 
; 1120 : 						run_length++;

  0018c	8b 45 f4	 mov	 eax, DWORD PTR _run_length$4[ebp]
  0018f	83 c0 01	 add	 eax, 1
  00192	89 45 f4	 mov	 DWORD PTR _run_length$4[ebp], eax

; 1121 : 					}
; 1122 : 					else

  00195	eb 07		 jmp	 SHORT $LN20@run_length
$LN19@run_length:

; 1123 : 					{
; 1124 : 
; 1125 : 						different = TRUE;

  00197	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _different$5[ebp], 1
$LN20@run_length:

; 1126 : 					}
; 1127 : 				}

  0019e	eb b9		 jmp	 SHORT $LN4@run_length
$LN5@run_length:

; 1128 : 
; 1129 : 				*result++ = -( run_length - 1 );

  001a0	8b 45 f4	 mov	 eax, DWORD PTR _run_length$4[ebp]
  001a3	83 e8 01	 sub	 eax, 1
  001a6	f7 d8		 neg	 eax
  001a8	8b 4d 0c	 mov	 ecx, DWORD PTR _result$[ebp]
  001ab	88 01		 mov	 BYTE PTR [ecx], al
  001ad	8b 55 0c	 mov	 edx, DWORD PTR _result$[ebp]
  001b0	83 c2 01	 add	 edx, 1
  001b3	89 55 0c	 mov	 DWORD PTR _result$[ebp], edx

; 1130 : 				*result++ = ( ( const char * ) source_data )[0];

  001b6	b8 01 00 00 00	 mov	 eax, 1
  001bb	6b c8 00	 imul	 ecx, eax, 0
  001be	8b 55 0c	 mov	 edx, DWORD PTR _result$[ebp]
  001c1	8b 45 08	 mov	 eax, DWORD PTR _source_data$[ebp]
  001c4	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  001c7	88 0a		 mov	 BYTE PTR [edx], cl
  001c9	8b 55 0c	 mov	 edx, DWORD PTR _result$[ebp]
  001cc	83 c2 01	 add	 edx, 1
  001cf	89 55 0c	 mov	 DWORD PTR _result$[ebp], edx

; 1131 : 
; 1132 : 				source_data += run_length;

  001d2	8b 45 08	 mov	 eax, DWORD PTR _source_data$[ebp]
  001d5	03 45 f4	 add	 eax, DWORD PTR _run_length$4[ebp]
  001d8	89 45 08	 mov	 DWORD PTR _source_data$[ebp], eax

; 1133 : 				data_written += 2;

  001db	8b 45 fc	 mov	 eax, DWORD PTR _data_written$[ebp]
  001de	83 c0 02	 add	 eax, 2
  001e1	89 45 fc	 mov	 DWORD PTR _data_written$[ebp], eax

; 1134 : 
; 1135 : 				length -= run_length;

  001e4	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  001e7	2b 45 f4	 sub	 eax, DWORD PTR _run_length$4[ebp]
  001ea	89 45 10	 mov	 DWORD PTR _length$[ebp], eax

; 1136 : 			}
; 1137 : 			else

  001ed	e9 04 01 00 00	 jmp	 $LN12@run_length
$LN17@run_length:

; 1138 : 			{
; 1139 : 
; 1140 : 				int
; 1141 : 					count,
; 1142 : 					different,
; 1143 : 					run_length;
; 1144 : 
; 1145 : 				//
; 1146 : 				// Write out a run of different pixel values
; 1147 : 				//
; 1148 : 
; 1149 : 				different = TRUE;

  001f2	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _different$2[ebp], 1

; 1150 : 
; 1151 : 				run_length = 2;

  001f9	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _run_length$1[ebp], 2
$LN6@run_length:

; 1152 : 
; 1153 : 				while ( ( different ) && ( run_length < length ) && ( run_length < 128 ) )

  00200	83 7d ec 00	 cmp	 DWORD PTR _different$2[ebp], 0
  00204	0f 84 87 00 00
	00		 je	 $LN7@run_length
  0020a	8b 45 e8	 mov	 eax, DWORD PTR _run_length$1[ebp]
  0020d	3b 45 10	 cmp	 eax, DWORD PTR _length$[ebp]
  00210	7d 7f		 jge	 SHORT $LN7@run_length
  00212	81 7d e8 80 00
	00 00		 cmp	 DWORD PTR _run_length$1[ebp], 128 ; 00000080H
  00219	7d 76		 jge	 SHORT $LN7@run_length

; 1154 : 				{
; 1155 : 
; 1156 : 					if ( source_data[run_length] != source_data[run_length-1] )

  0021b	8b 45 08	 mov	 eax, DWORD PTR _source_data$[ebp]
  0021e	03 45 e8	 add	 eax, DWORD PTR _run_length$1[ebp]
  00221	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00224	8b 55 08	 mov	 edx, DWORD PTR _source_data$[ebp]
  00227	03 55 e8	 add	 edx, DWORD PTR _run_length$1[ebp]
  0022a	0f b6 42 ff	 movzx	 eax, BYTE PTR [edx-1]
  0022e	3b c8		 cmp	 ecx, eax
  00230	74 0b		 je	 SHORT $LN21@run_length

; 1157 : 					{
; 1158 : 
; 1159 : 						run_length++;

  00232	8b 45 e8	 mov	 eax, DWORD PTR _run_length$1[ebp]
  00235	83 c0 01	 add	 eax, 1
  00238	89 45 e8	 mov	 DWORD PTR _run_length$1[ebp], eax

; 1160 : 					}
; 1161 : 					else

  0023b	eb 4f		 jmp	 SHORT $LN22@run_length
$LN21@run_length:

; 1162 : 					{
; 1163 : 
; 1164 : 						//
; 1165 : 						// If the next byte is different, don't do it!
; 1166 : 						//
; 1167 : 
; 1168 : 						if ( run_length < ( length - 1 ) )

  0023d	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  00240	83 e8 01	 sub	 eax, 1
  00243	39 45 e8	 cmp	 DWORD PTR _run_length$1[ebp], eax
  00246	7d 34		 jge	 SHORT $LN23@run_length

; 1169 : 						{
; 1170 : 
; 1171 : 							if ( source_data[run_length+1] == source_data[run_length] )

  00248	8b 45 08	 mov	 eax, DWORD PTR _source_data$[ebp]
  0024b	03 45 e8	 add	 eax, DWORD PTR _run_length$1[ebp]
  0024e	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00252	8b 55 08	 mov	 edx, DWORD PTR _source_data$[ebp]
  00255	03 55 e8	 add	 edx, DWORD PTR _run_length$1[ebp]
  00258	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0025b	3b c8		 cmp	 ecx, eax
  0025d	75 12		 jne	 SHORT $LN25@run_length

; 1172 : 							{
; 1173 : 		
; 1174 : 								different = FALSE;

  0025f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _different$2[ebp], 0

; 1175 : 		
; 1176 : 								run_length -= 1;

  00266	8b 45 e8	 mov	 eax, DWORD PTR _run_length$1[ebp]
  00269	83 e8 01	 sub	 eax, 1
  0026c	89 45 e8	 mov	 DWORD PTR _run_length$1[ebp], eax

; 1177 : 							}
; 1178 : 							else

  0026f	eb 09		 jmp	 SHORT $LN26@run_length
$LN25@run_length:

; 1179 : 							{
; 1180 : 
; 1181 : 								run_length++;

  00271	8b 45 e8	 mov	 eax, DWORD PTR _run_length$1[ebp]
  00274	83 c0 01	 add	 eax, 1
  00277	89 45 e8	 mov	 DWORD PTR _run_length$1[ebp], eax
$LN26@run_length:

; 1182 : 							}
; 1183 : 						}
; 1184 : 						else

  0027a	eb 10		 jmp	 SHORT $LN22@run_length
$LN23@run_length:

; 1185 : 						{
; 1186 : 	
; 1187 : 							different = FALSE;

  0027c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _different$2[ebp], 0

; 1188 : 	
; 1189 : 							run_length -= 1;

  00283	8b 45 e8	 mov	 eax, DWORD PTR _run_length$1[ebp]
  00286	83 e8 01	 sub	 eax, 1
  00289	89 45 e8	 mov	 DWORD PTR _run_length$1[ebp], eax
$LN22@run_length:

; 1190 : 						}
; 1191 : 					}
; 1192 : 				}

  0028c	e9 6f ff ff ff	 jmp	 $LN6@run_length
$LN7@run_length:

; 1193 : 
; 1194 : 				*result++ = run_length - 1;

  00291	8b 45 e8	 mov	 eax, DWORD PTR _run_length$1[ebp]
  00294	83 e8 01	 sub	 eax, 1
  00297	8b 4d 0c	 mov	 ecx, DWORD PTR _result$[ebp]
  0029a	88 01		 mov	 BYTE PTR [ecx], al
  0029c	8b 55 0c	 mov	 edx, DWORD PTR _result$[ebp]
  0029f	83 c2 01	 add	 edx, 1
  002a2	89 55 0c	 mov	 DWORD PTR _result$[ebp], edx

; 1195 : 
; 1196 : 				for ( count = 0; count < run_length; count++ )

  002a5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$3[ebp], 0
  002ac	eb 09		 jmp	 SHORT $LN10@run_length
$LN8@run_length:
  002ae	8b 45 f0	 mov	 eax, DWORD PTR _count$3[ebp]
  002b1	83 c0 01	 add	 eax, 1
  002b4	89 45 f0	 mov	 DWORD PTR _count$3[ebp], eax
$LN10@run_length:
  002b7	8b 45 f0	 mov	 eax, DWORD PTR _count$3[ebp]
  002ba	3b 45 e8	 cmp	 eax, DWORD PTR _run_length$1[ebp]
  002bd	7d 18		 jge	 SHORT $LN9@run_length

; 1197 : 				{
; 1198 : 
; 1199 : 					*result++ = ( ( const char * ) source_data )[count];

  002bf	8b 45 08	 mov	 eax, DWORD PTR _source_data$[ebp]
  002c2	03 45 f0	 add	 eax, DWORD PTR _count$3[ebp]
  002c5	8b 4d 0c	 mov	 ecx, DWORD PTR _result$[ebp]
  002c8	8a 10		 mov	 dl, BYTE PTR [eax]
  002ca	88 11		 mov	 BYTE PTR [ecx], dl
  002cc	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  002cf	83 c0 01	 add	 eax, 1
  002d2	89 45 0c	 mov	 DWORD PTR _result$[ebp], eax

; 1200 : 				}

  002d5	eb d7		 jmp	 SHORT $LN8@run_length
$LN9@run_length:

; 1201 : 
; 1202 : 				source_data += run_length;

  002d7	8b 45 08	 mov	 eax, DWORD PTR _source_data$[ebp]
  002da	03 45 e8	 add	 eax, DWORD PTR _run_length$1[ebp]
  002dd	89 45 08	 mov	 DWORD PTR _source_data$[ebp], eax

; 1203 : 				data_written += run_length + 1;

  002e0	8b 45 e8	 mov	 eax, DWORD PTR _run_length$1[ebp]
  002e3	8b 4d fc	 mov	 ecx, DWORD PTR _data_written$[ebp]
  002e6	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  002ea	89 55 fc	 mov	 DWORD PTR _data_written$[ebp], edx

; 1204 : 
; 1205 : 				length -= run_length;

  002ed	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  002f0	2b 45 e8	 sub	 eax, DWORD PTR _run_length$1[ebp]
  002f3	89 45 10	 mov	 DWORD PTR _length$[ebp], eax
$LN12@run_length:

; 1206 : 			}
; 1207 : 		}
; 1208 : 	}

  002f6	e9 15 fd ff ff	 jmp	 $LN2@run_length
$LN3@run_length:

; 1209 : 
; 1210 : 	return ( data_written );

  002fb	8b 45 fc	 mov	 eax, DWORD PTR _data_written$[ebp]

; 1211 : }

  002fe	5f		 pop	 edi
  002ff	5e		 pop	 esi
  00300	5b		 pop	 ebx
  00301	8b e5		 mov	 esp, ebp
  00303	5d		 pop	 ebp
  00304	c2 0c 00	 ret	 12			; 0000000cH
?run_length_encode_data@@YGHPBEPAEH@Z ENDP		; run_length_encode_data
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\psdwrite.c
;	COMDAT ?write_psd_colourindex_and_alpha@@YGXPBDHHHPBE@Z
_TEXT	SEGMENT
_source_line$1 = -44					; size = 4
_source_line$2 = -40					; size = 4
_graphic_data$ = -36					; size = 4
_y$ = -32						; size = 4
_x$ = -28						; size = 4
_compression_tables_offset$ = -24			; size = 4
_length$ = -20						; size = 4
_count$ = -16						; size = 4
_reserved_bytes$ = -12					; size = 6
_fp$ = -4						; size = 4
_filename$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_pitch$ = 20						; size = 4
_data$ = 24						; size = 4
?write_psd_colourindex_and_alpha@@YGXPBDHHHPBE@Z PROC	; write_psd_colourindex_and_alpha, COMDAT

; 799  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 800  : 
; 801  : 	FILE
; 802  : 		*fp;
; 803  : 
; 804  : 	char
; 805  : 		reserved_bytes[6];
; 806  : 
; 807  : 	int
; 808  : 		count,
; 809  : 		length,
; 810  : 		compression_tables_offset,
; 811  : 		x,
; 812  : 		y;
; 813  : 
; 814  : 	const unsigned char
; 815  : 		*graphic_data;
; 816  : 
; 817  : 	fp = safe_fopen ( filename, "wb" );

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  0000e	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?safe_fopen@@YGPAU_iobuf@@PBD0@Z ; safe_fopen
  00017	89 45 fc	 mov	 DWORD PTR _fp$[ebp], eax

; 818  : 
; 819  : 	//
; 820  : 	// Allocate the memory arrays.
; 821  : 	//
; 822  : 
; 823  : 	red_channel_line_lengths = ( unsigned short * ) safe_malloc ( height * sizeof ( short int ) );

  0001a	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  0001d	d1 e0		 shl	 eax, 1
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00025	a3 00 00 00 00	 mov	 DWORD PTR ?red_channel_line_lengths@@3PAGA, eax ; red_channel_line_lengths

; 824  : 
; 825  : 	green_channel_line_lengths = ( unsigned short * ) safe_malloc ( height * sizeof ( short int ) );

  0002a	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  0002d	d1 e0		 shl	 eax, 1
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00035	a3 00 00 00 00	 mov	 DWORD PTR ?green_channel_line_lengths@@3PAGA, eax ; green_channel_line_lengths

; 826  : 
; 827  : 	channel_compressed_data = ( unsigned char * ) safe_malloc ( width * 8 );

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0003d	c1 e0 03	 shl	 eax, 3
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00046	a3 00 00 00 00	 mov	 DWORD PTR ?channel_compressed_data@@3PAEA, eax ; channel_compressed_data

; 828  : 
; 829  : 	channel_line_data = ( unsigned char * ) safe_malloc ( width );

  0004b	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00054	a3 00 00 00 00	 mov	 DWORD PTR ?channel_line_data@@3PAEA, eax ; channel_line_data

; 830  : 
; 831  : 	//
; 832  : 	// Write out the signature of the file
; 833  : 	//
; 834  : 
; 835  : 	fwrite ( "8BPS", 4, 1, fp );

  00059	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0005c	50		 push	 eax
  0005d	6a 01		 push	 1
  0005f	6a 04		 push	 4
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_04GELLELDE@8BPS@
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0006c	83 c4 10	 add	 esp, 16			; 00000010H

; 836  : 
; 837  : 	//
; 838  : 	// Set the version of the format
; 839  : 	//
; 840  : 
; 841  : 	iff_short_int_write ( 1, fp );

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00072	50		 push	 eax
  00073	6a 01		 push	 1
  00075	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 842  : 
; 843  : 	//
; 844  : 	// Write the reserved bytes
; 845  : 	//
; 846  : 
; 847  : 	memset ( reserved_bytes, 0, 6 );

  0007a	6a 06		 push	 6
  0007c	6a 00		 push	 0
  0007e	8d 45 f4	 lea	 eax, DWORD PTR _reserved_bytes$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 _memset
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH

; 848  : 
; 849  : 	fwrite ( reserved_bytes, 6, 1, fp );

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0008d	50		 push	 eax
  0008e	6a 01		 push	 1
  00090	6a 06		 push	 6
  00092	8d 4d f4	 lea	 ecx, DWORD PTR _reserved_bytes$[ebp]
  00095	51		 push	 ecx
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0009c	83 c4 10	 add	 esp, 16			; 00000010H

; 850  : 
; 851  : 	//
; 852  : 	// Set the information about the image
; 853  : 	//
; 854  : 
; 855  : 	//
; 856  : 	// Number of channels
; 857  : 	//
; 858  : 
; 859  : 	iff_short_int_write ( 2, fp );

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000a2	50		 push	 eax
  000a3	6a 02		 push	 2
  000a5	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 860  : 
; 861  : 	//
; 862  : 	// Height, width
; 863  : 	//
; 864  : 
; 865  : 	iff_int_write ( height, fp );

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d 10	 mov	 ecx, DWORD PTR _height$[ebp]
  000b1	51		 push	 ecx
  000b2	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 866  : 
; 867  : 	iff_int_write ( width, fp );

  000b7	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _width$[ebp]
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 868  : 
; 869  : 	//
; 870  : 	// Bits per channel
; 871  : 	//
; 872  : 
; 873  : 	iff_short_int_write ( 8, fp );

  000c4	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000c7	50		 push	 eax
  000c8	6a 08		 push	 8
  000ca	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 874  : 
; 875  : 	//
; 876  : 	// Image mode - colourindex
; 877  : 	//
; 878  : 
; 879  : 	iff_short_int_write ( 2, fp );

  000cf	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000d2	50		 push	 eax
  000d3	6a 02		 push	 2
  000d5	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 880  : 
; 881  : 	//
; 882  : 	// Need to write colour palette
; 883  : 	//
; 884  : 
; 885  : 	iff_int_write ( 768, fp );

  000da	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000dd	50		 push	 eax
  000de	68 00 03 00 00	 push	 768			; 00000300H
  000e3	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 886  : 
; 887  : 	for ( count = 0; count < 256; count++ )

  000e8	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  000ef	eb 09		 jmp	 SHORT $LN4@write_psd_
$LN2@write_psd_:
  000f1	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  000f4	83 c0 01	 add	 eax, 1
  000f7	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN4@write_psd_:
  000fa	81 7d f0 00 01
	00 00		 cmp	 DWORD PTR _count$[ebp], 256 ; 00000100H
  00101	7d 1e		 jge	 SHORT $LN3@write_psd_

; 888  : 	{
; 889  : 
; 890  : 		fwrite ( &psd_palette[count].r, 1, 1, fp );

  00103	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00106	50		 push	 eax
  00107	6a 01		 push	 1
  00109	6a 01		 push	 1
  0010b	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  0010e	8d 14 8d 02 00
	00 00		 lea	 edx, DWORD PTR ?psd_palette@@3PAUREAL_COLOUR@@A[ecx*4+2]
  00115	52		 push	 edx
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0011c	83 c4 10	 add	 esp, 16			; 00000010H

; 891  : 	}

  0011f	eb d0		 jmp	 SHORT $LN2@write_psd_
$LN3@write_psd_:

; 892  : 
; 893  : 	for ( count = 0; count < 256; count++ )

  00121	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00128	eb 09		 jmp	 SHORT $LN7@write_psd_
$LN5@write_psd_:
  0012a	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  0012d	83 c0 01	 add	 eax, 1
  00130	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN7@write_psd_:
  00133	81 7d f0 00 01
	00 00		 cmp	 DWORD PTR _count$[ebp], 256 ; 00000100H
  0013a	7d 1e		 jge	 SHORT $LN6@write_psd_

; 894  : 	{
; 895  : 
; 896  : 		fwrite ( &psd_palette[count].g, 1, 1, fp );

  0013c	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0013f	50		 push	 eax
  00140	6a 01		 push	 1
  00142	6a 01		 push	 1
  00144	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  00147	8d 14 8d 01 00
	00 00		 lea	 edx, DWORD PTR ?psd_palette@@3PAUREAL_COLOUR@@A[ecx*4+1]
  0014e	52		 push	 edx
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00155	83 c4 10	 add	 esp, 16			; 00000010H

; 897  : 	}

  00158	eb d0		 jmp	 SHORT $LN5@write_psd_
$LN6@write_psd_:

; 898  : 
; 899  : 	for ( count = 0; count < 256; count++ )

  0015a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00161	eb 09		 jmp	 SHORT $LN10@write_psd_
$LN8@write_psd_:
  00163	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  00166	83 c0 01	 add	 eax, 1
  00169	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN10@write_psd_:
  0016c	81 7d f0 00 01
	00 00		 cmp	 DWORD PTR _count$[ebp], 256 ; 00000100H
  00173	7d 1e		 jge	 SHORT $LN9@write_psd_

; 900  : 	{
; 901  : 
; 902  : 		fwrite ( &psd_palette[count].b, 1, 1, fp );

  00175	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00178	50		 push	 eax
  00179	6a 01		 push	 1
  0017b	6a 01		 push	 1
  0017d	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  00180	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR ?psd_palette@@3PAUREAL_COLOUR@@A[ecx*4]
  00187	52		 push	 edx
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0018e	83 c4 10	 add	 esp, 16			; 00000010H

; 903  : 	}

  00191	eb d0		 jmp	 SHORT $LN8@write_psd_
$LN9@write_psd_:

; 904  : 
; 905  : 	//
; 906  : 	// Write out no image resources, length = 0
; 907  : 	//
; 908  : 
; 909  : 	iff_int_write ( 0, fp );

  00193	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00196	50		 push	 eax
  00197	6a 00		 push	 0
  00199	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 910  : 
; 911  : 	//
; 912  : 	// Write out no layer/mask information, length = 0 
; 913  : 	//
; 914  : 
; 915  : 	iff_int_write ( 0, fp );

  0019e	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  001a1	50		 push	 eax
  001a2	6a 00		 push	 0
  001a4	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 916  : 
; 917  : 	//
; 918  : 	// Set the compression to RLE compressed ( 1 )
; 919  : 	//
; 920  : 
; 921  : 	iff_short_int_write ( 1, fp );

  001a9	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  001ac	50		 push	 eax
  001ad	6a 01		 push	 1
  001af	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 922  : 
; 923  : 	//
; 924  : 	// Skip over the compression table - seek back later & write it
; 925  : 	//
; 926  : 
; 927  : 	compression_tables_offset = ftell ( fp );

  001b4	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  001b7	50		 push	 eax
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  001be	83 c4 04	 add	 esp, 4
  001c1	89 45 e8	 mov	 DWORD PTR _compression_tables_offset$[ebp], eax

; 928  : 
; 929  : 	fseek ( fp, ( height * 2 * 2 ), SEEK_CUR );

  001c4	6a 01		 push	 1
  001c6	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  001c9	d1 e0		 shl	 eax, 1
  001cb	d1 e0		 shl	 eax, 1
  001cd	50		 push	 eax
  001ce	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  001d1	51		 push	 ecx
  001d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  001d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 930  : 
; 931  : 	//
; 932  : 	// Write out the paletted channel.
; 933  : 	//
; 934  : 
; 935  : 	graphic_data = data;

  001db	8b 45 18	 mov	 eax, DWORD PTR _data$[ebp]
  001de	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 936  : 
; 937  : 	for ( y = 0; y < height; y++ )

  001e1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  001e8	eb 09		 jmp	 SHORT $LN13@write_psd_
$LN11@write_psd_:
  001ea	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  001ed	83 c0 01	 add	 eax, 1
  001f0	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax
$LN13@write_psd_:
  001f3	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  001f6	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  001f9	0f 8d 8d 00 00
	00		 jge	 $LN12@write_psd_

; 938  : 	{
; 939  : 
; 940  : 		const unsigned char
; 941  : 			*source_line;
; 942  : 
; 943  : 		source_line = graphic_data;

  001ff	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  00202	89 45 d8	 mov	 DWORD PTR _source_line$2[ebp], eax

; 944  : 
; 945  : 		for ( x = 0; x < width; x++ )

  00205	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  0020c	eb 09		 jmp	 SHORT $LN16@write_psd_
$LN14@write_psd_:
  0020e	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  00211	83 c0 01	 add	 eax, 1
  00214	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax
$LN16@write_psd_:
  00217	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  0021a	3b 45 0c	 cmp	 eax, DWORD PTR _width$[ebp]
  0021d	7d 1a		 jge	 SHORT $LN15@write_psd_

; 946  : 		{
; 947  : 
; 948  : 			channel_line_data[x] = *source_line;

  0021f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  00224	03 45 e4	 add	 eax, DWORD PTR _x$[ebp]
  00227	8b 4d d8	 mov	 ecx, DWORD PTR _source_line$2[ebp]
  0022a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0022c	88 10		 mov	 BYTE PTR [eax], dl

; 949  : 
; 950  : 			source_line += 2;

  0022e	8b 45 d8	 mov	 eax, DWORD PTR _source_line$2[ebp]
  00231	83 c0 02	 add	 eax, 2
  00234	89 45 d8	 mov	 DWORD PTR _source_line$2[ebp], eax

; 951  : 		}

  00237	eb d5		 jmp	 SHORT $LN14@write_psd_
$LN15@write_psd_:

; 952  : 
; 953  : 		//
; 954  : 		// Now compress the line itself
; 955  : 		//
; 956  : 
; 957  : 		length = run_length_encode_data ( channel_line_data, channel_compressed_data, width );

  00239	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0023c	50		 push	 eax
  0023d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  00243	51		 push	 ecx
  00244	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  0024a	52		 push	 edx
  0024b	e8 00 00 00 00	 call	 ?run_length_encode_data@@YGHPBEPAEH@Z ; run_length_encode_data
  00250	89 45 ec	 mov	 DWORD PTR _length$[ebp], eax

; 958  : 
; 959  : 		red_channel_line_lengths[y] = length;

  00253	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00256	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?red_channel_line_lengths@@3PAGA ; red_channel_line_lengths
  0025c	66 8b 55 ec	 mov	 dx, WORD PTR _length$[ebp]
  00260	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 960  : 
; 961  : 		fwrite ( channel_compressed_data, length, 1, fp );

  00264	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00267	50		 push	 eax
  00268	6a 01		 push	 1
  0026a	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  0026d	51		 push	 ecx
  0026e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  00274	52		 push	 edx
  00275	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0027b	83 c4 10	 add	 esp, 16			; 00000010H

; 962  : 
; 963  : 		graphic_data += pitch;

  0027e	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  00281	03 45 14	 add	 eax, DWORD PTR _pitch$[ebp]
  00284	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 964  : 	}

  00287	e9 5e ff ff ff	 jmp	 $LN11@write_psd_
$LN12@write_psd_:

; 965  : 
; 966  : 	//
; 967  : 	// Write out the alpha channel.
; 968  : 	//
; 969  : 
; 970  : 	graphic_data = &data[1];

  0028c	b8 01 00 00 00	 mov	 eax, 1
  00291	c1 e0 00	 shl	 eax, 0
  00294	03 45 18	 add	 eax, DWORD PTR _data$[ebp]
  00297	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 971  : 
; 972  : 	for ( y = 0; y < height; y++ )

  0029a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  002a1	eb 09		 jmp	 SHORT $LN19@write_psd_
$LN17@write_psd_:
  002a3	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  002a6	83 c0 01	 add	 eax, 1
  002a9	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax
$LN19@write_psd_:
  002ac	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  002af	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  002b2	0f 8d 8d 00 00
	00		 jge	 $LN18@write_psd_

; 973  : 	{
; 974  : 
; 975  : 		const unsigned char
; 976  : 			*source_line;
; 977  : 
; 978  : 		source_line = graphic_data;

  002b8	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  002bb	89 45 d4	 mov	 DWORD PTR _source_line$1[ebp], eax

; 979  : 
; 980  : 		for ( x = 0; x < width; x++ )

  002be	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  002c5	eb 09		 jmp	 SHORT $LN22@write_psd_
$LN20@write_psd_:
  002c7	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  002ca	83 c0 01	 add	 eax, 1
  002cd	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax
$LN22@write_psd_:
  002d0	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  002d3	3b 45 0c	 cmp	 eax, DWORD PTR _width$[ebp]
  002d6	7d 1a		 jge	 SHORT $LN21@write_psd_

; 981  : 		{
; 982  : 
; 983  : 			channel_line_data[x] = *source_line;

  002d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  002dd	03 45 e4	 add	 eax, DWORD PTR _x$[ebp]
  002e0	8b 4d d4	 mov	 ecx, DWORD PTR _source_line$1[ebp]
  002e3	8a 11		 mov	 dl, BYTE PTR [ecx]
  002e5	88 10		 mov	 BYTE PTR [eax], dl

; 984  : 
; 985  : 			source_line += 2;

  002e7	8b 45 d4	 mov	 eax, DWORD PTR _source_line$1[ebp]
  002ea	83 c0 02	 add	 eax, 2
  002ed	89 45 d4	 mov	 DWORD PTR _source_line$1[ebp], eax

; 986  : 		}

  002f0	eb d5		 jmp	 SHORT $LN20@write_psd_
$LN21@write_psd_:

; 987  : 
; 988  : 		//
; 989  : 		// Now compress the line itself
; 990  : 		//
; 991  : 
; 992  : 		length = run_length_encode_data ( channel_line_data, channel_compressed_data, width );

  002f2	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  002f5	50		 push	 eax
  002f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  002fc	51		 push	 ecx
  002fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  00303	52		 push	 edx
  00304	e8 00 00 00 00	 call	 ?run_length_encode_data@@YGHPBEPAEH@Z ; run_length_encode_data
  00309	89 45 ec	 mov	 DWORD PTR _length$[ebp], eax

; 993  : 
; 994  : 		green_channel_line_lengths[y] = length;

  0030c	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  0030f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?green_channel_line_lengths@@3PAGA ; green_channel_line_lengths
  00315	66 8b 55 ec	 mov	 dx, WORD PTR _length$[ebp]
  00319	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 995  : 
; 996  : 		fwrite ( channel_compressed_data, length, 1, fp );

  0031d	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00320	50		 push	 eax
  00321	6a 01		 push	 1
  00323	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  00326	51		 push	 ecx
  00327	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  0032d	52		 push	 edx
  0032e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00334	83 c4 10	 add	 esp, 16			; 00000010H

; 997  : 
; 998  : 		graphic_data += pitch;

  00337	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  0033a	03 45 14	 add	 eax, DWORD PTR _pitch$[ebp]
  0033d	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 999  : 	}

  00340	e9 5e ff ff ff	 jmp	 $LN17@write_psd_
$LN18@write_psd_:

; 1000 : 
; 1001 : 	//
; 1002 : 	// Write out the compression table for each channel
; 1003 : 	//
; 1004 : 
; 1005 : 	fseek ( fp, compression_tables_offset, SEEK_SET );

  00345	6a 00		 push	 0
  00347	8b 45 e8	 mov	 eax, DWORD PTR _compression_tables_offset$[ebp]
  0034a	50		 push	 eax
  0034b	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  0034e	51		 push	 ecx
  0034f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00355	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1006 : 
; 1007 : 	for ( count = 0; count < height; count++ )

  00358	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  0035f	eb 09		 jmp	 SHORT $LN25@write_psd_
$LN23@write_psd_:
  00361	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  00364	83 c0 01	 add	 eax, 1
  00367	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN25@write_psd_:
  0036a	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  0036d	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  00370	7d 19		 jge	 SHORT $LN24@write_psd_

; 1008 : 	{
; 1009 : 
; 1010 : 		iff_short_int_write ( red_channel_line_lengths[count], fp );

  00372	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00375	50		 push	 eax
  00376	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  00379	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?red_channel_line_lengths@@3PAGA ; red_channel_line_lengths
  0037f	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00383	50		 push	 eax
  00384	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 1011 : 	}

  00389	eb d6		 jmp	 SHORT $LN23@write_psd_
$LN24@write_psd_:

; 1012 : 
; 1013 : 	for ( count = 0; count < height; count++ )

  0038b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00392	eb 09		 jmp	 SHORT $LN28@write_psd_
$LN26@write_psd_:
  00394	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  00397	83 c0 01	 add	 eax, 1
  0039a	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN28@write_psd_:
  0039d	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  003a0	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  003a3	7d 19		 jge	 SHORT $LN27@write_psd_

; 1014 : 	{
; 1015 : 
; 1016 : 		iff_short_int_write ( green_channel_line_lengths[count], fp );

  003a5	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  003a8	50		 push	 eax
  003a9	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  003ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?green_channel_line_lengths@@3PAGA ; green_channel_line_lengths
  003b2	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003b6	50		 push	 eax
  003b7	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 1017 : 	}

  003bc	eb d6		 jmp	 SHORT $LN26@write_psd_
$LN27@write_psd_:

; 1018 : 
; 1019 : 	//
; 1020 : 	// Close the file
; 1021 : 	//
; 1022 : 
; 1023 : 	fclose ( fp );

  003be	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  003c1	50		 push	 eax
  003c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  003c8	83 c4 04	 add	 esp, 4

; 1024 : 
; 1025 : 	//
; 1026 : 	// Free up the memory
; 1027 : 	//
; 1028 : 
; 1029 : 	safe_free ( red_channel_line_lengths );

  003cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?red_channel_line_lengths@@3PAGA ; red_channel_line_lengths
  003d0	50		 push	 eax
  003d1	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 1030 : 
; 1031 : 	safe_free ( green_channel_line_lengths );

  003d6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?green_channel_line_lengths@@3PAGA ; green_channel_line_lengths
  003db	50		 push	 eax
  003dc	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 1032 : 
; 1033 : 	safe_free ( channel_compressed_data );

  003e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  003e6	50		 push	 eax
  003e7	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 1034 : 
; 1035 : 	safe_free ( channel_line_data );

  003ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  003f1	50		 push	 eax
  003f2	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 1036 : }

  003f7	5f		 pop	 edi
  003f8	5e		 pop	 esi
  003f9	5b		 pop	 ebx
  003fa	8b e5		 mov	 esp, ebp
  003fc	5d		 pop	 ebp
  003fd	c2 14 00	 ret	 20			; 00000014H
?write_psd_colourindex_and_alpha@@YGXPBDHHHPBE@Z ENDP	; write_psd_colourindex_and_alpha
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\psdwrite.c
;	COMDAT ?write_psd_greyscale@@YGXPBDHHHPBE@Z
_TEXT	SEGMENT
_y$ = -32						; size = 4
_x$ = -28						; size = 4
_compression_tables_offset$ = -24			; size = 4
_length$ = -20						; size = 4
_count$ = -16						; size = 4
_reserved_bytes$ = -12					; size = 6
_fp$ = -4						; size = 4
_filename$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_pitch$ = 20						; size = 4
_data$ = 24						; size = 4
?write_psd_greyscale@@YGXPBDHHHPBE@Z PROC		; write_psd_greyscale, COMDAT

; 630  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 631  : 
; 632  : 	FILE
; 633  : 		*fp;
; 634  : 
; 635  : 	char
; 636  : 		reserved_bytes[6];
; 637  : 
; 638  : 	int
; 639  : 		count,
; 640  : 		length,
; 641  : 		compression_tables_offset,
; 642  : 		x,
; 643  : 		y;
; 644  : 
; 645  : 	fp = safe_fopen ( filename, "wb" );

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  0000e	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?safe_fopen@@YGPAU_iobuf@@PBD0@Z ; safe_fopen
  00017	89 45 fc	 mov	 DWORD PTR _fp$[ebp], eax

; 646  : 
; 647  : 	//
; 648  : 	// Allocate the memory arrays.
; 649  : 	//
; 650  : 
; 651  : 	red_channel_line_lengths = ( unsigned short * ) safe_malloc ( height * sizeof ( short int ) );

  0001a	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  0001d	d1 e0		 shl	 eax, 1
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00025	a3 00 00 00 00	 mov	 DWORD PTR ?red_channel_line_lengths@@3PAGA, eax ; red_channel_line_lengths

; 652  : 
; 653  : 	channel_compressed_data = ( unsigned char * ) safe_malloc ( width * 8 );

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0002d	c1 e0 03	 shl	 eax, 3
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00036	a3 00 00 00 00	 mov	 DWORD PTR ?channel_compressed_data@@3PAEA, eax ; channel_compressed_data

; 654  : 
; 655  : 	channel_line_data = ( unsigned char * ) safe_malloc ( width );

  0003b	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00044	a3 00 00 00 00	 mov	 DWORD PTR ?channel_line_data@@3PAEA, eax ; channel_line_data

; 656  : 
; 657  : 	//
; 658  : 	// Write out the signature of the file
; 659  : 	//
; 660  : 
; 661  : 	fwrite ( "8BPS", 4, 1, fp );

  00049	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0004c	50		 push	 eax
  0004d	6a 01		 push	 1
  0004f	6a 04		 push	 4
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_04GELLELDE@8BPS@
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0005c	83 c4 10	 add	 esp, 16			; 00000010H

; 662  : 
; 663  : 	//
; 664  : 	// Set the version of the format
; 665  : 	//
; 666  : 
; 667  : 	iff_short_int_write ( 1, fp );

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00062	50		 push	 eax
  00063	6a 01		 push	 1
  00065	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 668  : 
; 669  : 	//
; 670  : 	// Write the reserved bytes
; 671  : 	//
; 672  : 
; 673  : 	memset ( reserved_bytes, 0, 6 );

  0006a	6a 06		 push	 6
  0006c	6a 00		 push	 0
  0006e	8d 45 f4	 lea	 eax, DWORD PTR _reserved_bytes$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _memset
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 674  : 
; 675  : 	fwrite ( reserved_bytes, 6, 1, fp );

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0007d	50		 push	 eax
  0007e	6a 01		 push	 1
  00080	6a 06		 push	 6
  00082	8d 4d f4	 lea	 ecx, DWORD PTR _reserved_bytes$[ebp]
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0008c	83 c4 10	 add	 esp, 16			; 00000010H

; 676  : 
; 677  : 	//
; 678  : 	// Set the information about the image
; 679  : 	//
; 680  : 
; 681  : 	//
; 682  : 	// Number of channels
; 683  : 	//
; 684  : 
; 685  : 	iff_short_int_write ( 1, fp );

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00092	50		 push	 eax
  00093	6a 01		 push	 1
  00095	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 686  : 
; 687  : 	//
; 688  : 	// Height, width
; 689  : 	//
; 690  : 
; 691  : 	iff_int_write ( height, fp );

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0009d	50		 push	 eax
  0009e	8b 4d 10	 mov	 ecx, DWORD PTR _height$[ebp]
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 692  : 
; 693  : 	iff_int_write ( width, fp );

  000a7	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000aa	50		 push	 eax
  000ab	8b 4d 0c	 mov	 ecx, DWORD PTR _width$[ebp]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 694  : 
; 695  : 	//
; 696  : 	// Bits per channel
; 697  : 	//
; 698  : 
; 699  : 	iff_short_int_write ( 8, fp );

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000b7	50		 push	 eax
  000b8	6a 08		 push	 8
  000ba	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 700  : 
; 701  : 	//
; 702  : 	// Image mode - greyscale
; 703  : 	//
; 704  : 
; 705  : 	iff_short_int_write ( 1, fp );

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000c2	50		 push	 eax
  000c3	6a 01		 push	 1
  000c5	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 706  : 
; 707  : 	//
; 708  : 	// No colour mode data, so write length = 0
; 709  : 	//
; 710  : 
; 711  : 	iff_int_write ( 0, fp );

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000cd	50		 push	 eax
  000ce	6a 00		 push	 0
  000d0	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 712  : 
; 713  : 	//
; 714  : 	// Write out no image resources, length = 0
; 715  : 	//
; 716  : 
; 717  : 	iff_int_write ( 0, fp );

  000d5	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000d8	50		 push	 eax
  000d9	6a 00		 push	 0
  000db	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 718  : 
; 719  : 	//
; 720  : 	// Write out no layer/mask information, length = 0 
; 721  : 	//
; 722  : 
; 723  : 	iff_int_write ( 0, fp );

  000e0	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000e3	50		 push	 eax
  000e4	6a 00		 push	 0
  000e6	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 724  : 
; 725  : 	//
; 726  : 	// Set the compression to RLE compressed ( 1 )
; 727  : 	//
; 728  : 
; 729  : 	iff_short_int_write ( 1, fp );

  000eb	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000ee	50		 push	 eax
  000ef	6a 01		 push	 1
  000f1	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 730  : 
; 731  : 	//
; 732  : 	// Skip over the compression table - seek back later & write it
; 733  : 	//
; 734  : 
; 735  : 	compression_tables_offset = ftell ( fp );

  000f6	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000f9	50		 push	 eax
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00100	83 c4 04	 add	 esp, 4
  00103	89 45 e8	 mov	 DWORD PTR _compression_tables_offset$[ebp], eax

; 736  : 
; 737  : 	fseek ( fp, height * 2, SEEK_CUR );

  00106	6a 01		 push	 1
  00108	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  0010b	d1 e0		 shl	 eax, 1
  0010d	50		 push	 eax
  0010e	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  00111	51		 push	 ecx
  00112	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH

; 738  : 
; 739  : 	//
; 740  : 	// Now write out the grey channel.
; 741  : 	//
; 742  : 
; 743  : 	for ( y = 0; y < height; y++ )

  0011b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00122	eb 09		 jmp	 SHORT $LN4@write_psd_
$LN2@write_psd_:
  00124	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00127	83 c0 01	 add	 eax, 1
  0012a	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax
$LN4@write_psd_:
  0012d	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00130	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  00133	0f 8d 81 00 00
	00		 jge	 $LN3@write_psd_

; 744  : 	{
; 745  : 
; 746  : 		for ( x = 0; x < width; x++ )

  00139	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00140	eb 09		 jmp	 SHORT $LN7@write_psd_
$LN5@write_psd_:
  00142	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  00145	83 c0 01	 add	 eax, 1
  00148	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax
$LN7@write_psd_:
  0014b	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  0014e	3b 45 0c	 cmp	 eax, DWORD PTR _width$[ebp]
  00151	7d 14		 jge	 SHORT $LN6@write_psd_

; 747  : 		{
; 748  : 
; 749  : 			channel_line_data[x] = data[x];

  00153	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  00158	03 45 e4	 add	 eax, DWORD PTR _x$[ebp]
  0015b	8b 4d 18	 mov	 ecx, DWORD PTR _data$[ebp]
  0015e	03 4d e4	 add	 ecx, DWORD PTR _x$[ebp]
  00161	8a 11		 mov	 dl, BYTE PTR [ecx]
  00163	88 10		 mov	 BYTE PTR [eax], dl

; 750  : 		}

  00165	eb db		 jmp	 SHORT $LN5@write_psd_
$LN6@write_psd_:

; 751  : 
; 752  : 		//
; 753  : 		// Now compress the line itself
; 754  : 		//
; 755  : 
; 756  : 		length = run_length_encode_data ( channel_line_data, channel_compressed_data, width );

  00167	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0016a	50		 push	 eax
  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  00171	51		 push	 ecx
  00172	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  00178	52		 push	 edx
  00179	e8 00 00 00 00	 call	 ?run_length_encode_data@@YGHPBEPAEH@Z ; run_length_encode_data
  0017e	89 45 ec	 mov	 DWORD PTR _length$[ebp], eax

; 757  : 
; 758  : 		red_channel_line_lengths[y] = length;

  00181	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00184	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?red_channel_line_lengths@@3PAGA ; red_channel_line_lengths
  0018a	66 8b 55 ec	 mov	 dx, WORD PTR _length$[ebp]
  0018e	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 759  : 
; 760  : 		fwrite ( channel_compressed_data, length, 1, fp );

  00192	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00195	50		 push	 eax
  00196	6a 01		 push	 1
  00198	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  0019b	51		 push	 ecx
  0019c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  001a2	52		 push	 edx
  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  001a9	83 c4 10	 add	 esp, 16			; 00000010H

; 761  : 
; 762  : 		data += pitch;

  001ac	8b 45 18	 mov	 eax, DWORD PTR _data$[ebp]
  001af	03 45 14	 add	 eax, DWORD PTR _pitch$[ebp]
  001b2	89 45 18	 mov	 DWORD PTR _data$[ebp], eax

; 763  : 	}

  001b5	e9 6a ff ff ff	 jmp	 $LN2@write_psd_
$LN3@write_psd_:

; 764  : 
; 765  : 	//
; 766  : 	// Write out the compression table for each channel
; 767  : 	//
; 768  : 
; 769  : 	fseek ( fp, compression_tables_offset, SEEK_SET );

  001ba	6a 00		 push	 0
  001bc	8b 45 e8	 mov	 eax, DWORD PTR _compression_tables_offset$[ebp]
  001bf	50		 push	 eax
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  001c3	51		 push	 ecx
  001c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  001ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 770  : 
; 771  : 	for ( count = 0; count < height; count++ )

  001cd	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  001d4	eb 09		 jmp	 SHORT $LN10@write_psd_
$LN8@write_psd_:
  001d6	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  001d9	83 c0 01	 add	 eax, 1
  001dc	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN10@write_psd_:
  001df	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  001e2	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  001e5	7d 19		 jge	 SHORT $LN9@write_psd_

; 772  : 	{
; 773  : 
; 774  : 		iff_short_int_write ( red_channel_line_lengths[count], fp );

  001e7	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  001ea	50		 push	 eax
  001eb	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  001ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?red_channel_line_lengths@@3PAGA ; red_channel_line_lengths
  001f4	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  001f8	50		 push	 eax
  001f9	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 775  : 	}

  001fe	eb d6		 jmp	 SHORT $LN8@write_psd_
$LN9@write_psd_:

; 776  : 
; 777  : 	//
; 778  : 	// Close the file
; 779  : 	//
; 780  : 
; 781  : 	fclose ( fp );

  00200	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00203	50		 push	 eax
  00204	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0020a	83 c4 04	 add	 esp, 4

; 782  : 
; 783  : 	//
; 784  : 	// Free up the memory
; 785  : 	//
; 786  : 
; 787  : 	safe_free ( red_channel_line_lengths );

  0020d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?red_channel_line_lengths@@3PAGA ; red_channel_line_lengths
  00212	50		 push	 eax
  00213	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 788  : 
; 789  : 	safe_free ( channel_compressed_data );

  00218	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 790  : 
; 791  : 	safe_free ( channel_line_data );

  00223	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  00228	50		 push	 eax
  00229	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 792  : }

  0022e	5f		 pop	 edi
  0022f	5e		 pop	 esi
  00230	5b		 pop	 ebx
  00231	8b e5		 mov	 esp, ebp
  00233	5d		 pop	 ebp
  00234	c2 14 00	 ret	 20			; 00000014H
?write_psd_greyscale@@YGXPBDHHHPBE@Z ENDP		; write_psd_greyscale
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\psdwrite.c
;	COMDAT ?write_psd_rgb_file@@YGXPBDHHHPBE@Z
_TEXT	SEGMENT
_source_line$ = -40					; size = 4
_graphic_data$ = -36					; size = 4
_y$ = -32						; size = 4
_x$ = -28						; size = 4
_compression_tables_offset$ = -24			; size = 4
_length$ = -20						; size = 4
_count$ = -16						; size = 4
_reserved_bytes$ = -12					; size = 6
_fp$ = -4						; size = 4
_filename$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_pitch$ = 20						; size = 4
_data$ = 24						; size = 4
?write_psd_rgb_file@@YGXPBDHHHPBE@Z PROC		; write_psd_rgb_file, COMDAT

; 375  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 376  : 
; 377  : 	FILE
; 378  : 		*fp;
; 379  : 
; 380  : 	char
; 381  : 		reserved_bytes[6];
; 382  : 
; 383  : 	int
; 384  : 		count,
; 385  : 		length,
; 386  : 		compression_tables_offset,
; 387  : 		x,
; 388  : 		y;
; 389  : 
; 390  : 	const unsigned char
; 391  : 		*graphic_data,
; 392  : 		*source_line;
; 393  : 
; 394  : 	fp = safe_fopen ( filename, "wb" );

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  0000e	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?safe_fopen@@YGPAU_iobuf@@PBD0@Z ; safe_fopen
  00017	89 45 fc	 mov	 DWORD PTR _fp$[ebp], eax

; 395  : 
; 396  : 	//
; 397  : 	// Allocate the memory arrays.
; 398  : 	//
; 399  : 
; 400  : 	red_channel_line_lengths = ( unsigned short * ) safe_malloc ( height * sizeof ( short int ) );

  0001a	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  0001d	d1 e0		 shl	 eax, 1
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00025	a3 00 00 00 00	 mov	 DWORD PTR ?red_channel_line_lengths@@3PAGA, eax ; red_channel_line_lengths

; 401  : 
; 402  : 	green_channel_line_lengths = ( unsigned short * ) safe_malloc ( height * sizeof ( short int ) );

  0002a	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  0002d	d1 e0		 shl	 eax, 1
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00035	a3 00 00 00 00	 mov	 DWORD PTR ?green_channel_line_lengths@@3PAGA, eax ; green_channel_line_lengths

; 403  : 
; 404  : 	blue_channel_line_lengths = ( unsigned short * ) safe_malloc ( height * sizeof ( short int ) );

  0003a	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  0003d	d1 e0		 shl	 eax, 1
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00045	a3 00 00 00 00	 mov	 DWORD PTR ?blue_channel_line_lengths@@3PAGA, eax ; blue_channel_line_lengths

; 405  : 
; 406  : 	channel_compressed_data = ( unsigned char * ) safe_malloc ( width * 4 );

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0004d	c1 e0 02	 shl	 eax, 2
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00056	a3 00 00 00 00	 mov	 DWORD PTR ?channel_compressed_data@@3PAEA, eax ; channel_compressed_data

; 407  : 
; 408  : 	channel_line_data = ( unsigned char * ) safe_malloc ( width );

  0005b	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00064	a3 00 00 00 00	 mov	 DWORD PTR ?channel_line_data@@3PAEA, eax ; channel_line_data

; 409  : 
; 410  : 	//
; 411  : 	// Write out the signature of the file
; 412  : 	//
; 413  : 
; 414  : 	fwrite ( "8BPS", 4, 1, fp );

  00069	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0006c	50		 push	 eax
  0006d	6a 01		 push	 1
  0006f	6a 04		 push	 4
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_04GELLELDE@8BPS@
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0007c	83 c4 10	 add	 esp, 16			; 00000010H

; 415  : 
; 416  : 	//
; 417  : 	// Set the version of the format
; 418  : 	//
; 419  : 
; 420  : 	iff_short_int_write ( 1, fp );

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00082	50		 push	 eax
  00083	6a 01		 push	 1
  00085	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 421  : 
; 422  : 	//
; 423  : 	// Write the reserved bytes
; 424  : 	//
; 425  : 
; 426  : 	memset ( reserved_bytes, 0, 6 );

  0008a	6a 06		 push	 6
  0008c	6a 00		 push	 0
  0008e	8d 45 f4	 lea	 eax, DWORD PTR _reserved_bytes$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _memset
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH

; 427  : 
; 428  : 	fwrite ( reserved_bytes, 6, 1, fp );

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0009d	50		 push	 eax
  0009e	6a 01		 push	 1
  000a0	6a 06		 push	 6
  000a2	8d 4d f4	 lea	 ecx, DWORD PTR _reserved_bytes$[ebp]
  000a5	51		 push	 ecx
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  000ac	83 c4 10	 add	 esp, 16			; 00000010H

; 429  : 
; 430  : 	//
; 431  : 	// Set the information about the image
; 432  : 	//
; 433  : 
; 434  : 	//
; 435  : 	// Number of channels
; 436  : 	//
; 437  : 
; 438  : 	iff_short_int_write ( 3, fp );

  000af	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000b2	50		 push	 eax
  000b3	6a 03		 push	 3
  000b5	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 439  : 
; 440  : 	//
; 441  : 	// Height, width
; 442  : 	//
; 443  : 
; 444  : 	iff_int_write ( height, fp );

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 10	 mov	 ecx, DWORD PTR _height$[ebp]
  000c1	51		 push	 ecx
  000c2	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 445  : 
; 446  : 	iff_int_write ( width, fp );

  000c7	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000ca	50		 push	 eax
  000cb	8b 4d 0c	 mov	 ecx, DWORD PTR _width$[ebp]
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 447  : 
; 448  : 	//
; 449  : 	// Bits per channel
; 450  : 	//
; 451  : 
; 452  : 	iff_short_int_write ( 8, fp );

  000d4	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000d7	50		 push	 eax
  000d8	6a 08		 push	 8
  000da	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 453  : 
; 454  : 	//
; 455  : 	// Image mode
; 456  : 	//
; 457  : 
; 458  : 	iff_short_int_write ( 3, fp );

  000df	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000e2	50		 push	 eax
  000e3	6a 03		 push	 3
  000e5	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 459  : 
; 460  : 	//
; 461  : 	// No colour mode data, so write length = 0
; 462  : 	//
; 463  : 
; 464  : 	iff_int_write ( 0, fp );

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000ed	50		 push	 eax
  000ee	6a 00		 push	 0
  000f0	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 465  : 
; 466  : 	//
; 467  : 	// Write out no image resources, length = 0
; 468  : 	//
; 469  : 
; 470  : 	iff_int_write ( 0, fp );

  000f5	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000f8	50		 push	 eax
  000f9	6a 00		 push	 0
  000fb	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 471  : 
; 472  : 	//
; 473  : 	// Write out no layer/mask information, length = 0 
; 474  : 	//
; 475  : 
; 476  : 	iff_int_write ( 0, fp );

  00100	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00103	50		 push	 eax
  00104	6a 00		 push	 0
  00106	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 477  : 
; 478  : 	//
; 479  : 	// Set the compression to RLE compressed ( 1 )
; 480  : 	//
; 481  : 
; 482  : 	iff_short_int_write ( 1, fp );

  0010b	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0010e	50		 push	 eax
  0010f	6a 01		 push	 1
  00111	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 483  : 
; 484  : 	//
; 485  : 	// Skip over the compression tables for now - fill them in later
; 486  : 	//
; 487  : 
; 488  : 	compression_tables_offset = ftell ( fp );

  00116	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00119	50		 push	 eax
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00120	83 c4 04	 add	 esp, 4
  00123	89 45 e8	 mov	 DWORD PTR _compression_tables_offset$[ebp], eax

; 489  : 
; 490  : 	fseek ( fp, ( height * 2 * 3 ), SEEK_CUR );

  00126	6a 01		 push	 1
  00128	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  0012b	d1 e0		 shl	 eax, 1
  0012d	6b c8 03	 imul	 ecx, eax, 3
  00130	51		 push	 ecx
  00131	8b 55 fc	 mov	 edx, DWORD PTR _fp$[ebp]
  00134	52		 push	 edx
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 491  : 
; 492  : 	//
; 493  : 	// Write out the red channel.
; 494  : 	//
; 495  : 
; 496  : 	graphic_data = &data[0];

  0013e	b8 01 00 00 00	 mov	 eax, 1
  00143	6b c8 00	 imul	 ecx, eax, 0
  00146	03 4d 18	 add	 ecx, DWORD PTR _data$[ebp]
  00149	89 4d dc	 mov	 DWORD PTR _graphic_data$[ebp], ecx

; 497  : 
; 498  : 	for ( y = 0; y < height; y++ )

  0014c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00153	eb 09		 jmp	 SHORT $LN4@write_psd_
$LN2@write_psd_:
  00155	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00158	83 c0 01	 add	 eax, 1
  0015b	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax
$LN4@write_psd_:
  0015e	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00161	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  00164	0f 8d 8d 00 00
	00		 jge	 $LN3@write_psd_

; 499  : 	{
; 500  : 
; 501  : 		source_line = graphic_data;

  0016a	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  0016d	89 45 d8	 mov	 DWORD PTR _source_line$[ebp], eax

; 502  : 
; 503  : 		for ( x = 0; x < width; x++ )

  00170	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00177	eb 09		 jmp	 SHORT $LN7@write_psd_
$LN5@write_psd_:
  00179	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  0017c	83 c0 01	 add	 eax, 1
  0017f	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax
$LN7@write_psd_:
  00182	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  00185	3b 45 0c	 cmp	 eax, DWORD PTR _width$[ebp]
  00188	7d 1a		 jge	 SHORT $LN6@write_psd_

; 504  : 		{
; 505  : 
; 506  : 			channel_line_data[x] = *source_line;

  0018a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  0018f	03 45 e4	 add	 eax, DWORD PTR _x$[ebp]
  00192	8b 4d d8	 mov	 ecx, DWORD PTR _source_line$[ebp]
  00195	8a 11		 mov	 dl, BYTE PTR [ecx]
  00197	88 10		 mov	 BYTE PTR [eax], dl

; 507  : 
; 508  : 			source_line += 3;

  00199	8b 45 d8	 mov	 eax, DWORD PTR _source_line$[ebp]
  0019c	83 c0 03	 add	 eax, 3
  0019f	89 45 d8	 mov	 DWORD PTR _source_line$[ebp], eax

; 509  : 		}

  001a2	eb d5		 jmp	 SHORT $LN5@write_psd_
$LN6@write_psd_:

; 510  : 
; 511  : 		length = run_length_encode_data ( channel_line_data, channel_compressed_data, width );

  001a4	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  001a7	50		 push	 eax
  001a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  001ae	51		 push	 ecx
  001af	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  001b5	52		 push	 edx
  001b6	e8 00 00 00 00	 call	 ?run_length_encode_data@@YGHPBEPAEH@Z ; run_length_encode_data
  001bb	89 45 ec	 mov	 DWORD PTR _length$[ebp], eax

; 512  : 
; 513  : 		red_channel_line_lengths[y] = length;

  001be	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  001c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?red_channel_line_lengths@@3PAGA ; red_channel_line_lengths
  001c7	66 8b 55 ec	 mov	 dx, WORD PTR _length$[ebp]
  001cb	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 514  : 
; 515  : 		fwrite ( channel_compressed_data, length, 1, fp );

  001cf	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  001d2	50		 push	 eax
  001d3	6a 01		 push	 1
  001d5	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  001d8	51		 push	 ecx
  001d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  001df	52		 push	 edx
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  001e6	83 c4 10	 add	 esp, 16			; 00000010H

; 516  : 
; 517  : 		graphic_data += pitch;

  001e9	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  001ec	03 45 14	 add	 eax, DWORD PTR _pitch$[ebp]
  001ef	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 518  : 	}

  001f2	e9 5e ff ff ff	 jmp	 $LN2@write_psd_
$LN3@write_psd_:

; 519  : 
; 520  : 	//
; 521  : 	// Write out the green channel.
; 522  : 	//
; 523  : 
; 524  : 	graphic_data = &data[1];

  001f7	b8 01 00 00 00	 mov	 eax, 1
  001fc	c1 e0 00	 shl	 eax, 0
  001ff	03 45 18	 add	 eax, DWORD PTR _data$[ebp]
  00202	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 525  : 
; 526  : 	for ( y = 0; y < height; y++ )

  00205	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  0020c	eb 09		 jmp	 SHORT $LN10@write_psd_
$LN8@write_psd_:
  0020e	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00211	83 c0 01	 add	 eax, 1
  00214	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax
$LN10@write_psd_:
  00217	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  0021a	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  0021d	0f 8d 8d 00 00
	00		 jge	 $LN9@write_psd_

; 527  : 	{
; 528  : 
; 529  : 		source_line = graphic_data;

  00223	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  00226	89 45 d8	 mov	 DWORD PTR _source_line$[ebp], eax

; 530  : 
; 531  : 		for ( x = 0; x < width; x++ )

  00229	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00230	eb 09		 jmp	 SHORT $LN13@write_psd_
$LN11@write_psd_:
  00232	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  00235	83 c0 01	 add	 eax, 1
  00238	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax
$LN13@write_psd_:
  0023b	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  0023e	3b 45 0c	 cmp	 eax, DWORD PTR _width$[ebp]
  00241	7d 1a		 jge	 SHORT $LN12@write_psd_

; 532  : 		{
; 533  : 
; 534  : 			channel_line_data[x] = *source_line;

  00243	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  00248	03 45 e4	 add	 eax, DWORD PTR _x$[ebp]
  0024b	8b 4d d8	 mov	 ecx, DWORD PTR _source_line$[ebp]
  0024e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00250	88 10		 mov	 BYTE PTR [eax], dl

; 535  : 
; 536  : 			source_line += 3;

  00252	8b 45 d8	 mov	 eax, DWORD PTR _source_line$[ebp]
  00255	83 c0 03	 add	 eax, 3
  00258	89 45 d8	 mov	 DWORD PTR _source_line$[ebp], eax

; 537  : 		}

  0025b	eb d5		 jmp	 SHORT $LN11@write_psd_
$LN12@write_psd_:

; 538  : 
; 539  : 		length = run_length_encode_data ( channel_line_data, channel_compressed_data, width );

  0025d	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  00260	50		 push	 eax
  00261	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  00267	51		 push	 ecx
  00268	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  0026e	52		 push	 edx
  0026f	e8 00 00 00 00	 call	 ?run_length_encode_data@@YGHPBEPAEH@Z ; run_length_encode_data
  00274	89 45 ec	 mov	 DWORD PTR _length$[ebp], eax

; 540  : 
; 541  : 		green_channel_line_lengths[y] = length;

  00277	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  0027a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?green_channel_line_lengths@@3PAGA ; green_channel_line_lengths
  00280	66 8b 55 ec	 mov	 dx, WORD PTR _length$[ebp]
  00284	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 542  : 
; 543  : 		fwrite ( channel_compressed_data, length, 1, fp );

  00288	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0028b	50		 push	 eax
  0028c	6a 01		 push	 1
  0028e	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  00291	51		 push	 ecx
  00292	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  00298	52		 push	 edx
  00299	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0029f	83 c4 10	 add	 esp, 16			; 00000010H

; 544  : 
; 545  : 		graphic_data += pitch;

  002a2	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  002a5	03 45 14	 add	 eax, DWORD PTR _pitch$[ebp]
  002a8	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 546  : 	}

  002ab	e9 5e ff ff ff	 jmp	 $LN8@write_psd_
$LN9@write_psd_:

; 547  : 
; 548  : 	//
; 549  : 	// Write out the blue channel.
; 550  : 	//
; 551  : 
; 552  : 	graphic_data = &data[2];

  002b0	b8 01 00 00 00	 mov	 eax, 1
  002b5	d1 e0		 shl	 eax, 1
  002b7	03 45 18	 add	 eax, DWORD PTR _data$[ebp]
  002ba	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 553  : 
; 554  : 	for ( y = 0; y < height; y++ )

  002bd	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  002c4	eb 09		 jmp	 SHORT $LN16@write_psd_
$LN14@write_psd_:
  002c6	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  002c9	83 c0 01	 add	 eax, 1
  002cc	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax
$LN16@write_psd_:
  002cf	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  002d2	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  002d5	0f 8d 8d 00 00
	00		 jge	 $LN15@write_psd_

; 555  : 	{
; 556  : 
; 557  : 		source_line = graphic_data;

  002db	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  002de	89 45 d8	 mov	 DWORD PTR _source_line$[ebp], eax

; 558  : 
; 559  : 		for ( x = 0; x < width; x++ )

  002e1	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  002e8	eb 09		 jmp	 SHORT $LN19@write_psd_
$LN17@write_psd_:
  002ea	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  002ed	83 c0 01	 add	 eax, 1
  002f0	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax
$LN19@write_psd_:
  002f3	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  002f6	3b 45 0c	 cmp	 eax, DWORD PTR _width$[ebp]
  002f9	7d 1a		 jge	 SHORT $LN18@write_psd_

; 560  : 		{
; 561  : 
; 562  : 			channel_line_data[x] = *source_line;

  002fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  00300	03 45 e4	 add	 eax, DWORD PTR _x$[ebp]
  00303	8b 4d d8	 mov	 ecx, DWORD PTR _source_line$[ebp]
  00306	8a 11		 mov	 dl, BYTE PTR [ecx]
  00308	88 10		 mov	 BYTE PTR [eax], dl

; 563  : 
; 564  : 			source_line += 3;

  0030a	8b 45 d8	 mov	 eax, DWORD PTR _source_line$[ebp]
  0030d	83 c0 03	 add	 eax, 3
  00310	89 45 d8	 mov	 DWORD PTR _source_line$[ebp], eax

; 565  : 		}

  00313	eb d5		 jmp	 SHORT $LN17@write_psd_
$LN18@write_psd_:

; 566  : 
; 567  : 		length = run_length_encode_data ( channel_line_data, channel_compressed_data, width );

  00315	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  00318	50		 push	 eax
  00319	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  0031f	51		 push	 ecx
  00320	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  00326	52		 push	 edx
  00327	e8 00 00 00 00	 call	 ?run_length_encode_data@@YGHPBEPAEH@Z ; run_length_encode_data
  0032c	89 45 ec	 mov	 DWORD PTR _length$[ebp], eax

; 568  : 
; 569  : 		blue_channel_line_lengths[y] = length;

  0032f	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00332	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?blue_channel_line_lengths@@3PAGA ; blue_channel_line_lengths
  00338	66 8b 55 ec	 mov	 dx, WORD PTR _length$[ebp]
  0033c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 570  : 
; 571  : 		fwrite ( channel_compressed_data, length, 1, fp );

  00340	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00343	50		 push	 eax
  00344	6a 01		 push	 1
  00346	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  00349	51		 push	 ecx
  0034a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  00350	52		 push	 edx
  00351	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00357	83 c4 10	 add	 esp, 16			; 00000010H

; 572  : 
; 573  : 		graphic_data += pitch;

  0035a	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  0035d	03 45 14	 add	 eax, DWORD PTR _pitch$[ebp]
  00360	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 574  : 	}

  00363	e9 5e ff ff ff	 jmp	 $LN14@write_psd_
$LN15@write_psd_:

; 575  : 
; 576  : 	//
; 577  : 	// Go back to the compression tables offset
; 578  : 	//
; 579  : 
; 580  : 	fseek ( fp, compression_tables_offset, SEEK_SET );

  00368	6a 00		 push	 0
  0036a	8b 45 e8	 mov	 eax, DWORD PTR _compression_tables_offset$[ebp]
  0036d	50		 push	 eax
  0036e	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  00371	51		 push	 ecx
  00372	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00378	83 c4 0c	 add	 esp, 12			; 0000000cH

; 581  : 
; 582  : 	//
; 583  : 	// Write out the compression table for each channel
; 584  : 	//
; 585  : 
; 586  : 	for ( count = 0; count < height; count++ )

  0037b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00382	eb 09		 jmp	 SHORT $LN22@write_psd_
$LN20@write_psd_:
  00384	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  00387	83 c0 01	 add	 eax, 1
  0038a	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN22@write_psd_:
  0038d	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  00390	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  00393	7d 19		 jge	 SHORT $LN21@write_psd_

; 587  : 	{
; 588  : 
; 589  : 		iff_short_int_write ( red_channel_line_lengths[count], fp );

  00395	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00398	50		 push	 eax
  00399	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  0039c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?red_channel_line_lengths@@3PAGA ; red_channel_line_lengths
  003a2	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003a6	50		 push	 eax
  003a7	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 590  : 	}

  003ac	eb d6		 jmp	 SHORT $LN20@write_psd_
$LN21@write_psd_:

; 591  : 
; 592  : 	for ( count = 0; count < height; count++ )

  003ae	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  003b5	eb 09		 jmp	 SHORT $LN25@write_psd_
$LN23@write_psd_:
  003b7	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  003ba	83 c0 01	 add	 eax, 1
  003bd	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN25@write_psd_:
  003c0	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  003c3	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  003c6	7d 19		 jge	 SHORT $LN24@write_psd_

; 593  : 	{
; 594  : 
; 595  : 		iff_short_int_write ( green_channel_line_lengths[count], fp );

  003c8	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  003cb	50		 push	 eax
  003cc	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  003cf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?green_channel_line_lengths@@3PAGA ; green_channel_line_lengths
  003d5	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003d9	50		 push	 eax
  003da	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 596  : 	}

  003df	eb d6		 jmp	 SHORT $LN23@write_psd_
$LN24@write_psd_:

; 597  : 
; 598  : 	for ( count = 0; count < height; count++ )

  003e1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  003e8	eb 09		 jmp	 SHORT $LN28@write_psd_
$LN26@write_psd_:
  003ea	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  003ed	83 c0 01	 add	 eax, 1
  003f0	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN28@write_psd_:
  003f3	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  003f6	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  003f9	7d 19		 jge	 SHORT $LN27@write_psd_

; 599  : 	{
; 600  : 
; 601  : 		iff_short_int_write ( blue_channel_line_lengths[count], fp );

  003fb	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  003fe	50		 push	 eax
  003ff	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  00402	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?blue_channel_line_lengths@@3PAGA ; blue_channel_line_lengths
  00408	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0040c	50		 push	 eax
  0040d	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 602  : 	}

  00412	eb d6		 jmp	 SHORT $LN26@write_psd_
$LN27@write_psd_:

; 603  : 
; 604  : 	//
; 605  : 	// Close the file
; 606  : 	//
; 607  : 
; 608  : 	fclose ( fp );

  00414	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00417	50		 push	 eax
  00418	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0041e	83 c4 04	 add	 esp, 4

; 609  : 
; 610  : 	//
; 611  : 	// Free up the memory
; 612  : 	//
; 613  : 
; 614  : 	safe_free ( red_channel_line_lengths );

  00421	a1 00 00 00 00	 mov	 eax, DWORD PTR ?red_channel_line_lengths@@3PAGA ; red_channel_line_lengths
  00426	50		 push	 eax
  00427	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 615  : 
; 616  : 	safe_free ( green_channel_line_lengths );

  0042c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?green_channel_line_lengths@@3PAGA ; green_channel_line_lengths
  00431	50		 push	 eax
  00432	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 617  : 
; 618  : 	safe_free ( blue_channel_line_lengths );

  00437	a1 00 00 00 00	 mov	 eax, DWORD PTR ?blue_channel_line_lengths@@3PAGA ; blue_channel_line_lengths
  0043c	50		 push	 eax
  0043d	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 619  : 
; 620  : 	safe_free ( channel_compressed_data );

  00442	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  00447	50		 push	 eax
  00448	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 621  : 
; 622  : 	safe_free ( channel_line_data );

  0044d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  00452	50		 push	 eax
  00453	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 623  : }

  00458	5f		 pop	 edi
  00459	5e		 pop	 esi
  0045a	5b		 pop	 ebx
  0045b	8b e5		 mov	 esp, ebp
  0045d	5d		 pop	 ebp
  0045e	c2 14 00	 ret	 20			; 00000014H
?write_psd_rgb_file@@YGXPBDHHHPBE@Z ENDP		; write_psd_rgb_file
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\psdwrite.c
;	COMDAT ?write_psd_screen_file@@YGXPBDHHHPBE@Z
_TEXT	SEGMENT
$T1 = -128						; size = 4
$T2 = -124						; size = 4
$T3 = -120						; size = 4
_this_colour$4 = -52					; size = 4
_this_colour$5 = -48					; size = 4
_this_colour$6 = -44					; size = 4
_source_line$ = -40					; size = 4
_graphic_data$ = -36					; size = 4
_y$ = -32						; size = 4
_x$ = -28						; size = 4
_compression_tables_offset$ = -24			; size = 4
_length$ = -20						; size = 4
_count$ = -16						; size = 4
_reserved_bytes$ = -12					; size = 6
_fp$ = -4						; size = 4
_filename$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_pitch$ = 20						; size = 4
_data$ = 24						; size = 4
?write_psd_screen_file@@YGXPBDHHHPBE@Z PROC		; write_psd_screen_file, COMDAT

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 110  : 
; 111  : 	FILE
; 112  : 		*fp;
; 113  : 
; 114  : 	char
; 115  : 		reserved_bytes[6];
; 116  : 
; 117  : 	int
; 118  : 		count,
; 119  : 		length,
; 120  : 		compression_tables_offset,
; 121  : 		x,
; 122  : 		y;
; 123  : 
; 124  : 	const unsigned char
; 125  : 		*graphic_data;
; 126  : 
; 127  : 	unsigned short int
; 128  : 		*source_line;
; 129  : 
; 130  : 	fp = safe_fopen ( filename, "wb" );

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  00011	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?safe_fopen@@YGPAU_iobuf@@PBD0@Z ; safe_fopen
  0001a	89 45 fc	 mov	 DWORD PTR _fp$[ebp], eax

; 131  : 
; 132  : 	//
; 133  : 	// Allocate the memory arrays.
; 134  : 	//
; 135  : 
; 136  : 	red_channel_line_lengths = ( unsigned short * ) safe_malloc ( height * sizeof ( short int ) );

  0001d	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  00020	d1 e0		 shl	 eax, 1
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00028	a3 00 00 00 00	 mov	 DWORD PTR ?red_channel_line_lengths@@3PAGA, eax ; red_channel_line_lengths

; 137  : 
; 138  : 	green_channel_line_lengths = ( unsigned short * ) safe_malloc ( height * sizeof ( short int ) );

  0002d	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  00030	d1 e0		 shl	 eax, 1
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00038	a3 00 00 00 00	 mov	 DWORD PTR ?green_channel_line_lengths@@3PAGA, eax ; green_channel_line_lengths

; 139  : 
; 140  : 	blue_channel_line_lengths = ( unsigned short * ) safe_malloc ( height * sizeof ( short int ) );

  0003d	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  00040	d1 e0		 shl	 eax, 1
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00048	a3 00 00 00 00	 mov	 DWORD PTR ?blue_channel_line_lengths@@3PAGA, eax ; blue_channel_line_lengths

; 141  : 
; 142  : 	channel_compressed_data = ( unsigned char * ) safe_malloc ( width * 2 );

  0004d	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  00050	d1 e0		 shl	 eax, 1
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00058	a3 00 00 00 00	 mov	 DWORD PTR ?channel_compressed_data@@3PAEA, eax ; channel_compressed_data

; 143  : 
; 144  : 	channel_line_data = ( unsigned char * ) safe_malloc ( width );

  0005d	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00066	a3 00 00 00 00	 mov	 DWORD PTR ?channel_line_data@@3PAEA, eax ; channel_line_data

; 145  : 
; 146  : 	//
; 147  : 	// Write out the signature of the file
; 148  : 	//
; 149  : 
; 150  : 	fwrite ( "8BPS", 4, 1, fp );

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0006e	50		 push	 eax
  0006f	6a 01		 push	 1
  00071	6a 04		 push	 4
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_04GELLELDE@8BPS@
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0007e	83 c4 10	 add	 esp, 16			; 00000010H

; 151  : 
; 152  : 	//
; 153  : 	// Set the version of the format
; 154  : 	//
; 155  : 
; 156  : 	iff_short_int_write ( 1, fp );

  00081	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00084	50		 push	 eax
  00085	6a 01		 push	 1
  00087	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 157  : 
; 158  : 	//
; 159  : 	// Write the reserved bytes
; 160  : 	//
; 161  : 
; 162  : 	memset ( reserved_bytes, 0, 6 );

  0008c	6a 06		 push	 6
  0008e	6a 00		 push	 0
  00090	8d 45 f4	 lea	 eax, DWORD PTR _reserved_bytes$[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _memset
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH

; 163  : 
; 164  : 	fwrite ( reserved_bytes, 6, 1, fp );

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0009f	50		 push	 eax
  000a0	6a 01		 push	 1
  000a2	6a 06		 push	 6
  000a4	8d 4d f4	 lea	 ecx, DWORD PTR _reserved_bytes$[ebp]
  000a7	51		 push	 ecx
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  000ae	83 c4 10	 add	 esp, 16			; 00000010H

; 165  : 
; 166  : 	//
; 167  : 	// Set the information about the image
; 168  : 	//
; 169  : 
; 170  : 	//
; 171  : 	// Number of channels
; 172  : 	//
; 173  : 
; 174  : 	iff_short_int_write ( 3, fp );

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000b4	50		 push	 eax
  000b5	6a 03		 push	 3
  000b7	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 175  : 
; 176  : 	//
; 177  : 	// Height, width
; 178  : 	//
; 179  : 
; 180  : 	iff_int_write ( height, fp );

  000bc	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d 10	 mov	 ecx, DWORD PTR _height$[ebp]
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 181  : 
; 182  : 	iff_int_write ( width, fp );

  000c9	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d 0c	 mov	 ecx, DWORD PTR _width$[ebp]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 183  : 
; 184  : 	//
; 185  : 	// Bits per channel
; 186  : 	//
; 187  : 
; 188  : 	iff_short_int_write ( 8, fp );

  000d6	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000d9	50		 push	 eax
  000da	6a 08		 push	 8
  000dc	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 189  : 
; 190  : 	//
; 191  : 	// Image mode
; 192  : 	//
; 193  : 
; 194  : 	iff_short_int_write ( 3, fp );

  000e1	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000e4	50		 push	 eax
  000e5	6a 03		 push	 3
  000e7	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 195  : 
; 196  : 	//
; 197  : 	// No colour mode data, so write length = 0
; 198  : 	//
; 199  : 
; 200  : 	iff_int_write ( 0, fp );

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000ef	50		 push	 eax
  000f0	6a 00		 push	 0
  000f2	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 201  : 
; 202  : 	//
; 203  : 	// Write out no image resources, length = 0
; 204  : 	//
; 205  : 
; 206  : 	iff_int_write ( 0, fp );

  000f7	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  000fa	50		 push	 eax
  000fb	6a 00		 push	 0
  000fd	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 207  : 
; 208  : 	//
; 209  : 	// Write out no layer/mask information, length = 0 
; 210  : 	//
; 211  : 
; 212  : 	iff_int_write ( 0, fp );

  00102	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00105	50		 push	 eax
  00106	6a 00		 push	 0
  00108	e8 00 00 00 00	 call	 ?iff_int_write@@YGXHPAU_iobuf@@@Z ; iff_int_write

; 213  : 
; 214  : 	//
; 215  : 	// Set the compression to RLE compressed ( 1 )
; 216  : 	//
; 217  : 
; 218  : 	iff_short_int_write ( 1, fp );

  0010d	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00110	50		 push	 eax
  00111	6a 01		 push	 1
  00113	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 219  : 
; 220  : 	//
; 221  : 	// Skip over the compression tables for now - fill them in later
; 222  : 	//
; 223  : 
; 224  : 	compression_tables_offset = ftell ( fp );

  00118	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0011b	50		 push	 eax
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00122	83 c4 04	 add	 esp, 4
  00125	89 45 e8	 mov	 DWORD PTR _compression_tables_offset$[ebp], eax

; 225  : 
; 226  : 	fseek ( fp, ( height * 2 * 3 ), SEEK_CUR );

  00128	6a 01		 push	 1
  0012a	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  0012d	d1 e0		 shl	 eax, 1
  0012f	6b c8 03	 imul	 ecx, eax, 3
  00132	51		 push	 ecx
  00133	8b 55 fc	 mov	 edx, DWORD PTR _fp$[ebp]
  00136	52		 push	 edx
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 227  : 
; 228  : 	//
; 229  : 	// Write out the red channel.
; 230  : 	//
; 231  : 
; 232  : 	graphic_data = data;

  00140	8b 45 18	 mov	 eax, DWORD PTR _data$[ebp]
  00143	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 233  : 
; 234  : 	for ( y = 0; y < height; y++ )

  00146	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  0014d	eb 09		 jmp	 SHORT $LN4@write_psd_
$LN2@write_psd_:
  0014f	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00152	83 c0 01	 add	 eax, 1
  00155	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax
$LN4@write_psd_:
  00158	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  0015b	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  0015e	0f 8d 9b 00 00
	00		 jge	 $LN3@write_psd_

; 235  : 	{
; 236  : 
; 237  : 		source_line = ( unsigned short int * ) graphic_data;

  00164	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  00167	89 45 d8	 mov	 DWORD PTR _source_line$[ebp], eax

; 238  : 
; 239  : 		for ( x = 0; x < width; x++ )

  0016a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00171	eb 09		 jmp	 SHORT $LN7@write_psd_
$LN5@write_psd_:
  00173	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  00176	83 c0 01	 add	 eax, 1
  00179	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax
$LN7@write_psd_:
  0017c	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  0017f	3b 45 0c	 cmp	 eax, DWORD PTR _width$[ebp]
  00182	7d 28		 jge	 SHORT $LN6@write_psd_

; 240  : 		{
; 241  : 
; 242  : 			rgb_colour
; 243  : 				this_colour;
; 244  : 
; 245  : 			this_colour = get_general_colour_value ( ( rgb_packed ) source_line[x] );

  00184	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  00187	8b 4d d8	 mov	 ecx, DWORD PTR _source_line$[ebp]
  0018a	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0018e	52		 push	 edx
  0018f	e8 00 00 00 00	 call	 ?get_general_colour_value@@YG?AUREAL_COLOUR@@G@Z ; get_general_colour_value
  00194	89 45 88	 mov	 DWORD PTR $T3[ebp], eax
  00197	8b 45 88	 mov	 eax, DWORD PTR $T3[ebp]
  0019a	89 45 d4	 mov	 DWORD PTR _this_colour$6[ebp], eax

; 246  : 
; 247  : 			channel_line_data[x] = this_colour.r;

  0019d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  001a2	03 45 e4	 add	 eax, DWORD PTR _x$[ebp]
  001a5	8a 4d d6	 mov	 cl, BYTE PTR _this_colour$6[ebp+2]
  001a8	88 08		 mov	 BYTE PTR [eax], cl

; 248  : 		}

  001aa	eb c7		 jmp	 SHORT $LN5@write_psd_
$LN6@write_psd_:

; 249  : 
; 250  : 		length = run_length_encode_data ( channel_line_data, channel_compressed_data, width );

  001ac	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  001af	50		 push	 eax
  001b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  001b6	51		 push	 ecx
  001b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  001bd	52		 push	 edx
  001be	e8 00 00 00 00	 call	 ?run_length_encode_data@@YGHPBEPAEH@Z ; run_length_encode_data
  001c3	89 45 ec	 mov	 DWORD PTR _length$[ebp], eax

; 251  : 
; 252  : 		red_channel_line_lengths[y] = length;

  001c6	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  001c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?red_channel_line_lengths@@3PAGA ; red_channel_line_lengths
  001cf	66 8b 55 ec	 mov	 dx, WORD PTR _length$[ebp]
  001d3	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 253  : 
; 254  : 		fwrite ( channel_compressed_data, length, 1, fp );

  001d7	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  001da	50		 push	 eax
  001db	6a 01		 push	 1
  001dd	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  001e0	51		 push	 ecx
  001e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  001e7	52		 push	 edx
  001e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  001ee	83 c4 10	 add	 esp, 16			; 00000010H

; 255  : 
; 256  : 		graphic_data += pitch;

  001f1	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  001f4	03 45 14	 add	 eax, DWORD PTR _pitch$[ebp]
  001f7	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 257  : 	}

  001fa	e9 50 ff ff ff	 jmp	 $LN2@write_psd_
$LN3@write_psd_:

; 258  : 
; 259  : 	//
; 260  : 	// Write out the green channel.
; 261  : 	//
; 262  : 
; 263  : 	graphic_data = data;

  001ff	8b 45 18	 mov	 eax, DWORD PTR _data$[ebp]
  00202	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 264  : 
; 265  : 	for ( y = 0; y < height; y++ )

  00205	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  0020c	eb 09		 jmp	 SHORT $LN10@write_psd_
$LN8@write_psd_:
  0020e	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00211	83 c0 01	 add	 eax, 1
  00214	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax
$LN10@write_psd_:
  00217	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  0021a	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  0021d	0f 8d 9b 00 00
	00		 jge	 $LN9@write_psd_

; 266  : 	{
; 267  : 
; 268  : 		source_line = ( unsigned short int * ) graphic_data;

  00223	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  00226	89 45 d8	 mov	 DWORD PTR _source_line$[ebp], eax

; 269  : 
; 270  : 		for ( x = 0; x < width; x++ )

  00229	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00230	eb 09		 jmp	 SHORT $LN13@write_psd_
$LN11@write_psd_:
  00232	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  00235	83 c0 01	 add	 eax, 1
  00238	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax
$LN13@write_psd_:
  0023b	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  0023e	3b 45 0c	 cmp	 eax, DWORD PTR _width$[ebp]
  00241	7d 28		 jge	 SHORT $LN12@write_psd_

; 271  : 		{
; 272  : 
; 273  : 			rgb_colour
; 274  : 				this_colour;
; 275  : 
; 276  : 			this_colour = get_rgb_colour_value ( ( rgb_packed ) source_line[x] );

  00243	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  00246	8b 4d d8	 mov	 ecx, DWORD PTR _source_line$[ebp]
  00249	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0024d	52		 push	 edx
  0024e	e8 00 00 00 00	 call	 ?get_rgb_colour_value@@YG?AUREAL_COLOUR@@K@Z ; get_rgb_colour_value
  00253	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
  00256	8b 45 84	 mov	 eax, DWORD PTR $T2[ebp]
  00259	89 45 d0	 mov	 DWORD PTR _this_colour$5[ebp], eax

; 277  : 
; 278  : 			channel_line_data[x] = this_colour.g;

  0025c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  00261	03 45 e4	 add	 eax, DWORD PTR _x$[ebp]
  00264	8a 4d d1	 mov	 cl, BYTE PTR _this_colour$5[ebp+1]
  00267	88 08		 mov	 BYTE PTR [eax], cl

; 279  : 		}

  00269	eb c7		 jmp	 SHORT $LN11@write_psd_
$LN12@write_psd_:

; 280  : 
; 281  : 		length = run_length_encode_data ( channel_line_data, channel_compressed_data, width );

  0026b	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0026e	50		 push	 eax
  0026f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  00275	51		 push	 ecx
  00276	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  0027c	52		 push	 edx
  0027d	e8 00 00 00 00	 call	 ?run_length_encode_data@@YGHPBEPAEH@Z ; run_length_encode_data
  00282	89 45 ec	 mov	 DWORD PTR _length$[ebp], eax

; 282  : 
; 283  : 		green_channel_line_lengths[y] = length;

  00285	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00288	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?green_channel_line_lengths@@3PAGA ; green_channel_line_lengths
  0028e	66 8b 55 ec	 mov	 dx, WORD PTR _length$[ebp]
  00292	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 284  : 
; 285  : 		fwrite ( channel_compressed_data, length, 1, fp );

  00296	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00299	50		 push	 eax
  0029a	6a 01		 push	 1
  0029c	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  0029f	51		 push	 ecx
  002a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  002a6	52		 push	 edx
  002a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  002ad	83 c4 10	 add	 esp, 16			; 00000010H

; 286  : 
; 287  : 		graphic_data += pitch;

  002b0	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  002b3	03 45 14	 add	 eax, DWORD PTR _pitch$[ebp]
  002b6	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 288  : 	}

  002b9	e9 50 ff ff ff	 jmp	 $LN8@write_psd_
$LN9@write_psd_:

; 289  : 
; 290  : 	//
; 291  : 	// Write out the blue channel.
; 292  : 	//
; 293  : 
; 294  : 	graphic_data = data;

  002be	8b 45 18	 mov	 eax, DWORD PTR _data$[ebp]
  002c1	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 295  : 
; 296  : 	for ( y = 0; y < height; y++ )

  002c4	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  002cb	eb 09		 jmp	 SHORT $LN16@write_psd_
$LN14@write_psd_:
  002cd	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  002d0	83 c0 01	 add	 eax, 1
  002d3	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax
$LN16@write_psd_:
  002d6	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  002d9	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  002dc	0f 8d 9b 00 00
	00		 jge	 $LN15@write_psd_

; 297  : 	{
; 298  : 
; 299  : 		source_line = ( unsigned short int * ) graphic_data;

  002e2	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  002e5	89 45 d8	 mov	 DWORD PTR _source_line$[ebp], eax

; 300  : 
; 301  : 		for ( x = 0; x < width; x++ )

  002e8	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  002ef	eb 09		 jmp	 SHORT $LN19@write_psd_
$LN17@write_psd_:
  002f1	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  002f4	83 c0 01	 add	 eax, 1
  002f7	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax
$LN19@write_psd_:
  002fa	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  002fd	3b 45 0c	 cmp	 eax, DWORD PTR _width$[ebp]
  00300	7d 28		 jge	 SHORT $LN18@write_psd_

; 302  : 		{
; 303  : 
; 304  : 			rgb_colour
; 305  : 				this_colour;
; 306  : 
; 307  : 			this_colour = get_rgb_colour_value ( ( rgb_packed ) source_line[x] );

  00302	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  00305	8b 4d d8	 mov	 ecx, DWORD PTR _source_line$[ebp]
  00308	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0030c	52		 push	 edx
  0030d	e8 00 00 00 00	 call	 ?get_rgb_colour_value@@YG?AUREAL_COLOUR@@K@Z ; get_rgb_colour_value
  00312	89 45 80	 mov	 DWORD PTR $T1[ebp], eax
  00315	8b 45 80	 mov	 eax, DWORD PTR $T1[ebp]
  00318	89 45 cc	 mov	 DWORD PTR _this_colour$4[ebp], eax

; 308  : 
; 309  : 			channel_line_data[x] = this_colour.b;

  0031b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  00320	03 45 e4	 add	 eax, DWORD PTR _x$[ebp]
  00323	8a 4d cc	 mov	 cl, BYTE PTR _this_colour$4[ebp]
  00326	88 08		 mov	 BYTE PTR [eax], cl

; 310  : 		}

  00328	eb c7		 jmp	 SHORT $LN17@write_psd_
$LN18@write_psd_:

; 311  : 
; 312  : 		length = run_length_encode_data ( channel_line_data, channel_compressed_data, width );

  0032a	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0032d	50		 push	 eax
  0032e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  00334	51		 push	 ecx
  00335	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  0033b	52		 push	 edx
  0033c	e8 00 00 00 00	 call	 ?run_length_encode_data@@YGHPBEPAEH@Z ; run_length_encode_data
  00341	89 45 ec	 mov	 DWORD PTR _length$[ebp], eax

; 313  : 
; 314  : 		blue_channel_line_lengths[y] = length;

  00344	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00347	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?blue_channel_line_lengths@@3PAGA ; blue_channel_line_lengths
  0034d	66 8b 55 ec	 mov	 dx, WORD PTR _length$[ebp]
  00351	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 315  : 
; 316  : 		fwrite ( channel_compressed_data, length, 1, fp );

  00355	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00358	50		 push	 eax
  00359	6a 01		 push	 1
  0035b	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  0035e	51		 push	 ecx
  0035f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  00365	52		 push	 edx
  00366	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0036c	83 c4 10	 add	 esp, 16			; 00000010H

; 317  : 
; 318  : 		graphic_data += pitch;

  0036f	8b 45 dc	 mov	 eax, DWORD PTR _graphic_data$[ebp]
  00372	03 45 14	 add	 eax, DWORD PTR _pitch$[ebp]
  00375	89 45 dc	 mov	 DWORD PTR _graphic_data$[ebp], eax

; 319  : 	}

  00378	e9 50 ff ff ff	 jmp	 $LN14@write_psd_
$LN15@write_psd_:

; 320  : 
; 321  : 	//
; 322  : 	// Go back to the compression tables offset
; 323  : 	//
; 324  : 
; 325  : 	fseek ( fp, compression_tables_offset, SEEK_SET );

  0037d	6a 00		 push	 0
  0037f	8b 45 e8	 mov	 eax, DWORD PTR _compression_tables_offset$[ebp]
  00382	50		 push	 eax
  00383	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  00386	51		 push	 ecx
  00387	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  0038d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 326  : 
; 327  : 	//
; 328  : 	// Write out the compression table for each channel
; 329  : 	//
; 330  : 
; 331  : 	for ( count = 0; count < height; count++ )

  00390	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00397	eb 09		 jmp	 SHORT $LN22@write_psd_
$LN20@write_psd_:
  00399	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  0039c	83 c0 01	 add	 eax, 1
  0039f	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN22@write_psd_:
  003a2	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  003a5	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  003a8	7d 19		 jge	 SHORT $LN21@write_psd_

; 332  : 	{
; 333  : 
; 334  : 		iff_short_int_write ( red_channel_line_lengths[count], fp );

  003aa	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  003ad	50		 push	 eax
  003ae	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  003b1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?red_channel_line_lengths@@3PAGA ; red_channel_line_lengths
  003b7	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003bb	50		 push	 eax
  003bc	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 335  : 	}

  003c1	eb d6		 jmp	 SHORT $LN20@write_psd_
$LN21@write_psd_:

; 336  : 
; 337  : 	for ( count = 0; count < height; count++ )

  003c3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  003ca	eb 09		 jmp	 SHORT $LN25@write_psd_
$LN23@write_psd_:
  003cc	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  003cf	83 c0 01	 add	 eax, 1
  003d2	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN25@write_psd_:
  003d5	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  003d8	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  003db	7d 19		 jge	 SHORT $LN24@write_psd_

; 338  : 	{
; 339  : 
; 340  : 		iff_short_int_write ( green_channel_line_lengths[count], fp );

  003dd	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  003e0	50		 push	 eax
  003e1	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  003e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?green_channel_line_lengths@@3PAGA ; green_channel_line_lengths
  003ea	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003ee	50		 push	 eax
  003ef	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 341  : 	}

  003f4	eb d6		 jmp	 SHORT $LN23@write_psd_
$LN24@write_psd_:

; 342  : 
; 343  : 	for ( count = 0; count < height; count++ )

  003f6	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  003fd	eb 09		 jmp	 SHORT $LN28@write_psd_
$LN26@write_psd_:
  003ff	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  00402	83 c0 01	 add	 eax, 1
  00405	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN28@write_psd_:
  00408	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  0040b	3b 45 10	 cmp	 eax, DWORD PTR _height$[ebp]
  0040e	7d 19		 jge	 SHORT $LN27@write_psd_

; 344  : 	{
; 345  : 
; 346  : 		iff_short_int_write ( blue_channel_line_lengths[count], fp );

  00410	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00413	50		 push	 eax
  00414	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  00417	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?blue_channel_line_lengths@@3PAGA ; blue_channel_line_lengths
  0041d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00421	50		 push	 eax
  00422	e8 00 00 00 00	 call	 ?iff_short_int_write@@YGXFPAU_iobuf@@@Z ; iff_short_int_write

; 347  : 	}

  00427	eb d6		 jmp	 SHORT $LN26@write_psd_
$LN27@write_psd_:

; 348  : 
; 349  : 	//
; 350  : 	// Close the file
; 351  : 	//
; 352  : 
; 353  : 	fclose ( fp );

  00429	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0042c	50		 push	 eax
  0042d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00433	83 c4 04	 add	 esp, 4

; 354  : 
; 355  : 	//
; 356  : 	// Free up the memory
; 357  : 	//
; 358  : 
; 359  : 	safe_free ( red_channel_line_lengths );

  00436	a1 00 00 00 00	 mov	 eax, DWORD PTR ?red_channel_line_lengths@@3PAGA ; red_channel_line_lengths
  0043b	50		 push	 eax
  0043c	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 360  : 
; 361  : 	safe_free ( green_channel_line_lengths );

  00441	a1 00 00 00 00	 mov	 eax, DWORD PTR ?green_channel_line_lengths@@3PAGA ; green_channel_line_lengths
  00446	50		 push	 eax
  00447	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 362  : 
; 363  : 	safe_free ( blue_channel_line_lengths );

  0044c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?blue_channel_line_lengths@@3PAGA ; blue_channel_line_lengths
  00451	50		 push	 eax
  00452	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 364  : 
; 365  : 	safe_free ( channel_compressed_data );

  00457	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_compressed_data@@3PAEA ; channel_compressed_data
  0045c	50		 push	 eax
  0045d	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 366  : 
; 367  : 	safe_free ( channel_line_data );

  00462	a1 00 00 00 00	 mov	 eax, DWORD PTR ?channel_line_data@@3PAEA ; channel_line_data
  00467	50		 push	 eax
  00468	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 368  : }

  0046d	5f		 pop	 edi
  0046e	5e		 pop	 esi
  0046f	5b		 pop	 ebx
  00470	8b e5		 mov	 esp, ebp
  00472	5d		 pop	 ebp
  00473	c2 14 00	 ret	 20			; 00000014H
?write_psd_screen_file@@YGXPBDHHHPBE@Z ENDP		; write_psd_screen_file
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\psdwrite.c
;	COMDAT ?save_psd_screen@@YGXPBD@Z
_TEXT	SEGMENT
_filename$ = 8						; size = 4
?save_psd_screen@@YGXPBD@Z PROC				; save_psd_screen, COMDAT

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 
; 97   : 	write_psd_screen_file ( filename,

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?video_screen@@3PAUSCREEN@@A ; video_screen
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?get_screen_data@@YGPAEPAUSCREEN@@@Z ; get_screen_data
  00014	50		 push	 eax
  00015	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?video_screen@@3PAUSCREEN@@A ; video_screen
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ?get_screen_pitch@@YGHPAUSCREEN@@@Z ; get_screen_pitch
  00021	50		 push	 eax
  00022	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?video_screen@@3PAUSCREEN@@A ; video_screen
  00028	52		 push	 edx
  00029	e8 00 00 00 00	 call	 ?get_screen_height@@YGHPAUSCREEN@@@Z ; get_screen_height
  0002e	50		 push	 eax
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?video_screen@@3PAUSCREEN@@A ; video_screen
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ?get_screen_width@@YGHPAUSCREEN@@@Z ; get_screen_width
  0003a	50		 push	 eax
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _filename$[ebp]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ?write_psd_screen_file@@YGXPBDHHHPBE@Z ; write_psd_screen_file

; 98   : 										get_screen_width ( video_screen ),
; 99   : 										get_screen_height ( video_screen ),
; 100  : 										get_screen_pitch ( video_screen ),
; 101  : 										get_screen_data ( video_screen ) );
; 102  : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?save_psd_screen@@YGXPBD@Z ENDP				; save_psd_screen
_TEXT	ENDS
END
