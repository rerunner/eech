; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\aphavoc\source\entity\special\guide\gd_cover.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_atan2f
PUBLIC	?atan2@@YGMMM@Z					; atan2
PUBLIC	?reset_guide_seek_cover_results@@YGXPAUENTITY@@@Z ; reset_guide_seek_cover_results
PUBLIC	?update_guide_seek_cover_results@@YGHPAUENTITY@@@Z ; update_guide_seek_cover_results
PUBLIC	??$min@M@std@@YGABMABM0@Z			; std::min<float>
PUBLIC	??$max@M@std@@YGABMABM0@Z			; std::max<float>
PUBLIC	??$min@H@std@@YGABHABH0@Z			; std::min<int>
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	?__LINE__Var@?0??reset_guide_seek_cover_results@@YGXPAUENTITY@@@Z@4JA ; `reset_guide_seek_cover_results'::`1'::__LINE__Var
PUBLIC	??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@ ; `string'
PUBLIC	??_C@_02LFNMGJAP@en@				; `string'
PUBLIC	?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA ; `update_guide_seek_cover_results'::`1'::__LINE__Var
PUBLIC	??_C@_09HKMIOAOH@aggressor@			; `string'
PUBLIC	??_C@_05MGJOOGAJ@group@				; `string'
PUBLIC	??_C@_0CA@JDIGCNOK@GD_COVER?3?5No?5Cover?5found?5for?5?$CFs@ ; `string'
PUBLIC	??_C@_0BP@LPAMFHPN@GD_COVER?3?5Invalid?5seek?5mode?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z@4JA ; `set_guide_seek_cover_next_search_mode'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA ; `assess_cover_position'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@FBJGKGOB@selected_weapon?5?$CB?$DN?5ENTITY_SUB_T@ ; `string'
PUBLIC	??_C@_0DF@EFCIKDJJ@aggressor_3d_index?5?$CB?$DN?5OBJECT_3D@ ; `string'
PUBLIC	??_C@_0BH@OLIBHAPL@aggressor_bounding_box@	; `string'
PUBLIC	??_C@_0DC@BJJCPMFI@object_3d_index?5?$CB?$DN?5OBJECT_3D_IN@ ; `string'
PUBLIC	??_C@_06IDGHNJOB@sector@			; `string'
PUBLIC	??_C@_0BE@NINKBKAC@object_bounding_box@		; `string'
PUBLIC	??_C@_0L@GPAIBKEE@object_pos@			; `string'
PUBLIC	?__LINE__Var@?0??check_fixed_structure_search_object_type@@YGHPAUENTITY@@0@Z@4JA ; `check_fixed_structure_search_object_type'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA ; `update_guide_seek_cover_fixed_structure_search'::`1'::__LINE__Var
PUBLIC	??_C@_0BJ@JBLGADFG@count?5?$DM?5SEEK_COUNT_LIMIT@ ; `string'
PUBLIC	??_C@_0N@LOLJEHA@bounding_box@			; `string'
PUBLIC	?__LINE__Var@?0??update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z@4JA ; `update_guide_seek_cover_forest_search'::`1'::__LINE__Var
PUBLIC	??_C@_0BK@HPLLKKAK@raw?9?$DOterrain_polygon_list@ ; `string'
PUBLIC	?__LINE__Var@?0??update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z@4JA ; `update_guide_seek_cover_default_terrain_search'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??update_guide_seek_cover_current_position_search@@YGHPAUENTITY@@@Z@4JA ; `update_guide_seek_cover_current_position_search'::`1'::__LINE__Var
PUBLIC	??_C@_0BD@FEEMDEPI@invalid?5comparator@		; `string'
PUBLIC	??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1BC@BLAPCBGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAi?$AAn@ ; `string'
PUBLIC	??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ ; `string'
PUBLIC	??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@ ; `string'
PUBLIC	__real@3fd55553ef6b5d46
PUBLIC	__real@3fd8000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fe54fdf3b645a1d
PUBLIC	__real@3fe921fb60000000
PUBLIC	__real@3feccccccccccccd
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@4014000000000000
PUBLIC	__real@4018000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@402e000000000000
PUBLIC	__real@4034000000000000
PUBLIC	__real@4044000000000000
PUBLIC	__real@4049000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@41000000
PUBLIC	__real@41200000
PUBLIC	__real@41c80000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__imp___invalid_parameter:PROC
EXTRN	_memset:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	_atan2:PROC
EXTRN	?process_assert@@YGXPBD0H@Z:PROC		; process_assert
EXTRN	?debug_fatal@@YAXPBDZZ:PROC			; debug_fatal
EXTRN	?debug_colour_log@@YAXW4DEBUG_COLOURS@@PBDZZ:PROC ; debug_colour_log
EXTRN	?malloc_fast_memory@@YGPAXI@Z:PROC		; malloc_fast_memory
EXTRN	?free_mem@@YGXPAX@Z:PROC			; free_mem
EXTRN	?normalise_any_3d_vector@@YGMPAUVEC3D@@@Z:PROC	; normalise_any_3d_vector
EXTRN	?normalise_any_2d_vector@@YGMPAUVEC2D@@@Z:PROC	; normalise_any_2d_vector
EXTRN	?get_3d_unit_vector_dot_product@@YGMPBUVEC3D@@0@Z:PROC ; get_3d_unit_vector_dot_product
EXTRN	?get_3d_vector_cube_cube_intersect@@YGHPBUVEC3D@@000@Z:PROC ; get_3d_vector_cube_cube_intersect
EXTRN	?rotate_2d_vector@@YGXPAUVEC2D@@M@Z:PROC	; rotate_2d_vector
EXTRN	?get_2d_range@@YGMPBUVEC3D@@0@Z:PROC		; get_2d_range
EXTRN	?get_object_3d_bounding_box_without_lines@@YGPAUOBJECT_3D_BOUNDS@@H@Z:PROC ; get_object_3d_bounding_box_without_lines
EXTRN	?get_object_3d_radius@@YGMH@Z:PROC		; get_object_3d_radius
EXTRN	?get_terrain_3d_number_of_type_triangles_in_sector@@YGHMMH@Z:PROC ; get_terrain_3d_number_of_type_triangles_in_sector
EXTRN	?get_terrain_3d_type_triangles_in_sector@@YGXMMHPAUTERRAIN_3D_TRIANGLE@@@Z:PROC ; get_terrain_3d_type_triangles_in_sector
EXTRN	?get_3d_terrain_point_data@@YGMMMPAUTERRAIN_3D_POINT_DATA@@@Z:PROC ; get_3d_terrain_point_data
EXTRN	?get_3d_terrain_point_data_type@@YGHPAUTERRAIN_3D_POINT_DATA@@@Z:PROC ; get_3d_terrain_point_data_type
EXTRN	?bound_position_to_map_area@@YGHPAUVEC3D@@@Z:PROC ; bound_position_to_map_area
EXTRN	?check_position_line_of_sight@@YGHPAUENTITY@@0PAUVEC3D@@1W4MOBILE_LOS_CHECK_CRITERIA@@@Z:PROC ; check_position_line_of_sight
EXTRN	?attack_guide_no_cover_found@@YGXPAUENTITY@@@Z:PROC ; attack_guide_no_cover_found
EXTRN	?set_attack_guide_fly_to_cover_position@@YGXPAUENTITY@@@Z:PROC ; set_attack_guide_fly_to_cover_position
EXTRN	?get_local_guide_entity_pointers@@YGXPAUENTITY@@PAPAU1@111@Z:PROC ; get_local_guide_entity_pointers
EXTRN	?get_local_sector_entity@@YGPAUENTITY@@PAUVEC3D@@@Z:PROC ; get_local_sector_entity
EXTRN	?get_terrain_type_class@@YG?AW4TERRAIN_CLASSES@@H@Z:PROC ; get_terrain_type_class
EXTRN	?null_entity_pointer_message@@3PBDB:DWORD	; null_entity_pointer_message
EXTRN	?world_map@@3UWORLD_MAP_DATA@@A:BYTE		; world_map
EXTRN	?overload_invalid_list_type_message@@3PBDB:DWORD ; overload_invalid_list_type_message
EXTRN	?fn_get_local_entity_first_child@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA:BYTE ; fn_get_local_entity_first_child
EXTRN	?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA:BYTE ; fn_get_local_entity_parent
EXTRN	?fn_get_local_entity_child_succ@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA:BYTE ; fn_get_local_entity_child_succ
EXTRN	?overload_invalid_int_type_message@@3PBDB:DWORD	; overload_invalid_int_type_message
EXTRN	?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA:BYTE ; fn_get_local_entity_int_value
EXTRN	?overload_invalid_string_type_message@@3PBDB:DWORD ; overload_invalid_string_type_message
EXTRN	?fn_get_local_entity_string@@3PAY0N@P6GPBDPAUENTITY@@W4STRING_TYPES@@@ZA:BYTE ; fn_get_local_entity_string
EXTRN	?overload_invalid_vec3d_type_message@@3PBDB:DWORD ; overload_invalid_vec3d_type_message
EXTRN	?fn_set_local_entity_vec3d@@3PAY0BI@P6GXPAUENTITY@@W4VEC3D_TYPES@@PAUVEC3D@@@ZA:BYTE ; fn_set_local_entity_vec3d
EXTRN	?fn_get_local_entity_vec3d@@3PAY0BI@P6GXPAUENTITY@@W4VEC3D_TYPES@@PAUVEC3D@@@ZA:BYTE ; fn_get_local_entity_vec3d
EXTRN	?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA:BYTE ; fn_get_local_entity_vec3d_ptr
EXTRN	?weapon_database@@3PAUWEAPON_DATA@@A:BYTE	; weapon_database
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4049000000000000
CONST	SEGMENT
__real@4049000000000000 DQ 04049000000000000r	; 50
CONST	ENDS
;	COMDAT __real@4044000000000000
CONST	SEGMENT
__real@4044000000000000 DQ 04044000000000000r	; 40
CONST	ENDS
;	COMDAT __real@4034000000000000
CONST	SEGMENT
__real@4034000000000000 DQ 04034000000000000r	; 20
CONST	ENDS
;	COMDAT __real@402e000000000000
CONST	SEGMENT
__real@402e000000000000 DQ 0402e000000000000r	; 15
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3feccccccccccccd
CONST	SEGMENT
__real@3feccccccccccccd DQ 03feccccccccccccdr	; 0.9
CONST	ENDS
;	COMDAT __real@3fe921fb60000000
CONST	SEGMENT
__real@3fe921fb60000000 DQ 03fe921fb60000000r	; 0.785398
CONST	ENDS
;	COMDAT __real@3fe54fdf3b645a1d
CONST	SEGMENT
__real@3fe54fdf3b645a1d DQ 03fe54fdf3b645a1dr	; 0.666
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fd8000000000000
CONST	SEGMENT
__real@3fd8000000000000 DQ 03fd8000000000000r	; 0.375
CONST	ENDS
;	COMDAT __real@3fd55553ef6b5d46
CONST	SEGMENT
__real@3fd55553ef6b5d46 DQ 03fd55553ef6b5d46r	; 0.333333
CONST	ENDS
;	COMDAT ??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@
CONST	SEGMENT
??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@ DB 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'm', 00H, 'a', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
CONST	SEGMENT
??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@BLAPCBGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAi?$AAn@
CONST	SEGMENT
??_C@_1BC@BLAPCBGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAi?$AAn@ DB 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'm', 00H, 'i', 00H, 'n'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 'l', 00H
	DB	'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\algorithm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FEEMDEPI@invalid?5comparator@
CONST	SEGMENT
??_C@_0BD@FEEMDEPI@invalid?5comparator@ DB 'invalid comparator', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??update_guide_seek_cover_current_position_search@@YGHPAUENTITY@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??update_guide_seek_cover_current_position_search@@YGHPAUENTITY@@@Z@4JA DD 0675H ; `update_guide_seek_cover_current_position_search'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z@4JA DD 05ecH ; `update_guide_seek_cover_default_terrain_search'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BK@HPLLKKAK@raw?9?$DOterrain_polygon_list@
CONST	SEGMENT
??_C@_0BK@HPLLKKAK@raw?9?$DOterrain_polygon_list@ DB 'raw->terrain_polygo'
	DB	'n_list', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z@4JA DD 04d7H ; `update_guide_seek_cover_forest_search'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@LOLJEHA@bounding_box@
CONST	SEGMENT
??_C@_0N@LOLJEHA@bounding_box@ DB 'bounding_box', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JBLGADFG@count?5?$DM?5SEEK_COUNT_LIMIT@
CONST	SEGMENT
??_C@_0BJ@JBLGADFG@count?5?$DM?5SEEK_COUNT_LIMIT@ DB 'count < SEEK_COUNT_'
	DB	'LIMIT', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA DD 03faH ; `update_guide_seek_cover_fixed_structure_search'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??check_fixed_structure_search_object_type@@YGHPAUENTITY@@0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??check_fixed_structure_search_object_type@@YGHPAUENTITY@@0@Z@4JA DD 03c5H ; `check_fixed_structure_search_object_type'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0L@GPAIBKEE@object_pos@
CONST	SEGMENT
??_C@_0L@GPAIBKEE@object_pos@ DB 'object_pos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NINKBKAC@object_bounding_box@
CONST	SEGMENT
??_C@_0BE@NINKBKAC@object_bounding_box@ DB 'object_bounding_box', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDGHNJOB@sector@
CONST	SEGMENT
??_C@_06IDGHNJOB@sector@ DB 'sector', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BJJCPMFI@object_3d_index?5?$CB?$DN?5OBJECT_3D_IN@
CONST	SEGMENT
??_C@_0DC@BJJCPMFI@object_3d_index?5?$CB?$DN?5OBJECT_3D_IN@ DB 'object_3d'
	DB	'_index != OBJECT_3D_INVALID_OBJECT_INDEX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OLIBHAPL@aggressor_bounding_box@
CONST	SEGMENT
??_C@_0BH@OLIBHAPL@aggressor_bounding_box@ DB 'aggressor_bounding_box', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EFCIKDJJ@aggressor_3d_index?5?$CB?$DN?5OBJECT_3D@
CONST	SEGMENT
??_C@_0DF@EFCIKDJJ@aggressor_3d_index?5?$CB?$DN?5OBJECT_3D@ DB 'aggressor'
	DB	'_3d_index != OBJECT_3D_INVALID_OBJECT_INDEX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FBJGKGOB@selected_weapon?5?$CB?$DN?5ENTITY_SUB_T@
CONST	SEGMENT
??_C@_0DE@FBJGKGOB@selected_weapon?5?$CB?$DN?5ENTITY_SUB_T@ DB 'selected_'
	DB	'weapon != ENTITY_SUB_TYPE_WEAPON_NO_WEAPON', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA DD 016dH ; `assess_cover_position'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z@4JA DD 0150H ; `set_guide_seek_cover_next_search_mode'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BP@LPAMFHPN@GD_COVER?3?5Invalid?5seek?5mode?5?$CFd@
CONST	SEGMENT
??_C@_0BP@LPAMFHPN@GD_COVER?3?5Invalid?5seek?5mode?5?$CFd@ DB 'GD_COVER: '
	DB	'Invalid seek mode %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JDIGCNOK@GD_COVER?3?5No?5Cover?5found?5for?5?$CFs@
CONST	SEGMENT
??_C@_0CA@JDIGCNOK@GD_COVER?3?5No?5Cover?5found?5for?5?$CFs@ DB 'GD_COVER'
	DB	': No Cover found for %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGJOOGAJ@group@
CONST	SEGMENT
??_C@_05MGJOOGAJ@group@ DB 'group', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09HKMIOAOH@aggressor@
CONST	SEGMENT
??_C@_09HKMIOAOH@aggressor@ DB 'aggressor', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA DD 0a3H ; `update_guide_seek_cover_results'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02LFNMGJAP@en@
CONST	SEGMENT
??_C@_02LFNMGJAP@en@ DB 'en', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
CONST	SEGMENT
??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@ DB 'c:\users\nh'
	DB	'v90\projects\eech\aphavoc\source\entity\special\guide\gd_cove'
	DB	'r.c', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??reset_guide_seek_cover_results@@YGXPAUENTITY@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??reset_guide_seek_cover_results@@YGXPAUENTITY@@@Z@4JA DD 088H ; `reset_guide_seek_cover_results'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
;	COMDAT ??$min@H@std@@YGABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YGABHABH0@Z PROC				; std::min<int>, COMDAT

; 5427 : 	{	// return smaller of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5428 : 	if (_Right < _Left)

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00013	7d 61		 jge	 SHORT $LN8@min
$LN4@min:

; 5429 : 		{
; 5430 : 		_STL_ASSERT(!(_Left < _Right), "invalid comparator");

  00015	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00018	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0001f	7c 02		 jl	 SHORT $LN7@min
  00021	eb 4a		 jmp	 SHORT $LN2@min
$LN7@min:
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FEEMDEPI@invalid?5comparator@
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0002d	6a 00		 push	 0
  0002f	68 36 15 00 00	 push	 5430			; 00001536H
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00039	6a 02		 push	 2
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00041	83 c4 18	 add	 esp, 24			; 00000018H
  00044	83 f8 01	 cmp	 eax, 1
  00047	75 01		 jne	 SHORT $LN12@min
  00049	cc		 int	 3
$LN12@min:
  0004a	6a 00		 push	 0
  0004c	68 36 15 00 00	 push	 5430			; 00001536H
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@BLAPCBGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAi?$AAn@
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00066	83 c4 14	 add	 esp, 20			; 00000014H
  00069	33 c0		 xor	 eax, eax
  0006b	75 b6		 jne	 SHORT $LN7@min
$LN2@min:
  0006d	33 c0		 xor	 eax, eax
  0006f	75 a4		 jne	 SHORT $LN4@min

; 5431 : 		return (_Right);

  00071	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00074	eb 03		 jmp	 SHORT $LN11@min
$LN8@min:

; 5432 : 		}
; 5433 : 
; 5434 : 	return (_Left);

  00076	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
$LN11@min:

; 5435 : 	}

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 08 00	 ret	 8
??$min@H@std@@YGABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\guide\gd_cover.c
;	COMDAT ?check_fixed_structure_search_object_type@@YGHPAUENTITY@@0@Z
_TEXT	SEGMENT
tv139 = -72						; size = 4
tv132 = -72						; size = 4
tv93 = -72						; size = 4
tv86 = -72						; size = 4
tv79 = -72						; size = 4
tv73 = -72						; size = 4
_raw$ = -4						; size = 4
_en$ = 8						; size = 4
_structure$ = 12					; size = 4
?check_fixed_structure_search_object_type@@YGHPAUENTITY@@0@Z PROC ; check_fixed_structure_search_object_type, COMDAT

; 965  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 966  : 	guide
; 967  : 		*raw;
; 968  : 
; 969  : 	ASSERT (en);

  00009	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN4@check_fixe
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??check_fixed_structure_search_object_type@@YGHPAUENTITY@@0@Z@4JA
  00014	83 c0 04	 add	 eax, 4
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02LFNMGJAP@en@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN4@check_fixe:

; 970  : 
; 971  : 	raw = (guide *) get_local_entity_data (en);

  00027	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  0002a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002d	89 4d fc	 mov	 DWORD PTR _raw$[ebp], ecx

; 972  : 
; 973  : 	switch (raw->current_seek_cover_result.search_mode)

  00030	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  00033	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00039	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0003c	89 4d b8	 mov	 DWORD PTR tv73[ebp], ecx
  0003f	83 7d b8 02	 cmp	 DWORD PTR tv73[ebp], 2
  00043	74 19		 je	 SHORT $LN5@check_fixe
  00045	83 7d b8 03	 cmp	 DWORD PTR tv73[ebp], 3
  00049	0f 84 b1 00 00
	00		 je	 $LN8@check_fixe
  0004f	83 7d b8 04	 cmp	 DWORD PTR tv73[ebp], 4
  00053	0f 84 e3 00 00
	00		 je	 $LN10@check_fixe
  00059	e9 18 01 00 00	 jmp	 $LN2@check_fixe
$LN5@check_fixe:

; 974  : 	{
; 975  : 		case SEEK_COVER_MODE_BUILDINGS:
; 976  : 		{
; 977  : 			if (
; 978  : 					(get_local_entity_type (structure) == ENTITY_TYPE_SCENIC) ||
; 979  : 					(get_local_entity_type (structure) == ENTITY_TYPE_SITE) ||

  0005e	83 7d 0c 00	 cmp	 DWORD PTR _structure$[ebp], 0
  00062	74 0a		 je	 SHORT $LN13@check_fixe
  00064	8b 45 0c	 mov	 eax, DWORD PTR _structure$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	89 4d b8	 mov	 DWORD PTR tv79[ebp], ecx
  0006c	eb 1d		 jmp	 SHORT $LN14@check_fixe
$LN13@check_fixe:
  0006e	68 d2 03 00 00	 push	 978			; 000003d2H
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00078	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00084	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$LN14@check_fixe:
  0008b	83 7d b8 18	 cmp	 DWORD PTR tv79[ebp], 24	; 00000018H
  0008f	74 66		 je	 SHORT $LN7@check_fixe
  00091	83 7d 0c 00	 cmp	 DWORD PTR _structure$[ebp], 0
  00095	74 0a		 je	 SHORT $LN15@check_fixe
  00097	8b 45 0c	 mov	 eax, DWORD PTR _structure$[ebp]
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d b8	 mov	 DWORD PTR tv86[ebp], ecx
  0009f	eb 1d		 jmp	 SHORT $LN16@check_fixe
$LN15@check_fixe:
  000a1	68 d3 03 00 00	 push	 979			; 000003d3H
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  000ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  000b7	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
$LN16@check_fixe:
  000be	83 7d b8 1d	 cmp	 DWORD PTR tv86[ebp], 29	; 0000001dH
  000c2	74 33		 je	 SHORT $LN7@check_fixe
  000c4	83 7d 0c 00	 cmp	 DWORD PTR _structure$[ebp], 0
  000c8	74 0a		 je	 SHORT $LN17@check_fixe
  000ca	8b 45 0c	 mov	 eax, DWORD PTR _structure$[ebp]
  000cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cf	89 4d b8	 mov	 DWORD PTR tv93[ebp], ecx
  000d2	eb 1d		 jmp	 SHORT $LN18@check_fixe
$LN17@check_fixe:
  000d4	68 d4 03 00 00	 push	 980			; 000003d4H
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  000de	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  000ea	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
$LN18@check_fixe:
  000f1	83 7d b8 1e	 cmp	 DWORD PTR tv93[ebp], 30	; 0000001eH
  000f5	75 07		 jne	 SHORT $LN6@check_fixe
$LN7@check_fixe:

; 980  : 					(get_local_entity_type (structure) == ENTITY_TYPE_SITE_UPDATABLE)
; 981  : 				)
; 982  : 			{
; 983  : 				return TRUE;

  000f7	b8 01 00 00 00	 mov	 eax, 1
  000fc	eb 7a		 jmp	 SHORT $LN1@check_fixe
$LN6@check_fixe:

; 984  : 			}
; 985  : 
; 986  : 			break;

  000fe	eb 76		 jmp	 SHORT $LN2@check_fixe
$LN8@check_fixe:

; 987  : 		}
; 988  : 
; 989  : 		case SEEK_COVER_MODE_BRIDGES:
; 990  : 		{
; 991  : 			if (get_local_entity_type (structure) == ENTITY_TYPE_SEGMENT)

  00100	83 7d 0c 00	 cmp	 DWORD PTR _structure$[ebp], 0
  00104	74 0a		 je	 SHORT $LN19@check_fixe
  00106	8b 45 0c	 mov	 eax, DWORD PTR _structure$[ebp]
  00109	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010b	89 4d b8	 mov	 DWORD PTR tv132[ebp], ecx
  0010e	eb 1d		 jmp	 SHORT $LN20@check_fixe
$LN19@check_fixe:
  00110	68 df 03 00 00	 push	 991			; 000003dfH
  00115	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0011a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00126	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv132[ebp], 0
$LN20@check_fixe:
  0012d	83 7d b8 1a	 cmp	 DWORD PTR tv132[ebp], 26 ; 0000001aH
  00131	75 07		 jne	 SHORT $LN9@check_fixe

; 992  : 			{
; 993  : 				return TRUE;

  00133	b8 01 00 00 00	 mov	 eax, 1
  00138	eb 3e		 jmp	 SHORT $LN1@check_fixe
$LN9@check_fixe:

; 994  : 			}
; 995  : 
; 996  : 			break;

  0013a	eb 3a		 jmp	 SHORT $LN2@check_fixe
$LN10@check_fixe:

; 997  : 		}	
; 998  : 
; 999  : 		case SEEK_COVER_MODE_CITY_BUILDINGS:
; 1000 : 		{
; 1001 : 			if (get_local_entity_type (structure) == ENTITY_TYPE_CITY_BUILDING)

  0013c	83 7d 0c 00	 cmp	 DWORD PTR _structure$[ebp], 0
  00140	74 0a		 je	 SHORT $LN21@check_fixe
  00142	8b 45 0c	 mov	 eax, DWORD PTR _structure$[ebp]
  00145	8b 08		 mov	 ecx, DWORD PTR [eax]
  00147	89 4d b8	 mov	 DWORD PTR tv139[ebp], ecx
  0014a	eb 1d		 jmp	 SHORT $LN22@check_fixe
$LN21@check_fixe:
  0014c	68 e9 03 00 00	 push	 1001			; 000003e9H
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00156	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0015c	52		 push	 edx
  0015d	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00162	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv139[ebp], 0
$LN22@check_fixe:
  00169	83 7d b8 06	 cmp	 DWORD PTR tv139[ebp], 6
  0016d	75 07		 jne	 SHORT $LN2@check_fixe

; 1002 : 			{
; 1003 : 				return TRUE;

  0016f	b8 01 00 00 00	 mov	 eax, 1
  00174	eb 02		 jmp	 SHORT $LN1@check_fixe
$LN2@check_fixe:

; 1004 : 			}
; 1005 : 
; 1006 : 			break;
; 1007 : 		}	
; 1008 : 	}
; 1009 : 
; 1010 : 	return FALSE;

  00176	33 c0		 xor	 eax, eax
$LN1@check_fixe:

; 1011 : }

  00178	5f		 pop	 edi
  00179	5e		 pop	 esi
  0017a	5b		 pop	 ebx
  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c2 08 00	 ret	 8
?check_fixed_structure_search_object_type@@YGHPAUENTITY@@0@Z ENDP ; check_fixed_structure_search_object_type
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
;	COMDAT ??$max@M@std@@YGABMABM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@M@std@@YGABMABM0@Z PROC				; std::max<float>, COMDAT

; 5387 : 	{	// return larger of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5388 : 	if (_Left < _Right)

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00013	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00016	76 64		 jbe	 SHORT $LN8@max
$LN4@max:

; 5389 : 		{
; 5390 : 		_STL_ASSERT(!(_Right < _Left), "invalid comparator");

  00018	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00022	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00025	77 02		 ja	 SHORT $LN9@max
  00027	eb 4a		 jmp	 SHORT $LN6@max
$LN9@max:
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FEEMDEPI@invalid?5comparator@
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00033	6a 00		 push	 0
  00035	68 0e 15 00 00	 push	 5390			; 0000150eH
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  0003f	6a 02		 push	 2
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00047	83 c4 18	 add	 esp, 24			; 00000018H
  0004a	83 f8 01	 cmp	 eax, 1
  0004d	75 01		 jne	 SHORT $LN12@max
  0004f	cc		 int	 3
$LN12@max:
  00050	6a 00		 push	 0
  00052	68 0e 15 00 00	 push	 5390			; 0000150eH
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0006c	83 c4 14	 add	 esp, 20			; 00000014H
  0006f	33 c0		 xor	 eax, eax
  00071	75 b6		 jne	 SHORT $LN9@max
$LN6@max:
  00073	33 c0		 xor	 eax, eax
  00075	75 a1		 jne	 SHORT $LN4@max

; 5391 : 		return (_Right);

  00077	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0007a	eb 03		 jmp	 SHORT $LN1@max
$LN8@max:

; 5392 : 		}
; 5393 : 
; 5394 : 	return (_Left);

  0007c	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
$LN1@max:

; 5395 : 	}

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
??$max@M@std@@YGABMABM0@Z ENDP				; std::max<float>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
;	COMDAT ??$min@M@std@@YGABMABM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@M@std@@YGABMABM0@Z PROC				; std::min<float>, COMDAT

; 5427 : 	{	// return smaller of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5428 : 	if (_Right < _Left)

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00013	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00016	76 64		 jbe	 SHORT $LN8@min
$LN4@min:

; 5429 : 		{
; 5430 : 		_STL_ASSERT(!(_Left < _Right), "invalid comparator");

  00018	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00022	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00025	77 02		 ja	 SHORT $LN9@min
  00027	eb 4a		 jmp	 SHORT $LN6@min
$LN9@min:
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FEEMDEPI@invalid?5comparator@
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00033	6a 00		 push	 0
  00035	68 36 15 00 00	 push	 5430			; 00001536H
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  0003f	6a 02		 push	 2
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00047	83 c4 18	 add	 esp, 24			; 00000018H
  0004a	83 f8 01	 cmp	 eax, 1
  0004d	75 01		 jne	 SHORT $LN12@min
  0004f	cc		 int	 3
$LN12@min:
  00050	6a 00		 push	 0
  00052	68 36 15 00 00	 push	 5430			; 00001536H
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@BLAPCBGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAi?$AAn@
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0006c	83 c4 14	 add	 esp, 20			; 00000014H
  0006f	33 c0		 xor	 eax, eax
  00071	75 b6		 jne	 SHORT $LN9@min
$LN6@min:
  00073	33 c0		 xor	 eax, eax
  00075	75 a1		 jne	 SHORT $LN4@min

; 5431 : 		return (_Right);

  00077	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0007a	eb 03		 jmp	 SHORT $LN1@min
$LN8@min:

; 5432 : 		}
; 5433 : 
; 5434 : 	return (_Left);

  0007c	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
$LN1@min:

; 5435 : 	}

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
??$min@M@std@@YGABMABM0@Z ENDP				; std::min<float>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\guide\gd_cover.c
;	COMDAT ?assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z
_TEXT	SEGMENT
tv790 = -336						; size = 8
tv1004 = -328						; size = 8
tv828 = -328						; size = 4
tv791 = -328						; size = 8
tv774 = -328						; size = 4
tv723 = -328						; size = 4
tv695 = -328						; size = 4
tv680 = -328						; size = 4
tv665 = -328						; size = 4
tv596 = -328						; size = 4
tv566 = -328						; size = 4
tv540 = -328						; size = 4
tv517 = -328						; size = 4
tv496 = -328						; size = 4
tv442 = -328						; size = 4
tv417 = -328						; size = 4
tv347 = -328						; size = 4
tv311 = -328						; size = 4
tv259 = -328						; size = 4
tv188 = -328						; size = 4
tv139 = -328						; size = 4
tv87 = -328						; size = 4
tv1249 = -324						; size = 4
tv1231 = -324						; size = 4
tv1099 = -324						; size = 4
tv820 = -324						; size = 4
tv766 = -324						; size = 4
tv715 = -324						; size = 4
tv687 = -324						; size = 4
tv679 = -324						; size = 4
tv657 = -324						; size = 4
tv588 = -324						; size = 4
tv558 = -324						; size = 4
tv532 = -324						; size = 4
tv509 = -324						; size = 4
tv488 = -324						; size = 4
tv434 = -324						; size = 4
tv409 = -324						; size = 4
tv339 = -324						; size = 4
tv303 = -324						; size = 4
tv251 = -324						; size = 4
tv180 = -324						; size = 4
tv131 = -324						; size = 4
tv79 = -324						; size = 4
_object_max$1 = -256					; size = 12
_object_min$2 = -244					; size = 12
_object_pos$3 = -232					; size = 4
_object$4 = -228					; size = 4
_sector$5 = -224					; size = 4
_distance$6 = -220					; size = 4
_member_pos$7 = -216					; size = 12
_guide_type$8 = -204					; size = 4
_guide$9 = -200						; size = 4
_member$10 = -196					; size = 4
_group$11 = -192					; size = 4
_selected_weapon$ = -188				; size = 4
_object_3d_index$ = -184				; size = 4
_aggressor_3d_index$ = -180				; size = 4
_object_bounding_box$ = -176				; size = 4
_aggressor_bounding_box$ = -172				; size = 4
_result$ = -168						; size = 4
_weapon_effective_range$ = -164				; size = 4
_weapon_min_range$ = -160				; size = 4
_weapon_max_range$ = -156				; size = 4
_object_height$ = -152					; size = 4
_aggressor_width$ = -148				; size = 4
_aggressor_height$ = -144				; size = 4
_wmax$ = -140						; size = 4
_wmin$ = -136						; size = 4
_total$ = -132						; size = 4
_altitude_rating$ = -128				; size = 4
_altitude$ = -124					; size = 4
_heading$ = -120					; size = 4
_ac_rating$ = -116					; size = 4
_tc_rating$ = -112					; size = 4
_ac_range$ = -108					; size = 4
_tc_range$ = -104					; size = 4
_ta_range$ = -100					; size = 4
_check_point$ = -96					; size = 8
_ac_vec$ = -88						; size = 12
_tc_vec$ = -76						; size = 12
_ta_vec$ = -64						; size = 12
_aggressor_max$ = -52					; size = 12
_aggressor_min$ = -40					; size = 12
_check_pos$ = -28					; size = 12
_structure_pos$ = -16					; size = 4
_target_pos$ = -12					; size = 4
_aggressor_pos$ = -8					; size = 4
_raw$ = -4						; size = 4
_en$ = 8						; size = 4
_aggressor$ = 12					; size = 4
_target$ = 16						; size = 4
_cover_pos$ = 20					; size = 4
_cover_structure$ = 24					; size = 4
?assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z PROC ; assess_cover_position, COMDAT

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 366  : 	guide
; 367  : 		*raw;
; 368  : 
; 369  : 	vec3d
; 370  : 		*aggressor_pos,
; 371  : 		*target_pos,
; 372  : 		*structure_pos,
; 373  : 		check_pos,
; 374  : 		aggressor_min,
; 375  : 		aggressor_max,
; 376  : 		ta_vec,
; 377  : 		tc_vec,
; 378  : 		ac_vec;
; 379  : 
; 380  : 	vec2d
; 381  : 		check_point;
; 382  : 
; 383  : 	float
; 384  : 		ta_range,
; 385  : 		tc_range,
; 386  : 		ac_range,
; 387  : 		tc_rating,
; 388  : 		ac_rating,
; 389  : 		heading,
; 390  : 		altitude,
; 391  : 		altitude_rating,
; 392  : 		total,
; 393  : 		wmin,
; 394  : 		wmax,
; 395  : 		aggressor_height,
; 396  : 		aggressor_width,
; 397  : 		object_height,
; 398  : 		weapon_max_range,
; 399  : 		weapon_min_range,
; 400  : 		weapon_effective_range;
; 401  : 
; 402  : 	unsigned int
; 403  : 		result;
; 404  : 
; 405  : 	object_3d_bounds
; 406  : 		*aggressor_bounding_box,
; 407  : 		*object_bounding_box;
; 408  : 
; 409  : 	object_3d_index_numbers
; 410  : 		aggressor_3d_index,
; 411  : 		object_3d_index;
; 412  : 
; 413  : 	entity_sub_types
; 414  : 		selected_weapon;
; 415  : 
; 416  : 	raw = (guide *) get_local_entity_data (en);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	89 4d fc	 mov	 DWORD PTR _raw$[ebp], ecx

; 417  : 
; 418  : 	result = 0;

  00015	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _result$[ebp], 0

; 419  : 
; 420  : 	#if DEBUG_MODULE
; 421  : 
; 422  : 	if (cover_structure)
; 423  : 	{
; 424  : 		if (aggressor == get_external_view_entity ())
; 425  : 		{
; 426  : 			debug_filtered_log ("*************************************");
; 427  : 			debug_filtered_log ("GD_COVER: Checking %s (%s)", get_local_entity_string (cover_structure, STRING_TYPE_FULL_NAME), object_3d_enumeration_names[get_local_entity_int_value (cover_structure, INT_TYPE_OBJECT_3D_SHAPE)]);
; 428  : 		}
; 429  : 	}
; 430  : 
; 431  : 	#endif
; 432  : 
; 433  : 	//
; 434  : 	// check position is within map boundaries (TRIVIAL REJECTION)
; 435  : 	//
; 436  : 
; 437  : 	if (!point_inside_map_area (cover_pos))

  0001f	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  00022	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00026	0f 2f 05 24 00
	00 00		 comiss	 xmm0, DWORD PTR ?world_map@@3UWORLD_MAP_DATA@@A+36
  0002d	72 32		 jb	 SHORT $LN12@assess_cov
  0002f	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  00032	f3 0f 10 05 3c
	00 00 00	 movss	 xmm0, DWORD PTR ?world_map@@3UWORLD_MAP_DATA@@A+60
  0003a	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  0003d	72 22		 jb	 SHORT $LN12@assess_cov
  0003f	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  00042	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00047	0f 2f 05 2c 00
	00 00		 comiss	 xmm0, DWORD PTR ?world_map@@3UWORLD_MAP_DATA@@A+44
  0004e	72 11		 jb	 SHORT $LN12@assess_cov
  00050	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  00053	f3 0f 10 05 44
	00 00 00	 movss	 xmm0, DWORD PTR ?world_map@@3UWORLD_MAP_DATA@@A+68
  0005b	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  0005f	73 0b		 jae	 SHORT $LN11@assess_cov
$LN12@assess_cov:

; 438  : 	{
; 439  : 		#if DEBUG_MODULE
; 440  : 
; 441  : 		if (aggressor == get_external_view_entity ())
; 442  : 		{
; 443  : 			debug_filtered_log ("	- REJECTED (point outside map area)");
; 444  : 		}
; 445  : 
; 446  : 		#endif
; 447  : 
; 448  : 		return result;

  00061	8a 85 58 ff ff
	ff		 mov	 al, BYTE PTR _result$[ebp]
  00067	e9 5e 16 00 00	 jmp	 $LN1@assess_cov
$LN11@assess_cov:

; 449  : 	}
; 450  : 
; 451  : 	aggressor_pos = get_local_entity_vec3d_ptr (aggressor, VEC3D_TYPE_POSITION);

  0006c	83 7d 0c 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  00070	74 0d		 je	 SHORT $LN47@assess_cov
  00072	8b 45 0c	 mov	 eax, DWORD PTR _aggressor$[ebp]
  00075	8b 08		 mov	 ecx, DWORD PTR [eax]
  00077	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv79[ebp], ecx
  0007d	eb 24		 jmp	 SHORT $LN48@assess_cov
$LN47@assess_cov:
  0007f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00085	83 c2 56	 add	 edx, 86			; 00000056H
  00088	52		 push	 edx
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0008e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00099	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv79[ebp], 0
$LN48@assess_cov:
  000a3	b9 01 00 00 00	 mov	 ecx, 1
  000a8	85 c9		 test	 ecx, ecx
  000aa	74 0c		 je	 SHORT $LN49@assess_cov
  000ac	c7 85 b8 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR tv87[ebp], 8
  000b6	eb 24		 jmp	 SHORT $LN50@assess_cov
$LN49@assess_cov:
  000b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  000be	83 c2 56	 add	 edx, 86			; 00000056H
  000c1	52		 push	 edx
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  000c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  000d2	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv87[ebp], 0
$LN50@assess_cov:
  000dc	6a 08		 push	 8
  000de	8b 4d 0c	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  000e1	51		 push	 ecx
  000e2	6b 95 bc fe ff
	ff 60		 imul	 edx, DWORD PTR tv79[ebp], 96
  000e9	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv87[ebp]
  000ef	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA[edx+eax*4]
  000f6	ff d1		 call	 ecx
  000f8	89 45 f8	 mov	 DWORD PTR _aggressor_pos$[ebp], eax

; 452  : 
; 453  : 	target_pos = get_local_entity_vec3d_ptr (target, VEC3D_TYPE_POSITION);

  000fb	83 7d 10 00	 cmp	 DWORD PTR _target$[ebp], 0
  000ff	74 0d		 je	 SHORT $LN51@assess_cov
  00101	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  00104	8b 08		 mov	 ecx, DWORD PTR [eax]
  00106	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv131[ebp], ecx
  0010c	eb 24		 jmp	 SHORT $LN52@assess_cov
$LN51@assess_cov:
  0010e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00114	83 c2 58	 add	 edx, 88			; 00000058H
  00117	52		 push	 edx
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0011d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00128	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv131[ebp], 0
$LN52@assess_cov:
  00132	b9 01 00 00 00	 mov	 ecx, 1
  00137	85 c9		 test	 ecx, ecx
  00139	74 0c		 je	 SHORT $LN53@assess_cov
  0013b	c7 85 b8 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR tv139[ebp], 8
  00145	eb 24		 jmp	 SHORT $LN54@assess_cov
$LN53@assess_cov:
  00147	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  0014d	83 c2 58	 add	 edx, 88			; 00000058H
  00150	52		 push	 edx
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00156	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00161	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv139[ebp], 0
$LN54@assess_cov:
  0016b	6a 08		 push	 8
  0016d	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  00170	51		 push	 ecx
  00171	6b 95 bc fe ff
	ff 60		 imul	 edx, DWORD PTR tv131[ebp], 96
  00178	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv139[ebp]
  0017e	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA[edx+eax*4]
  00185	ff d1		 call	 ecx
  00187	89 45 f4	 mov	 DWORD PTR _target_pos$[ebp], eax

; 454  : 
; 455  : 	//
; 456  : 	// target to aggressor vector
; 457  : 	//
; 458  : 
; 459  : 	ta_vec.x = aggressor_pos->x - target_pos->x;

  0018a	8b 45 f8	 mov	 eax, DWORD PTR _aggressor_pos$[ebp]
  0018d	8b 4d f4	 mov	 ecx, DWORD PTR _target_pos$[ebp]
  00190	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00194	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00198	f3 0f 11 45 c0	 movss	 DWORD PTR _ta_vec$[ebp], xmm0

; 460  : 	ta_vec.y = 0.0;

  0019d	0f 57 c0	 xorps	 xmm0, xmm0
  001a0	f3 0f 11 45 c4	 movss	 DWORD PTR _ta_vec$[ebp+4], xmm0

; 461  : 	ta_vec.z = aggressor_pos->z - target_pos->z;

  001a5	8b 45 f8	 mov	 eax, DWORD PTR _aggressor_pos$[ebp]
  001a8	8b 4d f4	 mov	 ecx, DWORD PTR _target_pos$[ebp]
  001ab	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001b0	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  001b5	f3 0f 11 45 c8	 movss	 DWORD PTR _ta_vec$[ebp+8], xmm0

; 462  : 
; 463  : 	ta_range = normalise_any_3d_vector (&ta_vec);

  001ba	8d 45 c0	 lea	 eax, DWORD PTR _ta_vec$[ebp]
  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 ?normalise_any_3d_vector@@YGMPAUVEC3D@@@Z ; normalise_any_3d_vector
  001c3	d9 5d 9c	 fstp	 DWORD PTR _ta_range$[ebp]

; 464  : 
; 465  : 	//
; 466  : 	// target to cover vector
; 467  : 	//
; 468  : 
; 469  : 	tc_vec.x = cover_pos->x - target_pos->x;

  001c6	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  001c9	8b 4d f4	 mov	 ecx, DWORD PTR _target_pos$[ebp]
  001cc	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001d0	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  001d4	f3 0f 11 45 b4	 movss	 DWORD PTR _tc_vec$[ebp], xmm0

; 470  : 	tc_vec.y = 0.0;

  001d9	0f 57 c0	 xorps	 xmm0, xmm0
  001dc	f3 0f 11 45 b8	 movss	 DWORD PTR _tc_vec$[ebp+4], xmm0

; 471  : 	tc_vec.z = cover_pos->z - target_pos->z;

  001e1	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  001e4	8b 4d f4	 mov	 ecx, DWORD PTR _target_pos$[ebp]
  001e7	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001ec	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  001f1	f3 0f 11 45 bc	 movss	 DWORD PTR _tc_vec$[ebp+8], xmm0

; 472  : 
; 473  : 	tc_range = normalise_any_3d_vector (&tc_vec);

  001f6	8d 45 b4	 lea	 eax, DWORD PTR _tc_vec$[ebp]
  001f9	50		 push	 eax
  001fa	e8 00 00 00 00	 call	 ?normalise_any_3d_vector@@YGMPAUVEC3D@@@Z ; normalise_any_3d_vector
  001ff	d9 5d 98	 fstp	 DWORD PTR _tc_range$[ebp]

; 474  : 
; 475  : 	//
; 476  : 	// aggressor to cover vector
; 477  : 	//
; 478  : 	
; 479  : 	ac_vec.x = cover_pos->x - aggressor_pos->x;

  00202	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  00205	8b 4d f8	 mov	 ecx, DWORD PTR _aggressor_pos$[ebp]
  00208	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0020c	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00210	f3 0f 11 45 a8	 movss	 DWORD PTR _ac_vec$[ebp], xmm0

; 480  : 	ac_vec.y = 0.0;

  00215	0f 57 c0	 xorps	 xmm0, xmm0
  00218	f3 0f 11 45 ac	 movss	 DWORD PTR _ac_vec$[ebp+4], xmm0

; 481  : 	ac_vec.z = cover_pos->z - aggressor_pos->z;

  0021d	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  00220	8b 4d f8	 mov	 ecx, DWORD PTR _aggressor_pos$[ebp]
  00223	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00228	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0022d	f3 0f 11 45 b0	 movss	 DWORD PTR _ac_vec$[ebp+8], xmm0

; 482  : 
; 483  : 	ac_range = normalise_any_3d_vector (&ac_vec);

  00232	8d 45 a8	 lea	 eax, DWORD PTR _ac_vec$[ebp]
  00235	50		 push	 eax
  00236	e8 00 00 00 00	 call	 ?normalise_any_3d_vector@@YGMPAUVEC3D@@@Z ; normalise_any_3d_vector
  0023b	d9 5d 94	 fstp	 DWORD PTR _ac_range$[ebp]

; 484  : 
; 485  : 	//
; 486  : 	// check if aggressor has to fly past target (TRIVIAL REJECTION) 
; 487  : 	//
; 488  : 
; 489  : 	if (get_3d_unit_vector_dot_product (&ta_vec, &tc_vec) < 0.0)

  0023e	8d 45 b4	 lea	 eax, DWORD PTR _tc_vec$[ebp]
  00241	50		 push	 eax
  00242	8d 4d c0	 lea	 ecx, DWORD PTR _ta_vec$[ebp]
  00245	51		 push	 ecx
  00246	e8 00 00 00 00	 call	 ?get_3d_unit_vector_dot_product@@YGMPBUVEC3D@@0@Z ; get_3d_unit_vector_dot_product
  0024b	dd 9d b8 fe ff
	ff		 fstp	 QWORD PTR tv1004[ebp]
  00251	0f 57 c0	 xorps	 xmm0, xmm0
  00254	66 0f 2f 85 b8
	fe ff ff	 comisd	 xmm0, QWORD PTR tv1004[ebp]
  0025c	76 0b		 jbe	 SHORT $LN13@assess_cov

; 490  : 	{
; 491  : 		#if DEBUG_MODULE
; 492  : 
; 493  : 		if (aggressor == get_external_view_entity ())
; 494  : 		{
; 495  : 			debug_filtered_log ("	- REJECTED (fly past target)");
; 496  : 		}
; 497  : 
; 498  : 		#endif
; 499  : 
; 500  : 		return result;

  0025e	8a 85 58 ff ff
	ff		 mov	 al, BYTE PTR _result$[ebp]
  00264	e9 61 14 00 00	 jmp	 $LN1@assess_cov
$LN13@assess_cov:

; 501  : 	}
; 502  : 
; 503  : 	//
; 504  : 	// find aggressors selected weapon
; 505  : 	//
; 506  : 
; 507  : 	selected_weapon = get_local_entity_int_value (aggressor, INT_TYPE_SELECTED_WEAPON);

  00269	83 7d 0c 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  0026d	74 0d		 je	 SHORT $LN55@assess_cov
  0026f	8b 45 0c	 mov	 eax, DWORD PTR _aggressor$[ebp]
  00272	8b 08		 mov	 ecx, DWORD PTR [eax]
  00274	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv180[ebp], ecx
  0027a	eb 27		 jmp	 SHORT $LN56@assess_cov
$LN55@assess_cov:
  0027c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00282	81 c2 8e 00 00
	00		 add	 edx, 142		; 0000008eH
  00288	52		 push	 edx
  00289	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0028e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00293	50		 push	 eax
  00294	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00299	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv180[ebp], 0
$LN56@assess_cov:
  002a3	b9 01 00 00 00	 mov	 ecx, 1
  002a8	85 c9		 test	 ecx, ecx
  002aa	74 0c		 je	 SHORT $LN57@assess_cov
  002ac	c7 85 b8 fe ff
	ff b8 00 00 00	 mov	 DWORD PTR tv188[ebp], 184 ; 000000b8H
  002b6	eb 27		 jmp	 SHORT $LN58@assess_cov
$LN57@assess_cov:
  002b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  002be	81 c2 8e 00 00
	00		 add	 edx, 142		; 0000008eH
  002c4	52		 push	 edx
  002c5	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  002ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  002cf	50		 push	 eax
  002d0	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  002d5	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv188[ebp], 0
$LN58@assess_cov:
  002df	68 b8 00 00 00	 push	 184			; 000000b8H
  002e4	8b 4d 0c	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  002e7	51		 push	 ecx
  002e8	69 95 bc fe ff
	ff 5c 04 00 00	 imul	 edx, DWORD PTR tv180[ebp], 1116
  002f2	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv188[ebp]
  002f8	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[edx+eax*4]
  002ff	ff d1		 call	 ecx
  00301	89 85 44 ff ff
	ff		 mov	 DWORD PTR _selected_weapon$[ebp], eax

; 508  : 
; 509  : 	ASSERT (selected_weapon != ENTITY_SUB_TYPE_WEAPON_NO_WEAPON);

  00307	83 bd 44 ff ff
	ff 00		 cmp	 DWORD PTR _selected_weapon$[ebp], 0
  0030e	75 1a		 jne	 SHORT $LN14@assess_cov
  00310	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00315	05 90 00 00 00	 add	 eax, 144		; 00000090H
  0031a	50		 push	 eax
  0031b	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00320	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@FBJGKGOB@selected_weapon?5?$CB?$DN?5ENTITY_SUB_T@
  00325	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN14@assess_cov:

; 510  : 	
; 511  : 	weapon_max_range = weapon_database [selected_weapon].max_range * 0.9;

  0032a	69 85 44 ff ff
	ff e0 00 00 00	 imul	 eax, DWORD PTR _selected_weapon$[ebp], 224
  00334	f3 0f 5a 80 90
	00 00 00	 cvtss2sd xmm0, DWORD PTR ?weapon_database@@3PAUWEAPON_DATA@@A[eax+144]
  0033c	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3feccccccccccccd
  00344	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00348	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _weapon_max_range$[ebp], xmm0

; 512  : 
; 513  : 	weapon_min_range = weapon_database [selected_weapon].min_range;

  00350	69 85 44 ff ff
	ff e0 00 00 00	 imul	 eax, DWORD PTR _selected_weapon$[ebp], 224
  0035a	f3 0f 10 80 8c
	00 00 00	 movss	 xmm0, DWORD PTR ?weapon_database@@3PAUWEAPON_DATA@@A[eax+140]
  00362	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _weapon_min_range$[ebp], xmm0

; 514  : 
; 515  : 	weapon_effective_range = weapon_database [selected_weapon].effective_range;

  0036a	69 85 44 ff ff
	ff e0 00 00 00	 imul	 eax, DWORD PTR _selected_weapon$[ebp], 224
  00374	f3 0f 10 80 94
	00 00 00	 movss	 xmm0, DWORD PTR ?weapon_database@@3PAUWEAPON_DATA@@A[eax+148]
  0037c	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _weapon_effective_range$[ebp], xmm0

; 516  : 
; 517  : 	//
; 518  : 	// check cover pos lies within range of weapon (TRIVIAL REJECTION)
; 519  : 	//
; 520  : 
; 521  : 	if ((tc_range < weapon_min_range) || (tc_range > weapon_max_range))

  00384	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _weapon_min_range$[ebp]
  0038c	0f 2f 45 98	 comiss	 xmm0, DWORD PTR _tc_range$[ebp]
  00390	77 0e		 ja	 SHORT $LN16@assess_cov
  00392	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _tc_range$[ebp]
  00397	0f 2f 85 64 ff
	ff ff		 comiss	 xmm0, DWORD PTR _weapon_max_range$[ebp]
  0039e	76 0b		 jbe	 SHORT $LN15@assess_cov
$LN16@assess_cov:

; 522  : 	{
; 523  : 		#if DEBUG_MODULE
; 524  : 
; 525  : 		if (aggressor == get_external_view_entity ())
; 526  : 		{
; 527  : 			debug_filtered_log ("	- REJECTED (out of weapon range)");
; 528  : 		}
; 529  : 
; 530  : 		#endif
; 531  : 
; 532  : 		return result;

  003a0	8a 85 58 ff ff
	ff		 mov	 al, BYTE PTR _result$[ebp]
  003a6	e9 1f 13 00 00	 jmp	 $LN1@assess_cov
$LN15@assess_cov:

; 533  : 	}
; 534  : 
; 535  : 	//
; 536  : 	// check object is big enough to provide cover
; 537  : 	//
; 538  : 
; 539  : 	aggressor_3d_index = get_local_entity_int_value (aggressor, INT_TYPE_OBJECT_3D_SHAPE);

  003ab	83 7d 0c 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  003af	74 0d		 je	 SHORT $LN59@assess_cov
  003b1	8b 45 0c	 mov	 eax, DWORD PTR _aggressor$[ebp]
  003b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b6	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv251[ebp], ecx
  003bc	eb 27		 jmp	 SHORT $LN60@assess_cov
$LN59@assess_cov:
  003be	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  003c4	81 c2 ae 00 00
	00		 add	 edx, 174		; 000000aeH
  003ca	52		 push	 edx
  003cb	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  003d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  003d5	50		 push	 eax
  003d6	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  003db	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv251[ebp], 0
$LN60@assess_cov:
  003e5	b9 01 00 00 00	 mov	 ecx, 1
  003ea	85 c9		 test	 ecx, ecx
  003ec	74 0c		 je	 SHORT $LN61@assess_cov
  003ee	c7 85 b8 fe ff
	ff 92 00 00 00	 mov	 DWORD PTR tv259[ebp], 146 ; 00000092H
  003f8	eb 27		 jmp	 SHORT $LN62@assess_cov
$LN61@assess_cov:
  003fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00400	81 c2 ae 00 00
	00		 add	 edx, 174		; 000000aeH
  00406	52		 push	 edx
  00407	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0040c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  00411	50		 push	 eax
  00412	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00417	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv259[ebp], 0
$LN62@assess_cov:
  00421	68 92 00 00 00	 push	 146			; 00000092H
  00426	8b 4d 0c	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  00429	51		 push	 ecx
  0042a	69 95 bc fe ff
	ff 5c 04 00 00	 imul	 edx, DWORD PTR tv251[ebp], 1116
  00434	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv259[ebp]
  0043a	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[edx+eax*4]
  00441	ff d1		 call	 ecx
  00443	89 85 4c ff ff
	ff		 mov	 DWORD PTR _aggressor_3d_index$[ebp], eax

; 540  : 
; 541  : 	ASSERT (aggressor_3d_index != OBJECT_3D_INVALID_OBJECT_INDEX);

  00449	83 bd 4c ff ff
	ff 00		 cmp	 DWORD PTR _aggressor_3d_index$[ebp], 0
  00450	75 1a		 jne	 SHORT $LN17@assess_cov
  00452	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00457	05 b0 00 00 00	 add	 eax, 176		; 000000b0H
  0045c	50		 push	 eax
  0045d	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00462	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@EFCIKDJJ@aggressor_3d_index?5?$CB?$DN?5OBJECT_3D@
  00467	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN17@assess_cov:

; 542  : 
; 543  : 	aggressor_bounding_box = get_object_3d_bounding_box_without_lines (aggressor_3d_index);

  0046c	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _aggressor_3d_index$[ebp]
  00472	50		 push	 eax
  00473	e8 00 00 00 00	 call	 ?get_object_3d_bounding_box_without_lines@@YGPAUOBJECT_3D_BOUNDS@@H@Z ; get_object_3d_bounding_box_without_lines
  00478	89 85 54 ff ff
	ff		 mov	 DWORD PTR _aggressor_bounding_box$[ebp], eax

; 544  : 
; 545  : 	ASSERT (aggressor_bounding_box);

  0047e	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR _aggressor_bounding_box$[ebp], 0
  00485	75 1a		 jne	 SHORT $LN18@assess_cov
  00487	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  0048c	05 b4 00 00 00	 add	 eax, 180		; 000000b4H
  00491	50		 push	 eax
  00492	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00497	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@OLIBHAPL@aggressor_bounding_box@
  0049c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN18@assess_cov:

; 546  : 
; 547  : 	aggressor_min.x = cover_pos->x + aggressor_bounding_box->xmin;

  004a1	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  004a4	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _aggressor_bounding_box$[ebp]
  004aa	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  004ae	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  004b2	f3 0f 11 45 d8	 movss	 DWORD PTR _aggressor_min$[ebp], xmm0

; 548  : 	aggressor_min.y = cover_pos->y + aggressor_bounding_box->ymin;

  004b7	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  004ba	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _aggressor_bounding_box$[ebp]
  004c0	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  004c5	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
  004ca	f3 0f 11 45 dc	 movss	 DWORD PTR _aggressor_min$[ebp+4], xmm0

; 549  : 	aggressor_min.z = cover_pos->z + aggressor_bounding_box->zmin;

  004cf	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  004d2	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _aggressor_bounding_box$[ebp]
  004d8	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  004dd	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  004e2	f3 0f 11 45 e0	 movss	 DWORD PTR _aggressor_min$[ebp+8], xmm0

; 550  : 
; 551  : 	aggressor_max.x = cover_pos->x + aggressor_bounding_box->xmax;

  004e7	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  004ea	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _aggressor_bounding_box$[ebp]
  004f0	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  004f4	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  004f9	f3 0f 11 45 cc	 movss	 DWORD PTR _aggressor_max$[ebp], xmm0

; 552  : 	aggressor_max.y = cover_pos->y + aggressor_bounding_box->ymax;

  004fe	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  00501	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _aggressor_bounding_box$[ebp]
  00507	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0050c	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [ecx+12]
  00511	f3 0f 11 45 d0	 movss	 DWORD PTR _aggressor_max$[ebp+4], xmm0

; 553  : 	aggressor_max.z = cover_pos->z + aggressor_bounding_box->zmax;

  00516	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  00519	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _aggressor_bounding_box$[ebp]
  0051f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00524	f3 0f 58 41 14	 addss	 xmm0, DWORD PTR [ecx+20]
  00529	f3 0f 11 45 d4	 movss	 DWORD PTR _aggressor_max$[ebp+8], xmm0

; 554  : 
; 555  : 	if (cover_structure)

  0052e	83 7d 18 00	 cmp	 DWORD PTR _cover_structure$[ebp], 0
  00532	0f 84 29 04 00
	00		 je	 $LN22@assess_cov

; 556  : 	{
; 557  : 		aggressor_height = aggressor_bounding_box->ymax;

  00538	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _aggressor_bounding_box$[ebp]
  0053e	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00543	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _aggressor_height$[ebp], xmm0

; 558  : 
; 559  : 		object_3d_index = get_local_entity_int_value (cover_structure, INT_TYPE_OBJECT_3D_SHAPE);

  0054b	83 7d 18 00	 cmp	 DWORD PTR _cover_structure$[ebp], 0
  0054f	74 0d		 je	 SHORT $LN63@assess_cov
  00551	8b 45 18	 mov	 eax, DWORD PTR _cover_structure$[ebp]
  00554	8b 08		 mov	 ecx, DWORD PTR [eax]
  00556	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv303[ebp], ecx
  0055c	eb 27		 jmp	 SHORT $LN64@assess_cov
$LN63@assess_cov:
  0055e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00564	81 c2 c2 00 00
	00		 add	 edx, 194		; 000000c2H
  0056a	52		 push	 edx
  0056b	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00570	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00575	50		 push	 eax
  00576	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0057b	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv303[ebp], 0
$LN64@assess_cov:
  00585	b9 01 00 00 00	 mov	 ecx, 1
  0058a	85 c9		 test	 ecx, ecx
  0058c	74 0c		 je	 SHORT $LN65@assess_cov
  0058e	c7 85 b8 fe ff
	ff 92 00 00 00	 mov	 DWORD PTR tv311[ebp], 146 ; 00000092H
  00598	eb 27		 jmp	 SHORT $LN66@assess_cov
$LN65@assess_cov:
  0059a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  005a0	81 c2 c2 00 00
	00		 add	 edx, 194		; 000000c2H
  005a6	52		 push	 edx
  005a7	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  005ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  005b1	50		 push	 eax
  005b2	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  005b7	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv311[ebp], 0
$LN66@assess_cov:
  005c1	68 92 00 00 00	 push	 146			; 00000092H
  005c6	8b 4d 18	 mov	 ecx, DWORD PTR _cover_structure$[ebp]
  005c9	51		 push	 ecx
  005ca	69 95 bc fe ff
	ff 5c 04 00 00	 imul	 edx, DWORD PTR tv303[ebp], 1116
  005d4	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv311[ebp]
  005da	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[edx+eax*4]
  005e1	ff d1		 call	 ecx
  005e3	89 85 48 ff ff
	ff		 mov	 DWORD PTR _object_3d_index$[ebp], eax

; 560  : 
; 561  : 		ASSERT (object_3d_index != OBJECT_3D_INVALID_OBJECT_INDEX);

  005e9	83 bd 48 ff ff
	ff 00		 cmp	 DWORD PTR _object_3d_index$[ebp], 0
  005f0	75 1a		 jne	 SHORT $LN20@assess_cov
  005f2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  005f7	05 c4 00 00 00	 add	 eax, 196		; 000000c4H
  005fc	50		 push	 eax
  005fd	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00602	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@BJJCPMFI@object_3d_index?5?$CB?$DN?5OBJECT_3D_IN@
  00607	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN20@assess_cov:

; 562  : 
; 563  : 		object_bounding_box = get_object_3d_bounding_box_without_lines (object_3d_index);

  0060c	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _object_3d_index$[ebp]
  00612	50		 push	 eax
  00613	e8 00 00 00 00	 call	 ?get_object_3d_bounding_box_without_lines@@YGPAUOBJECT_3D_BOUNDS@@H@Z ; get_object_3d_bounding_box_without_lines
  00618	89 85 50 ff ff
	ff		 mov	 DWORD PTR _object_bounding_box$[ebp], eax

; 564  : 
; 565  : 		object_height = object_bounding_box->ymax;

  0061e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _object_bounding_box$[ebp]
  00624	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00629	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _object_height$[ebp], xmm0

; 566  : 
; 567  : 		//
; 568  : 		// check height
; 569  : 		//
; 570  : 
; 571  : 		if (object_height < (GUIDE_COVER_ALTITUDE + (0.666 * aggressor_height)))

  00631	f3 0f 5a 85 68
	ff ff ff	 cvtss2sd xmm0, DWORD PTR _object_height$[ebp]
  00639	f3 0f 5a 8d 70
	ff ff ff	 cvtss2sd xmm1, DWORD PTR _aggressor_height$[ebp]
  00641	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe54fdf3b645a1d
  00649	f2 0f 58 0d 00
	00 00 00	 addsd	 xmm1, QWORD PTR __real@4014000000000000
  00651	66 0f 2f c8	 comisd	 xmm1, xmm0
  00655	76 0b		 jbe	 SHORT $LN21@assess_cov

; 572  : 		{
; 573  : 			#if DEBUG_MODULE
; 574  : 
; 575  : 			if (aggressor == get_external_view_entity ())
; 576  : 			{
; 577  : 				debug_filtered_log ("	- REJECTED (structure too short - %f / %f)", object_height, (GUIDE_COVER_ALTITUDE + (0.666 * aggressor_height)));
; 578  : 			}
; 579  : 
; 580  : 			#endif
; 581  : 
; 582  : 			return result;

  00657	8a 85 58 ff ff
	ff		 mov	 al, BYTE PTR _result$[ebp]
  0065d	e9 68 10 00 00	 jmp	 $LN1@assess_cov
$LN21@assess_cov:

; 583  : 		}
; 584  : 
; 585  : 		//
; 586  : 		// check width
; 587  : 		//
; 588  : 
; 589  : 		aggressor_width = aggressor_bounding_box->xmax - aggressor_bounding_box->xmin;

  00662	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _aggressor_bounding_box$[ebp]
  00668	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _aggressor_bounding_box$[ebp]
  0066e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00673	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00677	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _aggressor_width$[ebp], xmm0

; 590  : 
; 591  : 		structure_pos = get_local_entity_vec3d_ptr (cover_structure, VEC3D_TYPE_POSITION);

  0067f	83 7d 18 00	 cmp	 DWORD PTR _cover_structure$[ebp], 0
  00683	74 0d		 je	 SHORT $LN67@assess_cov
  00685	8b 45 18	 mov	 eax, DWORD PTR _cover_structure$[ebp]
  00688	8b 08		 mov	 ecx, DWORD PTR [eax]
  0068a	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv339[ebp], ecx
  00690	eb 27		 jmp	 SHORT $LN68@assess_cov
$LN67@assess_cov:
  00692	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00698	81 c2 e2 00 00
	00		 add	 edx, 226		; 000000e2H
  0069e	52		 push	 edx
  0069f	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  006a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  006a9	50		 push	 eax
  006aa	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  006af	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv339[ebp], 0
$LN68@assess_cov:
  006b9	b9 01 00 00 00	 mov	 ecx, 1
  006be	85 c9		 test	 ecx, ecx
  006c0	74 0c		 je	 SHORT $LN69@assess_cov
  006c2	c7 85 b8 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR tv347[ebp], 8
  006cc	eb 27		 jmp	 SHORT $LN70@assess_cov
$LN69@assess_cov:
  006ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  006d4	81 c2 e2 00 00
	00		 add	 edx, 226		; 000000e2H
  006da	52		 push	 edx
  006db	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  006e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  006e5	50		 push	 eax
  006e6	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  006eb	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv347[ebp], 0
$LN70@assess_cov:
  006f5	6a 08		 push	 8
  006f7	8b 4d 18	 mov	 ecx, DWORD PTR _cover_structure$[ebp]
  006fa	51		 push	 ecx
  006fb	6b 95 bc fe ff
	ff 60		 imul	 edx, DWORD PTR tv339[ebp], 96
  00702	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv347[ebp]
  00708	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA[edx+eax*4]
  0070f	ff d1		 call	 ecx
  00711	89 45 f0	 mov	 DWORD PTR _structure_pos$[ebp], eax

; 592  : 
; 593  : 		heading = -atan2 (tc_vec.x, tc_vec.z);

  00714	51		 push	 ecx
  00715	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _tc_vec$[ebp+8]
  0071a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0071f	51		 push	 ecx
  00720	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _tc_vec$[ebp]
  00725	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0072a	e8 00 00 00 00	 call	 ?atan2@@YGMMM@Z		; atan2
  0072f	d9 9d bc fe ff
	ff		 fstp	 DWORD PTR tv1099[ebp]
  00735	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR tv1099[ebp]
  0073d	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00744	f3 0f 11 45 88	 movss	 DWORD PTR _heading$[ebp], xmm0

; 594  : 
; 595  : 		wmin = 0.0;

  00749	0f 57 c0	 xorps	 xmm0, xmm0
  0074c	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _wmin$[ebp], xmm0

; 596  : 		wmax = 0.0;

  00754	0f 57 c0	 xorps	 xmm0, xmm0
  00757	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _wmax$[ebp], xmm0

; 597  : 
; 598  : 		// point 1
; 599  : 
; 600  : 		check_point.x = object_bounding_box->xmin;

  0075f	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _object_bounding_box$[ebp]
  00765	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00769	f3 0f 11 45 a0	 movss	 DWORD PTR _check_point$[ebp], xmm0

; 601  : 		check_point.y = object_bounding_box->zmin;

  0076e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _object_bounding_box$[ebp]
  00774	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00779	f3 0f 11 45 a4	 movss	 DWORD PTR _check_point$[ebp+4], xmm0

; 602  : 
; 603  : 		rotate_2d_vector (&check_point, heading);

  0077e	51		 push	 ecx
  0077f	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _heading$[ebp]
  00784	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00789	8d 45 a0	 lea	 eax, DWORD PTR _check_point$[ebp]
  0078c	50		 push	 eax
  0078d	e8 00 00 00 00	 call	 ?rotate_2d_vector@@YGXPAUVEC2D@@M@Z ; rotate_2d_vector

; 604  : 
; 605  : 		wmin = min (wmin, check_point.x);

  00792	8d 45 a0	 lea	 eax, DWORD PTR _check_point$[ebp]
  00795	50		 push	 eax
  00796	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _wmin$[ebp]
  0079c	51		 push	 ecx
  0079d	e8 00 00 00 00	 call	 ??$min@M@std@@YGABMABM0@Z ; std::min<float>
  007a2	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  007a6	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _wmin$[ebp], xmm0

; 606  : 		wmax = max (wmax, check_point.x);

  007ae	8d 45 a0	 lea	 eax, DWORD PTR _check_point$[ebp]
  007b1	50		 push	 eax
  007b2	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _wmax$[ebp]
  007b8	51		 push	 ecx
  007b9	e8 00 00 00 00	 call	 ??$max@M@std@@YGABMABM0@Z ; std::max<float>
  007be	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  007c2	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _wmax$[ebp], xmm0

; 607  : 
; 608  : 		// point 2
; 609  : 
; 610  : 		check_point.x = object_bounding_box->xmax;

  007ca	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _object_bounding_box$[ebp]
  007d0	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  007d5	f3 0f 11 45 a0	 movss	 DWORD PTR _check_point$[ebp], xmm0

; 611  : 		check_point.y = object_bounding_box->zmin;

  007da	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _object_bounding_box$[ebp]
  007e0	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  007e5	f3 0f 11 45 a4	 movss	 DWORD PTR _check_point$[ebp+4], xmm0

; 612  : 
; 613  : 		rotate_2d_vector (&check_point, heading);

  007ea	51		 push	 ecx
  007eb	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _heading$[ebp]
  007f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007f5	8d 45 a0	 lea	 eax, DWORD PTR _check_point$[ebp]
  007f8	50		 push	 eax
  007f9	e8 00 00 00 00	 call	 ?rotate_2d_vector@@YGXPAUVEC2D@@M@Z ; rotate_2d_vector

; 614  : 
; 615  : 		wmin = min (wmin, check_point.x);

  007fe	8d 45 a0	 lea	 eax, DWORD PTR _check_point$[ebp]
  00801	50		 push	 eax
  00802	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _wmin$[ebp]
  00808	51		 push	 ecx
  00809	e8 00 00 00 00	 call	 ??$min@M@std@@YGABMABM0@Z ; std::min<float>
  0080e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00812	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _wmin$[ebp], xmm0

; 616  : 		wmax = max (wmax, check_point.x);

  0081a	8d 45 a0	 lea	 eax, DWORD PTR _check_point$[ebp]
  0081d	50		 push	 eax
  0081e	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _wmax$[ebp]
  00824	51		 push	 ecx
  00825	e8 00 00 00 00	 call	 ??$max@M@std@@YGABMABM0@Z ; std::max<float>
  0082a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0082e	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _wmax$[ebp], xmm0

; 617  : 
; 618  : 		// point 3
; 619  : 
; 620  : 		check_point.x = object_bounding_box->xmin;

  00836	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _object_bounding_box$[ebp]
  0083c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00840	f3 0f 11 45 a0	 movss	 DWORD PTR _check_point$[ebp], xmm0

; 621  : 		check_point.y = object_bounding_box->zmax;

  00845	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _object_bounding_box$[ebp]
  0084b	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00850	f3 0f 11 45 a4	 movss	 DWORD PTR _check_point$[ebp+4], xmm0

; 622  : 
; 623  : 		rotate_2d_vector (&check_point, heading);

  00855	51		 push	 ecx
  00856	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _heading$[ebp]
  0085b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00860	8d 45 a0	 lea	 eax, DWORD PTR _check_point$[ebp]
  00863	50		 push	 eax
  00864	e8 00 00 00 00	 call	 ?rotate_2d_vector@@YGXPAUVEC2D@@M@Z ; rotate_2d_vector

; 624  : 
; 625  : 		wmin = min (wmin, check_point.x);

  00869	8d 45 a0	 lea	 eax, DWORD PTR _check_point$[ebp]
  0086c	50		 push	 eax
  0086d	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _wmin$[ebp]
  00873	51		 push	 ecx
  00874	e8 00 00 00 00	 call	 ??$min@M@std@@YGABMABM0@Z ; std::min<float>
  00879	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0087d	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _wmin$[ebp], xmm0

; 626  : 		wmax = max (wmax, check_point.x);

  00885	8d 45 a0	 lea	 eax, DWORD PTR _check_point$[ebp]
  00888	50		 push	 eax
  00889	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _wmax$[ebp]
  0088f	51		 push	 ecx
  00890	e8 00 00 00 00	 call	 ??$max@M@std@@YGABMABM0@Z ; std::max<float>
  00895	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00899	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _wmax$[ebp], xmm0

; 627  : 
; 628  : 		// point 4
; 629  : 
; 630  : 		check_point.x = object_bounding_box->xmax;

  008a1	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _object_bounding_box$[ebp]
  008a7	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  008ac	f3 0f 11 45 a0	 movss	 DWORD PTR _check_point$[ebp], xmm0

; 631  : 		check_point.y = object_bounding_box->zmax;

  008b1	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _object_bounding_box$[ebp]
  008b7	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  008bc	f3 0f 11 45 a4	 movss	 DWORD PTR _check_point$[ebp+4], xmm0

; 632  : 
; 633  : 		rotate_2d_vector (&check_point, heading);

  008c1	51		 push	 ecx
  008c2	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _heading$[ebp]
  008c7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008cc	8d 45 a0	 lea	 eax, DWORD PTR _check_point$[ebp]
  008cf	50		 push	 eax
  008d0	e8 00 00 00 00	 call	 ?rotate_2d_vector@@YGXPAUVEC2D@@M@Z ; rotate_2d_vector

; 634  : 
; 635  : 		wmin = min (wmin, check_point.x);

  008d5	8d 45 a0	 lea	 eax, DWORD PTR _check_point$[ebp]
  008d8	50		 push	 eax
  008d9	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _wmin$[ebp]
  008df	51		 push	 ecx
  008e0	e8 00 00 00 00	 call	 ??$min@M@std@@YGABMABM0@Z ; std::min<float>
  008e5	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  008e9	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _wmin$[ebp], xmm0

; 636  : 		wmax = max (wmax, check_point.x);

  008f1	8d 45 a0	 lea	 eax, DWORD PTR _check_point$[ebp]
  008f4	50		 push	 eax
  008f5	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _wmax$[ebp]
  008fb	51		 push	 ecx
  008fc	e8 00 00 00 00	 call	 ??$max@M@std@@YGABMABM0@Z ; std::max<float>
  00901	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00905	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _wmax$[ebp], xmm0

; 637  : 
; 638  : 		aggressor_width *= (0.5 * 0.75);

  0090d	f3 0f 5a 85 6c
	ff ff ff	 cvtss2sd xmm0, DWORD PTR _aggressor_width$[ebp]
  00915	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fd8000000000000
  0091d	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00921	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _aggressor_width$[ebp], xmm0

; 639  : 
; 640  : 		if ((wmax < aggressor_width) || ((-wmin) < aggressor_width))

  00929	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _aggressor_width$[ebp]
  00931	0f 2f 85 74 ff
	ff ff		 comiss	 xmm0, DWORD PTR _wmax$[ebp]
  00938	77 1c		 ja	 SHORT $LN23@assess_cov
  0093a	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _wmin$[ebp]
  00942	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00949	f3 0f 10 8d 6c
	ff ff ff	 movss	 xmm1, DWORD PTR _aggressor_width$[ebp]
  00951	0f 2f c8	 comiss	 xmm1, xmm0
  00954	76 0b		 jbe	 SHORT $LN22@assess_cov
$LN23@assess_cov:

; 641  : 		{
; 642  : 			#if DEBUG_MODULE
; 643  : 
; 644  : 			if (aggressor == get_external_view_entity ())
; 645  : 			{
; 646  : 				debug_filtered_log ("	- REJECTED (structure too narrow - %f / %f)", fabs (check_point.x), aggressor_width);
; 647  : 			}
; 648  : 
; 649  : 			#endif
; 650  : 
; 651  : 			return result;

  00956	8a 85 58 ff ff
	ff		 mov	 al, BYTE PTR _result$[ebp]
  0095c	e9 69 0d 00 00	 jmp	 $LN1@assess_cov
$LN22@assess_cov:

; 652  : 		}
; 653  : 	}
; 654  : 
; 655  : 	//
; 656  : 	// check if other group members are hiding here (TRIVIAL REJECTION) 
; 657  : 	//
; 658  : 
; 659  : 	{
; 660  : 		entity
; 661  : 			*group,
; 662  : 			*member,
; 663  : 			*guide;
; 664  : 
; 665  : 		entity_sub_types
; 666  : 			guide_type;
; 667  : 
; 668  : 		vec3d
; 669  : 			member_pos;
; 670  : 
; 671  : 		float
; 672  : 			distance;
; 673  : 
; 674  : 		group = get_local_entity_parent (en, LIST_TYPE_GUIDE_STACK);

  00961	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  00965	74 0d		 je	 SHORT $LN71@assess_cov
  00967	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  0096a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0096c	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv409[ebp], ecx
  00972	eb 27		 jmp	 SHORT $LN72@assess_cov
$LN71@assess_cov:
  00974	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  0097a	81 c2 35 01 00
	00		 add	 edx, 309		; 00000135H
  00980	52		 push	 edx
  00981	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00986	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0098b	50		 push	 eax
  0098c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00991	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv409[ebp], 0
$LN72@assess_cov:
  0099b	b9 01 00 00 00	 mov	 ecx, 1
  009a0	85 c9		 test	 ecx, ecx
  009a2	74 0c		 je	 SHORT $LN73@assess_cov
  009a4	c7 85 b8 fe ff
	ff 11 00 00 00	 mov	 DWORD PTR tv417[ebp], 17 ; 00000011H
  009ae	eb 27		 jmp	 SHORT $LN74@assess_cov
$LN73@assess_cov:
  009b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  009b6	81 c2 35 01 00
	00		 add	 edx, 309		; 00000135H
  009bc	52		 push	 edx
  009bd	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  009c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  009c7	50		 push	 eax
  009c8	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  009cd	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv417[ebp], 0
$LN74@assess_cov:
  009d7	6a 11		 push	 17			; 00000011H
  009d9	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  009dc	51		 push	 ecx
  009dd	69 95 bc fe ff
	ff b4 00 00 00	 imul	 edx, DWORD PTR tv409[ebp], 180
  009e7	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv417[ebp]
  009ed	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  009f4	ff d1		 call	 ecx
  009f6	89 85 40 ff ff
	ff		 mov	 DWORD PTR _group$11[ebp], eax

; 675  : 
; 676  : 		ASSERT (group);

  009fc	83 bd 40 ff ff
	ff 00		 cmp	 DWORD PTR _group$11[ebp], 0
  00a03	75 1a		 jne	 SHORT $LN24@assess_cov
  00a05	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00a0a	05 37 01 00 00	 add	 eax, 311		; 00000137H
  00a0f	50		 push	 eax
  00a10	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00a15	68 00 00 00 00	 push	 OFFSET ??_C@_05MGJOOGAJ@group@
  00a1a	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN24@assess_cov:

; 677  : 
; 678  : 		member = get_local_entity_first_child (group, LIST_TYPE_MEMBER);

  00a1f	83 bd 40 ff ff
	ff 00		 cmp	 DWORD PTR _group$11[ebp], 0
  00a26	74 10		 je	 SHORT $LN75@assess_cov
  00a28	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _group$11[ebp]
  00a2e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a30	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv434[ebp], ecx
  00a36	eb 27		 jmp	 SHORT $LN76@assess_cov
$LN75@assess_cov:
  00a38	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00a3e	81 c2 39 01 00
	00		 add	 edx, 313		; 00000139H
  00a44	52		 push	 edx
  00a45	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00a4a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00a4f	50		 push	 eax
  00a50	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00a55	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv434[ebp], 0
$LN76@assess_cov:
  00a5f	b9 01 00 00 00	 mov	 ecx, 1
  00a64	85 c9		 test	 ecx, ecx
  00a66	74 0c		 je	 SHORT $LN77@assess_cov
  00a68	c7 85 b8 fe ff
	ff 19 00 00 00	 mov	 DWORD PTR tv442[ebp], 25 ; 00000019H
  00a72	eb 27		 jmp	 SHORT $LN78@assess_cov
$LN77@assess_cov:
  00a74	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00a7a	81 c2 39 01 00
	00		 add	 edx, 313		; 00000139H
  00a80	52		 push	 edx
  00a81	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00a86	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  00a8b	50		 push	 eax
  00a8c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00a91	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv442[ebp], 0
$LN78@assess_cov:
  00a9b	6a 19		 push	 25			; 00000019H
  00a9d	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _group$11[ebp]
  00aa3	51		 push	 ecx
  00aa4	69 95 bc fe ff
	ff b4 00 00 00	 imul	 edx, DWORD PTR tv434[ebp], 180
  00aae	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv442[ebp]
  00ab4	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_first_child@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  00abb	ff d1		 call	 ecx
  00abd	89 85 3c ff ff
	ff		 mov	 DWORD PTR _member$10[ebp], eax
$LN2@assess_cov:

; 679  : 
; 680  : 		while (member)

  00ac3	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR _member$10[ebp], 0
  00aca	0f 84 1e 04 00
	00		 je	 $LN3@assess_cov

; 681  : 		{
; 682  : 			if (member != aggressor)

  00ad0	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _member$10[ebp]
  00ad6	3b 45 0c	 cmp	 eax, DWORD PTR _aggressor$[ebp]
  00ad9	0f 84 66 03 00
	00		 je	 $LN30@assess_cov

; 683  : 			{
; 684  : 				guide = get_local_entity_parent (member, LIST_TYPE_FOLLOWER);

  00adf	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR _member$10[ebp], 0
  00ae6	74 10		 je	 SHORT $LN79@assess_cov
  00ae8	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _member$10[ebp]
  00aee	8b 08		 mov	 ecx, DWORD PTR [eax]
  00af0	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv488[ebp], ecx
  00af6	eb 27		 jmp	 SHORT $LN80@assess_cov
$LN79@assess_cov:
  00af8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00afe	81 c2 3f 01 00
	00		 add	 edx, 319		; 0000013fH
  00b04	52		 push	 edx
  00b05	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00b0a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00b0f	50		 push	 eax
  00b10	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00b15	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv488[ebp], 0
$LN80@assess_cov:
  00b1f	b9 01 00 00 00	 mov	 ecx, 1
  00b24	85 c9		 test	 ecx, ecx
  00b26	74 0c		 je	 SHORT $LN81@assess_cov
  00b28	c7 85 b8 fe ff
	ff 0d 00 00 00	 mov	 DWORD PTR tv496[ebp], 13 ; 0000000dH
  00b32	eb 27		 jmp	 SHORT $LN82@assess_cov
$LN81@assess_cov:
  00b34	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00b3a	81 c2 3f 01 00
	00		 add	 edx, 319		; 0000013fH
  00b40	52		 push	 edx
  00b41	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00b46	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  00b4b	50		 push	 eax
  00b4c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00b51	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv496[ebp], 0
$LN82@assess_cov:
  00b5b	6a 0d		 push	 13			; 0000000dH
  00b5d	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _member$10[ebp]
  00b63	51		 push	 ecx
  00b64	69 95 bc fe ff
	ff b4 00 00 00	 imul	 edx, DWORD PTR tv488[ebp], 180
  00b6e	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv496[ebp]
  00b74	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  00b7b	ff d1		 call	 ecx
  00b7d	89 85 38 ff ff
	ff		 mov	 DWORD PTR _guide$9[ebp], eax

; 685  : 
; 686  : 				if (guide)

  00b83	83 bd 38 ff ff
	ff 00		 cmp	 DWORD PTR _guide$9[ebp], 0
  00b8a	0f 84 b5 02 00
	00		 je	 $LN30@assess_cov

; 687  : 				{
; 688  : 					guide_type = get_local_entity_int_value (guide, INT_TYPE_ENTITY_SUB_TYPE);

  00b90	83 bd 38 ff ff
	ff 00		 cmp	 DWORD PTR _guide$9[ebp], 0
  00b97	74 10		 je	 SHORT $LN83@assess_cov
  00b99	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _guide$9[ebp]
  00b9f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ba1	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv509[ebp], ecx
  00ba7	eb 27		 jmp	 SHORT $LN84@assess_cov
$LN83@assess_cov:
  00ba9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00baf	81 c2 43 01 00
	00		 add	 edx, 323		; 00000143H
  00bb5	52		 push	 edx
  00bb6	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00bbb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00bc0	50		 push	 eax
  00bc1	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00bc6	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv509[ebp], 0
$LN84@assess_cov:
  00bd0	b9 01 00 00 00	 mov	 ecx, 1
  00bd5	85 c9		 test	 ecx, ecx
  00bd7	74 0c		 je	 SHORT $LN85@assess_cov
  00bd9	c7 85 b8 fe ff
	ff 34 00 00 00	 mov	 DWORD PTR tv517[ebp], 52 ; 00000034H
  00be3	eb 27		 jmp	 SHORT $LN86@assess_cov
$LN85@assess_cov:
  00be5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00beb	81 c2 43 01 00
	00		 add	 edx, 323		; 00000143H
  00bf1	52		 push	 edx
  00bf2	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00bf7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  00bfc	50		 push	 eax
  00bfd	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00c02	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv517[ebp], 0
$LN86@assess_cov:
  00c0c	6a 34		 push	 52			; 00000034H
  00c0e	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _guide$9[ebp]
  00c14	51		 push	 ecx
  00c15	69 95 bc fe ff
	ff 5c 04 00 00	 imul	 edx, DWORD PTR tv509[ebp], 1116
  00c1f	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv517[ebp]
  00c25	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[edx+eax*4]
  00c2c	ff d1		 call	 ecx
  00c2e	89 85 34 ff ff
	ff		 mov	 DWORD PTR _guide_type$8[ebp], eax

; 689  : 
; 690  : 					if (
; 691  : 							(guide_type == ENTITY_SUB_TYPE_GUIDE_ATTACK_AG_FLY_TO_COVER) ||
; 692  : 							(guide_type == ENTITY_SUB_TYPE_GUIDE_ATTACK_AG_TAKE_COVER) ||

  00c34	83 bd 34 ff ff
	ff 0b		 cmp	 DWORD PTR _guide_type$8[ebp], 11 ; 0000000bH
  00c3b	74 16		 je	 SHORT $LN28@assess_cov
  00c3d	83 bd 34 ff ff
	ff 0c		 cmp	 DWORD PTR _guide_type$8[ebp], 12 ; 0000000cH
  00c44	74 0d		 je	 SHORT $LN28@assess_cov
  00c46	83 bd 34 ff ff
	ff 0f		 cmp	 DWORD PTR _guide_type$8[ebp], 15 ; 0000000fH
  00c4d	0f 85 f2 01 00
	00		 jne	 $LN30@assess_cov
$LN28@assess_cov:

; 693  : 							(guide_type == ENTITY_SUB_TYPE_GUIDE_ATTACK_AG_FIRE)
; 694  : 						)
; 695  : 					{
; 696  : 						//
; 697  : 						// find distance between members hiding position, and the test hiding position
; 698  : 						//
; 699  : 
; 700  : 						get_local_entity_vec3d (guide, VEC3D_TYPE_GUIDE_POSITION, &member_pos);

  00c53	83 bd 38 ff ff
	ff 00		 cmp	 DWORD PTR _guide$9[ebp], 0
  00c5a	74 10		 je	 SHORT $LN87@assess_cov
  00c5c	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _guide$9[ebp]
  00c62	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c64	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv532[ebp], ecx
  00c6a	eb 27		 jmp	 SHORT $LN88@assess_cov
$LN87@assess_cov:
  00c6c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00c72	81 c2 4f 01 00
	00		 add	 edx, 335		; 0000014fH
  00c78	52		 push	 edx
  00c79	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00c7e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00c83	50		 push	 eax
  00c84	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00c89	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv532[ebp], 0
$LN88@assess_cov:
  00c93	b9 01 00 00 00	 mov	 ecx, 1
  00c98	85 c9		 test	 ecx, ecx
  00c9a	74 0c		 je	 SHORT $LN89@assess_cov
  00c9c	c7 85 b8 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR tv540[ebp], 4
  00ca6	eb 27		 jmp	 SHORT $LN90@assess_cov
$LN89@assess_cov:
  00ca8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00cae	81 c2 4f 01 00
	00		 add	 edx, 335		; 0000014fH
  00cb4	52		 push	 edx
  00cb5	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00cba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  00cbf	50		 push	 eax
  00cc0	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00cc5	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv540[ebp], 0
$LN90@assess_cov:
  00ccf	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _member_pos$7[ebp]
  00cd5	51		 push	 ecx
  00cd6	6a 04		 push	 4
  00cd8	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR _guide$9[ebp]
  00cde	52		 push	 edx
  00cdf	6b 85 bc fe ff
	ff 60		 imul	 eax, DWORD PTR tv532[ebp], 96
  00ce6	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR tv540[ebp]
  00cec	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR ?fn_get_local_entity_vec3d@@3PAY0BI@P6GXPAUENTITY@@W4VEC3D_TYPES@@PAUVEC3D@@@ZA[eax+ecx*4]
  00cf3	ff d2		 call	 edx

; 701  : 
; 702  : 						distance = get_2d_range (&member_pos, cover_pos);

  00cf5	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  00cf8	50		 push	 eax
  00cf9	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _member_pos$7[ebp]
  00cff	51		 push	 ecx
  00d00	e8 00 00 00 00	 call	 ?get_2d_range@@YGMPBUVEC3D@@0@Z ; get_2d_range
  00d05	d9 9d 24 ff ff
	ff		 fstp	 DWORD PTR _distance$6[ebp]

; 703  : 
; 704  : 						#if DEBUG_MODULE
; 705  : 
; 706  : 						if (aggressor == get_external_view_entity ())
; 707  : 						{
; 708  : 							debug_filtered_log ("%s (%d) hiding %f metres from cover pos",
; 709  : 													get_local_entity_string (member, STRING_TYPE_FULL_NAME),
; 710  : 													get_local_entity_index (member),
; 711  : 													distance);
; 712  : 						}
; 713  : 
; 714  : 						#endif
; 715  : 
; 716  : 						//
; 717  : 						// subtract the aggressors radius
; 718  : 						//
; 719  : 
; 720  : 						distance -= get_object_3d_radius (aggressor_3d_index);

  00d0b	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _aggressor_3d_index$[ebp]
  00d11	50		 push	 eax
  00d12	e8 00 00 00 00	 call	 ?get_object_3d_radius@@YGMH@Z ; get_object_3d_radius
  00d17	d9 9d bc fe ff
	ff		 fstp	 DWORD PTR tv1231[ebp]
  00d1d	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _distance$6[ebp]
  00d25	f3 0f 5c 85 bc
	fe ff ff	 subss	 xmm0, DWORD PTR tv1231[ebp]
  00d2d	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _distance$6[ebp], xmm0

; 721  : 
; 722  : 						//
; 723  : 						// subtract this members radius
; 724  : 						//
; 725  : 
; 726  : 						object_3d_index = get_local_entity_int_value (member, INT_TYPE_OBJECT_3D_SHAPE);

  00d35	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR _member$10[ebp], 0
  00d3c	74 10		 je	 SHORT $LN91@assess_cov
  00d3e	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _member$10[ebp]
  00d44	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d46	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv558[ebp], ecx
  00d4c	eb 27		 jmp	 SHORT $LN92@assess_cov
$LN91@assess_cov:
  00d4e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00d54	81 c2 69 01 00
	00		 add	 edx, 361		; 00000169H
  00d5a	52		 push	 edx
  00d5b	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00d60	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00d65	50		 push	 eax
  00d66	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00d6b	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv558[ebp], 0
$LN92@assess_cov:
  00d75	b9 01 00 00 00	 mov	 ecx, 1
  00d7a	85 c9		 test	 ecx, ecx
  00d7c	74 0c		 je	 SHORT $LN93@assess_cov
  00d7e	c7 85 b8 fe ff
	ff 92 00 00 00	 mov	 DWORD PTR tv566[ebp], 146 ; 00000092H
  00d88	eb 27		 jmp	 SHORT $LN94@assess_cov
$LN93@assess_cov:
  00d8a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00d90	81 c2 69 01 00
	00		 add	 edx, 361		; 00000169H
  00d96	52		 push	 edx
  00d97	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00d9c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  00da1	50		 push	 eax
  00da2	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00da7	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv566[ebp], 0
$LN94@assess_cov:
  00db1	68 92 00 00 00	 push	 146			; 00000092H
  00db6	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _member$10[ebp]
  00dbc	51		 push	 ecx
  00dbd	69 95 bc fe ff
	ff 5c 04 00 00	 imul	 edx, DWORD PTR tv558[ebp], 1116
  00dc7	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv566[ebp]
  00dcd	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[edx+eax*4]
  00dd4	ff d1		 call	 ecx
  00dd6	89 85 48 ff ff
	ff		 mov	 DWORD PTR _object_3d_index$[ebp], eax

; 727  : 
; 728  : 						ASSERT (object_3d_index != OBJECT_3D_INVALID_OBJECT_INDEX);

  00ddc	83 bd 48 ff ff
	ff 00		 cmp	 DWORD PTR _object_3d_index$[ebp], 0
  00de3	75 1a		 jne	 SHORT $LN29@assess_cov
  00de5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00dea	05 6b 01 00 00	 add	 eax, 363		; 0000016bH
  00def	50		 push	 eax
  00df0	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00df5	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@BJJCPMFI@object_3d_index?5?$CB?$DN?5OBJECT_3D_IN@
  00dfa	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN29@assess_cov:

; 729  : 
; 730  : 						distance -= get_object_3d_radius (object_3d_index);

  00dff	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _object_3d_index$[ebp]
  00e05	50		 push	 eax
  00e06	e8 00 00 00 00	 call	 ?get_object_3d_radius@@YGMH@Z ; get_object_3d_radius
  00e0b	d9 9d bc fe ff
	ff		 fstp	 DWORD PTR tv1249[ebp]
  00e11	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _distance$6[ebp]
  00e19	f3 0f 5c 85 bc
	fe ff ff	 subss	 xmm0, DWORD PTR tv1249[ebp]
  00e21	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _distance$6[ebp], xmm0

; 731  : 
; 732  : 						//
; 733  : 						// if distance < 0 then the two members would clash
; 734  : 						//
; 735  : 						
; 736  : 						#if DEBUG_MODULE
; 737  : 
; 738  : 						if (aggressor == get_external_view_entity ())
; 739  : 						{
; 740  : 							debug_filtered_log ("-  adjusted distance %f", distance);
; 741  : 						}
; 742  : 
; 743  : 						#endif
; 744  : 
; 745  : 						if (distance < 0.0)

  00e29	f3 0f 5a 85 24
	ff ff ff	 cvtss2sd xmm0, DWORD PTR _distance$6[ebp]
  00e31	0f 57 c9	 xorps	 xmm1, xmm1
  00e34	66 0f 2f c8	 comisd	 xmm1, xmm0
  00e38	76 0b		 jbe	 SHORT $LN30@assess_cov

; 746  : 						{
; 747  : 							return result;

  00e3a	8a 85 58 ff ff
	ff		 mov	 al, BYTE PTR _result$[ebp]
  00e40	e9 85 08 00 00	 jmp	 $LN1@assess_cov
$LN30@assess_cov:

; 748  : 						}
; 749  : 					}
; 750  : 				}
; 751  : 			}
; 752  : 
; 753  : 			member = get_local_entity_child_succ (member, LIST_TYPE_MEMBER);

  00e45	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR _member$10[ebp], 0
  00e4c	74 10		 je	 SHORT $LN95@assess_cov
  00e4e	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _member$10[ebp]
  00e54	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e56	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv588[ebp], ecx
  00e5c	eb 27		 jmp	 SHORT $LN96@assess_cov
$LN95@assess_cov:
  00e5e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00e64	81 c2 84 01 00
	00		 add	 edx, 388		; 00000184H
  00e6a	52		 push	 edx
  00e6b	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00e70	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00e75	50		 push	 eax
  00e76	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00e7b	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv588[ebp], 0
$LN96@assess_cov:
  00e85	b9 01 00 00 00	 mov	 ecx, 1
  00e8a	85 c9		 test	 ecx, ecx
  00e8c	74 0c		 je	 SHORT $LN97@assess_cov
  00e8e	c7 85 b8 fe ff
	ff 19 00 00 00	 mov	 DWORD PTR tv596[ebp], 25 ; 00000019H
  00e98	eb 27		 jmp	 SHORT $LN98@assess_cov
$LN97@assess_cov:
  00e9a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  00ea0	81 c2 84 01 00
	00		 add	 edx, 388		; 00000184H
  00ea6	52		 push	 edx
  00ea7	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00eac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  00eb1	50		 push	 eax
  00eb2	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00eb7	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv596[ebp], 0
$LN98@assess_cov:
  00ec1	6a 19		 push	 25			; 00000019H
  00ec3	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _member$10[ebp]
  00ec9	51		 push	 ecx
  00eca	69 95 bc fe ff
	ff b4 00 00 00	 imul	 edx, DWORD PTR tv588[ebp], 180
  00ed4	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv596[ebp]
  00eda	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_child_succ@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  00ee1	ff d1		 call	 ecx
  00ee3	89 85 3c ff ff
	ff		 mov	 DWORD PTR _member$10[ebp], eax

; 754  : 		}

  00ee9	e9 d5 fb ff ff	 jmp	 $LN2@assess_cov
$LN3@assess_cov:

; 755  : 	}
; 756  : 
; 757  : 	//
; 758  : 	// check LOS at cover position (TRIVIAL REJECTION)
; 759  : 	//
; 760  : 
; 761  : 	if (check_position_line_of_sight (aggressor, target, cover_pos, target_pos, MOBILE_LOS_CHECK_ALL))

  00eee	6a 1f		 push	 31			; 0000001fH
  00ef0	8b 45 f4	 mov	 eax, DWORD PTR _target_pos$[ebp]
  00ef3	50		 push	 eax
  00ef4	8b 4d 14	 mov	 ecx, DWORD PTR _cover_pos$[ebp]
  00ef7	51		 push	 ecx
  00ef8	8b 55 10	 mov	 edx, DWORD PTR _target$[ebp]
  00efb	52		 push	 edx
  00efc	8b 45 0c	 mov	 eax, DWORD PTR _aggressor$[ebp]
  00eff	50		 push	 eax
  00f00	e8 00 00 00 00	 call	 ?check_position_line_of_sight@@YGHPAUENTITY@@0PAUVEC3D@@1W4MOBILE_LOS_CHECK_CRITERIA@@@Z ; check_position_line_of_sight
  00f05	85 c0		 test	 eax, eax
  00f07	74 0b		 je	 SHORT $LN31@assess_cov

; 762  : 	{
; 763  : 		#if DEBUG_MODULE
; 764  : 
; 765  : 		if (aggressor == get_external_view_entity ())
; 766  : 		{
; 767  : 			debug_filtered_log ("	- REJECTED (no LOS at cover position)");
; 768  : 		}
; 769  : 
; 770  : 		#endif
; 771  : 
; 772  : 		return result;

  00f09	8a 85 58 ff ff
	ff		 mov	 al, BYTE PTR _result$[ebp]
  00f0f	e9 b6 07 00 00	 jmp	 $LN1@assess_cov
$LN31@assess_cov:

; 773  : 	}
; 774  : 
; 775  : 	//
; 776  : 	// find target->cover rating
; 777  : 	// 
; 778  : 
; 779  : 	if (tc_range < weapon_effective_range)

  00f14	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _weapon_effective_range$[ebp]
  00f1c	0f 2f 45 98	 comiss	 xmm0, DWORD PTR _tc_range$[ebp]
  00f20	76 28		 jbe	 SHORT $LN32@assess_cov

; 780  : 	{
; 781  : 		tc_rating = (tc_range - weapon_min_range) / (weapon_effective_range - weapon_min_range);

  00f22	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _tc_range$[ebp]
  00f27	f3 0f 5c 85 60
	ff ff ff	 subss	 xmm0, DWORD PTR _weapon_min_range$[ebp]
  00f2f	f3 0f 10 8d 5c
	ff ff ff	 movss	 xmm1, DWORD PTR _weapon_effective_range$[ebp]
  00f37	f3 0f 5c 8d 60
	ff ff ff	 subss	 xmm1, DWORD PTR _weapon_min_range$[ebp]
  00f3f	f3 0f 5e c1	 divss	 xmm0, xmm1
  00f43	f3 0f 11 45 90	 movss	 DWORD PTR _tc_rating$[ebp], xmm0

; 782  : 	}
; 783  : 	else

  00f48	eb 26		 jmp	 SHORT $LN33@assess_cov
$LN32@assess_cov:

; 784  : 	{
; 785  : 		tc_rating = (weapon_max_range - tc_range) / (weapon_max_range - weapon_effective_range);

  00f4a	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _weapon_max_range$[ebp]
  00f52	f3 0f 5c 45 98	 subss	 xmm0, DWORD PTR _tc_range$[ebp]
  00f57	f3 0f 10 8d 64
	ff ff ff	 movss	 xmm1, DWORD PTR _weapon_max_range$[ebp]
  00f5f	f3 0f 5c 8d 5c
	ff ff ff	 subss	 xmm1, DWORD PTR _weapon_effective_range$[ebp]
  00f67	f3 0f 5e c1	 divss	 xmm0, xmm1
  00f6b	f3 0f 11 45 90	 movss	 DWORD PTR _tc_rating$[ebp], xmm0
$LN33@assess_cov:

; 786  : 	}
; 787  : 
; 788  : 	//
; 789  : 	// find aggressor->cover rating
; 790  : 	//
; 791  : 	
; 792  : //	get_3d_unit_vector_dot_product (&ta_vec, &ac_vec)	// rate differently depending on whether the aggressor must
; 793  : 																		// fly towards, or away from, the target ?
; 794  : 
; 795  : 	if (ac_range >= 1000.0)		//temp

  00f70	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _ac_range$[ebp]
  00f75	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@408f400000000000
  00f7d	72 0a		 jb	 SHORT $LN34@assess_cov

; 796  : 	{
; 797  : 		ac_rating = 0.0;

  00f7f	0f 57 c0	 xorps	 xmm0, xmm0
  00f82	f3 0f 11 45 8c	 movss	 DWORD PTR _ac_rating$[ebp], xmm0

; 798  : 	}
; 799  : 	else

  00f87	eb 22		 jmp	 SHORT $LN35@assess_cov
$LN34@assess_cov:

; 800  : 	{
; 801  : 		ac_rating = (1000.0 - ac_range) / 1000.0;

  00f89	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _ac_range$[ebp]
  00f8e	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@408f400000000000
  00f96	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00f9a	f2 0f 5e 0d 00
	00 00 00	 divsd	 xmm1, QWORD PTR __real@408f400000000000
  00fa2	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  00fa6	f3 0f 11 45 8c	 movss	 DWORD PTR _ac_rating$[ebp], xmm0
$LN35@assess_cov:

; 802  : 	}
; 803  : 
; 804  : 	//
; 805  : 	// find altitude required for LOS rating
; 806  : 	//
; 807  : 
; 808  : 	check_pos.x = cover_pos->x;

  00fab	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  00fae	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00fb2	f3 0f 11 45 e4	 movss	 DWORD PTR _check_pos$[ebp], xmm0

; 809  : 	check_pos.z = cover_pos->z;

  00fb7	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  00fba	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00fbf	f3 0f 11 45 ec	 movss	 DWORD PTR _check_pos$[ebp+8], xmm0

; 810  : 	
; 811  : 	for (altitude = MIN_LOS_ALTITUDE; altitude < MAX_LOS_ALTITUDE; altitude += INC_LOS_ALTITUDE)

  00fc4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  00fcc	f3 0f 11 45 84	 movss	 DWORD PTR _altitude$[ebp], xmm0
  00fd1	eb 16		 jmp	 SHORT $LN6@assess_cov
$LN4@assess_cov:
  00fd3	f3 0f 5a 45 84	 cvtss2sd xmm0, DWORD PTR _altitude$[ebp]
  00fd8	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@4024000000000000
  00fe0	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00fe4	f3 0f 11 45 84	 movss	 DWORD PTR _altitude$[ebp], xmm0
$LN6@assess_cov:
  00fe9	f3 0f 5a 45 84	 cvtss2sd xmm0, DWORD PTR _altitude$[ebp]
  00fee	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4049000000000000
  00ff6	66 0f 2f c8	 comisd	 xmm1, xmm0
  00ffa	76 31		 jbe	 SHORT $LN5@assess_cov

; 812  : 	{
; 813  : 		check_pos.y = cover_pos->y + altitude;

  00ffc	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  00fff	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  01004	f3 0f 58 45 84	 addss	 xmm0, DWORD PTR _altitude$[ebp]
  01009	f3 0f 11 45 e8	 movss	 DWORD PTR _check_pos$[ebp+4], xmm0

; 814  : 
; 815  : 		if (check_position_line_of_sight (aggressor, target, &check_pos, target_pos, MOBILE_LOS_CHECK_ALL))

  0100e	6a 1f		 push	 31			; 0000001fH
  01010	8b 45 f4	 mov	 eax, DWORD PTR _target_pos$[ebp]
  01013	50		 push	 eax
  01014	8d 4d e4	 lea	 ecx, DWORD PTR _check_pos$[ebp]
  01017	51		 push	 ecx
  01018	8b 55 10	 mov	 edx, DWORD PTR _target$[ebp]
  0101b	52		 push	 edx
  0101c	8b 45 0c	 mov	 eax, DWORD PTR _aggressor$[ebp]
  0101f	50		 push	 eax
  01020	e8 00 00 00 00	 call	 ?check_position_line_of_sight@@YGHPAUENTITY@@0PAUVEC3D@@1W4MOBILE_LOS_CHECK_CRITERIA@@@Z ; check_position_line_of_sight
  01025	85 c0		 test	 eax, eax
  01027	74 02		 je	 SHORT $LN36@assess_cov

; 816  : 		{
; 817  : 			break;

  01029	eb 02		 jmp	 SHORT $LN5@assess_cov
$LN36@assess_cov:

; 818  : 		}
; 819  : 	}

  0102b	eb a6		 jmp	 SHORT $LN4@assess_cov
$LN5@assess_cov:

; 820  : 
; 821  : 	if (altitude >= MAX_LOS_ALTITUDE)

  0102d	f3 0f 5a 45 84	 cvtss2sd xmm0, DWORD PTR _altitude$[ebp]
  01032	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4049000000000000
  0103a	72 0b		 jb	 SHORT $LN37@assess_cov

; 822  : 	{
; 823  : 		#if DEBUG_MODULE
; 824  : 
; 825  : 		if (aggressor == get_external_view_entity ())
; 826  : 		{
; 827  : 			debug_filtered_log ("	- REJECTED (no LOS until max altitude)");
; 828  : 		}
; 829  : 
; 830  : 		#endif
; 831  : 
; 832  : 		return result;

  0103c	8a 85 58 ff ff
	ff		 mov	 al, BYTE PTR _result$[ebp]
  01042	e9 83 06 00 00	 jmp	 $LN1@assess_cov
$LN37@assess_cov:

; 833  : 	}
; 834  : 
; 835  : 	altitude_rating = (MAX_LOS_ALTITUDE - altitude) / (MAX_LOS_ALTITUDE - MIN_LOS_ALTITUDE);

  01047	f3 0f 5a 45 84	 cvtss2sd xmm0, DWORD PTR _altitude$[ebp]
  0104c	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4049000000000000
  01054	f2 0f 5c c8	 subsd	 xmm1, xmm0
  01058	f2 0f 5e 0d 00
	00 00 00	 divsd	 xmm1, QWORD PTR __real@4044000000000000
  01060	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  01064	f3 0f 11 45 80	 movss	 DWORD PTR _altitude_rating$[ebp], xmm0

; 836  : 
; 837  : 	//
; 838  : 	// check for collision with other objects in sector (TRIVIAL REJECTION)
; 839  : 	//
; 840  : 	{
; 841  : 		entity
; 842  : 			*sector,
; 843  : 			*object;
; 844  : 	
; 845  : 		vec3d
; 846  : 			*object_pos,
; 847  : 			object_min,
; 848  : 			object_max;
; 849  : 
; 850  : 		sector = get_local_sector_entity (cover_pos);

  01069	8b 45 14	 mov	 eax, DWORD PTR _cover_pos$[ebp]
  0106c	50		 push	 eax
  0106d	e8 00 00 00 00	 call	 ?get_local_sector_entity@@YGPAUENTITY@@PAUVEC3D@@@Z ; get_local_sector_entity
  01072	89 85 20 ff ff
	ff		 mov	 DWORD PTR _sector$5[ebp], eax

; 851  : 
; 852  : 		ASSERT (sector);

  01078	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR _sector$5[ebp], 0
  0107f	75 1a		 jne	 SHORT $LN38@assess_cov
  01081	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  01086	05 e7 01 00 00	 add	 eax, 487		; 000001e7H
  0108b	50		 push	 eax
  0108c	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  01091	68 00 00 00 00	 push	 OFFSET ??_C@_06IDGHNJOB@sector@
  01096	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN38@assess_cov:

; 853  : 
; 854  : 		//
; 855  : 		// check each object in the sector
; 856  : 		//
; 857  : 		
; 858  : 		object = get_local_entity_first_child (sector, LIST_TYPE_SECTOR);

  0109b	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR _sector$5[ebp], 0
  010a2	74 10		 je	 SHORT $LN99@assess_cov
  010a4	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _sector$5[ebp]
  010aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  010ac	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv657[ebp], ecx
  010b2	eb 27		 jmp	 SHORT $LN100@assess_cov
$LN99@assess_cov:
  010b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  010ba	81 c2 ed 01 00
	00		 add	 edx, 493		; 000001edH
  010c0	52		 push	 edx
  010c1	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  010c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  010cb	50		 push	 eax
  010cc	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  010d1	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv657[ebp], 0
$LN100@assess_cov:
  010db	b9 01 00 00 00	 mov	 ecx, 1
  010e0	85 c9		 test	 ecx, ecx
  010e2	74 0c		 je	 SHORT $LN101@assess_cov
  010e4	c7 85 b8 fe ff
	ff 21 00 00 00	 mov	 DWORD PTR tv665[ebp], 33 ; 00000021H
  010ee	eb 27		 jmp	 SHORT $LN102@assess_cov
$LN101@assess_cov:
  010f0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  010f6	81 c2 ed 01 00
	00		 add	 edx, 493		; 000001edH
  010fc	52		 push	 edx
  010fd	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  01102	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  01107	50		 push	 eax
  01108	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0110d	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv665[ebp], 0
$LN102@assess_cov:
  01117	6a 21		 push	 33			; 00000021H
  01119	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _sector$5[ebp]
  0111f	51		 push	 ecx
  01120	69 95 bc fe ff
	ff b4 00 00 00	 imul	 edx, DWORD PTR tv657[ebp], 180
  0112a	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv665[ebp]
  01130	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_first_child@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  01137	ff d1		 call	 ecx
  01139	89 85 1c ff ff
	ff		 mov	 DWORD PTR _object$4[ebp], eax
$LN7@assess_cov:

; 859  : 
; 860  : 		while (object)

  0113f	83 bd 1c ff ff
	ff 00		 cmp	 DWORD PTR _object$4[ebp], 0
  01146	0f 84 c4 03 00
	00		 je	 $LN8@assess_cov

; 861  : 		{
; 862  : 			if ((object != aggressor) && (object != target))

  0114c	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _object$4[ebp]
  01152	3b 45 0c	 cmp	 eax, DWORD PTR _aggressor$[ebp]
  01155	0f 84 0c 03 00
	00		 je	 $LN9@assess_cov
  0115b	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _object$4[ebp]
  01161	3b 45 10	 cmp	 eax, DWORD PTR _target$[ebp]
  01164	0f 84 fd 02 00
	00		 je	 $LN9@assess_cov

; 863  : 			{
; 864  : 				switch (get_local_entity_type (object))

  0116a	83 bd 1c ff ff
	ff 00		 cmp	 DWORD PTR _object$4[ebp], 0
  01171	74 10		 je	 SHORT $LN103@assess_cov
  01173	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _object$4[ebp]
  01179	8b 08		 mov	 ecx, DWORD PTR [eax]
  0117b	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv679[ebp], ecx
  01181	eb 20		 jmp	 SHORT $LN104@assess_cov
$LN103@assess_cov:
  01183	68 60 03 00 00	 push	 864			; 00000360H
  01188	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0118d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  01193	52		 push	 edx
  01194	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  01199	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv679[ebp], 0
$LN104@assess_cov:
  011a3	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR tv679[ebp]
  011a9	89 85 b8 fe ff
	ff		 mov	 DWORD PTR tv680[ebp], eax
  011af	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR tv680[ebp]
  011b5	83 e9 01	 sub	 ecx, 1
  011b8	89 8d b8 fe ff
	ff		 mov	 DWORD PTR tv680[ebp], ecx
  011be	83 bd b8 fe ff
	ff 1d		 cmp	 DWORD PTR tv680[ebp], 29 ; 0000001dH
  011c5	0f 87 9c 02 00
	00		 ja	 $LN9@assess_cov
  011cb	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv680[ebp]
  011d1	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN125@assess_cov[edx]
  011d8	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN126@assess_cov[eax*4]
$LN40@assess_cov:

; 865  : 				{
; 866  : 					case ENTITY_TYPE_ANTI_AIRCRAFT:
; 867  : 					case ENTITY_TYPE_CITY_BUILDING:
; 868  : 					case ENTITY_TYPE_FIXED_WING:
; 869  : 					case ENTITY_TYPE_HELICOPTER:
; 870  : 					case ENTITY_TYPE_PERSON:
; 871  : 					case ENTITY_TYPE_PYLON:
; 872  : 					case ENTITY_TYPE_ROUTED_VEHICLE:
; 873  : 					case ENTITY_TYPE_SCENIC:
; 874  : 					case ENTITY_TYPE_SEGMENT:
; 875  : 					case ENTITY_TYPE_SHIP_VEHICLE:
; 876  : 					case ENTITY_TYPE_SITE:
; 877  : 					case ENTITY_TYPE_SITE_UPDATABLE:
; 878  : 					{
; 879  : 						object_3d_index = get_local_entity_int_value (object, INT_TYPE_OBJECT_3D_SHAPE);

  011df	83 bd 1c ff ff
	ff 00		 cmp	 DWORD PTR _object$4[ebp], 0
  011e6	74 10		 je	 SHORT $LN105@assess_cov
  011e8	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _object$4[ebp]
  011ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  011f0	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv687[ebp], ecx
  011f6	eb 27		 jmp	 SHORT $LN106@assess_cov
$LN105@assess_cov:
  011f8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  011fe	81 c2 02 02 00
	00		 add	 edx, 514		; 00000202H
  01204	52		 push	 edx
  01205	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0120a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0120f	50		 push	 eax
  01210	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  01215	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv687[ebp], 0
$LN106@assess_cov:
  0121f	b9 01 00 00 00	 mov	 ecx, 1
  01224	85 c9		 test	 ecx, ecx
  01226	74 0c		 je	 SHORT $LN107@assess_cov
  01228	c7 85 b8 fe ff
	ff 92 00 00 00	 mov	 DWORD PTR tv695[ebp], 146 ; 00000092H
  01232	eb 27		 jmp	 SHORT $LN108@assess_cov
$LN107@assess_cov:
  01234	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  0123a	81 c2 02 02 00
	00		 add	 edx, 514		; 00000202H
  01240	52		 push	 edx
  01241	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  01246	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  0124b	50		 push	 eax
  0124c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  01251	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv695[ebp], 0
$LN108@assess_cov:
  0125b	68 92 00 00 00	 push	 146			; 00000092H
  01260	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _object$4[ebp]
  01266	51		 push	 ecx
  01267	69 95 bc fe ff
	ff 5c 04 00 00	 imul	 edx, DWORD PTR tv687[ebp], 1116
  01271	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv695[ebp]
  01277	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[edx+eax*4]
  0127e	ff d1		 call	 ecx
  01280	89 85 48 ff ff
	ff		 mov	 DWORD PTR _object_3d_index$[ebp], eax

; 880  : 				
; 881  : 						if (object_3d_index != OBJECT_3D_INVALID_OBJECT_INDEX)

  01286	83 bd 48 ff ff
	ff 00		 cmp	 DWORD PTR _object_3d_index$[ebp], 0
  0128d	0f 84 d4 01 00
	00		 je	 $LN44@assess_cov

; 882  : 						{
; 883  : 							object_bounding_box = get_object_3d_bounding_box_without_lines (object_3d_index);

  01293	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _object_3d_index$[ebp]
  01299	50		 push	 eax
  0129a	e8 00 00 00 00	 call	 ?get_object_3d_bounding_box_without_lines@@YGPAUOBJECT_3D_BOUNDS@@H@Z ; get_object_3d_bounding_box_without_lines
  0129f	89 85 50 ff ff
	ff		 mov	 DWORD PTR _object_bounding_box$[ebp], eax

; 884  : 					
; 885  : 							ASSERT (object_bounding_box);

  012a5	83 bd 50 ff ff
	ff 00		 cmp	 DWORD PTR _object_bounding_box$[ebp], 0
  012ac	75 1a		 jne	 SHORT $LN42@assess_cov
  012ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  012b3	05 08 02 00 00	 add	 eax, 520		; 00000208H
  012b8	50		 push	 eax
  012b9	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  012be	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NINKBKAC@object_bounding_box@
  012c3	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN42@assess_cov:

; 886  : 		
; 887  : 							object_pos = get_local_entity_vec3d_ptr (object, VEC3D_TYPE_POSITION);

  012c8	83 bd 1c ff ff
	ff 00		 cmp	 DWORD PTR _object$4[ebp], 0
  012cf	74 10		 je	 SHORT $LN109@assess_cov
  012d1	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _object$4[ebp]
  012d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  012d9	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv715[ebp], ecx
  012df	eb 27		 jmp	 SHORT $LN110@assess_cov
$LN109@assess_cov:
  012e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  012e7	81 c2 0a 02 00
	00		 add	 edx, 522		; 0000020aH
  012ed	52		 push	 edx
  012ee	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  012f3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  012f8	50		 push	 eax
  012f9	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  012fe	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv715[ebp], 0
$LN110@assess_cov:
  01308	b9 01 00 00 00	 mov	 ecx, 1
  0130d	85 c9		 test	 ecx, ecx
  0130f	74 0c		 je	 SHORT $LN111@assess_cov
  01311	c7 85 b8 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR tv723[ebp], 8
  0131b	eb 27		 jmp	 SHORT $LN112@assess_cov
$LN111@assess_cov:
  0131d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  01323	81 c2 0a 02 00
	00		 add	 edx, 522		; 0000020aH
  01329	52		 push	 edx
  0132a	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0132f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  01334	50		 push	 eax
  01335	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0133a	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv723[ebp], 0
$LN112@assess_cov:
  01344	6a 08		 push	 8
  01346	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _object$4[ebp]
  0134c	51		 push	 ecx
  0134d	6b 95 bc fe ff
	ff 60		 imul	 edx, DWORD PTR tv715[ebp], 96
  01354	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv723[ebp]
  0135a	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA[edx+eax*4]
  01361	ff d1		 call	 ecx
  01363	89 85 18 ff ff
	ff		 mov	 DWORD PTR _object_pos$3[ebp], eax

; 888  : 		
; 889  : 							ASSERT (object_pos);

  01369	83 bd 18 ff ff
	ff 00		 cmp	 DWORD PTR _object_pos$3[ebp], 0
  01370	75 1a		 jne	 SHORT $LN43@assess_cov
  01372	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  01377	05 0c 02 00 00	 add	 eax, 524		; 0000020cH
  0137c	50		 push	 eax
  0137d	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  01382	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GPAIBKEE@object_pos@
  01387	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN43@assess_cov:

; 890  : 					
; 891  : 							object_min.x = object_pos->x + object_bounding_box->xmin;

  0138c	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _object_pos$3[ebp]
  01392	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _object_bounding_box$[ebp]
  01398	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0139c	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  013a0	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR _object_min$2[ebp], xmm0

; 892  : 							object_min.y = object_pos->y + object_bounding_box->ymin;

  013a8	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _object_pos$3[ebp]
  013ae	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _object_bounding_box$[ebp]
  013b4	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  013b9	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
  013be	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _object_min$2[ebp+4], xmm0

; 893  : 							object_min.z = object_pos->z + object_bounding_box->zmin;

  013c6	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _object_pos$3[ebp]
  013cc	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _object_bounding_box$[ebp]
  013d2	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  013d7	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  013dc	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _object_min$2[ebp+8], xmm0

; 894  : 					
; 895  : 							object_max.x = object_pos->x + object_bounding_box->xmax;

  013e4	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _object_pos$3[ebp]
  013ea	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _object_bounding_box$[ebp]
  013f0	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  013f4	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  013f9	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _object_max$1[ebp], xmm0

; 896  : 							object_max.y = object_pos->y + object_bounding_box->ymax;

  01401	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _object_pos$3[ebp]
  01407	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _object_bounding_box$[ebp]
  0140d	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  01412	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [ecx+12]
  01417	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _object_max$1[ebp+4], xmm0

; 897  : 							object_max.z = object_pos->z + object_bounding_box->zmax;

  0141f	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _object_pos$3[ebp]
  01425	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _object_bounding_box$[ebp]
  0142b	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  01430	f3 0f 58 41 14	 addss	 xmm0, DWORD PTR [ecx+20]
  01435	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR _object_max$1[ebp+8], xmm0

; 898  : 					
; 899  : 							if (get_3d_vector_cube_cube_intersect (&aggressor_min, &aggressor_max, &object_min, &object_max))

  0143d	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _object_max$1[ebp]
  01443	50		 push	 eax
  01444	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _object_min$2[ebp]
  0144a	51		 push	 ecx
  0144b	8d 55 cc	 lea	 edx, DWORD PTR _aggressor_max$[ebp]
  0144e	52		 push	 edx
  0144f	8d 45 d8	 lea	 eax, DWORD PTR _aggressor_min$[ebp]
  01452	50		 push	 eax
  01453	e8 00 00 00 00	 call	 ?get_3d_vector_cube_cube_intersect@@YGHPBUVEC3D@@000@Z ; get_3d_vector_cube_cube_intersect
  01458	85 c0		 test	 eax, eax
  0145a	74 0b		 je	 SHORT $LN44@assess_cov

; 900  : 							{	
; 901  : 								#if DEBUG_MODULE
; 902  : 		
; 903  : 								if (aggressor == get_external_view_entity ())
; 904  : 								{
; 905  : 									debug_filtered_log ("	- REJECTED (object placed at cover position)");
; 906  : 								}
; 907  : 	
; 908  : 								#endif
; 909  : 		
; 910  : 								return result;

  0145c	8a 85 58 ff ff
	ff		 mov	 al, BYTE PTR _result$[ebp]
  01462	e9 63 02 00 00	 jmp	 $LN1@assess_cov
$LN44@assess_cov:
$LN9@assess_cov:

; 911  : 							}
; 912  : 						}
; 913  : 
; 914  : 						break;
; 915  : 					}
; 916  : 				}
; 917  : 			}
; 918  : 
; 919  : 			object = get_local_entity_child_succ (object, LIST_TYPE_SECTOR);

  01467	83 bd 1c ff ff
	ff 00		 cmp	 DWORD PTR _object$4[ebp], 0
  0146e	74 10		 je	 SHORT $LN113@assess_cov
  01470	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _object$4[ebp]
  01476	8b 08		 mov	 ecx, DWORD PTR [eax]
  01478	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv766[ebp], ecx
  0147e	eb 27		 jmp	 SHORT $LN114@assess_cov
$LN113@assess_cov:
  01480	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  01486	81 c2 2a 02 00
	00		 add	 edx, 554		; 0000022aH
  0148c	52		 push	 edx
  0148d	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  01492	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  01497	50		 push	 eax
  01498	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0149d	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv766[ebp], 0
$LN114@assess_cov:
  014a7	b9 01 00 00 00	 mov	 ecx, 1
  014ac	85 c9		 test	 ecx, ecx
  014ae	74 0c		 je	 SHORT $LN115@assess_cov
  014b0	c7 85 b8 fe ff
	ff 21 00 00 00	 mov	 DWORD PTR tv774[ebp], 33 ; 00000021H
  014ba	eb 27		 jmp	 SHORT $LN116@assess_cov
$LN115@assess_cov:
  014bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  014c2	81 c2 2a 02 00
	00		 add	 edx, 554		; 0000022aH
  014c8	52		 push	 edx
  014c9	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  014ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  014d3	50		 push	 eax
  014d4	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  014d9	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv774[ebp], 0
$LN116@assess_cov:
  014e3	6a 21		 push	 33			; 00000021H
  014e5	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _object$4[ebp]
  014eb	51		 push	 ecx
  014ec	69 95 bc fe ff
	ff b4 00 00 00	 imul	 edx, DWORD PTR tv766[ebp], 180
  014f6	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv774[ebp]
  014fc	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_child_succ@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  01503	ff d1		 call	 ecx
  01505	89 85 1c ff ff
	ff		 mov	 DWORD PTR _object$4[ebp], eax

; 920  : 		}

  0150b	e9 2f fc ff ff	 jmp	 $LN7@assess_cov
$LN8@assess_cov:

; 921  : 	}
; 922  : 
; 923  : 	//
; 924  : 	// overall rating
; 925  : 	//
; 926  : 
; 927  : 	total = (tc_rating + ac_rating + altitude_rating) / 3.0;		// temp

  01510	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _tc_rating$[ebp]
  01515	f3 0f 58 45 8c	 addss	 xmm0, DWORD PTR _ac_rating$[ebp]
  0151a	f3 0f 58 45 80	 addss	 xmm0, DWORD PTR _altitude_rating$[ebp]
  0151f	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  01523	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4008000000000000
  0152b	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0152f	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _total$[ebp], xmm0

; 928  : 
; 929  : 	total = bound (total, 0.0, 1.0);

  01537	f3 0f 5a 85 7c
	ff ff ff	 cvtss2sd xmm0, DWORD PTR _total$[ebp]
  0153f	0f 57 c9	 xorps	 xmm1, xmm1
  01542	66 0f 2f c8	 comisd	 xmm1, xmm0
  01546	76 0d		 jbe	 SHORT $LN119@assess_cov
  01548	0f 57 c0	 xorps	 xmm0, xmm0
  0154b	f2 0f 11 85 b8
	fe ff ff	 movsd	 QWORD PTR tv791[ebp], xmm0
  01553	eb 44		 jmp	 SHORT $LN120@assess_cov
$LN119@assess_cov:
  01555	f3 0f 5a 85 7c
	ff ff ff	 cvtss2sd xmm0, DWORD PTR _total$[ebp]
  0155d	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3ff0000000000000
  01565	76 12		 jbe	 SHORT $LN117@assess_cov
  01567	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0156f	f2 0f 11 85 b0
	fe ff ff	 movsd	 QWORD PTR tv790[ebp], xmm0
  01577	eb 10		 jmp	 SHORT $LN118@assess_cov
$LN117@assess_cov:
  01579	f3 0f 5a 85 7c
	ff ff ff	 cvtss2sd xmm0, DWORD PTR _total$[ebp]
  01581	f2 0f 11 85 b0
	fe ff ff	 movsd	 QWORD PTR tv790[ebp], xmm0
$LN118@assess_cov:
  01589	f2 0f 10 85 b0
	fe ff ff	 movsd	 xmm0, QWORD PTR tv790[ebp]
  01591	f2 0f 11 85 b8
	fe ff ff	 movsd	 QWORD PTR tv791[ebp], xmm0
$LN120@assess_cov:
  01599	f2 0f 5a 85 b8
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv791[ebp]
  015a1	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _total$[ebp], xmm0

; 930  : 
; 931  : 	total *= 255.0;

  015a9	f3 0f 5a 85 7c
	ff ff ff	 cvtss2sd xmm0, DWORD PTR _total$[ebp]
  015b1	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@406fe00000000000
  015b9	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  015bd	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _total$[ebp], xmm0

; 932  : 
; 933  : 	result = (unsigned char)total; 

  015c5	f3 0f 2c 85 7c
	ff ff ff	 cvttss2si eax, DWORD PTR _total$[ebp]
  015cd	0f b6 c8	 movzx	 ecx, al
  015d0	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _result$[ebp], ecx

; 934  : 
; 935  : 	//
; 936  : 	// best so far ?
; 937  : 	//
; 938  : 
; 939  : 	if (result > raw->best_seek_cover_result.score)

  015d6	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  015d9	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  015df	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  015e2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  015e8	39 8d 58 ff ff
	ff		 cmp	 DWORD PTR _result$[ebp], ecx
  015ee	0f 86 d0 00 00
	00		 jbe	 $LN45@assess_cov

; 940  : 	{
; 941  : 		raw->best_seek_cover_result = raw->current_seek_cover_result;

  015f4	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  015f7	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  015fd	8b 55 fc	 mov	 edx, DWORD PTR _raw$[ebp]
  01600	89 8a 8c 00 00
	00		 mov	 DWORD PTR [edx+140], ecx

; 942  : 
; 943  : 		raw->best_seek_cover_result.score = result;

  01606	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _result$[ebp]
  0160c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01611	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  01614	8b 4d fc	 mov	 ecx, DWORD PTR _raw$[ebp]
  01617	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  0161d	81 e2 ff 03 fc
	ff		 and	 edx, -261121		; fffc03ffH
  01623	0b d0		 or	 edx, eax
  01625	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  01628	89 90 8c 00 00
	00		 mov	 DWORD PTR [eax+140], edx

; 944  : 
; 945  : 		set_local_entity_vec3d (aggressor, VEC3D_TYPE_COVER_POSITION, cover_pos);

  0162e	83 7d 0c 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  01632	74 0d		 je	 SHORT $LN121@assess_cov
  01634	8b 45 0c	 mov	 eax, DWORD PTR _aggressor$[ebp]
  01637	8b 08		 mov	 ecx, DWORD PTR [eax]
  01639	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv820[ebp], ecx
  0163f	eb 27		 jmp	 SHORT $LN122@assess_cov
$LN121@assess_cov:
  01641	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  01647	81 c2 44 02 00
	00		 add	 edx, 580		; 00000244H
  0164d	52		 push	 edx
  0164e	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  01653	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  01658	50		 push	 eax
  01659	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0165e	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv820[ebp], 0
$LN122@assess_cov:
  01668	b9 01 00 00 00	 mov	 ecx, 1
  0166d	85 c9		 test	 ecx, ecx
  0166f	74 0c		 je	 SHORT $LN123@assess_cov
  01671	c7 85 b8 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv828[ebp], 2
  0167b	eb 27		 jmp	 SHORT $LN124@assess_cov
$LN123@assess_cov:
  0167d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z@4JA
  01683	81 c2 44 02 00
	00		 add	 edx, 580		; 00000244H
  01689	52		 push	 edx
  0168a	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0168f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  01694	50		 push	 eax
  01695	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0169a	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv828[ebp], 0
$LN124@assess_cov:
  016a4	8b 4d 14	 mov	 ecx, DWORD PTR _cover_pos$[ebp]
  016a7	51		 push	 ecx
  016a8	6a 02		 push	 2
  016aa	8b 55 0c	 mov	 edx, DWORD PTR _aggressor$[ebp]
  016ad	52		 push	 edx
  016ae	6b 85 bc fe ff
	ff 60		 imul	 eax, DWORD PTR tv820[ebp], 96
  016b5	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR tv828[ebp]
  016bb	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR ?fn_set_local_entity_vec3d@@3PAY0BI@P6GXPAUENTITY@@W4VEC3D_TYPES@@PAUVEC3D@@@ZA[eax+ecx*4]
  016c2	ff d2		 call	 edx
$LN45@assess_cov:

; 946  : 	}
; 947  : 
; 948  : 	#if DEBUG_MODULE
; 949  : 
; 950  : 	if (aggressor == get_external_view_entity ())
; 951  : 	{
; 952  : 		debug_filtered_log ("	- ACCEPTED");
; 953  : 	}
; 954  : 
; 955  : 	#endif
; 956  : 
; 957  : 	return result;

  016c4	8a 85 58 ff ff
	ff		 mov	 al, BYTE PTR _result$[ebp]
$LN1@assess_cov:

; 958  : }

  016ca	5f		 pop	 edi
  016cb	5e		 pop	 esi
  016cc	5b		 pop	 ebx
  016cd	8b e5		 mov	 esp, ebp
  016cf	5d		 pop	 ebp
  016d0	c2 14 00	 ret	 20			; 00000014H
  016d3	90		 npad	 1
$LN126@assess_cov:
  016d4	00 00 00 00	 DD	 $LN40@assess_cov
  016d8	00 00 00 00	 DD	 $LN9@assess_cov
$LN125@assess_cov:
  016dc	00		 DB	 0
  016dd	01		 DB	 1
  016de	01		 DB	 1
  016df	01		 DB	 1
  016e0	01		 DB	 1
  016e1	00		 DB	 0
  016e2	01		 DB	 1
  016e3	01		 DB	 1
  016e4	01		 DB	 1
  016e5	00		 DB	 0
  016e6	01		 DB	 1
  016e7	01		 DB	 1
  016e8	01		 DB	 1
  016e9	00		 DB	 0
  016ea	01		 DB	 1
  016eb	01		 DB	 1
  016ec	01		 DB	 1
  016ed	01		 DB	 1
  016ee	00		 DB	 0
  016ef	01		 DB	 1
  016f0	00		 DB	 0
  016f1	01		 DB	 1
  016f2	00		 DB	 0
  016f3	00		 DB	 0
  016f4	01		 DB	 1
  016f5	00		 DB	 0
  016f6	01		 DB	 1
  016f7	00		 DB	 0
  016f8	00		 DB	 0
  016f9	00		 DB	 0
?assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z ENDP ; assess_cover_position
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\guide\gd_cover.c
;	COMDAT ?update_guide_seek_cover_current_position_search@@YGHPAUENTITY@@@Z
_TEXT	SEGMENT
tv83 = -96						; size = 4
tv75 = -92						; size = 4
_score$ = -21						; size = 1
_aggressor_pos$ = -20					; size = 4
_task$ = -16						; size = 4
_wp$ = -12						; size = 4
_target$ = -8						; size = 4
_aggressor$ = -4					; size = 4
_en$ = 8						; size = 4
?update_guide_seek_cover_current_position_search@@YGHPAUENTITY@@@Z PROC ; update_guide_seek_cover_current_position_search, COMDAT

; 1653 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1654 : 	entity
; 1655 : 		*aggressor,
; 1656 : 		*target,
; 1657 : 		*wp,
; 1658 : 		*task;
; 1659 : 
; 1660 : 	vec3d
; 1661 : 		*aggressor_pos;
; 1662 : 
; 1663 : 	unsigned char
; 1664 : 		score;
; 1665 : 
; 1666 : 	get_local_guide_entity_pointers (en, &aggressor, &wp, &task, &target);

  00009	8d 45 f8	 lea	 eax, DWORD PTR _target$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d f0	 lea	 ecx, DWORD PTR _task$[ebp]
  00010	51		 push	 ecx
  00011	8d 55 f4	 lea	 edx, DWORD PTR _wp$[ebp]
  00014	52		 push	 edx
  00015	8d 45 fc	 lea	 eax, DWORD PTR _aggressor$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ?get_local_guide_entity_pointers@@YGXPAUENTITY@@PAPAU1@111@Z ; get_local_guide_entity_pointers

; 1667 : 
; 1668 : 	aggressor_pos = get_local_entity_vec3d_ptr (aggressor, VEC3D_TYPE_POSITION);

  00022	83 7d fc 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  00026	74 0a		 je	 SHORT $LN3@update_gui
  00028	8b 45 fc	 mov	 eax, DWORD PTR _aggressor$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	89 4d a4	 mov	 DWORD PTR tv75[ebp], ecx
  00030	eb 21		 jmp	 SHORT $LN4@update_gui
$LN3@update_gui:
  00032	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_current_position_search@@YGHPAUENTITY@@@Z@4JA
  00038	83 c2 0f	 add	 edx, 15			; 0000000fH
  0003b	52		 push	 edx
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0004c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN4@update_gui:
  00053	b9 01 00 00 00	 mov	 ecx, 1
  00058	85 c9		 test	 ecx, ecx
  0005a	74 09		 je	 SHORT $LN5@update_gui
  0005c	c7 45 a0 08 00
	00 00		 mov	 DWORD PTR tv83[ebp], 8
  00063	eb 21		 jmp	 SHORT $LN6@update_gui
$LN5@update_gui:
  00065	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_current_position_search@@YGHPAUENTITY@@@Z@4JA
  0006b	83 c2 0f	 add	 edx, 15			; 0000000fH
  0006e	52		 push	 edx
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0007f	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$LN6@update_gui:
  00086	6a 08		 push	 8
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  0008b	51		 push	 ecx
  0008c	6b 55 a4 60	 imul	 edx, DWORD PTR tv75[ebp], 96
  00090	8b 45 a0	 mov	 eax, DWORD PTR tv83[ebp]
  00093	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA[edx+eax*4]
  0009a	ff d1		 call	 ecx
  0009c	89 45 ec	 mov	 DWORD PTR _aggressor_pos$[ebp], eax

; 1669 : 	
; 1670 : 	set_guide_seek_cover_next_search_mode (en);

  0009f	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ?set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z ; set_guide_seek_cover_next_search_mode

; 1671 : 
; 1672 : 	score = assess_cover_position (en, aggressor, target, aggressor_pos, NULL);

  000a8	6a 00		 push	 0
  000aa	8b 45 ec	 mov	 eax, DWORD PTR _aggressor_pos$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR _target$[ebp]
  000b1	51		 push	 ecx
  000b2	8b 55 fc	 mov	 edx, DWORD PTR _aggressor$[ebp]
  000b5	52		 push	 edx
  000b6	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ?assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z ; assess_cover_position
  000bf	88 45 eb	 mov	 BYTE PTR _score$[ebp], al

; 1673 : 
; 1674 : 	#if DEBUG_MODULE
; 1675 : 
; 1676 : 	if (aggressor == get_external_view_entity ())
; 1677 : 	{
; 1678 : 		debug_filtered_log ("GD_COVER: (Current Position) SCORE %d", score);
; 1679 : 	}
; 1680 : 
; 1681 : 	#endif
; 1682 : 
; 1683 : 	return TRUE;

  000c2	b8 01 00 00 00	 mov	 eax, 1

; 1684 : }

  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c2 04 00	 ret	 4
?update_guide_seek_cover_current_position_search@@YGHPAUENTITY@@@Z ENDP ; update_guide_seek_cover_current_position_search
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\guide\gd_cover.c
;	COMDAT ?update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z
_TEXT	SEGMENT
tv341 = -164						; size = 8
tv160 = -164						; size = 4
tv140 = -164						; size = 4
tv88 = -164						; size = 4
tv152 = -160						; size = 4
tv132 = -160						; size = 4
tv80 = -160						; size = 4
$T1 = -156						; size = 4
$T2 = -152						; size = 4
_score$ = -81						; size = 1
_eff_range$ = -80					; size = 4
_min_range$ = -76					; size = 4
_distance$ = -72					; size = 4
_theta$ = -68						; size = 4
_cover_pos$ = -64					; size = 12
_aggressor_pos$ = -52					; size = 4
_target_pos$ = -48					; size = 4
_ta_vec$ = -44						; size = 8
_selected_weapon$ = -36					; size = 4
_count$ = -32						; size = 4
_b$ = -28						; size = 4
_a$ = -24						; size = 4
_raw$ = -20						; size = 4
_task$ = -16						; size = 4
_wp$ = -12						; size = 4
_target$ = -8						; size = 4
_aggressor$ = -4					; size = 4
_en$ = 8						; size = 4
?update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z PROC ; update_guide_seek_cover_default_terrain_search, COMDAT

; 1516 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1517 : 	entity
; 1518 : 		*aggressor,
; 1519 : 		*target,
; 1520 : 		*wp,
; 1521 : 		*task;
; 1522 : 
; 1523 : 	guide
; 1524 : 		*raw;
; 1525 : 
; 1526 : 	int
; 1527 : 		a,
; 1528 : 		b,
; 1529 : 		count,
; 1530 : 		selected_weapon;
; 1531 : 
; 1532 : 	vec2d
; 1533 : 		ta_vec;
; 1534 : 
; 1535 : 	vec3d
; 1536 : 		*target_pos,
; 1537 : 		*aggressor_pos,
; 1538 : 		cover_pos;
; 1539 : 
; 1540 : 	float
; 1541 : 		theta,
; 1542 : 		distance,
; 1543 : 		min_range,
; 1544 : 		eff_range;
; 1545 : 
; 1546 : 	unsigned char
; 1547 : 		score;
; 1548 : 
; 1549 : 	get_local_guide_entity_pointers (en, &aggressor, &wp, &task, &target);

  0000c	8d 45 f8	 lea	 eax, DWORD PTR _target$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f0	 lea	 ecx, DWORD PTR _task$[ebp]
  00013	51		 push	 ecx
  00014	8d 55 f4	 lea	 edx, DWORD PTR _wp$[ebp]
  00017	52		 push	 edx
  00018	8d 45 fc	 lea	 eax, DWORD PTR _aggressor$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ?get_local_guide_entity_pointers@@YGXPAUENTITY@@PAPAU1@111@Z ; get_local_guide_entity_pointers

; 1550 : 
; 1551 : 	raw = (guide *) get_local_entity_data (en);

  00025	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00028	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002b	89 4d ec	 mov	 DWORD PTR _raw$[ebp], ecx

; 1552 : 
; 1553 : 	//
; 1554 : 	// find constants
; 1555 : 	//	
; 1556 : 
; 1557 : 	count = raw->current_seek_cover_result.count;

  0002e	8b 45 ec	 mov	 eax, DWORD PTR _raw$[ebp]
  00031	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00037	c1 e9 05	 shr	 ecx, 5
  0003a	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0003d	89 4d e0	 mov	 DWORD PTR _count$[ebp], ecx

; 1558 : 
; 1559 : 	target_pos = get_local_entity_vec3d_ptr (target, VEC3D_TYPE_POSITION);

  00040	83 7d f8 00	 cmp	 DWORD PTR _target$[ebp], 0
  00044	74 0d		 je	 SHORT $LN8@update_gui
  00046	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv80[ebp], ecx
  00051	eb 24		 jmp	 SHORT $LN9@update_gui
$LN8@update_gui:
  00053	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z@4JA
  00059	83 c2 2b	 add	 edx, 43			; 0000002bH
  0005c	52		 push	 edx
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0006d	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv80[ebp], 0
$LN9@update_gui:
  00077	b9 01 00 00 00	 mov	 ecx, 1
  0007c	85 c9		 test	 ecx, ecx
  0007e	74 0c		 je	 SHORT $LN10@update_gui
  00080	c7 85 5c ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv88[ebp], 8
  0008a	eb 24		 jmp	 SHORT $LN11@update_gui
$LN10@update_gui:
  0008c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z@4JA
  00092	83 c2 2b	 add	 edx, 43			; 0000002bH
  00095	52		 push	 edx
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  000a6	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv88[ebp], 0
$LN11@update_gui:
  000b0	6a 08		 push	 8
  000b2	8b 4d f8	 mov	 ecx, DWORD PTR _target$[ebp]
  000b5	51		 push	 ecx
  000b6	6b 95 60 ff ff
	ff 60		 imul	 edx, DWORD PTR tv80[ebp], 96
  000bd	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv88[ebp]
  000c3	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA[edx+eax*4]
  000ca	ff d1		 call	 ecx
  000cc	89 45 d0	 mov	 DWORD PTR _target_pos$[ebp], eax

; 1560 : 	
; 1561 : 	aggressor_pos = get_local_entity_vec3d_ptr (aggressor, VEC3D_TYPE_POSITION);

  000cf	83 7d fc 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  000d3	74 0d		 je	 SHORT $LN12@update_gui
  000d5	8b 45 fc	 mov	 eax, DWORD PTR _aggressor$[ebp]
  000d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000da	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv132[ebp], ecx
  000e0	eb 24		 jmp	 SHORT $LN13@update_gui
$LN12@update_gui:
  000e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z@4JA
  000e8	83 c2 2d	 add	 edx, 45			; 0000002dH
  000eb	52		 push	 edx
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  000f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  000fc	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv132[ebp], 0
$LN13@update_gui:
  00106	b9 01 00 00 00	 mov	 ecx, 1
  0010b	85 c9		 test	 ecx, ecx
  0010d	74 0c		 je	 SHORT $LN14@update_gui
  0010f	c7 85 5c ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv140[ebp], 8
  00119	eb 24		 jmp	 SHORT $LN15@update_gui
$LN14@update_gui:
  0011b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z@4JA
  00121	83 c2 2d	 add	 edx, 45			; 0000002dH
  00124	52		 push	 edx
  00125	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0012a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00135	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv140[ebp], 0
$LN15@update_gui:
  0013f	6a 08		 push	 8
  00141	8b 4d fc	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  00144	51		 push	 ecx
  00145	6b 95 60 ff ff
	ff 60		 imul	 edx, DWORD PTR tv132[ebp], 96
  0014c	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv140[ebp]
  00152	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA[edx+eax*4]
  00159	ff d1		 call	 ecx
  0015b	89 45 cc	 mov	 DWORD PTR _aggressor_pos$[ebp], eax

; 1562 : 
; 1563 : 	selected_weapon = get_local_entity_int_value (aggressor, INT_TYPE_SELECTED_WEAPON);

  0015e	83 7d fc 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  00162	74 0d		 je	 SHORT $LN16@update_gui
  00164	8b 45 fc	 mov	 eax, DWORD PTR _aggressor$[ebp]
  00167	8b 08		 mov	 ecx, DWORD PTR [eax]
  00169	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv152[ebp], ecx
  0016f	eb 24		 jmp	 SHORT $LN17@update_gui
$LN16@update_gui:
  00171	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z@4JA
  00177	83 c2 2f	 add	 edx, 47			; 0000002fH
  0017a	52		 push	 edx
  0017b	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00180	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0018b	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv152[ebp], 0
$LN17@update_gui:
  00195	b9 01 00 00 00	 mov	 ecx, 1
  0019a	85 c9		 test	 ecx, ecx
  0019c	74 0c		 je	 SHORT $LN18@update_gui
  0019e	c7 85 5c ff ff
	ff b8 00 00 00	 mov	 DWORD PTR tv160[ebp], 184 ; 000000b8H
  001a8	eb 24		 jmp	 SHORT $LN19@update_gui
$LN18@update_gui:
  001aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z@4JA
  001b0	83 c2 2f	 add	 edx, 47			; 0000002fH
  001b3	52		 push	 edx
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  001b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  001be	50		 push	 eax
  001bf	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  001c4	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv160[ebp], 0
$LN19@update_gui:
  001ce	68 b8 00 00 00	 push	 184			; 000000b8H
  001d3	8b 4d fc	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  001d6	51		 push	 ecx
  001d7	69 95 60 ff ff
	ff 5c 04 00 00	 imul	 edx, DWORD PTR tv152[ebp], 1116
  001e1	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv160[ebp]
  001e7	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[edx+eax*4]
  001ee	ff d1		 call	 ecx
  001f0	89 45 dc	 mov	 DWORD PTR _selected_weapon$[ebp], eax

; 1564 : 
; 1565 : 	ASSERT (selected_weapon != ENTITY_SUB_TYPE_WEAPON_NO_WEAPON);

  001f3	83 7d dc 00	 cmp	 DWORD PTR _selected_weapon$[ebp], 0
  001f7	75 18		 jne	 SHORT $LN5@update_gui
  001f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z@4JA
  001fe	83 c0 31	 add	 eax, 49			; 00000031H
  00201	50		 push	 eax
  00202	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00207	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@FBJGKGOB@selected_weapon?5?$CB?$DN?5ENTITY_SUB_T@
  0020c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN5@update_gui:

; 1566 : 	
; 1567 : 	min_range = weapon_database [selected_weapon].min_range;

  00211	69 45 dc e0 00
	00 00		 imul	 eax, DWORD PTR _selected_weapon$[ebp], 224
  00218	f3 0f 10 80 8c
	00 00 00	 movss	 xmm0, DWORD PTR ?weapon_database@@3PAUWEAPON_DATA@@A[eax+140]
  00220	f3 0f 11 45 b4	 movss	 DWORD PTR _min_range$[ebp], xmm0

; 1568 : 
; 1569 : 	eff_range = weapon_database [selected_weapon].effective_range;

  00225	69 45 dc e0 00
	00 00		 imul	 eax, DWORD PTR _selected_weapon$[ebp], 224
  0022c	f3 0f 10 80 94
	00 00 00	 movss	 xmm0, DWORD PTR ?weapon_database@@3PAUWEAPON_DATA@@A[eax+148]
  00234	f3 0f 11 45 b0	 movss	 DWORD PTR _eff_range$[ebp], xmm0

; 1570 : 
; 1571 : 	ta_vec.x = aggressor_pos->x - target_pos->x;

  00239	8b 45 cc	 mov	 eax, DWORD PTR _aggressor_pos$[ebp]
  0023c	8b 4d d0	 mov	 ecx, DWORD PTR _target_pos$[ebp]
  0023f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00243	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00247	f3 0f 11 45 d4	 movss	 DWORD PTR _ta_vec$[ebp], xmm0

; 1572 : 	ta_vec.y = aggressor_pos->z - target_pos->z;

  0024c	8b 45 cc	 mov	 eax, DWORD PTR _aggressor_pos$[ebp]
  0024f	8b 4d d0	 mov	 ecx, DWORD PTR _target_pos$[ebp]
  00252	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00257	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0025c	f3 0f 11 45 d8	 movss	 DWORD PTR _ta_vec$[ebp+4], xmm0

; 1573 : 	
; 1574 : 	normalise_any_2d_vector (&ta_vec);

  00261	8d 45 d4	 lea	 eax, DWORD PTR _ta_vec$[ebp]
  00264	50		 push	 eax
  00265	e8 00 00 00 00	 call	 ?normalise_any_2d_vector@@YGMPAUVEC2D@@@Z ; normalise_any_2d_vector
  0026a	dd d8		 fstp	 ST(0)

; 1575 : 
; 1576 : 	a = count;

  0026c	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  0026f	89 45 e8	 mov	 DWORD PTR _a$[ebp], eax

; 1577 : 
; 1578 : 	theta = (((2.0 * (float)a) / MAX_RADIAL_CHECKS) - 1.0) * MAX_DEFLECTION;

  00272	f3 0f 2a 45 e8	 cvtsi2ss xmm0, DWORD PTR _a$[ebp]
  00277	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0027b	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4000000000000000
  00283	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@402e000000000000
  0028b	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00293	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe921fb60000000
  0029b	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0029f	f3 0f 11 45 bc	 movss	 DWORD PTR _theta$[ebp], xmm0

; 1579 : 
; 1580 : 	rotate_2d_vector (&ta_vec, theta);

  002a4	51		 push	 ecx
  002a5	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _theta$[ebp]
  002aa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002af	8d 45 d4	 lea	 eax, DWORD PTR _ta_vec$[ebp]
  002b2	50		 push	 eax
  002b3	e8 00 00 00 00	 call	 ?rotate_2d_vector@@YGXPAUVEC2D@@M@Z ; rotate_2d_vector

; 1581 : 	
; 1582 : 	//
; 1583 : 	// find position to check
; 1584 : 	//	
; 1585 : 
; 1586 : 	for (b = 0; b < MAX_DISTANCE_CHECKS; b ++)

  002b8	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _b$[ebp], 0
  002bf	eb 09		 jmp	 SHORT $LN4@update_gui
$LN2@update_gui:
  002c1	8b 45 e4	 mov	 eax, DWORD PTR _b$[ebp]
  002c4	83 c0 01	 add	 eax, 1
  002c7	89 45 e4	 mov	 DWORD PTR _b$[ebp], eax
$LN4@update_gui:
  002ca	83 7d e4 08	 cmp	 DWORD PTR _b$[ebp], 8
  002ce	0f 8d ba 00 00
	00		 jge	 $LN3@update_gui

; 1587 : 	{
; 1588 : 		distance = eff_range - (((float)b / MAX_DISTANCE_CHECKS) * (eff_range - min_range));

  002d4	f3 0f 2a 45 e4	 cvtsi2ss xmm0, DWORD PTR _b$[ebp]
  002d9	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41000000
  002e1	f3 0f 10 4d b0	 movss	 xmm1, DWORD PTR _eff_range$[ebp]
  002e6	f3 0f 5c 4d b4	 subss	 xmm1, DWORD PTR _min_range$[ebp]
  002eb	f3 0f 59 c1	 mulss	 xmm0, xmm1
  002ef	f3 0f 10 4d b0	 movss	 xmm1, DWORD PTR _eff_range$[ebp]
  002f4	f3 0f 5c c8	 subss	 xmm1, xmm0
  002f8	f3 0f 11 4d b8	 movss	 DWORD PTR _distance$[ebp], xmm1

; 1589 : 	
; 1590 : 		//
; 1591 : 		// find cover position
; 1592 : 		//
; 1593 : 	
; 1594 : 		cover_pos.x = target_pos->x + (ta_vec.x * distance);

  002fd	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _ta_vec$[ebp]
  00302	f3 0f 59 45 b8	 mulss	 xmm0, DWORD PTR _distance$[ebp]
  00307	8b 45 d0	 mov	 eax, DWORD PTR _target_pos$[ebp]
  0030a	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  0030e	f3 0f 11 45 c0	 movss	 DWORD PTR _cover_pos$[ebp], xmm0

; 1595 : 		cover_pos.z = target_pos->z + (ta_vec.y * distance);

  00313	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _ta_vec$[ebp+4]
  00318	f3 0f 59 45 b8	 mulss	 xmm0, DWORD PTR _distance$[ebp]
  0031d	8b 45 d0	 mov	 eax, DWORD PTR _target_pos$[ebp]
  00320	f3 0f 58 40 08	 addss	 xmm0, DWORD PTR [eax+8]
  00325	f3 0f 11 45 c8	 movss	 DWORD PTR _cover_pos$[ebp+8], xmm0

; 1596 : 		
; 1597 : 		bound_position_to_map_area (&cover_pos);

  0032a	8d 45 c0	 lea	 eax, DWORD PTR _cover_pos$[ebp]
  0032d	50		 push	 eax
  0032e	e8 00 00 00 00	 call	 ?bound_position_to_map_area@@YGHPAUVEC3D@@@Z ; bound_position_to_map_area

; 1598 : 
; 1599 : 		cover_pos.y = get_3d_terrain_elevation (cover_pos.x, cover_pos.z) + GUIDE_COVER_ALTITUDE;

  00333	6a 00		 push	 0
  00335	51		 push	 ecx
  00336	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _cover_pos$[ebp+8]
  0033b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00340	51		 push	 ecx
  00341	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _cover_pos$[ebp]
  00346	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0034b	e8 00 00 00 00	 call	 ?get_3d_terrain_point_data@@YGMMMPAUTERRAIN_3D_POINT_DATA@@@Z ; get_3d_terrain_point_data
  00350	dd 9d 5c ff ff
	ff		 fstp	 QWORD PTR tv341[ebp]
  00356	f2 0f 10 85 5c
	ff ff ff	 movsd	 xmm0, QWORD PTR tv341[ebp]
  0035e	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@4014000000000000
  00366	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0036a	f3 0f 11 45 c4	 movss	 DWORD PTR _cover_pos$[ebp+4], xmm0

; 1600 : 		
; 1601 : 		//
; 1602 : 		// assess cover position
; 1603 : 		//
; 1604 : 		
; 1605 : 		score = assess_cover_position (en, aggressor, target, &cover_pos, NULL);

  0036f	6a 00		 push	 0
  00371	8d 45 c0	 lea	 eax, DWORD PTR _cover_pos$[ebp]
  00374	50		 push	 eax
  00375	8b 4d f8	 mov	 ecx, DWORD PTR _target$[ebp]
  00378	51		 push	 ecx
  00379	8b 55 fc	 mov	 edx, DWORD PTR _aggressor$[ebp]
  0037c	52		 push	 edx
  0037d	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ?assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z ; assess_cover_position
  00386	88 45 af	 mov	 BYTE PTR _score$[ebp], al

; 1606 : 	
; 1607 : 		#if DEBUG_MODULE
; 1608 : 
; 1609 : 		if (aggressor == get_external_view_entity ())
; 1610 : 		{
; 1611 : 			debug_filtered_log ("GD_COVER: (%d - %d) Checking distance %f angle %f SCORE %d",
; 1612 : 										raw->current_seek_cover_result.search_mode,
; 1613 : 										count,
; 1614 : 										distance,
; 1615 : 										deg (theta),
; 1616 : 										score);
; 1617 : 		
; 1618 : 			create_debug_3d_line (target_pos, &cover_pos, sys_col_dark_blue, 10.0);
; 1619 : 
; 1620 : 			create_debug_3d_line (aggressor_pos, target_pos, sys_col_red, 0.0);
; 1621 : 		}	
; 1622 : 		#endif
; 1623 : 	}

  00389	e9 33 ff ff ff	 jmp	 $LN2@update_gui
$LN3@update_gui:

; 1624 : 	
; 1625 : 	count ++;

  0038e	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  00391	83 c0 01	 add	 eax, 1
  00394	89 45 e0	 mov	 DWORD PTR _count$[ebp], eax

; 1626 : 
; 1627 : 	if (count >= min (MAX_RADIAL_CHECKS, SEEK_COUNT_LIMIT))

  00397	c7 85 68 ff ff
	ff 20 00 00 00	 mov	 DWORD PTR $T2[ebp], 32	; 00000020H
  003a1	c7 85 64 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T1[ebp], 15	; 0000000fH
  003ab	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  003b1	50		 push	 eax
  003b2	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  003b8	51		 push	 ecx
  003b9	e8 00 00 00 00	 call	 ??$min@H@std@@YGABHABH0@Z ; std::min<int>
  003be	8b 55 e0	 mov	 edx, DWORD PTR _count$[ebp]
  003c1	3b 10		 cmp	 edx, DWORD PTR [eax]
  003c3	7c 0d		 jl	 SHORT $LN6@update_gui

; 1628 : 	{
; 1629 : 		#if DEBUG_MODULE
; 1630 : 
; 1631 : 		if (aggressor == get_external_view_entity ())
; 1632 : 		{
; 1633 : 			debug_filtered_log ("GD_COVER: (%d) ---------------------------", raw->current_seek_cover_result.search_mode);
; 1634 : 		}
; 1635 : 
; 1636 : 		#endif
; 1637 : 
; 1638 : 		set_guide_seek_cover_next_search_mode (en);

  003c5	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  003c8	50		 push	 eax
  003c9	e8 00 00 00 00	 call	 ?set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z ; set_guide_seek_cover_next_search_mode

; 1639 : 
; 1640 : 		return FALSE;

  003ce	33 c0		 xor	 eax, eax
  003d0	eb 28		 jmp	 SHORT $LN1@update_gui
$LN6@update_gui:

; 1641 : 	}
; 1642 : 
; 1643 : 	raw->current_seek_cover_result.count = count;

  003d2	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  003d5	83 e0 1f	 and	 eax, 31			; 0000001fH
  003d8	c1 e0 05	 shl	 eax, 5
  003db	8b 4d ec	 mov	 ecx, DWORD PTR _raw$[ebp]
  003de	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  003e4	81 e2 1f fc ff
	ff		 and	 edx, -993		; fffffc1fH
  003ea	0b d0		 or	 edx, eax
  003ec	8b 45 ec	 mov	 eax, DWORD PTR _raw$[ebp]
  003ef	89 90 88 00 00
	00		 mov	 DWORD PTR [eax+136], edx

; 1644 : 
; 1645 : 	return TRUE;

  003f5	b8 01 00 00 00	 mov	 eax, 1
$LN1@update_gui:

; 1646 : }

  003fa	5f		 pop	 edi
  003fb	5e		 pop	 esi
  003fc	5b		 pop	 ebx
  003fd	8b e5		 mov	 esp, ebp
  003ff	5d		 pop	 ebp
  00400	c2 04 00	 ret	 4
?update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z ENDP ; update_guide_seek_cover_default_terrain_search
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\guide\gd_cover.c
;	COMDAT ?update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z
_TEXT	SEGMENT
tv616 = -232						; size = 8
tv203 = -232						; size = 4
tv179 = -232						; size = 4
tv161 = -232						; size = 4
tv136 = -232						; size = 4
tv84 = -232						; size = 4
tv195 = -228						; size = 4
tv172 = -228						; size = 4
tv153 = -228						; size = 4
tv128 = -228						; size = 4
tv76 = -228						; size = 4
_test_pos$1 = -160					; size = 12
_score$ = -145						; size = 1
_distance$ = -144					; size = 4
_z$ = -140						; size = 4
_x$ = -136						; size = 4
_terrain_point_data$ = -132				; size = 44
_cover_pos$ = -88					; size = 12
_cover_vec$ = -76					; size = 12
_average_point$ = -64					; size = 12
_point$ = -52						; size = 4
_normal$ = -48						; size = 4
_aggressor_pos$ = -44					; size = 4
_target_pos$ = -40					; size = 4
_check_count$ = -36					; size = 4
_count$ = -32						; size = 4
_loop$ = -28						; size = 4
_raw$ = -24						; size = 4
_sector$ = -20						; size = 4
_task$ = -16						; size = 4
_wp$ = -12						; size = 4
_target$ = -8						; size = 4
_aggressor$ = -4					; size = 4
_en$ = 8						; size = 4
?update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z PROC ; update_guide_seek_cover_forest_search, COMDAT

; 1239 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1240 : 	entity
; 1241 : 		*aggressor,
; 1242 : 		*target,
; 1243 : 		*wp,
; 1244 : 		*task,
; 1245 : 		*sector;
; 1246 : 
; 1247 : 	guide
; 1248 : 		*raw;
; 1249 : 
; 1250 : 	int
; 1251 : 		loop,
; 1252 : 		count,
; 1253 : 		check_count;
; 1254 : 
; 1255 : 	vec3d
; 1256 : 		*target_pos,
; 1257 : 		*aggressor_pos,
; 1258 : 		*normal,
; 1259 : 		*point,
; 1260 : 		average_point,
; 1261 : 		cover_vec,
; 1262 : 		cover_pos;
; 1263 : 
; 1264 : 	terrain_3d_point_data
; 1265 : 		terrain_point_data;
; 1266 : 
; 1267 : 	float
; 1268 : 		x, z,
; 1269 : 		distance;
; 1270 : 
; 1271 : 	unsigned char
; 1272 : 		score;
; 1273 : 
; 1274 : 	get_local_guide_entity_pointers (en, &aggressor, &wp, &task, &target);

  0000c	8d 45 f8	 lea	 eax, DWORD PTR _target$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f0	 lea	 ecx, DWORD PTR _task$[ebp]
  00013	51		 push	 ecx
  00014	8d 55 f4	 lea	 edx, DWORD PTR _wp$[ebp]
  00017	52		 push	 edx
  00018	8d 45 fc	 lea	 eax, DWORD PTR _aggressor$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ?get_local_guide_entity_pointers@@YGXPAUENTITY@@PAPAU1@111@Z ; get_local_guide_entity_pointers

; 1275 : 
; 1276 : 	raw = (guide *) get_local_entity_data (en);

  00025	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00028	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002b	89 4d e8	 mov	 DWORD PTR _raw$[ebp], ecx

; 1277 : 
; 1278 : 	target_pos = get_local_entity_vec3d_ptr (target, VEC3D_TYPE_POSITION);

  0002e	83 7d f8 00	 cmp	 DWORD PTR _target$[ebp], 0
  00032	74 0d		 je	 SHORT $LN21@update_gui
  00034	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	89 8d 1c ff ff
	ff		 mov	 DWORD PTR tv76[ebp], ecx
  0003f	eb 24		 jmp	 SHORT $LN22@update_gui
$LN21@update_gui:
  00041	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z@4JA
  00047	83 c2 27	 add	 edx, 39			; 00000027H
  0004a	52		 push	 edx
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0005b	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv76[ebp], 0
$LN22@update_gui:
  00065	b9 01 00 00 00	 mov	 ecx, 1
  0006a	85 c9		 test	 ecx, ecx
  0006c	74 0c		 je	 SHORT $LN23@update_gui
  0006e	c7 85 18 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv84[ebp], 8
  00078	eb 24		 jmp	 SHORT $LN24@update_gui
$LN23@update_gui:
  0007a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z@4JA
  00080	83 c2 27	 add	 edx, 39			; 00000027H
  00083	52		 push	 edx
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00094	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv84[ebp], 0
$LN24@update_gui:
  0009e	6a 08		 push	 8
  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _target$[ebp]
  000a3	51		 push	 ecx
  000a4	6b 95 1c ff ff
	ff 60		 imul	 edx, DWORD PTR tv76[ebp], 96
  000ab	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv84[ebp]
  000b1	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA[edx+eax*4]
  000b8	ff d1		 call	 ecx
  000ba	89 45 d8	 mov	 DWORD PTR _target_pos$[ebp], eax

; 1279 : 	
; 1280 : 	aggressor_pos = get_local_entity_vec3d_ptr (aggressor, VEC3D_TYPE_POSITION);

  000bd	83 7d fc 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  000c1	74 0d		 je	 SHORT $LN25@update_gui
  000c3	8b 45 fc	 mov	 eax, DWORD PTR _aggressor$[ebp]
  000c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c8	89 8d 1c ff ff
	ff		 mov	 DWORD PTR tv128[ebp], ecx
  000ce	eb 24		 jmp	 SHORT $LN26@update_gui
$LN25@update_gui:
  000d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z@4JA
  000d6	83 c2 29	 add	 edx, 41			; 00000029H
  000d9	52		 push	 edx
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  000df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  000ea	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv128[ebp], 0
$LN26@update_gui:
  000f4	b9 01 00 00 00	 mov	 ecx, 1
  000f9	85 c9		 test	 ecx, ecx
  000fb	74 0c		 je	 SHORT $LN27@update_gui
  000fd	c7 85 18 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv136[ebp], 8
  00107	eb 24		 jmp	 SHORT $LN28@update_gui
$LN27@update_gui:
  00109	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z@4JA
  0010f	83 c2 29	 add	 edx, 41			; 00000029H
  00112	52		 push	 edx
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00123	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv136[ebp], 0
$LN28@update_gui:
  0012d	6a 08		 push	 8
  0012f	8b 4d fc	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  00132	51		 push	 ecx
  00133	6b 95 1c ff ff
	ff 60		 imul	 edx, DWORD PTR tv128[ebp], 96
  0013a	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv136[ebp]
  00140	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA[edx+eax*4]
  00147	ff d1		 call	 ecx
  00149	89 45 d4	 mov	 DWORD PTR _aggressor_pos$[ebp], eax

; 1281 : 	
; 1282 : 	//
; 1283 : 	// get search sector
; 1284 : 	//
; 1285 : 	
; 1286 : 	if (raw->current_seek_cover_result.sector)

  0014c	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  0014f	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00155	c1 e9 04	 shr	 ecx, 4
  00158	83 e1 01	 and	 ecx, 1
  0015b	0f 84 52 01 00
	00		 je	 $LN5@update_gui

; 1287 : 	{
; 1288 : 		sector = get_local_entity_parent (target, LIST_TYPE_SECTOR);

  00161	83 7d f8 00	 cmp	 DWORD PTR _target$[ebp], 0
  00165	74 0d		 je	 SHORT $LN29@update_gui
  00167	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  0016a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016c	89 8d 1c ff ff
	ff		 mov	 DWORD PTR tv153[ebp], ecx
  00172	eb 24		 jmp	 SHORT $LN30@update_gui
$LN29@update_gui:
  00174	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z@4JA
  0017a	83 c2 31	 add	 edx, 49			; 00000031H
  0017d	52		 push	 edx
  0017e	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00183	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0018e	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
$LN30@update_gui:
  00198	b9 01 00 00 00	 mov	 ecx, 1
  0019d	85 c9		 test	 ecx, ecx
  0019f	74 0c		 je	 SHORT $LN31@update_gui
  001a1	c7 85 18 ff ff
	ff 21 00 00 00	 mov	 DWORD PTR tv161[ebp], 33 ; 00000021H
  001ab	eb 24		 jmp	 SHORT $LN32@update_gui
$LN31@update_gui:
  001ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z@4JA
  001b3	83 c2 31	 add	 edx, 49			; 00000031H
  001b6	52		 push	 edx
  001b7	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  001bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  001c7	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv161[ebp], 0
$LN32@update_gui:
  001d1	6a 21		 push	 33			; 00000021H
  001d3	8b 4d f8	 mov	 ecx, DWORD PTR _target$[ebp]
  001d6	51		 push	 ecx
  001d7	69 95 1c ff ff
	ff b4 00 00 00	 imul	 edx, DWORD PTR tv153[ebp], 180
  001e1	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv161[ebp]
  001e7	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  001ee	ff d1		 call	 ecx
  001f0	89 45 ec	 mov	 DWORD PTR _sector$[ebp], eax

; 1289 : 
; 1290 : 		if (sector == get_local_entity_parent (aggressor, LIST_TYPE_SECTOR))

  001f3	83 7d fc 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  001f7	74 0d		 je	 SHORT $LN33@update_gui
  001f9	8b 45 fc	 mov	 eax, DWORD PTR _aggressor$[ebp]
  001fc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fe	89 8d 1c ff ff
	ff		 mov	 DWORD PTR tv172[ebp], ecx
  00204	eb 20		 jmp	 SHORT $LN34@update_gui
$LN33@update_gui:
  00206	68 0a 05 00 00	 push	 1290			; 0000050aH
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00210	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00216	52		 push	 edx
  00217	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0021c	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv172[ebp], 0
$LN34@update_gui:
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	85 c0		 test	 eax, eax
  0022d	74 0c		 je	 SHORT $LN35@update_gui
  0022f	c7 85 18 ff ff
	ff 21 00 00 00	 mov	 DWORD PTR tv179[ebp], 33 ; 00000021H
  00239	eb 20		 jmp	 SHORT $LN36@update_gui
$LN35@update_gui:
  0023b	68 0a 05 00 00	 push	 1290			; 0000050aH
  00240	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00245	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  0024b	51		 push	 ecx
  0024c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00251	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv179[ebp], 0
$LN36@update_gui:
  0025b	6a 21		 push	 33			; 00000021H
  0025d	8b 55 fc	 mov	 edx, DWORD PTR _aggressor$[ebp]
  00260	52		 push	 edx
  00261	69 85 1c ff ff
	ff b4 00 00 00	 imul	 eax, DWORD PTR tv172[ebp], 180
  0026b	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv179[ebp]
  00271	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR ?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[eax+ecx*4]
  00278	ff d2		 call	 edx
  0027a	39 45 ec	 cmp	 DWORD PTR _sector$[ebp], eax
  0027d	75 10		 jne	 SHORT $LN7@update_gui

; 1291 : 		{
; 1292 : 			set_guide_seek_cover_next_search_mode (en);

  0027f	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00282	50		 push	 eax
  00283	e8 00 00 00 00	 call	 ?set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z ; set_guide_seek_cover_next_search_mode

; 1293 : 
; 1294 : 			return FALSE;

  00288	33 c0		 xor	 eax, eax
  0028a	e9 c3 05 00 00	 jmp	 $LN1@update_gui
$LN7@update_gui:

; 1295 : 		}
; 1296 : 
; 1297 : 		x = target_pos->x;

  0028f	8b 45 d8	 mov	 eax, DWORD PTR _target_pos$[ebp]
  00292	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00296	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _x$[ebp], xmm0

; 1298 : 
; 1299 : 		z = target_pos->z;

  0029e	8b 45 d8	 mov	 eax, DWORD PTR _target_pos$[ebp]
  002a1	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002a6	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _z$[ebp], xmm0

; 1300 : 	}
; 1301 : 	else

  002ae	e9 b1 00 00 00	 jmp	 $LN6@update_gui
$LN5@update_gui:

; 1302 : 	{
; 1303 : 		sector = get_local_entity_parent (aggressor, LIST_TYPE_SECTOR);

  002b3	83 7d fc 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  002b7	74 0d		 je	 SHORT $LN37@update_gui
  002b9	8b 45 fc	 mov	 eax, DWORD PTR _aggressor$[ebp]
  002bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  002be	89 8d 1c ff ff
	ff		 mov	 DWORD PTR tv195[ebp], ecx
  002c4	eb 24		 jmp	 SHORT $LN38@update_gui
$LN37@update_gui:
  002c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z@4JA
  002cc	83 c2 40	 add	 edx, 64			; 00000040H
  002cf	52		 push	 edx
  002d0	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  002d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  002da	50		 push	 eax
  002db	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  002e0	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv195[ebp], 0
$LN38@update_gui:
  002ea	b9 01 00 00 00	 mov	 ecx, 1
  002ef	85 c9		 test	 ecx, ecx
  002f1	74 0c		 je	 SHORT $LN39@update_gui
  002f3	c7 85 18 ff ff
	ff 21 00 00 00	 mov	 DWORD PTR tv203[ebp], 33 ; 00000021H
  002fd	eb 24		 jmp	 SHORT $LN40@update_gui
$LN39@update_gui:
  002ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z@4JA
  00305	83 c2 40	 add	 edx, 64			; 00000040H
  00308	52		 push	 edx
  00309	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0030e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  00313	50		 push	 eax
  00314	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00319	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv203[ebp], 0
$LN40@update_gui:
  00323	6a 21		 push	 33			; 00000021H
  00325	8b 4d fc	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  00328	51		 push	 ecx
  00329	69 95 1c ff ff
	ff b4 00 00 00	 imul	 edx, DWORD PTR tv195[ebp], 180
  00333	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv203[ebp]
  00339	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  00340	ff d1		 call	 ecx
  00342	89 45 ec	 mov	 DWORD PTR _sector$[ebp], eax

; 1304 : 
; 1305 : 		x = aggressor_pos->x;

  00345	8b 45 d4	 mov	 eax, DWORD PTR _aggressor_pos$[ebp]
  00348	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0034c	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _x$[ebp], xmm0

; 1306 : 
; 1307 : 		z = aggressor_pos->z;

  00354	8b 45 d4	 mov	 eax, DWORD PTR _aggressor_pos$[ebp]
  00357	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0035c	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _z$[ebp], xmm0
$LN6@update_gui:

; 1308 : 	}
; 1309 : 
; 1310 : 	//
; 1311 : 	// Grab polygons (first time only)
; 1312 : 	//
; 1313 : 	
; 1314 : 	if (!raw->terrain_polygon_list)

  00364	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  00367	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  0036e	0f 85 3d 01 00
	00		 jne	 $LN8@update_gui

; 1315 : 	{
; 1316 : 		count = get_terrain_3d_number_of_type_triangles_in_sector (x, z, TERRAIN_TYPE_FOREST_SIDE_MID_X);

  00374	6a 21		 push	 33			; 00000021H
  00376	51		 push	 ecx
  00377	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _z$[ebp]
  0037f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00384	51		 push	 ecx
  00385	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _x$[ebp]
  0038d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00392	e8 00 00 00 00	 call	 ?get_terrain_3d_number_of_type_triangles_in_sector@@YGHMMH@Z ; get_terrain_3d_number_of_type_triangles_in_sector
  00397	89 45 e0	 mov	 DWORD PTR _count$[ebp], eax

; 1317 : 
; 1318 : 		raw->terrain_polygon_count = count + get_terrain_3d_number_of_type_triangles_in_sector (x, z, TERRAIN_TYPE_FOREST_SIDE_MID_Z);

  0039a	6a 22		 push	 34			; 00000022H
  0039c	51		 push	 ecx
  0039d	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _z$[ebp]
  003a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003aa	51		 push	 ecx
  003ab	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _x$[ebp]
  003b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003b8	e8 00 00 00 00	 call	 ?get_terrain_3d_number_of_type_triangles_in_sector@@YGHMMH@Z ; get_terrain_3d_number_of_type_triangles_in_sector
  003bd	03 45 e0	 add	 eax, DWORD PTR _count$[ebp]
  003c0	8b 4d e8	 mov	 ecx, DWORD PTR _raw$[ebp]
  003c3	89 81 94 00 00
	00		 mov	 DWORD PTR [ecx+148], eax

; 1319 : 
; 1320 : 		if (raw->terrain_polygon_count == 0)

  003c9	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  003cc	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [eax+148], 0
  003d3	75 50		 jne	 SHORT $LN9@update_gui

; 1321 : 		{
; 1322 : 			//
; 1323 : 			// None found - skip search
; 1324 : 			//
; 1325 : 			
; 1326 : 			if (raw->current_seek_cover_result.sector)

  003d5	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  003d8	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  003de	c1 e9 04	 shr	 ecx, 4
  003e1	83 e1 01	 and	 ecx, 1
  003e4	74 0b		 je	 SHORT $LN10@update_gui

; 1327 : 			{
; 1328 : 				set_guide_seek_cover_next_search_mode (en);

  003e6	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  003e9	50		 push	 eax
  003ea	e8 00 00 00 00	 call	 ?set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z ; set_guide_seek_cover_next_search_mode

; 1329 : 			}
; 1330 : 			else

  003ef	eb 2d		 jmp	 SHORT $LN11@update_gui
$LN10@update_gui:

; 1331 : 			{
; 1332 : 				raw->current_seek_cover_result.sector = TRUE;

  003f1	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  003f4	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  003fa	83 c9 10	 or	 ecx, 16			; 00000010H
  003fd	8b 55 e8	 mov	 edx, DWORD PTR _raw$[ebp]
  00400	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx

; 1333 : 
; 1334 : 				raw->current_seek_cover_result.count = 0;

  00406	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  00409	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  0040f	81 e1 1f fc ff
	ff		 and	 ecx, -993		; fffffc1fH
  00415	8b 55 e8	 mov	 edx, DWORD PTR _raw$[ebp]
  00418	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx
$LN11@update_gui:

; 1335 : 			}
; 1336 : 		
; 1337 : 			return FALSE;

  0041e	33 c0		 xor	 eax, eax
  00420	e9 2d 04 00 00	 jmp	 $LN1@update_gui
$LN9@update_gui:

; 1338 : 		}
; 1339 : 
; 1340 : 		raw->terrain_polygon_list = (terrain_3d_triangle *) malloc_fast_mem (sizeof (terrain_3d_triangle) * raw->terrain_polygon_count);

  00425	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  00428	6b 88 94 00 00
	00 30		 imul	 ecx, DWORD PTR [eax+148], 48
  0042f	51		 push	 ecx
  00430	e8 00 00 00 00	 call	 ?malloc_fast_memory@@YGPAXI@Z ; malloc_fast_memory
  00435	8b 55 e8	 mov	 edx, DWORD PTR _raw$[ebp]
  00438	89 82 90 00 00
	00		 mov	 DWORD PTR [edx+144], eax

; 1341 : 
; 1342 : 		get_terrain_3d_type_triangles_in_sector (x, z, TERRAIN_TYPE_FOREST_SIDE_MID_X, raw->terrain_polygon_list);

  0043e	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  00441	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00447	51		 push	 ecx
  00448	6a 21		 push	 33			; 00000021H
  0044a	51		 push	 ecx
  0044b	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _z$[ebp]
  00453	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00458	51		 push	 ecx
  00459	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _x$[ebp]
  00461	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00466	e8 00 00 00 00	 call	 ?get_terrain_3d_type_triangles_in_sector@@YGXMMHPAUTERRAIN_3D_TRIANGLE@@@Z ; get_terrain_3d_type_triangles_in_sector

; 1343 : 
; 1344 : 		get_terrain_3d_type_triangles_in_sector (x, z, TERRAIN_TYPE_FOREST_SIDE_MID_Z, &raw->terrain_polygon_list [count]);

  0046b	6b 45 e0 30	 imul	 eax, DWORD PTR _count$[ebp], 48
  0046f	8b 4d e8	 mov	 ecx, DWORD PTR _raw$[ebp]
  00472	03 81 90 00 00
	00		 add	 eax, DWORD PTR [ecx+144]
  00478	50		 push	 eax
  00479	6a 22		 push	 34			; 00000022H
  0047b	51		 push	 ecx
  0047c	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _z$[ebp]
  00484	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00489	51		 push	 ecx
  0048a	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _x$[ebp]
  00492	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00497	e8 00 00 00 00	 call	 ?get_terrain_3d_type_triangles_in_sector@@YGXMMHPAUTERRAIN_3D_TRIANGLE@@@Z ; get_terrain_3d_type_triangles_in_sector

; 1345 : 
; 1346 : 		raw->terrain_polygon_count -= 1;		// use as a countdown to reference into polygon array

  0049c	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  0049f	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  004a5	83 e9 01	 sub	 ecx, 1
  004a8	8b 55 e8	 mov	 edx, DWORD PTR _raw$[ebp]
  004ab	89 8a 94 00 00
	00		 mov	 DWORD PTR [edx+148], ecx
$LN8@update_gui:

; 1347 : 	}
; 1348 : 
; 1349 : 	//
; 1350 : 	// Test polygons
; 1351 : 	//
; 1352 : 	// Only do few proper assessments per frame, but check many polygons for trivial rejection (i.e. facing wrong way)
; 1353 : 	//
; 1354 : 
; 1355 : 	check_count = 0;

  004b1	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _check_count$[ebp], 0

; 1356 : 
; 1357 : 	for (loop = 0; loop < MAX_COVER_FOREST_POLY_CHECKS_PER_FRAME; loop ++)

  004b8	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _loop$[ebp], 0
  004bf	eb 09		 jmp	 SHORT $LN4@update_gui
$LN2@update_gui:
  004c1	8b 45 e4	 mov	 eax, DWORD PTR _loop$[ebp]
  004c4	83 c0 01	 add	 eax, 1
  004c7	89 45 e4	 mov	 DWORD PTR _loop$[ebp], eax
$LN4@update_gui:
  004ca	83 7d e4 0c	 cmp	 DWORD PTR _loop$[ebp], 12 ; 0000000cH
  004ce	0f 8d 7b 03 00
	00		 jge	 $LN3@update_gui

; 1358 : 	{
; 1359 : 		ASSERT (raw->terrain_polygon_list);

  004d4	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  004d7	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  004de	75 18		 jne	 SHORT $LN12@update_gui
  004e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z@4JA
  004e5	83 c0 78	 add	 eax, 120		; 00000078H
  004e8	50		 push	 eax
  004e9	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  004ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HPLLKKAK@raw?9?$DOterrain_polygon_list@
  004f3	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN12@update_gui:

; 1360 : 	
; 1361 : 		if (raw->terrain_polygon_count < 0)

  004f8	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  004fb	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [eax+148], 0
  00502	7d 50		 jge	 SHORT $LN13@update_gui

; 1362 : 		{
; 1363 : 			//
; 1364 : 			// Finished search
; 1365 : 			//
; 1366 : 			
; 1367 : 			if (raw->current_seek_cover_result.sector)

  00504	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  00507	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  0050d	c1 e9 04	 shr	 ecx, 4
  00510	83 e1 01	 and	 ecx, 1
  00513	74 0b		 je	 SHORT $LN14@update_gui

; 1368 : 			{
; 1369 : 				set_guide_seek_cover_next_search_mode (en);

  00515	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00518	50		 push	 eax
  00519	e8 00 00 00 00	 call	 ?set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z ; set_guide_seek_cover_next_search_mode

; 1370 : 			}
; 1371 : 			else

  0051e	eb 2d		 jmp	 SHORT $LN15@update_gui
$LN14@update_gui:

; 1372 : 			{
; 1373 : 				raw->current_seek_cover_result.sector = TRUE;

  00520	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  00523	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00529	83 c9 10	 or	 ecx, 16			; 00000010H
  0052c	8b 55 e8	 mov	 edx, DWORD PTR _raw$[ebp]
  0052f	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx

; 1374 : 	
; 1375 : 				raw->current_seek_cover_result.count = 0;

  00535	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  00538	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  0053e	81 e1 1f fc ff
	ff		 and	 ecx, -993		; fffffc1fH
  00544	8b 55 e8	 mov	 edx, DWORD PTR _raw$[ebp]
  00547	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx
$LN15@update_gui:

; 1376 : 			}
; 1377 : 			
; 1378 : 			return FALSE;

  0054d	33 c0		 xor	 eax, eax
  0054f	e9 fe 02 00 00	 jmp	 $LN1@update_gui
$LN13@update_gui:

; 1379 : 		}
; 1380 : 	
; 1381 : 		count = raw->terrain_polygon_count;

  00554	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  00557	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  0055d	89 4d e0	 mov	 DWORD PTR _count$[ebp], ecx

; 1382 : 	
; 1383 : 		raw->terrain_polygon_count -= 1;

  00560	8b 45 e8	 mov	 eax, DWORD PTR _raw$[ebp]
  00563	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  00569	83 e9 01	 sub	 ecx, 1
  0056c	8b 55 e8	 mov	 edx, DWORD PTR _raw$[ebp]
  0056f	89 8a 94 00 00
	00		 mov	 DWORD PTR [edx+148], ecx

; 1384 : 	
; 1385 : 		//
; 1386 : 		// Grab poly details
; 1387 : 		//
; 1388 : 	
; 1389 : 		normal = &(raw->terrain_polygon_list [count].normal);

  00575	6b 45 e0 30	 imul	 eax, DWORD PTR _count$[ebp], 48
  00579	8b 4d e8	 mov	 ecx, DWORD PTR _raw$[ebp]
  0057c	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00582	8d 44 02 24	 lea	 eax, DWORD PTR [edx+eax+36]
  00586	89 45 d0	 mov	 DWORD PTR _normal$[ebp], eax

; 1390 : 	
; 1391 : 		point = &(raw->terrain_polygon_list [count].point1);

  00589	6b 45 e0 30	 imul	 eax, DWORD PTR _count$[ebp], 48
  0058d	8b 4d e8	 mov	 ecx, DWORD PTR _raw$[ebp]
  00590	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00596	03 d0		 add	 edx, eax
  00598	89 55 cc	 mov	 DWORD PTR _point$[ebp], edx

; 1392 : 	
; 1393 : 		average_point = *point;

  0059b	8b 45 cc	 mov	 eax, DWORD PTR _point$[ebp]
  0059e	8b 08		 mov	 ecx, DWORD PTR [eax]
  005a0	89 4d c0	 mov	 DWORD PTR _average_point$[ebp], ecx
  005a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  005a6	89 55 c4	 mov	 DWORD PTR _average_point$[ebp+4], edx
  005a9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  005ac	89 45 c8	 mov	 DWORD PTR _average_point$[ebp+8], eax

; 1394 : 	
; 1395 : 		point = &(raw->terrain_polygon_list [count].point2);

  005af	6b 45 e0 30	 imul	 eax, DWORD PTR _count$[ebp], 48
  005b3	8b 4d e8	 mov	 ecx, DWORD PTR _raw$[ebp]
  005b6	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  005bc	8d 44 02 0c	 lea	 eax, DWORD PTR [edx+eax+12]
  005c0	89 45 cc	 mov	 DWORD PTR _point$[ebp], eax

; 1396 : 	
; 1397 : 		average_point.x += point->x;

  005c3	8b 45 cc	 mov	 eax, DWORD PTR _point$[ebp]
  005c6	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _average_point$[ebp]
  005cb	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  005cf	f3 0f 11 45 c0	 movss	 DWORD PTR _average_point$[ebp], xmm0

; 1398 : 		average_point.z += point->z;

  005d4	8b 45 cc	 mov	 eax, DWORD PTR _point$[ebp]
  005d7	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _average_point$[ebp+8]
  005dc	f3 0f 58 40 08	 addss	 xmm0, DWORD PTR [eax+8]
  005e1	f3 0f 11 45 c8	 movss	 DWORD PTR _average_point$[ebp+8], xmm0

; 1399 : 	
; 1400 : 		point = &(raw->terrain_polygon_list [count].point3);

  005e6	6b 45 e0 30	 imul	 eax, DWORD PTR _count$[ebp], 48
  005ea	8b 4d e8	 mov	 ecx, DWORD PTR _raw$[ebp]
  005ed	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  005f3	8d 44 02 18	 lea	 eax, DWORD PTR [edx+eax+24]
  005f7	89 45 cc	 mov	 DWORD PTR _point$[ebp], eax

; 1401 : 	
; 1402 : 		average_point.x += point->x;

  005fa	8b 45 cc	 mov	 eax, DWORD PTR _point$[ebp]
  005fd	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _average_point$[ebp]
  00602	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  00606	f3 0f 11 45 c0	 movss	 DWORD PTR _average_point$[ebp], xmm0

; 1403 : 		average_point.z += point->z;

  0060b	8b 45 cc	 mov	 eax, DWORD PTR _point$[ebp]
  0060e	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _average_point$[ebp+8]
  00613	f3 0f 58 40 08	 addss	 xmm0, DWORD PTR [eax+8]
  00618	f3 0f 11 45 c8	 movss	 DWORD PTR _average_point$[ebp+8], xmm0

; 1404 : 	
; 1405 : 		average_point.x *= 0.333333;

  0061d	f3 0f 5a 45 c0	 cvtss2sd xmm0, DWORD PTR _average_point$[ebp]
  00622	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fd55553ef6b5d46
  0062a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0062e	f3 0f 11 45 c0	 movss	 DWORD PTR _average_point$[ebp], xmm0

; 1406 : 		average_point.z *= 0.333333;

  00633	f3 0f 5a 45 c8	 cvtss2sd xmm0, DWORD PTR _average_point$[ebp+8]
  00638	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fd55553ef6b5d46
  00640	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00644	f3 0f 11 45 c8	 movss	 DWORD PTR _average_point$[ebp+8], xmm0

; 1407 : 		
; 1408 : 		//
; 1409 : 		// Find cover position
; 1410 : 		//
; 1411 : 	
; 1412 : 		distance = 25.0;					// to leave plenty of room for the aggressor (not forgetting tree objects

  00649	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41c80000
  00651	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _distance$[ebp], xmm0

; 1413 : 		
; 1414 : 		cover_pos.x = average_point.x + (normal->x * distance);

  00659	8b 45 d0	 mov	 eax, DWORD PTR _normal$[ebp]
  0065c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00660	f3 0f 59 85 70
	ff ff ff	 mulss	 xmm0, DWORD PTR _distance$[ebp]
  00668	f3 0f 58 45 c0	 addss	 xmm0, DWORD PTR _average_point$[ebp]
  0066d	f3 0f 11 45 a8	 movss	 DWORD PTR _cover_pos$[ebp], xmm0

; 1415 : 		cover_pos.z = average_point.z + (normal->z * distance);

  00672	8b 45 d0	 mov	 eax, DWORD PTR _normal$[ebp]
  00675	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0067a	f3 0f 59 85 70
	ff ff ff	 mulss	 xmm0, DWORD PTR _distance$[ebp]
  00682	f3 0f 58 45 c8	 addss	 xmm0, DWORD PTR _average_point$[ebp+8]
  00687	f3 0f 11 45 b0	 movss	 DWORD PTR _cover_pos$[ebp+8], xmm0

; 1416 : 
; 1417 : 		memset (&terrain_point_data, 0, sizeof (terrain_3d_point_data));

  0068c	6a 2c		 push	 44			; 0000002cH
  0068e	6a 00		 push	 0
  00690	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _terrain_point_data$[ebp]
  00696	50		 push	 eax
  00697	e8 00 00 00 00	 call	 _memset
  0069c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1418 : 		
; 1419 : 		cover_vec.x = cover_pos.x - target_pos->x;

  0069f	8b 45 d8	 mov	 eax, DWORD PTR _target_pos$[ebp]
  006a2	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _cover_pos$[ebp]
  006a7	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  006ab	f3 0f 11 45 b4	 movss	 DWORD PTR _cover_vec$[ebp], xmm0

; 1420 : 		cover_vec.y = 0.0;

  006b0	0f 57 c0	 xorps	 xmm0, xmm0
  006b3	f3 0f 11 45 b8	 movss	 DWORD PTR _cover_vec$[ebp+4], xmm0

; 1421 : 		cover_vec.z = cover_pos.z - target_pos->z;

  006b8	8b 45 d8	 mov	 eax, DWORD PTR _target_pos$[ebp]
  006bb	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _cover_pos$[ebp+8]
  006c0	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [eax+8]
  006c5	f3 0f 11 45 bc	 movss	 DWORD PTR _cover_vec$[ebp+8], xmm0

; 1422 : 	
; 1423 : 		normalise_any_3d_vector (&cover_vec);

  006ca	8d 45 b4	 lea	 eax, DWORD PTR _cover_vec$[ebp]
  006cd	50		 push	 eax
  006ce	e8 00 00 00 00	 call	 ?normalise_any_3d_vector@@YGMPAUVEC3D@@@Z ; normalise_any_3d_vector
  006d3	dd d8		 fstp	 ST(0)

; 1424 : 	
; 1425 : 		//
; 1426 : 		// determine cover Y position (complicated since cover pos could be in a river "gorge")
; 1427 : 		//
; 1428 : 		{
; 1429 : 			vec3d
; 1430 : 				test_pos;
; 1431 : 	
; 1432 : 			// find height of forest tops
; 1433 : 			test_pos.x = average_point.x - (normal->x * 10.0);

  006d5	f3 0f 5a 45 c0	 cvtss2sd xmm0, DWORD PTR _average_point$[ebp]
  006da	8b 45 d0	 mov	 eax, DWORD PTR _normal$[ebp]
  006dd	f3 0f 5a 08	 cvtss2sd xmm1, DWORD PTR [eax]
  006e1	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@4024000000000000
  006e9	f2 0f 5c c1	 subsd	 xmm0, xmm1
  006ed	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  006f1	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _test_pos$1[ebp], xmm0

; 1434 : 			test_pos.z = average_point.z - (normal->z * 10.0);

  006f9	f3 0f 5a 45 c8	 cvtss2sd xmm0, DWORD PTR _average_point$[ebp+8]
  006fe	8b 45 d0	 mov	 eax, DWORD PTR _normal$[ebp]
  00701	f3 0f 5a 48 08	 cvtss2sd xmm1, DWORD PTR [eax+8]
  00706	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@4024000000000000
  0070e	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00712	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00716	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _test_pos$1[ebp+8], xmm0

; 1435 : 	
; 1436 : 			bound_position_to_map_area (&test_pos);

  0071e	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _test_pos$1[ebp]
  00724	50		 push	 eax
  00725	e8 00 00 00 00	 call	 ?bound_position_to_map_area@@YGHPAUVEC3D@@@Z ; bound_position_to_map_area

; 1437 : 
; 1438 : 			test_pos.y = get_3d_terrain_point_data (test_pos.x, test_pos.z, &terrain_point_data);

  0072a	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _terrain_point_data$[ebp]
  00730	50		 push	 eax
  00731	51		 push	 ecx
  00732	f3 0f 10 85 68
	ff ff ff	 movss	 xmm0, DWORD PTR _test_pos$1[ebp+8]
  0073a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0073f	51		 push	 ecx
  00740	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _test_pos$1[ebp]
  00748	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0074d	e8 00 00 00 00	 call	 ?get_3d_terrain_point_data@@YGMMMPAUTERRAIN_3D_POINT_DATA@@@Z ; get_3d_terrain_point_data
  00752	d9 9d 64 ff ff
	ff		 fstp	 DWORD PTR _test_pos$1[ebp+4]

; 1439 : 			test_pos.y -= 6.0;	//magic number

  00758	f3 0f 5a 85 64
	ff ff ff	 cvtss2sd xmm0, DWORD PTR _test_pos$1[ebp+4]
  00760	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@4018000000000000
  00768	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0076c	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _test_pos$1[ebp+4], xmm0

; 1440 : 	
; 1441 : 			// find standard cover position height
; 1442 : 			bound_position_to_map_area (&cover_pos);

  00774	8d 45 a8	 lea	 eax, DWORD PTR _cover_pos$[ebp]
  00777	50		 push	 eax
  00778	e8 00 00 00 00	 call	 ?bound_position_to_map_area@@YGHPAUVEC3D@@@Z ; bound_position_to_map_area

; 1443 : 
; 1444 : 			cover_pos.y = get_3d_terrain_point_data (cover_pos.x, cover_pos.z, &terrain_point_data);

  0077d	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _terrain_point_data$[ebp]
  00783	50		 push	 eax
  00784	51		 push	 ecx
  00785	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _cover_pos$[ebp+8]
  0078a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0078f	51		 push	 ecx
  00790	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _cover_pos$[ebp]
  00795	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0079a	e8 00 00 00 00	 call	 ?get_3d_terrain_point_data@@YGMMMPAUTERRAIN_3D_POINT_DATA@@@Z ; get_3d_terrain_point_data
  0079f	d9 5d ac	 fstp	 DWORD PTR _cover_pos$[ebp+4]

; 1445 : 			cover_pos.y += GUIDE_COVER_ALTITUDE;

  007a2	f3 0f 5a 45 ac	 cvtss2sd xmm0, DWORD PTR _cover_pos$[ebp+4]
  007a7	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@4014000000000000
  007af	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  007b3	f3 0f 11 45 ac	 movss	 DWORD PTR _cover_pos$[ebp+4], xmm0

; 1446 : 	
; 1447 : 			// use the larger of the two
; 1448 : 			cover_pos.y = max(cover_pos.y, test_pos.y);

  007b8	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _test_pos$1[ebp+4]
  007be	50		 push	 eax
  007bf	8d 4d ac	 lea	 ecx, DWORD PTR _cover_pos$[ebp+4]
  007c2	51		 push	 ecx
  007c3	e8 00 00 00 00	 call	 ??$max@M@std@@YGABMABM0@Z ; std::max<float>
  007c8	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  007cc	f3 0f 11 45 ac	 movss	 DWORD PTR _cover_pos$[ebp+4], xmm0

; 1449 : 		}
; 1450 : 	
; 1451 : 		//
; 1452 : 		// Check forest is facing away from target
; 1453 : 		//
; 1454 : 		
; 1455 : 		if (get_3d_unit_vector_dot_product (normal, &cover_vec) <= 0.0)

  007d1	8d 45 b4	 lea	 eax, DWORD PTR _cover_vec$[ebp]
  007d4	50		 push	 eax
  007d5	8b 4d d0	 mov	 ecx, DWORD PTR _normal$[ebp]
  007d8	51		 push	 ecx
  007d9	e8 00 00 00 00	 call	 ?get_3d_unit_vector_dot_product@@YGMPBUVEC3D@@0@Z ; get_3d_unit_vector_dot_product
  007de	dd 9d 18 ff ff
	ff		 fstp	 QWORD PTR tv616[ebp]
  007e4	0f 57 c0	 xorps	 xmm0, xmm0
  007e7	66 0f 2f 85 18
	ff ff ff	 comisd	 xmm0, QWORD PTR tv616[ebp]
  007ef	72 05		 jb	 SHORT $LN16@update_gui

; 1456 : 		{
; 1457 : 			continue;

  007f1	e9 cb fc ff ff	 jmp	 $LN2@update_gui
$LN16@update_gui:

; 1458 : 		}
; 1459 : 	
; 1460 : 		//
; 1461 : 		// Check position is not on top of more forest
; 1462 : 		//
; 1463 : 	
; 1464 : 		if (get_terrain_type_class (get_3d_terrain_point_data_type (&terrain_point_data)) == TERRAIN_CLASS_FOREST)

  007f6	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _terrain_point_data$[ebp]
  007fc	50		 push	 eax
  007fd	e8 00 00 00 00	 call	 ?get_3d_terrain_point_data_type@@YGHPAUTERRAIN_3D_POINT_DATA@@@Z ; get_3d_terrain_point_data_type
  00802	50		 push	 eax
  00803	e8 00 00 00 00	 call	 ?get_terrain_type_class@@YG?AW4TERRAIN_CLASSES@@H@Z ; get_terrain_type_class
  00808	83 f8 02	 cmp	 eax, 2
  0080b	75 05		 jne	 SHORT $LN17@update_gui

; 1465 : 		{
; 1466 : 			continue;

  0080d	e9 af fc ff ff	 jmp	 $LN2@update_gui
$LN17@update_gui:

; 1467 : 		}
; 1468 : 	
; 1469 : 		//
; 1470 : 		// assess cover position
; 1471 : 		//
; 1472 : 		
; 1473 : 		score = assess_cover_position (en, aggressor, target, &cover_pos, NULL);

  00812	6a 00		 push	 0
  00814	8d 45 a8	 lea	 eax, DWORD PTR _cover_pos$[ebp]
  00817	50		 push	 eax
  00818	8b 4d f8	 mov	 ecx, DWORD PTR _target$[ebp]
  0081b	51		 push	 ecx
  0081c	8b 55 fc	 mov	 edx, DWORD PTR _aggressor$[ebp]
  0081f	52		 push	 edx
  00820	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00823	50		 push	 eax
  00824	e8 00 00 00 00	 call	 ?assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z ; assess_cover_position
  00829	88 85 6f ff ff
	ff		 mov	 BYTE PTR _score$[ebp], al

; 1474 : 	
; 1475 : 		#if DEBUG_MODULE
; 1476 : 
; 1477 : 		if (aggressor == get_external_view_entity ())
; 1478 : 		{
; 1479 : 			debug_filtered_log ("GD_COVER: (%d - %d) SCORE %d",
; 1480 : 										 raw->current_seek_cover_result.search_mode,
; 1481 : 										 count,
; 1482 : 										 score);
; 1483 : 		
; 1484 : 			create_debug_3d_line (aggressor_pos, &cover_pos, sys_col_ultramarine, 2.0);
; 1485 : 
; 1486 : 			create_debug_3d_line (aggressor_pos, target_pos, sys_col_red, 0.0);
; 1487 : 		}
; 1488 : 		#endif
; 1489 : 
; 1490 : 		check_count ++;

  0082f	8b 45 dc	 mov	 eax, DWORD PTR _check_count$[ebp]
  00832	83 c0 01	 add	 eax, 1
  00835	89 45 dc	 mov	 DWORD PTR _check_count$[ebp], eax

; 1491 : 
; 1492 : 		if (check_count >= MAX_COVER_FOREST_POSITION_CHECKS_PER_FRAME)

  00838	83 7d dc 02	 cmp	 DWORD PTR _check_count$[ebp], 2
  0083c	7c 07		 jl	 SHORT $LN18@update_gui

; 1493 : 		{
; 1494 : 			return check_count;

  0083e	8b 45 dc	 mov	 eax, DWORD PTR _check_count$[ebp]
  00841	eb 0f		 jmp	 SHORT $LN1@update_gui

; 1495 : 		}
; 1496 : 		else

  00843	eb 05		 jmp	 SHORT $LN19@update_gui
$LN18@update_gui:

; 1497 : 		{
; 1498 : 			continue;

  00845	e9 77 fc ff ff	 jmp	 $LN2@update_gui
$LN19@update_gui:

; 1499 : 		}
; 1500 : 	}

  0084a	e9 72 fc ff ff	 jmp	 $LN2@update_gui
$LN3@update_gui:

; 1501 : 
; 1502 : 	return check_count;

  0084f	8b 45 dc	 mov	 eax, DWORD PTR _check_count$[ebp]
$LN1@update_gui:

; 1503 : }

  00852	5f		 pop	 edi
  00853	5e		 pop	 esi
  00854	5b		 pop	 ebx
  00855	8b e5		 mov	 esp, ebp
  00857	5d		 pop	 ebp
  00858	c2 04 00	 ret	 4
?update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z ENDP ; update_guide_seek_cover_forest_search
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\guide\gd_cover.c
;	COMDAT ?update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z
_TEXT	SEGMENT
tv578 = -168						; size = 8
tv307 = -168						; size = 4
tv278 = -168						; size = 4
tv258 = -168						; size = 4
tv237 = -168						; size = 4
tv209 = -168						; size = 4
tv185 = -168						; size = 4
tv161 = -168						; size = 4
tv139 = -168						; size = 4
tv89 = -168						; size = 4
tv299 = -164						; size = 4
tv270 = -164						; size = 4
tv250 = -164						; size = 4
tv229 = -164						; size = 4
tv202 = -164						; size = 4
tv177 = -164						; size = 4
tv153 = -164						; size = 4
tv132 = -164						; size = 4
tv81 = -164						; size = 4
_size$1 = -96						; size = 4
_d$2 = -92						; size = 12
_bounding_box$3 = -80					; size = 4
_score$ = -73						; size = 1
_distance$ = -72					; size = 4
_cover_pos$ = -68					; size = 12
_cover_vec$ = -56					; size = 12
_structure_pos$ = -44					; size = 4
_target_pos$ = -40					; size = 4
_search_count$ = -36					; size = 4
_count$ = -32						; size = 4
_raw$ = -28						; size = 4
_structure$ = -24					; size = 4
_sector$ = -20						; size = 4
_task$ = -16						; size = 4
_wp$ = -12						; size = 4
_target$ = -8						; size = 4
_aggressor$ = -4					; size = 4
_en$ = 8						; size = 4
?update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z PROC ; update_guide_seek_cover_fixed_structure_search, COMDAT

; 1018 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1019 : 	entity
; 1020 : 		*aggressor,
; 1021 : 		*target,
; 1022 : 		*wp,
; 1023 : 		*task,
; 1024 : 		*sector,
; 1025 : 		*structure;
; 1026 : 
; 1027 : 	guide
; 1028 : 		*raw;
; 1029 : 
; 1030 : 	int
; 1031 : 		count,
; 1032 : 		search_count;
; 1033 : 
; 1034 : 	vec3d
; 1035 : 		*target_pos,
; 1036 : 		*structure_pos,
; 1037 : 		cover_vec,
; 1038 : 		cover_pos;
; 1039 : 
; 1040 : 	float
; 1041 : 		distance;
; 1042 : 
; 1043 : 	unsigned char
; 1044 : 		score;
; 1045 : 
; 1046 : 	get_local_guide_entity_pointers (en, &aggressor, &wp, &task, &target);

  0000c	8d 45 f8	 lea	 eax, DWORD PTR _target$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f0	 lea	 ecx, DWORD PTR _task$[ebp]
  00013	51		 push	 ecx
  00014	8d 55 f4	 lea	 edx, DWORD PTR _wp$[ebp]
  00017	52		 push	 edx
  00018	8d 45 fc	 lea	 eax, DWORD PTR _aggressor$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ?get_local_guide_entity_pointers@@YGXPAUENTITY@@PAPAU1@111@Z ; get_local_guide_entity_pointers

; 1047 : 
; 1048 : 	raw = (guide *) get_local_entity_data (en);

  00025	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00028	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002b	89 4d e4	 mov	 DWORD PTR _raw$[ebp], ecx

; 1049 : 
; 1050 : 	//
; 1051 : 	// get search sector
; 1052 : 	//
; 1053 : 	
; 1054 : 	if (raw->current_seek_cover_result.sector)

  0002e	8b 45 e4	 mov	 eax, DWORD PTR _raw$[ebp]
  00031	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00037	c1 e9 04	 shr	 ecx, 4
  0003a	83 e1 01	 and	 ecx, 1
  0003d	0f 84 33 01 00
	00		 je	 $LN4@update_gui

; 1055 : 	{
; 1056 : 		sector = get_local_entity_parent (target, LIST_TYPE_SECTOR);

  00043	83 7d f8 00	 cmp	 DWORD PTR _target$[ebp], 0
  00047	74 0d		 je	 SHORT $LN19@update_gui
  00049	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	89 8d 5c ff ff
	ff		 mov	 DWORD PTR tv81[ebp], ecx
  00054	eb 24		 jmp	 SHORT $LN20@update_gui
$LN19@update_gui:
  00056	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  0005c	83 c2 26	 add	 edx, 38			; 00000026H
  0005f	52		 push	 edx
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00070	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv81[ebp], 0
$LN20@update_gui:
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	85 c9		 test	 ecx, ecx
  00081	74 0c		 je	 SHORT $LN21@update_gui
  00083	c7 85 58 ff ff
	ff 21 00 00 00	 mov	 DWORD PTR tv89[ebp], 33	; 00000021H
  0008d	eb 24		 jmp	 SHORT $LN22@update_gui
$LN21@update_gui:
  0008f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  00095	83 c2 26	 add	 edx, 38			; 00000026H
  00098	52		 push	 edx
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  000a9	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv89[ebp], 0
$LN22@update_gui:
  000b3	6a 21		 push	 33			; 00000021H
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _target$[ebp]
  000b8	51		 push	 ecx
  000b9	69 95 5c ff ff
	ff b4 00 00 00	 imul	 edx, DWORD PTR tv81[ebp], 180
  000c3	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv89[ebp]
  000c9	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  000d0	ff d1		 call	 ecx
  000d2	89 45 ec	 mov	 DWORD PTR _sector$[ebp], eax

; 1057 : 
; 1058 : 		if (sector == get_local_entity_parent (aggressor, LIST_TYPE_SECTOR))

  000d5	83 7d fc 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  000d9	74 0d		 je	 SHORT $LN23@update_gui
  000db	8b 45 fc	 mov	 eax, DWORD PTR _aggressor$[ebp]
  000de	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e0	89 8d 5c ff ff
	ff		 mov	 DWORD PTR tv132[ebp], ecx
  000e6	eb 20		 jmp	 SHORT $LN24@update_gui
$LN23@update_gui:
  000e8	68 22 04 00 00	 push	 1058			; 00000422H
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  000f2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  000f8	52		 push	 edx
  000f9	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  000fe	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv132[ebp], 0
$LN24@update_gui:
  00108	b8 01 00 00 00	 mov	 eax, 1
  0010d	85 c0		 test	 eax, eax
  0010f	74 0c		 je	 SHORT $LN25@update_gui
  00111	c7 85 58 ff ff
	ff 21 00 00 00	 mov	 DWORD PTR tv139[ebp], 33 ; 00000021H
  0011b	eb 20		 jmp	 SHORT $LN26@update_gui
$LN25@update_gui:
  0011d	68 22 04 00 00	 push	 1058			; 00000422H
  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00127	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  0012d	51		 push	 ecx
  0012e	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00133	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv139[ebp], 0
$LN26@update_gui:
  0013d	6a 21		 push	 33			; 00000021H
  0013f	8b 55 fc	 mov	 edx, DWORD PTR _aggressor$[ebp]
  00142	52		 push	 edx
  00143	69 85 5c ff ff
	ff b4 00 00 00	 imul	 eax, DWORD PTR tv132[ebp], 180
  0014d	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR tv139[ebp]
  00153	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR ?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[eax+ecx*4]
  0015a	ff d2		 call	 edx
  0015c	39 45 ec	 cmp	 DWORD PTR _sector$[ebp], eax
  0015f	75 10		 jne	 SHORT $LN6@update_gui

; 1059 : 		{
; 1060 : 			set_guide_seek_cover_next_search_mode (en);

  00161	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 ?set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z ; set_guide_seek_cover_next_search_mode

; 1061 : 
; 1062 : 			return FALSE;

  0016a	33 c0		 xor	 eax, eax
  0016c	e9 7d 06 00 00	 jmp	 $LN1@update_gui
$LN6@update_gui:

; 1063 : 		}
; 1064 : 	}
; 1065 : 	else

  00171	e9 92 00 00 00	 jmp	 $LN5@update_gui
$LN4@update_gui:

; 1066 : 	{
; 1067 : 		sector = get_local_entity_parent (aggressor, LIST_TYPE_SECTOR);

  00176	83 7d fc 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  0017a	74 0d		 je	 SHORT $LN27@update_gui
  0017c	8b 45 fc	 mov	 eax, DWORD PTR _aggressor$[ebp]
  0017f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00181	89 8d 5c ff ff
	ff		 mov	 DWORD PTR tv153[ebp], ecx
  00187	eb 24		 jmp	 SHORT $LN28@update_gui
$LN27@update_gui:
  00189	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  0018f	83 c2 31	 add	 edx, 49			; 00000031H
  00192	52		 push	 edx
  00193	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00198	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  001a3	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
$LN28@update_gui:
  001ad	b9 01 00 00 00	 mov	 ecx, 1
  001b2	85 c9		 test	 ecx, ecx
  001b4	74 0c		 je	 SHORT $LN29@update_gui
  001b6	c7 85 58 ff ff
	ff 21 00 00 00	 mov	 DWORD PTR tv161[ebp], 33 ; 00000021H
  001c0	eb 24		 jmp	 SHORT $LN30@update_gui
$LN29@update_gui:
  001c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  001c8	83 c2 31	 add	 edx, 49			; 00000031H
  001cb	52		 push	 edx
  001cc	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  001d1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  001dc	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv161[ebp], 0
$LN30@update_gui:
  001e6	6a 21		 push	 33			; 00000021H
  001e8	8b 4d fc	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  001eb	51		 push	 ecx
  001ec	69 95 5c ff ff
	ff b4 00 00 00	 imul	 edx, DWORD PTR tv153[ebp], 180
  001f6	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv161[ebp]
  001fc	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  00203	ff d1		 call	 ecx
  00205	89 45 ec	 mov	 DWORD PTR _sector$[ebp], eax
$LN5@update_gui:

; 1068 : 	}
; 1069 : 
; 1070 : 	//
; 1071 : 	// find next object to check
; 1072 : 	//	
; 1073 : 
; 1074 : 	count = 0;

  00208	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 1075 : 
; 1076 : 	search_count = raw->current_seek_cover_result.count;

  0020f	8b 45 e4	 mov	 eax, DWORD PTR _raw$[ebp]
  00212	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00218	c1 e9 05	 shr	 ecx, 5
  0021b	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0021e	89 4d dc	 mov	 DWORD PTR _search_count$[ebp], ecx

; 1077 : 
; 1078 : 	structure = get_local_entity_first_child (sector, LIST_TYPE_SECTOR);

  00221	83 7d ec 00	 cmp	 DWORD PTR _sector$[ebp], 0
  00225	74 0d		 je	 SHORT $LN31@update_gui
  00227	8b 45 ec	 mov	 eax, DWORD PTR _sector$[ebp]
  0022a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022c	89 8d 5c ff ff
	ff		 mov	 DWORD PTR tv177[ebp], ecx
  00232	eb 24		 jmp	 SHORT $LN32@update_gui
$LN31@update_gui:
  00234	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  0023a	83 c2 3c	 add	 edx, 60			; 0000003cH
  0023d	52		 push	 edx
  0023e	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00243	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00248	50		 push	 eax
  00249	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0024e	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv177[ebp], 0
$LN32@update_gui:
  00258	b9 01 00 00 00	 mov	 ecx, 1
  0025d	85 c9		 test	 ecx, ecx
  0025f	74 0c		 je	 SHORT $LN33@update_gui
  00261	c7 85 58 ff ff
	ff 21 00 00 00	 mov	 DWORD PTR tv185[ebp], 33 ; 00000021H
  0026b	eb 24		 jmp	 SHORT $LN34@update_gui
$LN33@update_gui:
  0026d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  00273	83 c2 3c	 add	 edx, 60			; 0000003cH
  00276	52		 push	 edx
  00277	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0027c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  00281	50		 push	 eax
  00282	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00287	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv185[ebp], 0
$LN34@update_gui:
  00291	6a 21		 push	 33			; 00000021H
  00293	8b 4d ec	 mov	 ecx, DWORD PTR _sector$[ebp]
  00296	51		 push	 ecx
  00297	69 95 5c ff ff
	ff b4 00 00 00	 imul	 edx, DWORD PTR tv177[ebp], 180
  002a1	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv185[ebp]
  002a7	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_first_child@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  002ae	ff d1		 call	 ecx
  002b0	89 45 e8	 mov	 DWORD PTR _structure$[ebp], eax
$LN2@update_gui:

; 1079 : 
; 1080 : 	while (structure)

  002b3	83 7d e8 00	 cmp	 DWORD PTR _structure$[ebp], 0
  002b7	0f 84 77 01 00
	00		 je	 $LN3@update_gui

; 1081 : 	{
; 1082 : 		if (structure != target)			// just in case

  002bd	8b 45 e8	 mov	 eax, DWORD PTR _structure$[ebp]
  002c0	3b 45 f8	 cmp	 eax, DWORD PTR _target$[ebp]
  002c3	0f 84 d4 00 00
	00		 je	 $LN9@update_gui

; 1083 : 		{
; 1084 : 			if (check_fixed_structure_search_object_type (en, structure))

  002c9	8b 45 e8	 mov	 eax, DWORD PTR _structure$[ebp]
  002cc	50		 push	 eax
  002cd	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  002d0	51		 push	 ecx
  002d1	e8 00 00 00 00	 call	 ?check_fixed_structure_search_object_type@@YGHPAUENTITY@@0@Z ; check_fixed_structure_search_object_type
  002d6	85 c0		 test	 eax, eax
  002d8	0f 84 bf 00 00
	00		 je	 $LN9@update_gui

; 1085 : 			{
; 1086 : 				if (!get_local_entity_first_child (structure, LIST_TYPE_TARGET))	// don't hide behind something that is going to be blown up !

  002de	83 7d e8 00	 cmp	 DWORD PTR _structure$[ebp], 0
  002e2	74 0d		 je	 SHORT $LN35@update_gui
  002e4	8b 45 e8	 mov	 eax, DWORD PTR _structure$[ebp]
  002e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e9	89 8d 5c ff ff
	ff		 mov	 DWORD PTR tv202[ebp], ecx
  002ef	eb 20		 jmp	 SHORT $LN36@update_gui
$LN35@update_gui:
  002f1	68 3e 04 00 00	 push	 1086			; 0000043eH
  002f6	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  002fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00301	52		 push	 edx
  00302	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00307	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv202[ebp], 0
$LN36@update_gui:
  00311	b8 01 00 00 00	 mov	 eax, 1
  00316	85 c0		 test	 eax, eax
  00318	74 0c		 je	 SHORT $LN37@update_gui
  0031a	c7 85 58 ff ff
	ff 26 00 00 00	 mov	 DWORD PTR tv209[ebp], 38 ; 00000026H
  00324	eb 20		 jmp	 SHORT $LN38@update_gui
$LN37@update_gui:
  00326	68 3e 04 00 00	 push	 1086			; 0000043eH
  0032b	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00330	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  00336	51		 push	 ecx
  00337	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0033c	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv209[ebp], 0
$LN38@update_gui:
  00346	6a 26		 push	 38			; 00000026H
  00348	8b 55 e8	 mov	 edx, DWORD PTR _structure$[ebp]
  0034b	52		 push	 edx
  0034c	69 85 5c ff ff
	ff b4 00 00 00	 imul	 eax, DWORD PTR tv202[ebp], 180
  00356	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR tv209[ebp]
  0035c	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR ?fn_get_local_entity_first_child@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[eax+ecx*4]
  00363	ff d2		 call	 edx
  00365	85 c0		 test	 eax, eax
  00367	75 34		 jne	 SHORT $LN9@update_gui

; 1087 : 				{
; 1088 : 					ASSERT (count < SEEK_COUNT_LIMIT);

  00369	83 7d e0 20	 cmp	 DWORD PTR _count$[ebp], 32 ; 00000020H
  0036d	7c 18		 jl	 SHORT $LN10@update_gui
  0036f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  00374	83 c0 46	 add	 eax, 70			; 00000046H
  00377	50		 push	 eax
  00378	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0037d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@JBLGADFG@count?5?$DM?5SEEK_COUNT_LIMIT@
  00382	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN10@update_gui:

; 1089 : 
; 1090 : 					//
; 1091 : 					// is this the next object to check ?
; 1092 : 					//
; 1093 : 	
; 1094 : 					if (count == search_count)

  00387	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  0038a	3b 45 dc	 cmp	 eax, DWORD PTR _search_count$[ebp]
  0038d	75 05		 jne	 SHORT $LN11@update_gui

; 1095 : 					{
; 1096 : 						break;

  0038f	e9 a0 00 00 00	 jmp	 $LN3@update_gui
$LN11@update_gui:

; 1097 : 					}
; 1098 : 	
; 1099 : 					count ++;

  00394	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  00397	83 c0 01	 add	 eax, 1
  0039a	89 45 e0	 mov	 DWORD PTR _count$[ebp], eax
$LN9@update_gui:

; 1100 : 				}
; 1101 : 			}
; 1102 : 		}
; 1103 : 
; 1104 : 		structure = get_local_entity_child_succ (structure, LIST_TYPE_SECTOR);

  0039d	83 7d e8 00	 cmp	 DWORD PTR _structure$[ebp], 0
  003a1	74 0d		 je	 SHORT $LN39@update_gui
  003a3	8b 45 e8	 mov	 eax, DWORD PTR _structure$[ebp]
  003a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a8	89 8d 5c ff ff
	ff		 mov	 DWORD PTR tv229[ebp], ecx
  003ae	eb 24		 jmp	 SHORT $LN40@update_gui
$LN39@update_gui:
  003b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  003b6	83 c2 56	 add	 edx, 86			; 00000056H
  003b9	52		 push	 edx
  003ba	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  003bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  003c4	50		 push	 eax
  003c5	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  003ca	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv229[ebp], 0
$LN40@update_gui:
  003d4	b9 01 00 00 00	 mov	 ecx, 1
  003d9	85 c9		 test	 ecx, ecx
  003db	74 0c		 je	 SHORT $LN41@update_gui
  003dd	c7 85 58 ff ff
	ff 21 00 00 00	 mov	 DWORD PTR tv237[ebp], 33 ; 00000021H
  003e7	eb 24		 jmp	 SHORT $LN42@update_gui
$LN41@update_gui:
  003e9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  003ef	83 c2 56	 add	 edx, 86			; 00000056H
  003f2	52		 push	 edx
  003f3	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  003f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  003fd	50		 push	 eax
  003fe	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00403	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv237[ebp], 0
$LN42@update_gui:
  0040d	6a 21		 push	 33			; 00000021H
  0040f	8b 4d e8	 mov	 ecx, DWORD PTR _structure$[ebp]
  00412	51		 push	 ecx
  00413	69 95 5c ff ff
	ff b4 00 00 00	 imul	 edx, DWORD PTR tv229[ebp], 180
  0041d	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv237[ebp]
  00423	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_child_succ@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  0042a	ff d1		 call	 ecx
  0042c	89 45 e8	 mov	 DWORD PTR _structure$[ebp], eax

; 1105 : 	}

  0042f	e9 7f fe ff ff	 jmp	 $LN2@update_gui
$LN3@update_gui:

; 1106 : 
; 1107 : 	//
; 1108 : 	// find cover position for structure
; 1109 : 	//
; 1110 : 
; 1111 : 	if (structure)

  00434	83 7d e8 00	 cmp	 DWORD PTR _structure$[ebp], 0
  00438	0f 84 13 03 00
	00		 je	 $LN12@update_gui

; 1112 : 	{
; 1113 : 		//
; 1114 : 		// find vector from target to structure
; 1115 : 		//
; 1116 : 		
; 1117 : 		target_pos = get_local_entity_vec3d_ptr (target, VEC3D_TYPE_POSITION);

  0043e	83 7d f8 00	 cmp	 DWORD PTR _target$[ebp], 0
  00442	74 0d		 je	 SHORT $LN43@update_gui
  00444	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  00447	8b 08		 mov	 ecx, DWORD PTR [eax]
  00449	89 8d 5c ff ff
	ff		 mov	 DWORD PTR tv250[ebp], ecx
  0044f	eb 24		 jmp	 SHORT $LN44@update_gui
$LN43@update_gui:
  00451	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  00457	83 c2 63	 add	 edx, 99			; 00000063H
  0045a	52		 push	 edx
  0045b	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00460	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00465	50		 push	 eax
  00466	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0046b	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv250[ebp], 0
$LN44@update_gui:
  00475	b9 01 00 00 00	 mov	 ecx, 1
  0047a	85 c9		 test	 ecx, ecx
  0047c	74 0c		 je	 SHORT $LN45@update_gui
  0047e	c7 85 58 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv258[ebp], 8
  00488	eb 24		 jmp	 SHORT $LN46@update_gui
$LN45@update_gui:
  0048a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  00490	83 c2 63	 add	 edx, 99			; 00000063H
  00493	52		 push	 edx
  00494	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00499	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  0049e	50		 push	 eax
  0049f	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  004a4	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv258[ebp], 0
$LN46@update_gui:
  004ae	6a 08		 push	 8
  004b0	8b 4d f8	 mov	 ecx, DWORD PTR _target$[ebp]
  004b3	51		 push	 ecx
  004b4	6b 95 5c ff ff
	ff 60		 imul	 edx, DWORD PTR tv250[ebp], 96
  004bb	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv258[ebp]
  004c1	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA[edx+eax*4]
  004c8	ff d1		 call	 ecx
  004ca	89 45 d8	 mov	 DWORD PTR _target_pos$[ebp], eax

; 1118 : 	
; 1119 : 		structure_pos = get_local_entity_vec3d_ptr (structure, VEC3D_TYPE_POSITION);

  004cd	83 7d e8 00	 cmp	 DWORD PTR _structure$[ebp], 0
  004d1	74 0d		 je	 SHORT $LN47@update_gui
  004d3	8b 45 e8	 mov	 eax, DWORD PTR _structure$[ebp]
  004d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  004d8	89 8d 5c ff ff
	ff		 mov	 DWORD PTR tv270[ebp], ecx
  004de	eb 24		 jmp	 SHORT $LN48@update_gui
$LN47@update_gui:
  004e0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  004e6	83 c2 65	 add	 edx, 101		; 00000065H
  004e9	52		 push	 edx
  004ea	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  004ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  004f4	50		 push	 eax
  004f5	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  004fa	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv270[ebp], 0
$LN48@update_gui:
  00504	b9 01 00 00 00	 mov	 ecx, 1
  00509	85 c9		 test	 ecx, ecx
  0050b	74 0c		 je	 SHORT $LN49@update_gui
  0050d	c7 85 58 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv278[ebp], 8
  00517	eb 24		 jmp	 SHORT $LN50@update_gui
$LN49@update_gui:
  00519	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  0051f	83 c2 65	 add	 edx, 101		; 00000065H
  00522	52		 push	 edx
  00523	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00528	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_vec3d_type_message@@3PBDB ; overload_invalid_vec3d_type_message
  0052d	50		 push	 eax
  0052e	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00533	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv278[ebp], 0
$LN50@update_gui:
  0053d	6a 08		 push	 8
  0053f	8b 4d e8	 mov	 ecx, DWORD PTR _structure$[ebp]
  00542	51		 push	 ecx
  00543	6b 95 5c ff ff
	ff 60		 imul	 edx, DWORD PTR tv270[ebp], 96
  0054a	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv278[ebp]
  00550	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_vec3d_ptr@@3PAY0BI@P6GPAUVEC3D@@PAUENTITY@@W4VEC3D_TYPES@@@ZA[edx+eax*4]
  00557	ff d1		 call	 ecx
  00559	89 45 d4	 mov	 DWORD PTR _structure_pos$[ebp], eax

; 1120 : 	
; 1121 : 		cover_vec.x = structure_pos->x - target_pos->x;

  0055c	8b 45 d4	 mov	 eax, DWORD PTR _structure_pos$[ebp]
  0055f	8b 4d d8	 mov	 ecx, DWORD PTR _target_pos$[ebp]
  00562	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00566	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0056a	f3 0f 11 45 c8	 movss	 DWORD PTR _cover_vec$[ebp], xmm0

; 1122 : 		cover_vec.y = 0.0;

  0056f	0f 57 c0	 xorps	 xmm0, xmm0
  00572	f3 0f 11 45 cc	 movss	 DWORD PTR _cover_vec$[ebp+4], xmm0

; 1123 : 		cover_vec.z = structure_pos->z - target_pos->z;

  00577	8b 45 d4	 mov	 eax, DWORD PTR _structure_pos$[ebp]
  0057a	8b 4d d8	 mov	 ecx, DWORD PTR _target_pos$[ebp]
  0057d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00582	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00587	f3 0f 11 45 d0	 movss	 DWORD PTR _cover_vec$[ebp+8], xmm0

; 1124 : 	
; 1125 : 		distance = normalise_any_3d_vector (&cover_vec);

  0058c	8d 45 c8	 lea	 eax, DWORD PTR _cover_vec$[ebp]
  0058f	50		 push	 eax
  00590	e8 00 00 00 00	 call	 ?normalise_any_3d_vector@@YGMPAUVEC3D@@@Z ; normalise_any_3d_vector
  00595	d9 5d b8	 fstp	 DWORD PTR _distance$[ebp]

; 1126 : 	
; 1127 : 		//
; 1128 : 		// find size of structure, and determine how far behind it the aggressor should be
; 1129 : 		//
; 1130 : 	
; 1131 : 		{
; 1132 : 			struct OBJECT_3D_BOUNDS
; 1133 : 				*bounding_box;
; 1134 : 	
; 1135 : 			vec3d
; 1136 : 				d;
; 1137 : 	
; 1138 : 			float
; 1139 : 				size;
; 1140 : 	
; 1141 : 			bounding_box = get_object_3d_bounding_box_without_lines (get_local_entity_int_value (structure, INT_TYPE_OBJECT_3D_SHAPE));

  00598	83 7d e8 00	 cmp	 DWORD PTR _structure$[ebp], 0
  0059c	74 0d		 je	 SHORT $LN51@update_gui
  0059e	8b 45 e8	 mov	 eax, DWORD PTR _structure$[ebp]
  005a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  005a3	89 8d 5c ff ff
	ff		 mov	 DWORD PTR tv299[ebp], ecx
  005a9	eb 24		 jmp	 SHORT $LN52@update_gui
$LN51@update_gui:
  005ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  005b1	83 c2 7b	 add	 edx, 123		; 0000007bH
  005b4	52		 push	 edx
  005b5	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  005ba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  005bf	50		 push	 eax
  005c0	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  005c5	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv299[ebp], 0
$LN52@update_gui:
  005cf	b9 01 00 00 00	 mov	 ecx, 1
  005d4	85 c9		 test	 ecx, ecx
  005d6	74 0c		 je	 SHORT $LN53@update_gui
  005d8	c7 85 58 ff ff
	ff 92 00 00 00	 mov	 DWORD PTR tv307[ebp], 146 ; 00000092H
  005e2	eb 24		 jmp	 SHORT $LN54@update_gui
$LN53@update_gui:
  005e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  005ea	83 c2 7b	 add	 edx, 123		; 0000007bH
  005ed	52		 push	 edx
  005ee	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  005f3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  005f8	50		 push	 eax
  005f9	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  005fe	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv307[ebp], 0
$LN54@update_gui:
  00608	68 92 00 00 00	 push	 146			; 00000092H
  0060d	8b 4d e8	 mov	 ecx, DWORD PTR _structure$[ebp]
  00610	51		 push	 ecx
  00611	69 95 5c ff ff
	ff 5c 04 00 00	 imul	 edx, DWORD PTR tv299[ebp], 1116
  0061b	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv307[ebp]
  00621	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[edx+eax*4]
  00628	ff d1		 call	 ecx
  0062a	50		 push	 eax
  0062b	e8 00 00 00 00	 call	 ?get_object_3d_bounding_box_without_lines@@YGPAUOBJECT_3D_BOUNDS@@H@Z ; get_object_3d_bounding_box_without_lines
  00630	89 45 b0	 mov	 DWORD PTR _bounding_box$3[ebp], eax

; 1142 : 	
; 1143 : 			ASSERT (bounding_box);

  00633	83 7d b0 00	 cmp	 DWORD PTR _bounding_box$3[ebp], 0
  00637	75 18		 jne	 SHORT $LN13@update_gui
  00639	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z@4JA
  0063e	83 c0 7d	 add	 eax, 125		; 0000007dH
  00641	50		 push	 eax
  00642	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00647	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LOLJEHA@bounding_box@
  0064c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN13@update_gui:

; 1144 : 	
; 1145 : 			d.x = bounding_box->xmax - bounding_box->xmin;

  00651	8b 45 b0	 mov	 eax, DWORD PTR _bounding_box$3[ebp]
  00654	8b 4d b0	 mov	 ecx, DWORD PTR _bounding_box$3[ebp]
  00657	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0065c	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00660	f3 0f 11 45 a4	 movss	 DWORD PTR _d$2[ebp], xmm0

; 1146 : 			d.y = 0.0;

  00665	0f 57 c0	 xorps	 xmm0, xmm0
  00668	f3 0f 11 45 a8	 movss	 DWORD PTR _d$2[ebp+4], xmm0

; 1147 : 			d.z = bounding_box->zmax - bounding_box->zmin;

  0066d	8b 45 b0	 mov	 eax, DWORD PTR _bounding_box$3[ebp]
  00670	8b 4d b0	 mov	 ecx, DWORD PTR _bounding_box$3[ebp]
  00673	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00678	f3 0f 5c 41 10	 subss	 xmm0, DWORD PTR [ecx+16]
  0067d	f3 0f 11 45 ac	 movss	 DWORD PTR _d$2[ebp+8], xmm0

; 1148 : 	
; 1149 : 			size = normalise_any_3d_vector (&d);

  00682	8d 45 a4	 lea	 eax, DWORD PTR _d$2[ebp]
  00685	50		 push	 eax
  00686	e8 00 00 00 00	 call	 ?normalise_any_3d_vector@@YGMPAUVEC3D@@@Z ; normalise_any_3d_vector
  0068b	d9 5d a0	 fstp	 DWORD PTR _size$1[ebp]

; 1150 : 	
; 1151 : 			distance += (size * 0.5);		// to clear the structure

  0068e	f3 0f 5a 45 a0	 cvtss2sd xmm0, DWORD PTR _size$1[ebp]
  00693	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0069b	f3 0f 5a 4d b8	 cvtss2sd xmm1, DWORD PTR _distance$[ebp]
  006a0	f2 0f 58 c8	 addsd	 xmm1, xmm0
  006a4	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  006a8	f3 0f 11 45 b8	 movss	 DWORD PTR _distance$[ebp], xmm0

; 1152 : 	
; 1153 : 			distance += 20.0;					// to leave plenty of room for the aggressor

  006ad	f3 0f 5a 45 b8	 cvtss2sd xmm0, DWORD PTR _distance$[ebp]
  006b2	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@4034000000000000
  006ba	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  006be	f3 0f 11 45 b8	 movss	 DWORD PTR _distance$[ebp], xmm0

; 1154 : 		}
; 1155 : 	
; 1156 : 		//
; 1157 : 		// find cover position
; 1158 : 		//
; 1159 : 	
; 1160 : 		cover_pos.x = target_pos->x + (cover_vec.x * distance);

  006c3	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _cover_vec$[ebp]
  006c8	f3 0f 59 45 b8	 mulss	 xmm0, DWORD PTR _distance$[ebp]
  006cd	8b 45 d8	 mov	 eax, DWORD PTR _target_pos$[ebp]
  006d0	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  006d4	f3 0f 11 45 bc	 movss	 DWORD PTR _cover_pos$[ebp], xmm0

; 1161 : 		cover_pos.z = target_pos->z + (cover_vec.z * distance);

  006d9	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _cover_vec$[ebp+8]
  006de	f3 0f 59 45 b8	 mulss	 xmm0, DWORD PTR _distance$[ebp]
  006e3	8b 45 d8	 mov	 eax, DWORD PTR _target_pos$[ebp]
  006e6	f3 0f 58 40 08	 addss	 xmm0, DWORD PTR [eax+8]
  006eb	f3 0f 11 45 c4	 movss	 DWORD PTR _cover_pos$[ebp+8], xmm0

; 1162 : 	
; 1163 : 		bound_position_to_map_area (&cover_pos);

  006f0	8d 45 bc	 lea	 eax, DWORD PTR _cover_pos$[ebp]
  006f3	50		 push	 eax
  006f4	e8 00 00 00 00	 call	 ?bound_position_to_map_area@@YGHPAUVEC3D@@@Z ; bound_position_to_map_area

; 1164 : 
; 1165 : 		cover_pos.y = get_3d_terrain_elevation (cover_pos.x, cover_pos.z) + GUIDE_COVER_ALTITUDE;

  006f9	6a 00		 push	 0
  006fb	51		 push	 ecx
  006fc	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _cover_pos$[ebp+8]
  00701	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00706	51		 push	 ecx
  00707	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _cover_pos$[ebp]
  0070c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00711	e8 00 00 00 00	 call	 ?get_3d_terrain_point_data@@YGMMMPAUTERRAIN_3D_POINT_DATA@@@Z ; get_3d_terrain_point_data
  00716	dd 9d 58 ff ff
	ff		 fstp	 QWORD PTR tv578[ebp]
  0071c	f2 0f 10 85 58
	ff ff ff	 movsd	 xmm0, QWORD PTR tv578[ebp]
  00724	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@4014000000000000
  0072c	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00730	f3 0f 11 45 c0	 movss	 DWORD PTR _cover_pos$[ebp+4], xmm0

; 1166 : 	
; 1167 : 		//
; 1168 : 		// assess cover position
; 1169 : 		//
; 1170 : 	
; 1171 : 		score = assess_cover_position (en, aggressor, target, &cover_pos, structure);

  00735	8b 45 e8	 mov	 eax, DWORD PTR _structure$[ebp]
  00738	50		 push	 eax
  00739	8d 4d bc	 lea	 ecx, DWORD PTR _cover_pos$[ebp]
  0073c	51		 push	 ecx
  0073d	8b 55 f8	 mov	 edx, DWORD PTR _target$[ebp]
  00740	52		 push	 edx
  00741	8b 45 fc	 mov	 eax, DWORD PTR _aggressor$[ebp]
  00744	50		 push	 eax
  00745	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  00748	51		 push	 ecx
  00749	e8 00 00 00 00	 call	 ?assess_cover_position@@YGEPAUENTITY@@00PAUVEC3D@@0@Z ; assess_cover_position
  0074e	88 45 b7	 mov	 BYTE PTR _score$[ebp], al
$LN12@update_gui:

; 1172 : 
; 1173 : 		#if DEBUG_MODULE
; 1174 : 
; 1175 : 		if (aggressor == get_external_view_entity ())
; 1176 : 		{
; 1177 : 			vec3d
; 1178 : 				*aggressor_pos;
; 1179 : 	
; 1180 : 			debug_filtered_log ("GD_COVER: (%d - %d) Checking %s (%d) SCORE %d",
; 1181 : 										 raw->current_seek_cover_result.search_mode,
; 1182 : 										 count,
; 1183 : 										 get_local_entity_type_name (structure),
; 1184 : 										 get_local_entity_index (structure),
; 1185 : 										 score);
; 1186 : 	
; 1187 : 			aggressor_pos = get_local_entity_vec3d_ptr (aggressor, VEC3D_TYPE_POSITION);
; 1188 : 	
; 1189 : 			create_debug_3d_line (aggressor_pos, &cover_pos, sys_col_amber, 2.0);
; 1190 : 
; 1191 : 			create_debug_3d_line (aggressor_pos, target_pos, sys_col_red, 0.0);
; 1192 : 		}
; 1193 : 		#endif
; 1194 : 	}
; 1195 : 
; 1196 : 	//
; 1197 : 	// if no object found, or limit reached - go to next search
; 1198 : 	//
; 1199 : 
; 1200 : 	if ((!structure) || (raw->current_seek_cover_result.count == (SEEK_COUNT_LIMIT - 1)))

  00751	83 7d e8 00	 cmp	 DWORD PTR _structure$[ebp], 0
  00755	74 14		 je	 SHORT $LN15@update_gui
  00757	8b 45 e4	 mov	 eax, DWORD PTR _raw$[ebp]
  0075a	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00760	c1 e9 05	 shr	 ecx, 5
  00763	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00766	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  00769	75 4d		 jne	 SHORT $LN14@update_gui
$LN15@update_gui:

; 1201 : 	{
; 1202 : 		#if DEBUG_MODULE
; 1203 : 
; 1204 : 		if (aggressor == get_external_view_entity ())
; 1205 : 		{
; 1206 : 			debug_filtered_log ("GD_COVER: (%d) ---------------------------", raw->current_seek_cover_result.search_mode);
; 1207 : 		}
; 1208 : 
; 1209 : 		#endif
; 1210 : 
; 1211 : 		if (raw->current_seek_cover_result.sector)

  0076b	8b 45 e4	 mov	 eax, DWORD PTR _raw$[ebp]
  0076e	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00774	c1 e9 04	 shr	 ecx, 4
  00777	83 e1 01	 and	 ecx, 1
  0077a	74 0b		 je	 SHORT $LN16@update_gui

; 1212 : 		{
; 1213 : 			set_guide_seek_cover_next_search_mode (en);

  0077c	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  0077f	50		 push	 eax
  00780	e8 00 00 00 00	 call	 ?set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z ; set_guide_seek_cover_next_search_mode

; 1214 : 		}
; 1215 : 		else

  00785	eb 2d		 jmp	 SHORT $LN17@update_gui
$LN16@update_gui:

; 1216 : 		{
; 1217 : 			raw->current_seek_cover_result.sector = TRUE;

  00787	8b 45 e4	 mov	 eax, DWORD PTR _raw$[ebp]
  0078a	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00790	83 c9 10	 or	 ecx, 16			; 00000010H
  00793	8b 55 e4	 mov	 edx, DWORD PTR _raw$[ebp]
  00796	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx

; 1218 : 
; 1219 : 			raw->current_seek_cover_result.count = 0;

  0079c	8b 45 e4	 mov	 eax, DWORD PTR _raw$[ebp]
  0079f	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  007a5	81 e1 1f fc ff
	ff		 and	 ecx, -993		; fffffc1fH
  007ab	8b 55 e4	 mov	 edx, DWORD PTR _raw$[ebp]
  007ae	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx
$LN17@update_gui:

; 1220 : 		}
; 1221 : 
; 1222 : 		return FALSE;

  007b4	33 c0		 xor	 eax, eax
  007b6	eb 36		 jmp	 SHORT $LN1@update_gui
$LN14@update_gui:

; 1223 : 	}
; 1224 : 
; 1225 : 	//
; 1226 : 	// next structure in sector...
; 1227 : 	//
; 1228 : 
; 1229 : 	raw->current_seek_cover_result.count ++;

  007b8	8b 45 e4	 mov	 eax, DWORD PTR _raw$[ebp]
  007bb	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  007c1	c1 e9 05	 shr	 ecx, 5
  007c4	83 e1 1f	 and	 ecx, 31			; 0000001fH
  007c7	83 c1 01	 add	 ecx, 1
  007ca	83 e1 1f	 and	 ecx, 31			; 0000001fH
  007cd	c1 e1 05	 shl	 ecx, 5
  007d0	8b 55 e4	 mov	 edx, DWORD PTR _raw$[ebp]
  007d3	8b 82 88 00 00
	00		 mov	 eax, DWORD PTR [edx+136]
  007d9	25 1f fc ff ff	 and	 eax, -993		; fffffc1fH
  007de	0b c1		 or	 eax, ecx
  007e0	8b 4d e4	 mov	 ecx, DWORD PTR _raw$[ebp]
  007e3	89 81 88 00 00
	00		 mov	 DWORD PTR [ecx+136], eax

; 1230 : 
; 1231 : 	return TRUE;

  007e9	b8 01 00 00 00	 mov	 eax, 1
$LN1@update_gui:

; 1232 : }

  007ee	5f		 pop	 edi
  007ef	5e		 pop	 esi
  007f0	5b		 pop	 ebx
  007f1	8b e5		 mov	 esp, ebp
  007f3	5d		 pop	 ebp
  007f4	c2 04 00	 ret	 4
?update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z ENDP ; update_guide_seek_cover_fixed_structure_search
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\guide\gd_cover.c
;	COMDAT ?set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z
_TEXT	SEGMENT
_raw$ = -4						; size = 4
_en$ = 8						; size = 4
?set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z PROC ; set_guide_seek_cover_next_search_mode, COMDAT

; 336  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 337  : 	guide
; 338  : 		*raw;
; 339  : 
; 340  : 	ASSERT (en);

  00009	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN2@set_guide_
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z@4JA
  00014	83 c0 04	 add	 eax, 4
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02LFNMGJAP@en@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@set_guide_:

; 341  : 
; 342  : 	raw = (guide *) get_local_entity_data (en);

  00027	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  0002a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002d	89 4d fc	 mov	 DWORD PTR _raw$[ebp], ecx

; 343  : 
; 344  : 	raw->current_seek_cover_result.search_mode ++;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  00033	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00039	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0003c	83 c1 01	 add	 ecx, 1
  0003f	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00042	8b 55 fc	 mov	 edx, DWORD PTR _raw$[ebp]
  00045	8b 82 88 00 00
	00		 mov	 eax, DWORD PTR [edx+136]
  0004b	83 e0 f0	 and	 eax, -16		; fffffff0H
  0004e	0b c1		 or	 eax, ecx
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _raw$[ebp]
  00053	89 81 88 00 00
	00		 mov	 DWORD PTR [ecx+136], eax

; 345  : 
; 346  : 	raw->current_seek_cover_result.sector = 0;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  0005c	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00062	83 e1 ef	 and	 ecx, -17		; ffffffefH
  00065	8b 55 fc	 mov	 edx, DWORD PTR _raw$[ebp]
  00068	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx

; 347  : 	
; 348  : 	raw->current_seek_cover_result.count = 0;

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  00071	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00077	81 e1 1f fc ff
	ff		 and	 ecx, -993		; fffffc1fH
  0007d	8b 55 fc	 mov	 edx, DWORD PTR _raw$[ebp]
  00080	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx

; 349  : 
; 350  : 	if (raw->terrain_polygon_list)

  00086	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  00089	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00090	74 29		 je	 SHORT $LN1@set_guide_

; 351  : 	{
; 352  : 		free_mem (raw->terrain_polygon_list);

  00092	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  00095	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 ?free_mem@@YGXPAX@Z	; free_mem

; 353  : 
; 354  : 		raw->terrain_polygon_list = NULL;

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  000a4	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+144], 0

; 355  : 
; 356  : 		raw->terrain_polygon_count = 0;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  000b1	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+148], 0
$LN1@set_guide_:

; 357  : 	}
; 358  : }

  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 04 00	 ret	 4
?set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z ENDP ; set_guide_seek_cover_next_search_mode
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\guide\gd_cover.c
;	COMDAT ?update_guide_seek_cover_results@@YGHPAUENTITY@@@Z
_TEXT	SEGMENT
tv294 = -96						; size = 4
tv246 = -96						; size = 4
tv225 = -96						; size = 4
tv206 = -96						; size = 4
tv185 = -96						; size = 4
tv165 = -96						; size = 4
tv140 = -96						; size = 4
tv83 = -96						; size = 4
tv286 = -92						; size = 4
tv258 = -92						; size = 4
tv238 = -92						; size = 4
tv218 = -92						; size = 4
tv198 = -92						; size = 4
tv178 = -92						; size = 4
tv157 = -92						; size = 4
tv132 = -92						; size = 4
tv75 = -92						; size = 4
_loop$ = -24						; size = 4
_aggressor$ = -20					; size = 4
_member$ = -16						; size = 4
_guide$ = -12						; size = 4
_group$ = -8						; size = 4
_raw$ = -4						; size = 4
_en$ = 8						; size = 4
?update_guide_seek_cover_results@@YGHPAUENTITY@@@Z PROC	; update_guide_seek_cover_results, COMDAT

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 164  : 	guide
; 165  : 		*raw;
; 166  : 
; 167  : 	entity
; 168  : 		*group,
; 169  : 		*guide,
; 170  : 		*member,
; 171  : 		*aggressor;
; 172  : 
; 173  : 	int
; 174  : 		loop;
; 175  : 
; 176  : 	ASSERT (en);

  00009	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN9@update_gui
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  00014	83 c0 0d	 add	 eax, 13			; 0000000dH
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02LFNMGJAP@en@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN9@update_gui:

; 177  : 
; 178  : 	//
; 179  : 	// wait till other *AI* members have found cover
; 180  : 	//
; 181  : 
; 182  : 	aggressor = get_local_entity_first_child (en, LIST_TYPE_FOLLOWER);

  00027	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  0002b	74 0a		 je	 SHORT $LN30@update_gui
  0002d	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	89 4d a4	 mov	 DWORD PTR tv75[ebp], ecx
  00035	eb 21		 jmp	 SHORT $LN31@update_gui
$LN30@update_gui:
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  0003d	83 c2 13	 add	 edx, 19			; 00000013H
  00040	52		 push	 edx
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00051	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN31@update_gui:
  00058	b9 01 00 00 00	 mov	 ecx, 1
  0005d	85 c9		 test	 ecx, ecx
  0005f	74 09		 je	 SHORT $LN32@update_gui
  00061	c7 45 a0 0d 00
	00 00		 mov	 DWORD PTR tv83[ebp], 13	; 0000000dH
  00068	eb 21		 jmp	 SHORT $LN33@update_gui
$LN32@update_gui:
  0006a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  00070	83 c2 13	 add	 edx, 19			; 00000013H
  00073	52		 push	 edx
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00084	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$LN33@update_gui:
  0008b	6a 0d		 push	 13			; 0000000dH
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  00090	51		 push	 ecx
  00091	69 55 a4 b4 00
	00 00		 imul	 edx, DWORD PTR tv75[ebp], 180
  00098	8b 45 a0	 mov	 eax, DWORD PTR tv83[ebp]
  0009b	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_first_child@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  000a2	ff d1		 call	 ecx
  000a4	89 45 ec	 mov	 DWORD PTR _aggressor$[ebp], eax

; 183  : 
; 184  : 	ASSERT (aggressor);

  000a7	83 7d ec 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  000ab	75 18		 jne	 SHORT $LN10@update_gui
  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  000b2	83 c0 15	 add	 eax, 21			; 00000015H
  000b5	50		 push	 eax
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_09HKMIOAOH@aggressor@
  000c0	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN10@update_gui:

; 185  : 
; 186  : 	group = get_local_entity_parent (aggressor, LIST_TYPE_MEMBER);

  000c5	83 7d ec 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  000c9	74 0a		 je	 SHORT $LN34@update_gui
  000cb	8b 45 ec	 mov	 eax, DWORD PTR _aggressor$[ebp]
  000ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d0	89 4d a4	 mov	 DWORD PTR tv132[ebp], ecx
  000d3	eb 21		 jmp	 SHORT $LN35@update_gui
$LN34@update_gui:
  000d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  000db	83 c2 17	 add	 edx, 23			; 00000017H
  000de	52		 push	 edx
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  000ef	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv132[ebp], 0
$LN35@update_gui:
  000f6	b9 01 00 00 00	 mov	 ecx, 1
  000fb	85 c9		 test	 ecx, ecx
  000fd	74 09		 je	 SHORT $LN36@update_gui
  000ff	c7 45 a0 19 00
	00 00		 mov	 DWORD PTR tv140[ebp], 25 ; 00000019H
  00106	eb 21		 jmp	 SHORT $LN37@update_gui
$LN36@update_gui:
  00108	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  0010e	83 c2 17	 add	 edx, 23			; 00000017H
  00111	52		 push	 edx
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00117	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00122	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
$LN37@update_gui:
  00129	6a 19		 push	 25			; 00000019H
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  0012e	51		 push	 ecx
  0012f	69 55 a4 b4 00
	00 00		 imul	 edx, DWORD PTR tv132[ebp], 180
  00136	8b 45 a0	 mov	 eax, DWORD PTR tv140[ebp]
  00139	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  00140	ff d1		 call	 ecx
  00142	89 45 f8	 mov	 DWORD PTR _group$[ebp], eax

; 187  : 
; 188  : 	ASSERT (group);

  00145	83 7d f8 00	 cmp	 DWORD PTR _group$[ebp], 0
  00149	75 18		 jne	 SHORT $LN11@update_gui
  0014b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  00150	83 c0 19	 add	 eax, 25			; 00000019H
  00153	50		 push	 eax
  00154	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_05MGJOOGAJ@group@
  0015e	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN11@update_gui:

; 189  : 
; 190  : 	member = get_local_entity_first_child (group, LIST_TYPE_MEMBER);

  00163	83 7d f8 00	 cmp	 DWORD PTR _group$[ebp], 0
  00167	74 0a		 je	 SHORT $LN38@update_gui
  00169	8b 45 f8	 mov	 eax, DWORD PTR _group$[ebp]
  0016c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016e	89 4d a4	 mov	 DWORD PTR tv157[ebp], ecx
  00171	eb 21		 jmp	 SHORT $LN39@update_gui
$LN38@update_gui:
  00173	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  00179	83 c2 1b	 add	 edx, 27			; 0000001bH
  0017c	52		 push	 edx
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00182	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00187	50		 push	 eax
  00188	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0018d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv157[ebp], 0
$LN39@update_gui:
  00194	b9 01 00 00 00	 mov	 ecx, 1
  00199	85 c9		 test	 ecx, ecx
  0019b	74 09		 je	 SHORT $LN40@update_gui
  0019d	c7 45 a0 19 00
	00 00		 mov	 DWORD PTR tv165[ebp], 25 ; 00000019H
  001a4	eb 21		 jmp	 SHORT $LN41@update_gui
$LN40@update_gui:
  001a6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  001ac	83 c2 1b	 add	 edx, 27			; 0000001bH
  001af	52		 push	 edx
  001b0	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  001b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  001ba	50		 push	 eax
  001bb	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  001c0	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv165[ebp], 0
$LN41@update_gui:
  001c7	6a 19		 push	 25			; 00000019H
  001c9	8b 4d f8	 mov	 ecx, DWORD PTR _group$[ebp]
  001cc	51		 push	 ecx
  001cd	69 55 a4 b4 00
	00 00		 imul	 edx, DWORD PTR tv157[ebp], 180
  001d4	8b 45 a0	 mov	 eax, DWORD PTR tv165[ebp]
  001d7	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_first_child@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  001de	ff d1		 call	 ecx
  001e0	89 45 f0	 mov	 DWORD PTR _member$[ebp], eax
$LN2@update_gui:

; 191  : 
; 192  : 	while (member)

  001e3	83 7d f0 00	 cmp	 DWORD PTR _member$[ebp], 0
  001e7	0f 84 1d 02 00
	00		 je	 $LN3@update_gui

; 193  : 	{
; 194  : 		if (member == aggressor)

  001ed	8b 45 f0	 mov	 eax, DWORD PTR _member$[ebp]
  001f0	3b 45 ec	 cmp	 eax, DWORD PTR _aggressor$[ebp]
  001f3	75 05		 jne	 SHORT $LN12@update_gui

; 195  : 		{
; 196  : 			break;

  001f5	e9 10 02 00 00	 jmp	 $LN3@update_gui
$LN12@update_gui:

; 197  : 		}
; 198  : 
; 199  : 		if (get_local_entity_int_value (member, INT_TYPE_PLAYER) == ENTITY_PLAYER_AI)

  001fa	83 7d f0 00	 cmp	 DWORD PTR _member$[ebp], 0
  001fe	74 0a		 je	 SHORT $LN42@update_gui
  00200	8b 45 f0	 mov	 eax, DWORD PTR _member$[ebp]
  00203	8b 08		 mov	 ecx, DWORD PTR [eax]
  00205	89 4d a4	 mov	 DWORD PTR tv178[ebp], ecx
  00208	eb 1d		 jmp	 SHORT $LN43@update_gui
$LN42@update_gui:
  0020a	68 c7 00 00 00	 push	 199			; 000000c7H
  0020f	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00214	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0021a	52		 push	 edx
  0021b	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00220	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv178[ebp], 0
$LN43@update_gui:
  00227	b8 01 00 00 00	 mov	 eax, 1
  0022c	85 c0		 test	 eax, eax
  0022e	74 09		 je	 SHORT $LN44@update_gui
  00230	c7 45 a0 9c 00
	00 00		 mov	 DWORD PTR tv185[ebp], 156 ; 0000009cH
  00237	eb 1d		 jmp	 SHORT $LN45@update_gui
$LN44@update_gui:
  00239	68 c7 00 00 00	 push	 199			; 000000c7H
  0023e	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00243	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  00249	51		 push	 ecx
  0024a	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0024f	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv185[ebp], 0
$LN45@update_gui:
  00256	68 9c 00 00 00	 push	 156			; 0000009cH
  0025b	8b 55 f0	 mov	 edx, DWORD PTR _member$[ebp]
  0025e	52		 push	 edx
  0025f	69 45 a4 5c 04
	00 00		 imul	 eax, DWORD PTR tv178[ebp], 1116
  00266	8b 4d a0	 mov	 ecx, DWORD PTR tv185[ebp]
  00269	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[eax+ecx*4]
  00270	ff d2		 call	 edx
  00272	85 c0		 test	 eax, eax
  00274	0f 85 0b 01 00
	00		 jne	 $LN13@update_gui

; 200  : 		{
; 201  : 			guide = get_local_entity_parent (member, LIST_TYPE_FOLLOWER);

  0027a	83 7d f0 00	 cmp	 DWORD PTR _member$[ebp], 0
  0027e	74 0a		 je	 SHORT $LN46@update_gui
  00280	8b 45 f0	 mov	 eax, DWORD PTR _member$[ebp]
  00283	8b 08		 mov	 ecx, DWORD PTR [eax]
  00285	89 4d a4	 mov	 DWORD PTR tv198[ebp], ecx
  00288	eb 21		 jmp	 SHORT $LN47@update_gui
$LN46@update_gui:
  0028a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  00290	83 c2 26	 add	 edx, 38			; 00000026H
  00293	52		 push	 edx
  00294	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00299	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0029e	50		 push	 eax
  0029f	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  002a4	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv198[ebp], 0
$LN47@update_gui:
  002ab	b9 01 00 00 00	 mov	 ecx, 1
  002b0	85 c9		 test	 ecx, ecx
  002b2	74 09		 je	 SHORT $LN48@update_gui
  002b4	c7 45 a0 0d 00
	00 00		 mov	 DWORD PTR tv206[ebp], 13 ; 0000000dH
  002bb	eb 21		 jmp	 SHORT $LN49@update_gui
$LN48@update_gui:
  002bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  002c3	83 c2 26	 add	 edx, 38			; 00000026H
  002c6	52		 push	 edx
  002c7	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  002cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  002d1	50		 push	 eax
  002d2	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  002d7	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv206[ebp], 0
$LN49@update_gui:
  002de	6a 0d		 push	 13			; 0000000dH
  002e0	8b 4d f0	 mov	 ecx, DWORD PTR _member$[ebp]
  002e3	51		 push	 ecx
  002e4	69 55 a4 b4 00
	00 00		 imul	 edx, DWORD PTR tv198[ebp], 180
  002eb	8b 45 a0	 mov	 eax, DWORD PTR tv206[ebp]
  002ee	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_parent@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  002f5	ff d1		 call	 ecx
  002f7	89 45 f4	 mov	 DWORD PTR _guide$[ebp], eax

; 202  : 
; 203  : 			if (guide)

  002fa	83 7d f4 00	 cmp	 DWORD PTR _guide$[ebp], 0
  002fe	0f 84 81 00 00
	00		 je	 $LN13@update_gui

; 204  : 			{
; 205  : 				if (get_local_entity_int_value (guide, INT_TYPE_ENTITY_SUB_TYPE) == ENTITY_SUB_TYPE_GUIDE_ATTACK_AG_SEEK_COVER)

  00304	83 7d f4 00	 cmp	 DWORD PTR _guide$[ebp], 0
  00308	74 0a		 je	 SHORT $LN50@update_gui
  0030a	8b 45 f4	 mov	 eax, DWORD PTR _guide$[ebp]
  0030d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030f	89 4d a4	 mov	 DWORD PTR tv218[ebp], ecx
  00312	eb 1d		 jmp	 SHORT $LN51@update_gui
$LN50@update_gui:
  00314	68 cd 00 00 00	 push	 205			; 000000cdH
  00319	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0031e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00324	52		 push	 edx
  00325	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0032a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv218[ebp], 0
$LN51@update_gui:
  00331	b8 01 00 00 00	 mov	 eax, 1
  00336	85 c0		 test	 eax, eax
  00338	74 09		 je	 SHORT $LN52@update_gui
  0033a	c7 45 a0 34 00
	00 00		 mov	 DWORD PTR tv225[ebp], 52 ; 00000034H
  00341	eb 1d		 jmp	 SHORT $LN53@update_gui
$LN52@update_gui:
  00343	68 cd 00 00 00	 push	 205			; 000000cdH
  00348	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0034d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  00353	51		 push	 ecx
  00354	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00359	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv225[ebp], 0
$LN53@update_gui:
  00360	6a 34		 push	 52			; 00000034H
  00362	8b 55 f4	 mov	 edx, DWORD PTR _guide$[ebp]
  00365	52		 push	 edx
  00366	69 45 a4 5c 04
	00 00		 imul	 eax, DWORD PTR tv218[ebp], 1116
  0036d	8b 4d a0	 mov	 ecx, DWORD PTR tv225[ebp]
  00370	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[eax+ecx*4]
  00377	ff d2		 call	 edx
  00379	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0037c	75 07		 jne	 SHORT $LN13@update_gui

; 206  : 				{
; 207  : 					return FALSE;

  0037e	33 c0		 xor	 eax, eax
  00380	e9 5c 02 00 00	 jmp	 $LN1@update_gui
$LN13@update_gui:

; 208  : 				}
; 209  : 			}
; 210  : 		}
; 211  : 
; 212  : 		member = get_local_entity_child_succ (member, LIST_TYPE_MEMBER);

  00385	83 7d f0 00	 cmp	 DWORD PTR _member$[ebp], 0
  00389	74 0a		 je	 SHORT $LN54@update_gui
  0038b	8b 45 f0	 mov	 eax, DWORD PTR _member$[ebp]
  0038e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00390	89 4d a4	 mov	 DWORD PTR tv238[ebp], ecx
  00393	eb 21		 jmp	 SHORT $LN55@update_gui
$LN54@update_gui:
  00395	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  0039b	83 c2 31	 add	 edx, 49			; 00000031H
  0039e	52		 push	 edx
  0039f	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  003a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  003a9	50		 push	 eax
  003aa	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  003af	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv238[ebp], 0
$LN55@update_gui:
  003b6	b9 01 00 00 00	 mov	 ecx, 1
  003bb	85 c9		 test	 ecx, ecx
  003bd	74 09		 je	 SHORT $LN56@update_gui
  003bf	c7 45 a0 19 00
	00 00		 mov	 DWORD PTR tv246[ebp], 25 ; 00000019H
  003c6	eb 21		 jmp	 SHORT $LN57@update_gui
$LN56@update_gui:
  003c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  003ce	83 c2 31	 add	 edx, 49			; 00000031H
  003d1	52		 push	 edx
  003d2	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  003d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  003dc	50		 push	 eax
  003dd	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  003e2	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv246[ebp], 0
$LN57@update_gui:
  003e9	6a 19		 push	 25			; 00000019H
  003eb	8b 4d f0	 mov	 ecx, DWORD PTR _member$[ebp]
  003ee	51		 push	 ecx
  003ef	69 55 a4 b4 00
	00 00		 imul	 edx, DWORD PTR tv238[ebp], 180
  003f6	8b 45 a0	 mov	 eax, DWORD PTR tv246[ebp]
  003f9	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_child_succ@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  00400	ff d1		 call	 ecx
  00402	89 45 f0	 mov	 DWORD PTR _member$[ebp], eax

; 213  : 	}

  00405	e9 d9 fd ff ff	 jmp	 $LN2@update_gui
$LN3@update_gui:

; 214  : 
; 215  : 	//
; 216  : 	// seek cover
; 217  : 	//
; 218  : 
; 219  : 	raw = (struct GUIDE *) get_local_entity_data (en);

  0040a	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  0040d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00410	89 4d fc	 mov	 DWORD PTR _raw$[ebp], ecx

; 220  : 
; 221  : 	for (loop = 0; loop < NUM_COVER_CHECKS_PER_FRAME; loop ++)

  00413	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _loop$[ebp], 0
  0041a	eb 09		 jmp	 SHORT $LN6@update_gui
$LN4@update_gui:
  0041c	8b 45 e8	 mov	 eax, DWORD PTR _loop$[ebp]
  0041f	83 c0 01	 add	 eax, 1
  00422	89 45 e8	 mov	 DWORD PTR _loop$[ebp], eax
$LN6@update_gui:
  00425	83 7d e8 03	 cmp	 DWORD PTR _loop$[ebp], 3
  00429	0f 8d ad 01 00
	00		 jge	 $LN5@update_gui

; 222  : 	{
; 223  : 		switch (raw->current_seek_cover_result.search_mode)

  0042f	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  00432	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00438	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0043b	89 4d a4	 mov	 DWORD PTR tv258[ebp], ecx
  0043e	83 7d a4 0b	 cmp	 DWORD PTR tv258[ebp], 11 ; 0000000bH
  00442	0f 87 75 01 00
	00		 ja	 $LN28@update_gui
  00448	8b 55 a4	 mov	 edx, DWORD PTR tv258[ebp]
  0044b	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN62@update_gui[edx*4]
$LN16@update_gui:

; 224  : 		{
; 225  : 			case SEEK_COVER_MODE_CURRENT_POSITION:
; 226  : 			{
; 227  : 				update_guide_seek_cover_current_position_search (en);

  00452	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00455	50		 push	 eax
  00456	e8 00 00 00 00	 call	 ?update_guide_seek_cover_current_position_search@@YGHPAUENTITY@@@Z ; update_guide_seek_cover_current_position_search

; 228  : 	
; 229  : 				break;

  0045b	e9 77 01 00 00	 jmp	 $LN7@update_gui
$LN17@update_gui:

; 230  : 			}
; 231  : 	
; 232  : 			case SEEK_COVER_MODE_BUILDINGS:
; 233  : 			case SEEK_COVER_MODE_BRIDGES:
; 234  : 			{
; 235  : 				update_guide_seek_cover_fixed_structure_search (en);

  00460	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00463	50		 push	 eax
  00464	e8 00 00 00 00	 call	 ?update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z ; update_guide_seek_cover_fixed_structure_search

; 236  : 	
; 237  : 				break;

  00469	e9 69 01 00 00	 jmp	 $LN7@update_gui
$LN18@update_gui:

; 238  : 			}
; 239  : 	
; 240  : 			case SEEK_COVER_MODE_CITY_BUILDINGS:
; 241  : 			{
; 242  : 				update_guide_seek_cover_fixed_structure_search (en);

  0046e	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00471	50		 push	 eax
  00472	e8 00 00 00 00	 call	 ?update_guide_seek_cover_fixed_structure_search@@YGHPAUENTITY@@@Z ; update_guide_seek_cover_fixed_structure_search

; 243  : 
; 244  : 				loop += 2;		// less checks per frame for cities (check is slow)

  00477	8b 45 e8	 mov	 eax, DWORD PTR _loop$[ebp]
  0047a	83 c0 02	 add	 eax, 2
  0047d	89 45 e8	 mov	 DWORD PTR _loop$[ebp], eax

; 245  : 	
; 246  : 				break;

  00480	e9 52 01 00 00	 jmp	 $LN7@update_gui
$LN19@update_gui:

; 247  : 			}
; 248  : 	
; 249  : 			case SEEK_COVER_MODE_FOREST:
; 250  : 			{
; 251  : 				update_guide_seek_cover_forest_search (en);

  00485	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00488	50		 push	 eax
  00489	e8 00 00 00 00	 call	 ?update_guide_seek_cover_forest_search@@YGHPAUENTITY@@@Z ; update_guide_seek_cover_forest_search

; 252  : 	
; 253  : 				break;

  0048e	e9 44 01 00 00	 jmp	 $LN7@update_gui
$LN20@update_gui:

; 254  : 			}
; 255  : 	
; 256  : 			case SEEK_COVER_MODE_RIVER:
; 257  : 			{
; 258  : 				set_guide_seek_cover_next_search_mode (en);

  00493	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00496	50		 push	 eax
  00497	e8 00 00 00 00	 call	 ?set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z ; set_guide_seek_cover_next_search_mode

; 259  : 	
; 260  : 				break;

  0049c	e9 36 01 00 00	 jmp	 $LN7@update_gui
$LN21@update_gui:

; 261  : 			}
; 262  : 	
; 263  : 			case SEEK_COVER_MODE_DEFAULT_TERRAIN:
; 264  : 			{
; 265  : 				update_guide_seek_cover_default_terrain_search (en);

  004a1	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  004a4	50		 push	 eax
  004a5	e8 00 00 00 00	 call	 ?update_guide_seek_cover_default_terrain_search@@YGHPAUENTITY@@@Z ; update_guide_seek_cover_default_terrain_search

; 266  : 	
; 267  : 				break;

  004aa	e9 28 01 00 00	 jmp	 $LN7@update_gui
$LN22@update_gui:

; 268  : 			}
; 269  : 	
; 270  : 			case SEEK_COVER_MODE_CHECK_SCORE1:
; 271  : 			case SEEK_COVER_MODE_CHECK_SCORE2:
; 272  : 			case SEEK_COVER_MODE_CHECK_SCORE3:
; 273  : 			case SEEK_COVER_MODE_CHECK_SCORE4:
; 274  : 			{
; 275  : 				//
; 276  : 				// Check current score and early out if good
; 277  : 				//
; 278  : 				
; 279  : 				if (raw->best_seek_cover_result.score > SEEK_COVER_CURRENT_POSITION_THRESHOLD)

  004af	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  004b2	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  004b8	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  004bb	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  004c1	83 f9 64	 cmp	 ecx, 100		; 00000064H
  004c4	76 1e		 jbe	 SHORT $LN23@update_gui

; 280  : 				{
; 281  : 					//
; 282  : 					// set cover position to best result
; 283  : 					//
; 284  : 	
; 285  : 					set_attack_guide_fly_to_cover_position (en);

  004c6	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  004c9	50		 push	 eax
  004ca	e8 00 00 00 00	 call	 ?set_attack_guide_fly_to_cover_position@@YGXPAUENTITY@@@Z ; set_attack_guide_fly_to_cover_position

; 286  : 	
; 287  : 					reset_guide_seek_cover_results (en);

  004cf	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  004d2	50		 push	 eax
  004d3	e8 00 00 00 00	 call	 ?reset_guide_seek_cover_results@@YGXPAUENTITY@@@Z ; reset_guide_seek_cover_results

; 288  : 
; 289  : 					return TRUE;

  004d8	b8 01 00 00 00	 mov	 eax, 1
  004dd	e9 ff 00 00 00	 jmp	 $LN1@update_gui

; 290  : 				}
; 291  : 				else

  004e2	eb 09		 jmp	 SHORT $LN24@update_gui
$LN23@update_gui:

; 292  : 				{
; 293  : 					set_guide_seek_cover_next_search_mode (en);

  004e4	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  004e7	50		 push	 eax
  004e8	e8 00 00 00 00	 call	 ?set_guide_seek_cover_next_search_mode@@YGXPAUENTITY@@@Z ; set_guide_seek_cover_next_search_mode
$LN24@update_gui:

; 294  : 				}
; 295  : 	
; 296  : 				break;

  004ed	e9 e5 00 00 00	 jmp	 $LN7@update_gui
$LN25@update_gui:

; 297  : 			}
; 298  : 	
; 299  : 			case NUM_GUIDE_SEEK_COVER_MODES:
; 300  : 			{
; 301  : 				if (raw->best_seek_cover_result.score > 0)

  004f2	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  004f5	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  004fb	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  004fe	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00504	76 0e		 jbe	 SHORT $LN26@update_gui

; 302  : 				{
; 303  : 					//
; 304  : 					// set cover position to best result
; 305  : 					//
; 306  : 	
; 307  : 					set_attack_guide_fly_to_cover_position (en);

  00506	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00509	50		 push	 eax
  0050a	e8 00 00 00 00	 call	 ?set_attack_guide_fly_to_cover_position@@YGXPAUENTITY@@@Z ; set_attack_guide_fly_to_cover_position

; 308  : 				}
; 309  : 				else

  0050f	e9 99 00 00 00	 jmp	 $LN27@update_gui
$LN26@update_gui:

; 310  : 				{
; 311  : 					debug_colour_log (DEBUG_COLOUR_DARK_GREEN, "GD_COVER: No Cover found for %s", get_local_entity_string (aggressor, STRING_TYPE_FULL_NAME));

  00514	83 7d ec 00	 cmp	 DWORD PTR _aggressor$[ebp], 0
  00518	74 0a		 je	 SHORT $LN58@update_gui
  0051a	8b 45 ec	 mov	 eax, DWORD PTR _aggressor$[ebp]
  0051d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0051f	89 4d a4	 mov	 DWORD PTR tv286[ebp], ecx
  00522	eb 24		 jmp	 SHORT $LN59@update_gui
$LN58@update_gui:
  00524	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  0052a	81 c2 94 00 00
	00		 add	 edx, 148		; 00000094H
  00530	52		 push	 edx
  00531	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  00536	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0053b	50		 push	 eax
  0053c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00541	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv286[ebp], 0
$LN59@update_gui:
  00548	b9 01 00 00 00	 mov	 ecx, 1
  0054d	85 c9		 test	 ecx, ecx
  0054f	74 09		 je	 SHORT $LN60@update_gui
  00551	c7 45 a0 03 00
	00 00		 mov	 DWORD PTR tv294[ebp], 3
  00558	eb 24		 jmp	 SHORT $LN61@update_gui
$LN60@update_gui:
  0055a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??update_guide_seek_cover_results@@YGHPAUENTITY@@@Z@4JA
  00560	81 c2 94 00 00
	00		 add	 edx, 148		; 00000094H
  00566	52		 push	 edx
  00567	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0056c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_string_type_message@@3PBDB ; overload_invalid_string_type_message
  00571	50		 push	 eax
  00572	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00577	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv294[ebp], 0
$LN61@update_gui:
  0057e	6a 03		 push	 3
  00580	8b 4d ec	 mov	 ecx, DWORD PTR _aggressor$[ebp]
  00583	51		 push	 ecx
  00584	6b 55 a4 34	 imul	 edx, DWORD PTR tv286[ebp], 52
  00588	8b 45 a0	 mov	 eax, DWORD PTR tv294[ebp]
  0058b	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_string@@3PAY0N@P6GPBDPAUENTITY@@W4STRING_TYPES@@@ZA[edx+eax*4]
  00592	ff d1		 call	 ecx
  00594	50		 push	 eax
  00595	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JDIGCNOK@GD_COVER?3?5No?5Cover?5found?5for?5?$CFs@
  0059a	6a 12		 push	 18			; 00000012H
  0059c	e8 00 00 00 00	 call	 ?debug_colour_log@@YAXW4DEBUG_COLOURS@@PBDZZ ; debug_colour_log
  005a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 312  : 	
; 313  : 					attack_guide_no_cover_found (en);

  005a4	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  005a7	50		 push	 eax
  005a8	e8 00 00 00 00	 call	 ?attack_guide_no_cover_found@@YGXPAUENTITY@@@Z ; attack_guide_no_cover_found
$LN27@update_gui:

; 314  : 				}
; 315  : 	
; 316  : 				reset_guide_seek_cover_results (en);

  005ad	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  005b0	50		 push	 eax
  005b1	e8 00 00 00 00	 call	 ?reset_guide_seek_cover_results@@YGXPAUENTITY@@@Z ; reset_guide_seek_cover_results

; 317  : 	
; 318  : 				return TRUE;

  005b6	b8 01 00 00 00	 mov	 eax, 1
  005bb	eb 24		 jmp	 SHORT $LN1@update_gui
$LN28@update_gui:

; 319  : 			}
; 320  : 	
; 321  : 			default:
; 322  : 			{
; 323  : 				debug_fatal ("GD_COVER: Invalid seek mode %d", raw->current_seek_cover_result.search_mode);

  005bd	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  005c0	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  005c6	83 e1 0f	 and	 ecx, 15			; 0000000fH
  005c9	51		 push	 ecx
  005ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@LPAMFHPN@GD_COVER?3?5Invalid?5seek?5mode?5?$CFd@
  005cf	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  005d4	83 c4 08	 add	 esp, 8
$LN7@update_gui:

; 324  : 			}
; 325  : 		}
; 326  : 	}

  005d7	e9 40 fe ff ff	 jmp	 $LN4@update_gui
$LN5@update_gui:

; 327  : 	
; 328  : 	return TRUE;

  005dc	b8 01 00 00 00	 mov	 eax, 1
$LN1@update_gui:

; 329  : }

  005e1	5f		 pop	 edi
  005e2	5e		 pop	 esi
  005e3	5b		 pop	 ebx
  005e4	8b e5		 mov	 esp, ebp
  005e6	5d		 pop	 ebp
  005e7	c2 04 00	 ret	 4
  005ea	66 90		 npad	 2
$LN62@update_gui:
  005ec	00 00 00 00	 DD	 $LN16@update_gui
  005f0	00 00 00 00	 DD	 $LN22@update_gui
  005f4	00 00 00 00	 DD	 $LN17@update_gui
  005f8	00 00 00 00	 DD	 $LN17@update_gui
  005fc	00 00 00 00	 DD	 $LN18@update_gui
  00600	00 00 00 00	 DD	 $LN22@update_gui
  00604	00 00 00 00	 DD	 $LN19@update_gui
  00608	00 00 00 00	 DD	 $LN20@update_gui
  0060c	00 00 00 00	 DD	 $LN22@update_gui
  00610	00 00 00 00	 DD	 $LN21@update_gui
  00614	00 00 00 00	 DD	 $LN22@update_gui
  00618	00 00 00 00	 DD	 $LN25@update_gui
?update_guide_seek_cover_results@@YGHPAUENTITY@@@Z ENDP	; update_guide_seek_cover_results
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\guide\gd_cover.c
;	COMDAT ?reset_guide_seek_cover_results@@YGXPAUENTITY@@@Z
_TEXT	SEGMENT
_raw$ = -4						; size = 4
_en$ = 8						; size = 4
?reset_guide_seek_cover_results@@YGXPAUENTITY@@@Z PROC	; reset_guide_seek_cover_results, COMDAT

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 137  : 	guide
; 138  : 		*raw;
; 139  : 
; 140  : 	ASSERT (en);

  00009	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN2@reset_guid
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??reset_guide_seek_cover_results@@YGXPAUENTITY@@@Z@4JA
  00014	83 c0 04	 add	 eax, 4
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PLLCNLEJ@c?3?2users?2nhv90?2projects?2eech?2ap@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02LFNMGJAP@en@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@reset_guid:

; 141  : 
; 142  : 	raw = (guide *) get_local_entity_data (en);

  00027	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  0002a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002d	89 4d fc	 mov	 DWORD PTR _raw$[ebp], ecx

; 143  : 
; 144  : 	memset (&(raw->current_seek_cover_result), 0, sizeof (guide_seek_cover_result_type));

  00030	6a 04		 push	 4
  00032	6a 00		 push	 0
  00034	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  00037	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _memset
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 145  : 
; 146  : 	memset (&(raw->best_seek_cover_result), 0, sizeof (guide_seek_cover_result_type));

  00045	6a 04		 push	 4
  00047	6a 00		 push	 0
  00049	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  0004c	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _memset
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 147  : 
; 148  : 	if (raw->terrain_polygon_list)

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  0005d	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00064	74 29		 je	 SHORT $LN1@reset_guid

; 149  : 	{
; 150  : 		free_mem (raw->terrain_polygon_list);

  00066	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  00069	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 ?free_mem@@YGXPAX@Z	; free_mem

; 151  : 
; 152  : 		raw->terrain_polygon_list = NULL;

  00075	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  00078	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+144], 0

; 153  : 
; 154  : 		raw->terrain_polygon_count = 0;

  00082	8b 45 fc	 mov	 eax, DWORD PTR _raw$[ebp]
  00085	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+148], 0
$LN1@reset_guid:

; 155  : 	}
; 156  : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
?reset_guide_seek_cover_results@@YGXPAUENTITY@@@Z ENDP	; reset_guide_seek_cover_results
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?atan2@@YGMMM@Z
_TEXT	SEGMENT
__Yx$ = 8						; size = 4
__Xx$ = 12						; size = 4
?atan2@@YGMMM@Z PROC					; atan2, COMDAT

; 56   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 57   : 	return (_CSTD atan2f(_Yx, _Xx));

  00009	51		 push	 ecx
  0000a	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR __Xx$[ebp]
  0000f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00014	51		 push	 ecx
  00015	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Yx$[ebp]
  0001a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001f	e8 00 00 00 00	 call	 _atan2f
  00024	83 c4 08	 add	 esp, 8

; 58   : 	}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?atan2@@YGMMM@Z ENDP					; atan2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _atan2f
_TEXT	SEGMENT
tv74 = -68						; size = 4
__Y$ = 8						; size = 4
__X$ = 12						; size = 4
_atan2f	PROC						; COMDAT

; 633  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 634  :             return (float)atan2(_Y, _X);

  00009	f3 0f 5a 45 0c	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0000e	83 ec 08	 sub	 esp, 8
  00011	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00016	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __Y$[ebp]
  0001b	83 ec 08	 sub	 esp, 8
  0001e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00023	e8 00 00 00 00	 call	 _atan2
  00028	83 c4 10	 add	 esp, 16			; 00000010H
  0002b	d9 5d bc	 fstp	 DWORD PTR tv74[ebp]
  0002e	d9 45 bc	 fld	 DWORD PTR tv74[ebp]

; 635  :         }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_atan2f	ENDP
_TEXT	ENDS
END
