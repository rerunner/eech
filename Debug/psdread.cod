; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\graphics\psdread.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?psd_layers@@3PAUPSD_LAYER_INFO@@A		; psd_layers
PUBLIC	?number_of_psd_layers@@3HA			; number_of_psd_layers
PUBLIC	?psd_palette@@3PAUREAL_COLOUR@@A		; psd_palette
_BSS	SEGMENT
?psd_layers@@3PAUPSD_LAYER_INFO@@A DB 019c0H DUP (?)	; psd_layers
?number_of_psd_layers@@3HA DD 01H DUP (?)		; number_of_psd_layers
?psd_palette@@3PAUREAL_COLOUR@@A DD 0100H DUP (?)	; psd_palette
_BSS	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?initialise_psd_layers@@YGXXZ			; initialise_psd_layers
PUBLIC	?load_psd_file@@YGPAXPBDPAH11@Z			; load_psd_file
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?__LINE__Var@?0??load_psd_file@@YGPAXPBDPAH11@Z@4JA ; `load_psd_file'::`1'::__LINE__Var
PUBLIC	??_C@_0L@LBAOFDNG@?$CF?4?$CKs?2?$CFs?2?$CFs@	; `string'
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs@			; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_04GELLELDE@8BPS@				; `string'
PUBLIC	??_C@_0CE@NONIEFE@File?5not?5a?5photoshop?5psd?5format@ ; `string'
PUBLIC	??_C@_0CH@MOIKMHFA@File?5not?5correct?5photoshop?5vers@ ; `string'
PUBLIC	??_C@_0CL@NBADNBNH@Unsupported?5number?5of?5bits?5per?5@ ; `string'
PUBLIC	??_C@_0CA@NKFEDGIF@Unsupported?5image?5mode?3?5?$CI?$CFd?$CJ?5?$CFs@ ; `string'
PUBLIC	??_C@_04KDANOMBE@8BIM@				; `string'
PUBLIC	??_C@_0DC@IFJIPEEO@File?5not?5a?5photoshop?5multi?9laye@ ; `string'
PUBLIC	??_C@_0EJ@PPNKFPMK@Layer?5not?5same?5size?5as?5main?5ima@ ; `string'
PUBLIC	??_C@_0DI@LMAEGLML@c?3?2users?2nhv90?2projects?2eech?2mo@ ; `string'
PUBLIC	??_C@_04PJOLNDGD@data@				; `string'
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fgetc:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__ftell:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_memset:PROC
EXTRN	_strrchr:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	?process_assert@@YGXPBD0H@Z:PROC		; process_assert
EXTRN	?debug_fatal@@YAXPBDZZ:PROC			; debug_fatal
EXTRN	?safe_malloc_memory@@YGPAXI@Z:PROC		; safe_malloc_memory
EXTRN	?safe_free@@YGXPAX@Z:PROC			; safe_free
EXTRN	?file_exist@@YGHPBD@Z:PROC			; file_exist
EXTRN	?safe_fopen@@YGPAU_iobuf@@PBD0@Z:PROC		; safe_fopen
EXTRN	?iff_int_read@@YGHPAU_iobuf@@@Z:PROC		; iff_int_read
EXTRN	?iff_short_int_read@@YGFPAU_iobuf@@@Z:PROC	; iff_short_int_read
EXTRN	?psd_theme@@3PADA:BYTE				; psd_theme
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_04PJOLNDGD@data@
CONST	SEGMENT
??_C@_04PJOLNDGD@data@ DB 'data', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@LMAEGLML@c?3?2users?2nhv90?2projects?2eech?2mo@
CONST	SEGMENT
??_C@_0DI@LMAEGLML@c?3?2users?2nhv90?2projects?2eech?2mo@ DB 'c:\users\nh'
	DB	'v90\projects\eech\modules\graphics\psdread.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@PPNKFPMK@Layer?5not?5same?5size?5as?5main?5ima@
CONST	SEGMENT
??_C@_0EJ@PPNKFPMK@Layer?5not?5same?5size?5as?5main?5ima@ DB 'Layer not s'
	DB	'ame size as main image: ( %d, %d ) -> ( %d, %d ), ( %s ) - %s'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@IFJIPEEO@File?5not?5a?5photoshop?5multi?9laye@
CONST	SEGMENT
??_C@_0DC@IFJIPEEO@File?5not?5a?5photoshop?5multi?9laye@ DB 'File not a p'
	DB	'hotoshop multi-layered psd format: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04KDANOMBE@8BIM@
CONST	SEGMENT
??_C@_04KDANOMBE@8BIM@ DB '8BIM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NKFEDGIF@Unsupported?5image?5mode?3?5?$CI?$CFd?$CJ?5?$CFs@
CONST	SEGMENT
??_C@_0CA@NKFEDGIF@Unsupported?5image?5mode?3?5?$CI?$CFd?$CJ?5?$CFs@ DB 'U'
	DB	'nsupported image mode: (%d) %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NBADNBNH@Unsupported?5number?5of?5bits?5per?5@
CONST	SEGMENT
??_C@_0CL@NBADNBNH@Unsupported?5number?5of?5bits?5per?5@ DB 'Unsupported '
	DB	'number of bits per channel: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MOIKMHFA@File?5not?5correct?5photoshop?5vers@
CONST	SEGMENT
??_C@_0CH@MOIKMHFA@File?5not?5correct?5photoshop?5vers@ DB 'File not corr'
	DB	'ect photoshop version: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NONIEFE@File?5not?5a?5photoshop?5psd?5format@
CONST	SEGMENT
??_C@_0CE@NONIEFE@File?5not?5a?5photoshop?5psd?5format@ DB 'File not a ph'
	DB	'otoshop psd format: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GELLELDE@8BPS@
CONST	SEGMENT
??_C@_04GELLELDE@8BPS@ DB '8BPS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs@ DB '%s\%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LBAOFDNG@?$CF?4?$CKs?2?$CFs?2?$CFs@
CONST	SEGMENT
??_C@_0L@LBAOFDNG@?$CF?4?$CKs?2?$CFs?2?$CFs@ DB '%.*s\%s\%s', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??load_psd_file@@YGPAXPBDPAH11@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??load_psd_file@@YGPAXPBDPAH11@Z@4JA DD 06cH ; `load_psd_file'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\psdread.c
;	COMDAT ?load_psd_file@@YGPAXPBDPAH11@Z
_TEXT	SEGMENT
tv176 = -1632						; size = 4
_pixel_data$1 = -1434					; size = 1
_pixel_data$2 = -1433					; size = 1
_count$3 = -1432					; size = 4
_pixel_data$4 = -1425					; size = 1
_count$5 = -1424					; size = 4
_number_of_pixels_left$6 = -1420			; size = 4
_number_of_pixels_in_run$7 = -1416			; size = 4
_control$8 = -1409					; size = 1
_y$9 = -1408						; size = 4
_x$10 = -1404						; size = 4
_file_position$11 = -1400				; size = 4
_pixel_data$12 = -1394					; size = 1
_pixel_data$13 = -1393					; size = 1
_count$14 = -1392					; size = 4
_pixel_data$15 = -1385					; size = 1
_count$16 = -1384					; size = 4
_number_of_pixels_left$17 = -1380			; size = 4
_number_of_pixels_in_run$18 = -1376			; size = 4
_control$19 = -1369					; size = 1
_current_channel_id$20 = -1368				; size = 4
_current_channel_data_length$21 = -1364			; size = 4
_y$22 = -1360						; size = 4
_x$23 = -1356						; size = 4
_number_of_real_channels$24 = -1352			; size = 4
_extra_data_length$25 = -1348				; size = 4
_name_length$26 = -1344					; size = 4
_current_layer$27 = -1340				; size = 4
_ptr$28 = -1336						; size = 4
_fn$29 = -1332						; size = 1024
_version$ = -308					; size = 4
_length$ = -304						; size = 4
_compression$ = -300					; size = 4
_image_mode$ = -296					; size = 4
_bits_per_channel$ = -292				; size = 4
_number_of_channels$ = -288				; size = 4
_height$ = -284						; size = 4
_width$ = -280						; size = 4
_current_channel$ = -276				; size = 4
_count$ = -272						; size = 4
_ptr$ = -268						; size = 4
_data$ = -264						; size = 4
_id_buffer$ = -260					; size = 256
_fp$ = -4						; size = 4
_filename$ = 8						; size = 4
_width_return$ = 12					; size = 4
_height_return$ = 16					; size = 4
_number_of_channels_return$ = 20			; size = 4
?load_psd_file@@YGPAXPBDPAH11@Z PROC			; load_psd_file, COMDAT

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 60 06 00
	00		 sub	 esp, 1632		; 00000660H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 109  : 
; 110  : 	FILE
; 111  : 		*fp;
; 112  : 
; 113  : 	char
; 114  : 		id_buffer[256],
; 115  : 		*data,
; 116  : 		*ptr;
; 117  : 
; 118  : 	int
; 119  : 		count,
; 120  : 		current_channel,
; 121  : 		width,
; 122  : 		height,
; 123  : 		number_of_channels,
; 124  : 		bits_per_channel,
; 125  : 		image_mode,
; 126  : 		compression,
; 127  : 		length,
; 128  : 		version;
; 129  : 
; 130  : 	//
; 131  : 	// First, destroy any layers that may be allocated
; 132  : 	//
; 133  : 
; 134  : 	for ( count = 0; count < MAX_PSD_LAYERS; count++ )

  0000c	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$[ebp], 0
  00016	eb 0f		 jmp	 SHORT $LN4@load_psd_f
$LN2@load_psd_f:
  00018	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  0001e	83 c0 01	 add	 eax, 1
  00021	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
$LN4@load_psd_f:
  00027	83 bd f0 fe ff
	ff 10		 cmp	 DWORD PTR _count$[ebp], 16 ; 00000010H
  0002e	7d 3f		 jge	 SHORT $LN3@load_psd_f

; 135  : 	{
; 136  : 
; 137  : 		if ( psd_layers[count].data )

  00030	69 85 f0 fe ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _count$[ebp], 412
  0003a	83 b8 18 01 00
	00 00		 cmp	 DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+280], 0
  00041	74 2a		 je	 SHORT $LN65@load_psd_f

; 138  : 		{
; 139  : 
; 140  : 			safe_free ( psd_layers[count].data );

  00043	69 85 f0 fe ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _count$[ebp], 412
  0004d	8b 88 18 01 00
	00		 mov	 ecx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+280]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 141  : 			
; 142  : 			psd_layers[count].data = NULL;

  00059	69 85 f0 fe ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _count$[ebp], 412
  00063	c7 80 18 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+280], 0
$LN65@load_psd_f:

; 143  : 		}
; 144  : 	}

  0006d	eb a9		 jmp	 SHORT $LN2@load_psd_f
$LN3@load_psd_f:

; 145  : 
; 146  : 	// Casm 21DEC07
; 147  : 	{
; 148  : 		char
; 149  : 			fn[1024];
; 150  : 
; 151  : 		if (*psd_theme)

  0006f	b8 01 00 00 00	 mov	 eax, 1
  00074	6b c8 00	 imul	 ecx, eax, 0
  00077	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR ?psd_theme@@3PADA[ecx]
  0007e	85 d2		 test	 edx, edx
  00080	0f 84 92 00 00
	00		 je	 $LN66@load_psd_f

; 152  : 		{
; 153  : 			const char
; 154  : 				*ptr = strrchr(filename, '\\');

  00086	6a 5c		 push	 92			; 0000005cH
  00088	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _strrchr
  00091	83 c4 08	 add	 esp, 8
  00094	89 85 c8 fa ff
	ff		 mov	 DWORD PTR _ptr$28[ebp], eax

; 155  : 
; 156  : 			if (ptr)

  0009a	83 bd c8 fa ff
	ff 00		 cmp	 DWORD PTR _ptr$28[ebp], 0
  000a1	74 33		 je	 SHORT $LN68@load_psd_f

; 157  : 				sprintf(fn, "%.*s\\%s\\%s", ptr - filename, filename, psd_theme, ptr + 1);

  000a3	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _ptr$28[ebp]
  000a9	83 c0 01	 add	 eax, 1
  000ac	50		 push	 eax
  000ad	68 00 00 00 00	 push	 OFFSET ?psd_theme@@3PADA ; psd_theme
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR _filename$[ebp]
  000b5	51		 push	 ecx
  000b6	8b 95 c8 fa ff
	ff		 mov	 edx, DWORD PTR _ptr$28[ebp]
  000bc	2b 55 08	 sub	 edx, DWORD PTR _filename$[ebp]
  000bf	52		 push	 edx
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LBAOFDNG@?$CF?4?$CKs?2?$CFs?2?$CFs@
  000c5	8d 85 cc fa ff
	ff		 lea	 eax, DWORD PTR _fn$29[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _sprintf
  000d1	83 c4 18	 add	 esp, 24			; 00000018H

; 158  : 			else

  000d4	eb 1d		 jmp	 SHORT $LN69@load_psd_f
$LN68@load_psd_f:

; 159  : 				sprintf(fn, "%s\\%s", psd_theme, filename);

  000d6	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  000d9	50		 push	 eax
  000da	68 00 00 00 00	 push	 OFFSET ?psd_theme@@3PADA ; psd_theme
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
  000e4	8d 8d cc fa ff
	ff		 lea	 ecx, DWORD PTR _fn$29[ebp]
  000ea	51		 push	 ecx
  000eb	e8 00 00 00 00	 call	 _sprintf
  000f0	83 c4 10	 add	 esp, 16			; 00000010H
$LN69@load_psd_f:

; 160  : 			if (!file_exist(fn))

  000f3	8d 85 cc fa ff
	ff		 lea	 eax, DWORD PTR _fn$29[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?file_exist@@YGHPBD@Z	; file_exist
  000ff	85 c0		 test	 eax, eax
  00101	75 13		 jne	 SHORT $LN70@load_psd_f

; 161  : 				strcpy(fn, filename);

  00103	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00106	50		 push	 eax
  00107	8d 8d cc fa ff
	ff		 lea	 ecx, DWORD PTR _fn$29[ebp]
  0010d	51		 push	 ecx
  0010e	e8 00 00 00 00	 call	 _strcpy
  00113	83 c4 08	 add	 esp, 8
$LN70@load_psd_f:

; 162  : 		}
; 163  : 		else

  00116	eb 13		 jmp	 SHORT $LN67@load_psd_f
$LN66@load_psd_f:

; 164  : 			strcpy(fn, filename);

  00118	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0011b	50		 push	 eax
  0011c	8d 8d cc fa ff
	ff		 lea	 ecx, DWORD PTR _fn$29[ebp]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 _strcpy
  00128	83 c4 08	 add	 esp, 8
$LN67@load_psd_f:

; 165  : 		fp = safe_fopen(fn, "rb");

  0012b	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00130	8d 85 cc fa ff
	ff		 lea	 eax, DWORD PTR _fn$29[ebp]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 ?safe_fopen@@YGPAU_iobuf@@PBD0@Z ; safe_fopen
  0013c	89 45 fc	 mov	 DWORD PTR _fp$[ebp], eax

; 166  : 	}
; 167  : 
; 168  : 	//
; 169  : 	// Reset the number of layers
; 170  : 	//
; 171  : 
; 172  : 	number_of_psd_layers = 0;

  0013f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?number_of_psd_layers@@3HA, 0 ; number_of_psd_layers

; 173  : 
; 174  : 	//
; 175  : 	// Read in the signature of the file
; 176  : 	//
; 177  : 
; 178  : 	id_buffer[4] = '\0';

  00149	b8 01 00 00 00	 mov	 eax, 1
  0014e	c1 e0 02	 shl	 eax, 2
  00151	c6 84 05 fc fe
	ff ff 00	 mov	 BYTE PTR _id_buffer$[ebp+eax], 0

; 179  : 
; 180  : 	fread ( id_buffer, 4, 1, fp );

  00159	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0015c	50		 push	 eax
  0015d	6a 01		 push	 1
  0015f	6a 04		 push	 4
  00161	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _id_buffer$[ebp]
  00167	51		 push	 ecx
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0016e	83 c4 10	 add	 esp, 16			; 00000010H

; 181  : 
; 182  : 	if ( strcmp ( id_buffer, "8BPS" ) != 0 )

  00171	68 00 00 00 00	 push	 OFFSET ??_C@_04GELLELDE@8BPS@
  00176	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _id_buffer$[ebp]
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _strcmp
  00182	83 c4 08	 add	 esp, 8
  00185	85 c0		 test	 eax, eax
  00187	74 11		 je	 SHORT $LN71@load_psd_f

; 183  : 	{
; 184  : 
; 185  : 		debug_fatal ( "File not a photoshop psd format: %s", filename );

  00189	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0018c	50		 push	 eax
  0018d	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NONIEFE@File?5not?5a?5photoshop?5psd?5format@
  00192	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  00197	83 c4 08	 add	 esp, 8
$LN71@load_psd_f:

; 186  : 	}
; 187  : 
; 188  : 	//
; 189  : 	// Get the version of the format
; 190  : 	//
; 191  : 
; 192  : 	version = iff_short_int_read ( fp );

  0019a	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  001a3	0f bf c8	 movsx	 ecx, ax
  001a6	89 8d cc fe ff
	ff		 mov	 DWORD PTR _version$[ebp], ecx

; 193  : 
; 194  : 	if ( version != 1 )

  001ac	83 bd cc fe ff
	ff 01		 cmp	 DWORD PTR _version$[ebp], 1
  001b3	74 11		 je	 SHORT $LN72@load_psd_f

; 195  : 	{
; 196  : 
; 197  : 		debug_fatal ( "File not correct photoshop version: %s", filename );

  001b5	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  001b8	50		 push	 eax
  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MOIKMHFA@File?5not?5correct?5photoshop?5vers@
  001be	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  001c3	83 c4 08	 add	 esp, 8
$LN72@load_psd_f:

; 198  : 	}
; 199  : 
; 200  : 	//
; 201  : 	// Skip the reserved bytes
; 202  : 	//
; 203  : 
; 204  : 	fseek ( fp, 6, SEEK_CUR );

  001c6	6a 01		 push	 1
  001c8	6a 06		 push	 6
  001ca	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  001cd	50		 push	 eax
  001ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  001d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 205  : 
; 206  : 	//
; 207  : 	// Get the information about the image
; 208  : 	//
; 209  : 
; 210  : 	number_of_channels = iff_short_int_read ( fp );

  001d7	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  001e0	0f bf c8	 movsx	 ecx, ax
  001e3	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _number_of_channels$[ebp], ecx

; 211  : 
; 212  : 	height = iff_int_read ( fp );

  001e9	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  001ec	50		 push	 eax
  001ed	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  001f2	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _height$[ebp], eax

; 213  : 
; 214  : 	width = iff_int_read ( fp );

  001f8	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  001fb	50		 push	 eax
  001fc	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  00201	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _width$[ebp], eax

; 215  : 
; 216  : 	bits_per_channel = iff_short_int_read ( fp );

  00207	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0020a	50		 push	 eax
  0020b	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  00210	0f bf c8	 movsx	 ecx, ax
  00213	89 8d dc fe ff
	ff		 mov	 DWORD PTR _bits_per_channel$[ebp], ecx

; 217  : 
; 218  : 	image_mode = iff_short_int_read ( fp );

  00219	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0021c	50		 push	 eax
  0021d	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  00222	0f bf c8	 movsx	 ecx, ax
  00225	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _image_mode$[ebp], ecx

; 219  : 
; 220  : 	if ( bits_per_channel != 8 )

  0022b	83 bd dc fe ff
	ff 08		 cmp	 DWORD PTR _bits_per_channel$[ebp], 8
  00232	74 11		 je	 SHORT $LN73@load_psd_f

; 221  : 	{
; 222  : 
; 223  : 		debug_fatal ( "Unsupported number of bits per channel: %s", filename );

  00234	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00237	50		 push	 eax
  00238	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NBADNBNH@Unsupported?5number?5of?5bits?5per?5@
  0023d	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  00242	83 c4 08	 add	 esp, 8
$LN73@load_psd_f:

; 224  : 	}
; 225  : 
; 226  : 	switch ( image_mode )

  00245	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _image_mode$[ebp]
  0024b	89 85 a0 f9 ff
	ff		 mov	 DWORD PTR tv176[ebp], eax
  00251	83 bd a0 f9 ff
	ff 00		 cmp	 DWORD PTR tv176[ebp], 0
  00258	7e 0d		 jle	 SHORT $LN75@load_psd_f
  0025a	83 bd a0 f9 ff
	ff 03		 cmp	 DWORD PTR tv176[ebp], 3
  00261	7e 02		 jle	 SHORT $LN74@load_psd_f
  00263	eb 02		 jmp	 SHORT $LN75@load_psd_f
$LN74@load_psd_f:

; 227  : 	{
; 228  : 
; 229  : 		case 1:
; 230  : 		case 2:
; 231  : 		case 3:
; 232  : 		{
; 233  : 
; 234  : 			break;

  00265	eb 18		 jmp	 SHORT $LN5@load_psd_f
$LN75@load_psd_f:

; 235  : 		}
; 236  : 
; 237  : 		default:
; 238  : 		{
; 239  : 
; 240  : 			debug_fatal ( "Unsupported image mode: (%d) %s", image_mode, filename );

  00267	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0026a	50		 push	 eax
  0026b	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _image_mode$[ebp]
  00271	51		 push	 ecx
  00272	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NKFEDGIF@Unsupported?5image?5mode?3?5?$CI?$CFd?$CJ?5?$CFs@
  00277	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  0027c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@load_psd_f:

; 241  : 		}
; 242  : 	}
; 243  : 
; 244  : 	length = iff_int_read ( fp );

  0027f	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00282	50		 push	 eax
  00283	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  00288	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _length$[ebp], eax

; 245  : 
; 246  : 	if ( image_mode == 2 )

  0028e	83 bd d8 fe ff
	ff 02		 cmp	 DWORD PTR _image_mode$[ebp], 2
  00295	0f 85 ee 00 00
	00		 jne	 $LN76@load_psd_f

; 247  : 	{
; 248  : 
; 249  : 		//
; 250  : 		// Read in the palette
; 251  : 		//
; 252  : 
; 253  : 		memset ( psd_palette, 0, sizeof ( psd_palette ) );

  0029b	68 00 04 00 00	 push	 1024			; 00000400H
  002a0	6a 00		 push	 0
  002a2	68 00 00 00 00	 push	 OFFSET ?psd_palette@@3PAUREAL_COLOUR@@A ; psd_palette
  002a7	e8 00 00 00 00	 call	 _memset
  002ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 254  : 
; 255  : 		for ( count = 0; count < 256; count++ )

  002af	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$[ebp], 0
  002b9	eb 0f		 jmp	 SHORT $LN9@load_psd_f
$LN7@load_psd_f:
  002bb	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  002c1	83 c0 01	 add	 eax, 1
  002c4	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
$LN9@load_psd_f:
  002ca	81 bd f0 fe ff
	ff 00 01 00 00	 cmp	 DWORD PTR _count$[ebp], 256 ; 00000100H
  002d4	7d 21		 jge	 SHORT $LN8@load_psd_f

; 256  : 		{
; 257  : 
; 258  : 			fread ( &psd_palette[count].r, 1, 1, fp );

  002d6	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  002d9	50		 push	 eax
  002da	6a 01		 push	 1
  002dc	6a 01		 push	 1
  002de	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _count$[ebp]
  002e4	8d 14 8d 02 00
	00 00		 lea	 edx, DWORD PTR ?psd_palette@@3PAUREAL_COLOUR@@A[ecx*4+2]
  002eb	52		 push	 edx
  002ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  002f2	83 c4 10	 add	 esp, 16			; 00000010H

; 259  : 		}

  002f5	eb c4		 jmp	 SHORT $LN7@load_psd_f
$LN8@load_psd_f:

; 260  : 
; 261  : 		for ( count = 0; count < 256; count++ )

  002f7	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$[ebp], 0
  00301	eb 0f		 jmp	 SHORT $LN12@load_psd_f
$LN10@load_psd_f:
  00303	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  00309	83 c0 01	 add	 eax, 1
  0030c	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
$LN12@load_psd_f:
  00312	81 bd f0 fe ff
	ff 00 01 00 00	 cmp	 DWORD PTR _count$[ebp], 256 ; 00000100H
  0031c	7d 21		 jge	 SHORT $LN11@load_psd_f

; 262  : 		{
; 263  : 
; 264  : 			fread ( &psd_palette[count].g, 1, 1, fp );

  0031e	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00321	50		 push	 eax
  00322	6a 01		 push	 1
  00324	6a 01		 push	 1
  00326	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _count$[ebp]
  0032c	8d 14 8d 01 00
	00 00		 lea	 edx, DWORD PTR ?psd_palette@@3PAUREAL_COLOUR@@A[ecx*4+1]
  00333	52		 push	 edx
  00334	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0033a	83 c4 10	 add	 esp, 16			; 00000010H

; 265  : 		}

  0033d	eb c4		 jmp	 SHORT $LN10@load_psd_f
$LN11@load_psd_f:

; 266  : 
; 267  : 		for ( count = 0; count < 256; count++ )

  0033f	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$[ebp], 0
  00349	eb 0f		 jmp	 SHORT $LN15@load_psd_f
$LN13@load_psd_f:
  0034b	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  00351	83 c0 01	 add	 eax, 1
  00354	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
$LN15@load_psd_f:
  0035a	81 bd f0 fe ff
	ff 00 01 00 00	 cmp	 DWORD PTR _count$[ebp], 256 ; 00000100H
  00364	7d 21		 jge	 SHORT $LN14@load_psd_f

; 268  : 		{
; 269  : 
; 270  : 			fread ( &psd_palette[count].b, 1, 1, fp );

  00366	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00369	50		 push	 eax
  0036a	6a 01		 push	 1
  0036c	6a 01		 push	 1
  0036e	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _count$[ebp]
  00374	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR ?psd_palette@@3PAUREAL_COLOUR@@A[ecx*4]
  0037b	52		 push	 edx
  0037c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00382	83 c4 10	 add	 esp, 16			; 00000010H

; 271  : 		}

  00385	eb c4		 jmp	 SHORT $LN13@load_psd_f
$LN14@load_psd_f:

; 272  : 	}
; 273  : 	else

  00387	eb 16		 jmp	 SHORT $LN77@load_psd_f
$LN76@load_psd_f:

; 274  : 	{
; 275  : 	
; 276  : 		//
; 277  : 		// Skip over the mode data
; 278  : 		//
; 279  : 	
; 280  : 		fseek ( fp, length, SEEK_CUR );

  00389	6a 01		 push	 1
  0038b	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _length$[ebp]
  00391	50		 push	 eax
  00392	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  00395	51		 push	 ecx
  00396	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  0039c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN77@load_psd_f:

; 281  : 	}
; 282  : 
; 283  : 	//
; 284  : 	// Skip over the image resources
; 285  : 	//
; 286  : 
; 287  : 	length = iff_int_read ( fp );

  0039f	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  003a8	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _length$[ebp], eax

; 288  : 
; 289  : 	fseek ( fp, length, SEEK_CUR );

  003ae	6a 01		 push	 1
  003b0	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _length$[ebp]
  003b6	50		 push	 eax
  003b7	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  003ba	51		 push	 ecx
  003bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  003c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 290  : 
; 291  : 	//
; 292  : 	// Read in the layers
; 293  : 	//
; 294  : 
; 295  : 	length = iff_int_read ( fp );

  003c4	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  003c7	50		 push	 eax
  003c8	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  003cd	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _length$[ebp], eax

; 296  : 
; 297  : 	if ( length )

  003d3	83 bd d0 fe ff
	ff 00		 cmp	 DWORD PTR _length$[ebp], 0
  003da	0f 84 89 08 00
	00		 je	 $LN78@load_psd_f

; 298  : 	{
; 299  : 
; 300  : 		int
; 301  : 			current_layer;
; 302  : 
; 303  : 		//
; 304  : 		// Read in the layers information
; 305  : 		//
; 306  : 
; 307  : 		length = iff_int_read ( fp );

  003e0	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  003e3	50		 push	 eax
  003e4	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  003e9	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _length$[ebp], eax

; 308  : 
; 309  : 		number_of_psd_layers = iff_short_int_read ( fp );

  003ef	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  003f2	50		 push	 eax
  003f3	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  003f8	0f bf c8	 movsx	 ecx, ax
  003fb	89 0d 00 00 00
	00		 mov	 DWORD PTR ?number_of_psd_layers@@3HA, ecx ; number_of_psd_layers

; 310  : 
; 311  : 		if ( number_of_psd_layers < 0 )

  00401	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?number_of_psd_layers@@3HA, 0 ; number_of_psd_layers
  00408	7d 0c		 jge	 SHORT $LN79@load_psd_f

; 312  : 		{
; 313  : 
; 314  : 			number_of_psd_layers = -number_of_psd_layers;

  0040a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_psd_layers@@3HA ; number_of_psd_layers
  0040f	f7 d8		 neg	 eax
  00411	a3 00 00 00 00	 mov	 DWORD PTR ?number_of_psd_layers@@3HA, eax ; number_of_psd_layers
$LN79@load_psd_f:

; 315  : 		}
; 316  : 
; 317  : 		for ( current_layer = 0; current_layer < number_of_psd_layers; current_layer++ )

  00416	c7 85 c4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _current_layer$27[ebp], 0
  00420	eb 0f		 jmp	 SHORT $LN18@load_psd_f
$LN16@load_psd_f:
  00422	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _current_layer$27[ebp]
  00428	83 c0 01	 add	 eax, 1
  0042b	89 85 c4 fa ff
	ff		 mov	 DWORD PTR _current_layer$27[ebp], eax
$LN18@load_psd_f:
  00431	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _current_layer$27[ebp]
  00437	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_psd_layers@@3HA ; number_of_psd_layers
  0043d	0f 8d 74 03 00
	00		 jge	 $LN17@load_psd_f

; 318  : 		{
; 319  : 
; 320  : 			int
; 321  : 				name_length,
; 322  : 				extra_data_length;
; 323  : 
; 324  : 			psd_layers[current_layer].top = iff_int_read ( fp );

  00443	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00446	50		 push	 eax
  00447	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  0044c	69 8d c4 fa ff
	ff 9c 01 00 00	 imul	 ecx, DWORD PTR _current_layer$27[ebp], 412
  00456	89 81 00 01 00
	00		 mov	 DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[ecx+256], eax

; 325  : 
; 326  : 			psd_layers[current_layer].left = iff_int_read ( fp );

  0045c	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0045f	50		 push	 eax
  00460	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  00465	69 8d c4 fa ff
	ff 9c 01 00 00	 imul	 ecx, DWORD PTR _current_layer$27[ebp], 412
  0046f	89 81 04 01 00
	00		 mov	 DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[ecx+260], eax

; 327  : 
; 328  : 			psd_layers[current_layer].bottom = iff_int_read ( fp );

  00475	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00478	50		 push	 eax
  00479	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  0047e	69 8d c4 fa ff
	ff 9c 01 00 00	 imul	 ecx, DWORD PTR _current_layer$27[ebp], 412
  00488	89 81 08 01 00
	00		 mov	 DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[ecx+264], eax

; 329  : 
; 330  : 			psd_layers[current_layer].right = iff_int_read ( fp );

  0048e	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00491	50		 push	 eax
  00492	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  00497	69 8d c4 fa ff
	ff 9c 01 00 00	 imul	 ecx, DWORD PTR _current_layer$27[ebp], 412
  004a1	89 81 0c 01 00
	00		 mov	 DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[ecx+268], eax

; 331  : 
; 332  : 			psd_layers[current_layer].number_of_saved_channels = iff_short_int_read ( fp );

  004a7	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  004aa	50		 push	 eax
  004ab	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  004b0	0f bf c8	 movsx	 ecx, ax
  004b3	69 95 c4 fa ff
	ff 9c 01 00 00	 imul	 edx, DWORD PTR _current_layer$27[ebp], 412
  004bd	89 8a 10 01 00
	00		 mov	 DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[edx+272], ecx

; 333  : 
; 334  : 			for ( current_channel = 0; current_channel < psd_layers[current_layer].number_of_saved_channels; current_channel++ )

  004c3	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _current_channel$[ebp], 0
  004cd	eb 0f		 jmp	 SHORT $LN21@load_psd_f
$LN19@load_psd_f:
  004cf	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _current_channel$[ebp]
  004d5	83 c0 01	 add	 eax, 1
  004d8	89 85 ec fe ff
	ff		 mov	 DWORD PTR _current_channel$[ebp], eax
$LN21@load_psd_f:
  004de	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  004e8	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _current_channel$[ebp]
  004ee	3b 88 10 01 00
	00		 cmp	 ecx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+272]
  004f4	7d 45		 jge	 SHORT $LN20@load_psd_f

; 335  : 			{
; 336  : 
; 337  : 				psd_layers[current_layer].channel_info[current_channel].id = iff_short_int_read ( fp );

  004f6	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  004f9	50		 push	 eax
  004fa	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  004ff	0f bf c8	 movsx	 ecx, ax
  00502	69 95 c4 fa ff
	ff 9c 01 00 00	 imul	 edx, DWORD PTR _current_layer$27[ebp], 412
  0050c	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _current_channel$[ebp]
  00512	89 8c c2 1c 01
	00 00		 mov	 DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[edx+eax*8+284], ecx

; 338  : 
; 339  : 				psd_layers[current_layer].channel_info[current_channel].length = iff_int_read ( fp );

  00519	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0051c	50		 push	 eax
  0051d	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  00522	69 8d c4 fa ff
	ff 9c 01 00 00	 imul	 ecx, DWORD PTR _current_layer$27[ebp], 412
  0052c	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _current_channel$[ebp]
  00532	89 84 d1 20 01
	00 00		 mov	 DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[ecx+edx*8+288], eax

; 340  : 			}

  00539	eb 94		 jmp	 SHORT $LN19@load_psd_f
$LN20@load_psd_f:

; 341  : 
; 342  : 			//
; 343  : 			// Read in the id field or the layer
; 344  : 			//
; 345  : 
; 346  : 			fread ( id_buffer, 4, 1, fp );

  0053b	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0053e	50		 push	 eax
  0053f	6a 01		 push	 1
  00541	6a 04		 push	 4
  00543	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _id_buffer$[ebp]
  00549	51		 push	 ecx
  0054a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00550	83 c4 10	 add	 esp, 16			; 00000010H

; 347  : 		
; 348  : 			if ( strcmp ( id_buffer, "8BIM" ) != 0 )

  00553	68 00 00 00 00	 push	 OFFSET ??_C@_04KDANOMBE@8BIM@
  00558	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _id_buffer$[ebp]
  0055e	50		 push	 eax
  0055f	e8 00 00 00 00	 call	 _strcmp
  00564	83 c4 08	 add	 esp, 8
  00567	85 c0		 test	 eax, eax
  00569	74 11		 je	 SHORT $LN80@load_psd_f

; 349  : 			{
; 350  : 		
; 351  : 				debug_fatal ( "File not a photoshop multi-layered psd format: %s", filename );

  0056b	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0056e	50		 push	 eax
  0056f	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@IFJIPEEO@File?5not?5a?5photoshop?5multi?9laye@
  00574	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  00579	83 c4 08	 add	 esp, 8
$LN80@load_psd_f:

; 352  : 			}
; 353  : 
; 354  : 			//
; 355  : 			// Read in the blend mode for the layer
; 356  : 			//
; 357  : 
; 358  : 			fread ( id_buffer, 4, 1, fp );

  0057c	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0057f	50		 push	 eax
  00580	6a 01		 push	 1
  00582	6a 04		 push	 4
  00584	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _id_buffer$[ebp]
  0058a	51		 push	 ecx
  0058b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00591	83 c4 10	 add	 esp, 16			; 00000010H

; 359  : 
; 360  : 			//
; 361  : 			// Skip over [ opacity, clipping, flags & filler bytes ]
; 362  : 			//
; 363  : 
; 364  : 			fseek ( fp, 4, SEEK_CUR );

  00594	6a 01		 push	 1
  00596	6a 04		 push	 4
  00598	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0059b	50		 push	 eax
  0059c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  005a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 365  : 
; 366  : 			//
; 367  : 			// Get length of extra data fields
; 368  : 			//
; 369  : 
; 370  : 			extra_data_length = iff_int_read ( fp );

  005a5	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  005a8	50		 push	 eax
  005a9	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  005ae	89 85 bc fa ff
	ff		 mov	 DWORD PTR _extra_data_length$25[ebp], eax

; 371  : 
; 372  : 			//
; 373  : 			// Read in the layer mask data
; 374  : 			//
; 375  : 
; 376  : 			length = iff_int_read ( fp );

  005b4	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  005b7	50		 push	 eax
  005b8	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  005bd	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _length$[ebp], eax

; 377  : 
; 378  : 			fseek ( fp, length, SEEK_CUR );

  005c3	6a 01		 push	 1
  005c5	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _length$[ebp]
  005cb	50		 push	 eax
  005cc	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  005cf	51		 push	 ecx
  005d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  005d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 379  : 
; 380  : 			extra_data_length -= ( 4 + length );

  005d9	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _length$[ebp]
  005df	83 c0 04	 add	 eax, 4
  005e2	8b 8d bc fa ff
	ff		 mov	 ecx, DWORD PTR _extra_data_length$25[ebp]
  005e8	2b c8		 sub	 ecx, eax
  005ea	89 8d bc fa ff
	ff		 mov	 DWORD PTR _extra_data_length$25[ebp], ecx

; 381  : 
; 382  : 			//
; 383  : 			// Read in layer blending ranges
; 384  : 			//
; 385  : 
; 386  : 			length = iff_int_read ( fp );

  005f0	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  005f3	50		 push	 eax
  005f4	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  005f9	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _length$[ebp], eax

; 387  : 
; 388  : 			fseek ( fp, length, SEEK_CUR );

  005ff	6a 01		 push	 1
  00601	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _length$[ebp]
  00607	50		 push	 eax
  00608	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  0060b	51		 push	 ecx
  0060c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00612	83 c4 0c	 add	 esp, 12			; 0000000cH

; 389  : 
; 390  : 			extra_data_length -= ( 4 + length );

  00615	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _length$[ebp]
  0061b	83 c0 04	 add	 eax, 4
  0061e	8b 8d bc fa ff
	ff		 mov	 ecx, DWORD PTR _extra_data_length$25[ebp]
  00624	2b c8		 sub	 ecx, eax
  00626	89 8d bc fa ff
	ff		 mov	 DWORD PTR _extra_data_length$25[ebp], ecx

; 391  : 
; 392  : 			//
; 393  : 			// Read in the layer name ( pascal format: 1 byte = length of string, followed by string ) all formatted to multiple of 4 bytes
; 394  : 			//
; 395  : 
; 396  : 			name_length = fgetc ( fp );

  0062c	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  0062f	50		 push	 eax
  00630	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00636	83 c4 04	 add	 esp, 4
  00639	89 85 c0 fa ff
	ff		 mov	 DWORD PTR _name_length$26[ebp], eax

; 397  : 
; 398  : 			if ( ( name_length + 1 ) % 4 )

  0063f	8b 85 c0 fa ff
	ff		 mov	 eax, DWORD PTR _name_length$26[ebp]
  00645	83 c0 01	 add	 eax, 1
  00648	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0064d	79 05		 jns	 SHORT $LN109@load_psd_f
  0064f	48		 dec	 eax
  00650	83 c8 fc	 or	 eax, -4			; fffffffcH
  00653	40		 inc	 eax
$LN109@load_psd_f:
  00654	85 c0		 test	 eax, eax
  00656	74 2a		 je	 SHORT $LN81@load_psd_f

; 399  : 			{
; 400  : 
; 401  : 				length = name_length + ( 4 - ( name_length + 1 ) % 4 );

  00658	8b 85 c0 fa ff
	ff		 mov	 eax, DWORD PTR _name_length$26[ebp]
  0065e	83 c0 01	 add	 eax, 1
  00661	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00666	79 05		 jns	 SHORT $LN110@load_psd_f
  00668	48		 dec	 eax
  00669	83 c8 fc	 or	 eax, -4			; fffffffcH
  0066c	40		 inc	 eax
$LN110@load_psd_f:
  0066d	b9 04 00 00 00	 mov	 ecx, 4
  00672	2b c8		 sub	 ecx, eax
  00674	03 8d c0 fa ff
	ff		 add	 ecx, DWORD PTR _name_length$26[ebp]
  0067a	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _length$[ebp], ecx

; 402  : 			}
; 403  : 			else

  00680	eb 0c		 jmp	 SHORT $LN82@load_psd_f
$LN81@load_psd_f:

; 404  : 			{
; 405  : 
; 406  : 				length = name_length;

  00682	8b 85 c0 fa ff
	ff		 mov	 eax, DWORD PTR _name_length$26[ebp]
  00688	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _length$[ebp], eax
$LN82@load_psd_f:

; 407  : 			}
; 408  : 
; 409  : 			fread ( psd_layers[current_layer].name, length, 1, fp );

  0068e	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00691	50		 push	 eax
  00692	6a 01		 push	 1
  00694	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _length$[ebp]
  0069a	51		 push	 ecx
  0069b	69 95 c4 fa ff
	ff 9c 01 00 00	 imul	 edx, DWORD PTR _current_layer$27[ebp], 412
  006a5	81 c2 00 00 00
	00		 add	 edx, OFFSET ?psd_layers@@3PAUPSD_LAYER_INFO@@A ; psd_layers
  006ab	52		 push	 edx
  006ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  006b2	83 c4 10	 add	 esp, 16			; 00000010H

; 410  : 
; 411  : 			psd_layers[current_layer].name[length] = '\0';

  006b5	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  006bf	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _length$[ebp]
  006c5	c6 84 08 00 00
	00 00 00	 mov	 BYTE PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+ecx], 0

; 412  : 
; 413  : 			extra_data_length -= ( length + 1 );

  006cd	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _length$[ebp]
  006d3	83 c0 01	 add	 eax, 1
  006d6	8b 8d bc fa ff
	ff		 mov	 ecx, DWORD PTR _extra_data_length$25[ebp]
  006dc	2b c8		 sub	 ecx, eax
  006de	89 8d bc fa ff
	ff		 mov	 DWORD PTR _extra_data_length$25[ebp], ecx

; 414  : 
; 415  : 			if ( extra_data_length )

  006e4	74 16		 je	 SHORT $LN83@load_psd_f

; 416  : 			{
; 417  : 
; 418  : 				fseek ( fp, extra_data_length, SEEK_CUR );

  006e6	6a 01		 push	 1
  006e8	8b 85 bc fa ff
	ff		 mov	 eax, DWORD PTR _extra_data_length$25[ebp]
  006ee	50		 push	 eax
  006ef	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  006f2	51		 push	 ecx
  006f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  006f9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN83@load_psd_f:

; 419  : 			}
; 420  : 
; 421  : 			if (	( ( psd_layers[current_layer].bottom - psd_layers[current_layer].top ) != height ) ||

  006fc	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  00706	69 8d c4 fa ff
	ff 9c 01 00 00	 imul	 ecx, DWORD PTR _current_layer$27[ebp], 412
  00710	8b 90 08 01 00
	00		 mov	 edx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+264]
  00716	2b 91 00 01 00
	00		 sub	 edx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[ecx+256]
  0071c	3b 95 e4 fe ff
	ff		 cmp	 edx, DWORD PTR _height$[ebp]
  00722	75 28		 jne	 SHORT $LN85@load_psd_f
  00724	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  0072e	69 8d c4 fa ff
	ff 9c 01 00 00	 imul	 ecx, DWORD PTR _current_layer$27[ebp], 412
  00738	8b 90 0c 01 00
	00		 mov	 edx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+268]
  0073e	2b 91 04 01 00
	00		 sub	 edx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[ecx+260]
  00744	3b 95 e8 fe ff
	ff		 cmp	 edx, DWORD PTR _width$[ebp]
  0074a	74 66		 je	 SHORT $LN84@load_psd_f
$LN85@load_psd_f:

; 422  : 					( ( psd_layers[current_layer].right - psd_layers[current_layer].left ) != width ) )
; 423  : /*
; 424  : 			if (	( psd_layers[current_layer].top != 0 ) ||
; 425  : 					( psd_layers[current_layer].left != 0 ) ||
; 426  : 					( psd_layers[current_layer].bottom != height ) ||
; 427  : 					( psd_layers[current_layer].right != width ) )
; 428  : 					*/
; 429  : 			{
; 430  : 
; 431  : 				debug_fatal ( "Layer not same size as main image: ( %d, %d ) -> ( %d, %d ), ( %s ) - %s",

  0074c	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0074f	50		 push	 eax
  00750	69 8d c4 fa ff
	ff 9c 01 00 00	 imul	 ecx, DWORD PTR _current_layer$27[ebp], 412
  0075a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?psd_layers@@3PAUPSD_LAYER_INFO@@A ; psd_layers
  00760	51		 push	 ecx
  00761	69 95 c4 fa ff
	ff 9c 01 00 00	 imul	 edx, DWORD PTR _current_layer$27[ebp], 412
  0076b	8b 82 0c 01 00
	00		 mov	 eax, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[edx+268]
  00771	50		 push	 eax
  00772	69 8d c4 fa ff
	ff 9c 01 00 00	 imul	 ecx, DWORD PTR _current_layer$27[ebp], 412
  0077c	8b 91 08 01 00
	00		 mov	 edx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[ecx+264]
  00782	52		 push	 edx
  00783	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  0078d	8b 88 04 01 00
	00		 mov	 ecx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+260]
  00793	51		 push	 ecx
  00794	69 95 c4 fa ff
	ff 9c 01 00 00	 imul	 edx, DWORD PTR _current_layer$27[ebp], 412
  0079e	8b 82 00 01 00
	00		 mov	 eax, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[edx+256]
  007a4	50		 push	 eax
  007a5	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@PPNKFPMK@Layer?5not?5same?5size?5as?5main?5ima@
  007aa	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  007af	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN84@load_psd_f:

; 432  : 																					psd_layers[current_layer].top,
; 433  : 																					psd_layers[current_layer].left,
; 434  : 																					psd_layers[current_layer].bottom,
; 435  : 																					psd_layers[current_layer].right,
; 436  : 																					psd_layers[current_layer].name, filename );
; 437  : 			}
; 438  : 
; 439  : 		}

  007b2	e9 6b fc ff ff	 jmp	 $LN16@load_psd_f
$LN17@load_psd_f:

; 440  : 
; 441  : 		//
; 442  : 		// Read in each layers channel image data
; 443  : 		//
; 444  : 
; 445  : 		for ( current_layer = 0; current_layer < number_of_psd_layers; current_layer++ )

  007b7	c7 85 c4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _current_layer$27[ebp], 0
  007c1	eb 0f		 jmp	 SHORT $LN24@load_psd_f
$LN22@load_psd_f:
  007c3	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _current_layer$27[ebp]
  007c9	83 c0 01	 add	 eax, 1
  007cc	89 85 c4 fa ff
	ff		 mov	 DWORD PTR _current_layer$27[ebp], eax
$LN24@load_psd_f:
  007d2	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _current_layer$27[ebp]
  007d8	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_psd_layers@@3HA ; number_of_psd_layers
  007de	0f 8d 35 04 00
	00		 jge	 $LN23@load_psd_f

; 446  : 		{
; 447  : 
; 448  : 			int
; 449  : 				number_of_real_channels;
; 450  : 
; 451  : 			//
; 452  : 			// Assess the number of "real" channels
; 453  : 			//
; 454  : 
; 455  : 			number_of_real_channels = 0;

  007e4	c7 85 b8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _number_of_real_channels$24[ebp], 0

; 456  : 
; 457  : 			for ( current_channel = 0; current_channel < psd_layers[current_layer].number_of_saved_channels; current_channel++ )

  007ee	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _current_channel$[ebp], 0
  007f8	eb 0f		 jmp	 SHORT $LN27@load_psd_f
$LN25@load_psd_f:
  007fa	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _current_channel$[ebp]
  00800	83 c0 01	 add	 eax, 1
  00803	89 85 ec fe ff
	ff		 mov	 DWORD PTR _current_channel$[ebp], eax
$LN27@load_psd_f:
  00809	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  00813	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _current_channel$[ebp]
  00819	3b 88 10 01 00
	00		 cmp	 ecx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+272]
  0081f	7d 2b		 jge	 SHORT $LN26@load_psd_f

; 458  : 			{
; 459  : 
; 460  : 				if ( psd_layers[current_layer].channel_info[current_channel].id >= 0 )

  00821	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  0082b	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _current_channel$[ebp]
  00831	83 bc c8 1c 01
	00 00 00	 cmp	 DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+ecx*8+284], 0
  00839	7c 0f		 jl	 SHORT $LN86@load_psd_f

; 461  : 				{
; 462  : 
; 463  : 					number_of_real_channels++;

  0083b	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _number_of_real_channels$24[ebp]
  00841	83 c0 01	 add	 eax, 1
  00844	89 85 b8 fa ff
	ff		 mov	 DWORD PTR _number_of_real_channels$24[ebp], eax
$LN86@load_psd_f:

; 464  : 				}
; 465  : 			}

  0084a	eb ae		 jmp	 SHORT $LN25@load_psd_f
$LN26@load_psd_f:

; 466  : 
; 467  : 			psd_layers[current_layer].number_of_channels = number_of_real_channels;

  0084c	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  00856	8b 8d b8 fa ff
	ff		 mov	 ecx, DWORD PTR _number_of_real_channels$24[ebp]
  0085c	89 88 14 01 00
	00		 mov	 DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+276], ecx

; 468  : 
; 469  : 			//
; 470  : 			// Allocate enough memory for the whole image.
; 471  : 			//
; 472  : 		
; 473  : 			data = ( char * ) safe_malloc ( width * height * psd_layers[current_layer].number_of_channels );

  00862	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _width$[ebp]
  00868	0f af 85 e4 fe
	ff ff		 imul	 eax, DWORD PTR _height$[ebp]
  0086f	69 8d c4 fa ff
	ff 9c 01 00 00	 imul	 ecx, DWORD PTR _current_layer$27[ebp], 412
  00879	0f af 81 14 01
	00 00		 imul	 eax, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[ecx+276]
  00880	50		 push	 eax
  00881	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00886	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _data$[ebp], eax

; 474  : 
; 475  : 			ASSERT ( data );

  0088c	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR _data$[ebp], 0
  00893	75 1a		 jne	 SHORT $LN87@load_psd_f
  00895	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??load_psd_file@@YGPAXPBDPAH11@Z@4JA
  0089a	05 6f 01 00 00	 add	 eax, 367		; 0000016fH
  0089f	50		 push	 eax
  008a0	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@LMAEGLML@c?3?2users?2nhv90?2projects?2eech?2mo@
  008a5	68 00 00 00 00	 push	 OFFSET ??_C@_04PJOLNDGD@data@
  008aa	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN87@load_psd_f:

; 476  : 		
; 477  : 			//
; 478  : 			// Now read in the channels.
; 479  : 			//
; 480  : 		
; 481  : 			for ( current_channel = 0; current_channel < psd_layers[current_layer].number_of_saved_channels; current_channel++ )

  008af	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _current_channel$[ebp], 0
  008b9	eb 0f		 jmp	 SHORT $LN30@load_psd_f
$LN28@load_psd_f:
  008bb	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _current_channel$[ebp]
  008c1	83 c0 01	 add	 eax, 1
  008c4	89 85 ec fe ff
	ff		 mov	 DWORD PTR _current_channel$[ebp], eax
$LN30@load_psd_f:
  008ca	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  008d4	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _current_channel$[ebp]
  008da	3b 88 10 01 00
	00		 cmp	 ecx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+272]
  008e0	0f 8d 18 03 00
	00		 jge	 $LN29@load_psd_f

; 482  : 			{
; 483  : 		
; 484  : 				int
; 485  : 					x,
; 486  : 					y,
; 487  : 					current_channel_data_length,
; 488  : 					current_channel_id;
; 489  : 
; 490  : 				compression = iff_short_int_read ( fp );

  008e6	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  008e9	50		 push	 eax
  008ea	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  008ef	0f bf c8	 movsx	 ecx, ax
  008f2	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _compression$[ebp], ecx

; 491  : 
; 492  : 				if ( compression )

  008f8	83 bd d4 fe ff
	ff 00		 cmp	 DWORD PTR _compression$[ebp], 0
  008ff	74 4d		 je	 SHORT $LN88@load_psd_f

; 493  : 				{
; 494  : 
; 495  : 					//
; 496  : 					// Read in the number of bytes in this channel
; 497  : 					//
; 498  : 
; 499  : 					current_channel_data_length = 0;

  00901	c7 85 ac fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _current_channel_data_length$21[ebp], 0

; 500  : 
; 501  : 					for ( y = 0; y < height; y++ )

  0090b	c7 85 b0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$22[ebp], 0
  00915	eb 0f		 jmp	 SHORT $LN33@load_psd_f
$LN31@load_psd_f:
  00917	8b 85 b0 fa ff
	ff		 mov	 eax, DWORD PTR _y$22[ebp]
  0091d	83 c0 01	 add	 eax, 1
  00920	89 85 b0 fa ff
	ff		 mov	 DWORD PTR _y$22[ebp], eax
$LN33@load_psd_f:
  00926	8b 85 b0 fa ff
	ff		 mov	 eax, DWORD PTR _y$22[ebp]
  0092c	3b 85 e4 fe ff
	ff		 cmp	 eax, DWORD PTR _height$[ebp]
  00932	7d 1a		 jge	 SHORT $LN88@load_psd_f

; 502  : 					{
; 503  : 
; 504  : 						current_channel_data_length += iff_short_int_read ( fp );

  00934	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00937	50		 push	 eax
  00938	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  0093d	0f bf c8	 movsx	 ecx, ax
  00940	03 8d ac fa ff
	ff		 add	 ecx, DWORD PTR _current_channel_data_length$21[ebp]
  00946	89 8d ac fa ff
	ff		 mov	 DWORD PTR _current_channel_data_length$21[ebp], ecx

; 505  : 					}

  0094c	eb c9		 jmp	 SHORT $LN31@load_psd_f
$LN88@load_psd_f:

; 506  : 				}
; 507  : 
; 508  : 				current_channel_id = psd_layers[current_layer].channel_info[current_channel].id;

  0094e	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  00958	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _current_channel$[ebp]
  0095e	8b 94 c8 1c 01
	00 00		 mov	 edx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+ecx*8+284]
  00965	89 95 a8 fa ff
	ff		 mov	 DWORD PTR _current_channel_id$20[ebp], edx

; 509  : 
; 510  : 				if ( current_channel_id < 0 )

  0096b	83 bd a8 fa ff
	ff 00		 cmp	 DWORD PTR _current_channel_id$20[ebp], 0
  00972	7d 43		 jge	 SHORT $LN89@load_psd_f

; 511  : 				{
; 512  : 
; 513  : 					//
; 514  : 					// Skip over the data for this channel
; 515  : 					//
; 516  : 
; 517  : 					if ( compression )

  00974	83 bd d4 fe ff
	ff 00		 cmp	 DWORD PTR _compression$[ebp], 0
  0097b	74 18		 je	 SHORT $LN91@load_psd_f

; 518  : 					{
; 519  : 	
; 520  : 						fseek ( fp, current_channel_data_length, SEEK_CUR );

  0097d	6a 01		 push	 1
  0097f	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR _current_channel_data_length$21[ebp]
  00985	50		 push	 eax
  00986	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  00989	51		 push	 ecx
  0098a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00990	83 c4 0c	 add	 esp, 12			; 0000000cH

; 521  : 					}
; 522  : 					else

  00993	eb 1d		 jmp	 SHORT $LN92@load_psd_f
$LN91@load_psd_f:

; 523  : 					{
; 524  : 
; 525  : 						fseek ( fp, width * height, SEEK_CUR );

  00995	6a 01		 push	 1
  00997	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _width$[ebp]
  0099d	0f af 85 e4 fe
	ff ff		 imul	 eax, DWORD PTR _height$[ebp]
  009a4	50		 push	 eax
  009a5	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  009a8	51		 push	 ecx
  009a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  009af	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN92@load_psd_f:

; 526  : 					}
; 527  : 				}
; 528  : 				else

  009b2	e9 42 02 00 00	 jmp	 $LN90@load_psd_f
$LN89@load_psd_f:

; 529  : 				{
; 530  : 	
; 531  : 					//
; 532  : 					// There is no compression over rows.
; 533  : 					//
; 534  : 			
; 535  : 					for ( y = 0; y < height; y++ )

  009b7	c7 85 b0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$22[ebp], 0
  009c1	eb 0f		 jmp	 SHORT $LN36@load_psd_f
$LN34@load_psd_f:
  009c3	8b 85 b0 fa ff
	ff		 mov	 eax, DWORD PTR _y$22[ebp]
  009c9	83 c0 01	 add	 eax, 1
  009cc	89 85 b0 fa ff
	ff		 mov	 DWORD PTR _y$22[ebp], eax
$LN36@load_psd_f:
  009d2	8b 85 b0 fa ff
	ff		 mov	 eax, DWORD PTR _y$22[ebp]
  009d8	3b 85 e4 fe ff
	ff		 cmp	 eax, DWORD PTR _height$[ebp]
  009de	0f 8d 15 02 00
	00		 jge	 $LN90@load_psd_f

; 536  : 					{
; 537  : 			
; 538  : 						ptr = &data[ ( ( width * psd_layers[current_layer].number_of_channels * y ) + current_channel_id ) ];

  009e4	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  009ee	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _width$[ebp]
  009f4	0f af 88 14 01
	00 00		 imul	 ecx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+276]
  009fb	0f af 8d b0 fa
	ff ff		 imul	 ecx, DWORD PTR _y$22[ebp]
  00a02	03 8d a8 fa ff
	ff		 add	 ecx, DWORD PTR _current_channel_id$20[ebp]
  00a08	03 8d f8 fe ff
	ff		 add	 ecx, DWORD PTR _data$[ebp]
  00a0e	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _ptr$[ebp], ecx

; 539  : 			
; 540  : 						if ( compression )

  00a14	83 bd d4 fe ff
	ff 00		 cmp	 DWORD PTR _compression$[ebp], 0
  00a1b	0f 84 6b 01 00
	00		 je	 $LN93@load_psd_f

; 541  : 						{
; 542  : 			
; 543  : 							signed char
; 544  : 								control;
; 545  : 			
; 546  : 							int
; 547  : 								number_of_pixels_in_run;
; 548  : 			
; 549  : 							int
; 550  : 								number_of_pixels_left;
; 551  : 			
; 552  : 							number_of_pixels_left = width;

  00a21	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _width$[ebp]
  00a27	89 85 9c fa ff
	ff		 mov	 DWORD PTR _number_of_pixels_left$17[ebp], eax
$LN37@load_psd_f:

; 553  : 			
; 554  : 							while ( number_of_pixels_left > 0 )

  00a2d	83 bd 9c fa ff
	ff 00		 cmp	 DWORD PTR _number_of_pixels_left$17[ebp], 0
  00a34	0f 8e 50 01 00
	00		 jle	 $LN38@load_psd_f

; 555  : 							{
; 556  : 			
; 557  : 								//
; 558  : 								// Read the source byte in
; 559  : 								//
; 560  : 			
; 561  : 								control = fgetc ( fp );

  00a3a	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00a3d	50		 push	 eax
  00a3e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00a44	83 c4 04	 add	 esp, 4
  00a47	88 85 a7 fa ff
	ff		 mov	 BYTE PTR _control$19[ebp], al

; 562  : 			
; 563  : 								number_of_pixels_in_run = control;

  00a4d	0f be 85 a7 fa
	ff ff		 movsx	 eax, BYTE PTR _control$19[ebp]
  00a54	89 85 a0 fa ff
	ff		 mov	 DWORD PTR _number_of_pixels_in_run$18[ebp], eax

; 564  : 			
; 565  : 								if ( number_of_pixels_in_run >= 0 )

  00a5a	83 bd a0 fa ff
	ff 00		 cmp	 DWORD PTR _number_of_pixels_in_run$18[ebp], 0
  00a61	0f 8c 84 00 00
	00		 jl	 $LN95@load_psd_f

; 566  : 								{
; 567  : 			
; 568  : 									int
; 569  : 										count;
; 570  : 			
; 571  : 									//
; 572  : 									// Copy the next ( number_of_pixels_in_run + 1 ) bytes literally.
; 573  : 									//
; 574  : 			
; 575  : 									for ( count = 0; count <= number_of_pixels_in_run; count++ )

  00a67	c7 85 98 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$16[ebp], 0
  00a71	eb 0f		 jmp	 SHORT $LN41@load_psd_f
$LN39@load_psd_f:
  00a73	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _count$16[ebp]
  00a79	83 c0 01	 add	 eax, 1
  00a7c	89 85 98 fa ff
	ff		 mov	 DWORD PTR _count$16[ebp], eax
$LN41@load_psd_f:
  00a82	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _count$16[ebp]
  00a88	3b 85 a0 fa ff
	ff		 cmp	 eax, DWORD PTR _number_of_pixels_in_run$18[ebp]
  00a8e	7f 3f		 jg	 SHORT $LN40@load_psd_f

; 576  : 									{
; 577  : 			
; 578  : 										unsigned char
; 579  : 											pixel_data;
; 580  : 			
; 581  : 										pixel_data = fgetc ( fp );

  00a90	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00a93	50		 push	 eax
  00a94	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00a9a	83 c4 04	 add	 esp, 4
  00a9d	88 85 97 fa ff
	ff		 mov	 BYTE PTR _pixel_data$15[ebp], al

; 582  : 			
; 583  : 										*ptr = pixel_data;

  00aa3	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  00aa9	8a 8d 97 fa ff
	ff		 mov	 cl, BYTE PTR _pixel_data$15[ebp]
  00aaf	88 08		 mov	 BYTE PTR [eax], cl

; 584  : 			
; 585  : 										ptr += psd_layers[current_layer].number_of_channels;

  00ab1	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  00abb	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _ptr$[ebp]
  00ac1	03 88 14 01 00
	00		 add	 ecx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+276]
  00ac7	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _ptr$[ebp], ecx

; 586  : 									}

  00acd	eb a4		 jmp	 SHORT $LN39@load_psd_f
$LN40@load_psd_f:

; 587  : 			
; 588  : 									number_of_pixels_left -= ( number_of_pixels_in_run + 1 );

  00acf	8b 85 a0 fa ff
	ff		 mov	 eax, DWORD PTR _number_of_pixels_in_run$18[ebp]
  00ad5	83 c0 01	 add	 eax, 1
  00ad8	8b 8d 9c fa ff
	ff		 mov	 ecx, DWORD PTR _number_of_pixels_left$17[ebp]
  00ade	2b c8		 sub	 ecx, eax
  00ae0	89 8d 9c fa ff
	ff		 mov	 DWORD PTR _number_of_pixels_left$17[ebp], ecx
  00ae6	e9 9a 00 00 00	 jmp	 $LN98@load_psd_f
$LN95@load_psd_f:

; 589  : 								}
; 590  : 								else if ( number_of_pixels_in_run != -128 )

  00aeb	83 bd a0 fa ff
	ff 80		 cmp	 DWORD PTR _number_of_pixels_in_run$18[ebp], -128 ; ffffff80H
  00af2	0f 84 8d 00 00
	00		 je	 $LN98@load_psd_f

; 591  : 								{
; 592  : 			
; 593  : 									int
; 594  : 										count;
; 595  : 			
; 596  : 									unsigned char
; 597  : 										pixel_data;
; 598  : 			
; 599  : 									//
; 600  : 									// Repeat the next byte ( ( -control ) + 1 ) times
; 601  : 									//
; 602  : 			
; 603  : 									number_of_pixels_in_run = -number_of_pixels_in_run;

  00af8	8b 85 a0 fa ff
	ff		 mov	 eax, DWORD PTR _number_of_pixels_in_run$18[ebp]
  00afe	f7 d8		 neg	 eax
  00b00	89 85 a0 fa ff
	ff		 mov	 DWORD PTR _number_of_pixels_in_run$18[ebp], eax

; 604  : 			
; 605  : 									pixel_data = fgetc ( fp );

  00b06	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00b09	50		 push	 eax
  00b0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00b10	83 c4 04	 add	 esp, 4
  00b13	88 85 8f fa ff
	ff		 mov	 BYTE PTR _pixel_data$13[ebp], al

; 606  : 			
; 607  : 									for ( count = 0; count <= number_of_pixels_in_run; count++ )

  00b19	c7 85 90 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$14[ebp], 0
  00b23	eb 0f		 jmp	 SHORT $LN44@load_psd_f
$LN42@load_psd_f:
  00b25	8b 85 90 fa ff
	ff		 mov	 eax, DWORD PTR _count$14[ebp]
  00b2b	83 c0 01	 add	 eax, 1
  00b2e	89 85 90 fa ff
	ff		 mov	 DWORD PTR _count$14[ebp], eax
$LN44@load_psd_f:
  00b34	8b 85 90 fa ff
	ff		 mov	 eax, DWORD PTR _count$14[ebp]
  00b3a	3b 85 a0 fa ff
	ff		 cmp	 eax, DWORD PTR _number_of_pixels_in_run$18[ebp]
  00b40	7f 2c		 jg	 SHORT $LN43@load_psd_f

; 608  : 									{
; 609  : 			
; 610  : 										*ptr = pixel_data;

  00b42	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  00b48	8a 8d 8f fa ff
	ff		 mov	 cl, BYTE PTR _pixel_data$13[ebp]
  00b4e	88 08		 mov	 BYTE PTR [eax], cl

; 611  : 			
; 612  : 										ptr += psd_layers[current_layer].number_of_channels;

  00b50	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  00b5a	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _ptr$[ebp]
  00b60	03 88 14 01 00
	00		 add	 ecx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+276]
  00b66	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _ptr$[ebp], ecx

; 613  : 									}

  00b6c	eb b7		 jmp	 SHORT $LN42@load_psd_f
$LN43@load_psd_f:

; 614  : 			
; 615  : 									number_of_pixels_left -= ( number_of_pixels_in_run + 1 );

  00b6e	8b 85 a0 fa ff
	ff		 mov	 eax, DWORD PTR _number_of_pixels_in_run$18[ebp]
  00b74	83 c0 01	 add	 eax, 1
  00b77	8b 8d 9c fa ff
	ff		 mov	 ecx, DWORD PTR _number_of_pixels_left$17[ebp]
  00b7d	2b c8		 sub	 ecx, eax
  00b7f	89 8d 9c fa ff
	ff		 mov	 DWORD PTR _number_of_pixels_left$17[ebp], ecx
$LN98@load_psd_f:

; 616  : 								}
; 617  : 			
; 618  : 								if ( number_of_pixels_left < 0 )
; 619  : 								{
; 620  : 			
; 621  : //									BREAKOUT ();
; 622  : 								}
; 623  : 							}

  00b85	e9 a3 fe ff ff	 jmp	 $LN37@load_psd_f
$LN38@load_psd_f:

; 624  : 						}
; 625  : 						else

  00b8a	eb 68		 jmp	 SHORT $LN94@load_psd_f
$LN93@load_psd_f:

; 626  : 						{
; 627  : 			
; 628  : 							for ( x = 0; x < width; x++ )

  00b8c	c7 85 b4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$23[ebp], 0
  00b96	eb 0f		 jmp	 SHORT $LN47@load_psd_f
$LN45@load_psd_f:
  00b98	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _x$23[ebp]
  00b9e	83 c0 01	 add	 eax, 1
  00ba1	89 85 b4 fa ff
	ff		 mov	 DWORD PTR _x$23[ebp], eax
$LN47@load_psd_f:
  00ba7	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _x$23[ebp]
  00bad	3b 85 e8 fe ff
	ff		 cmp	 eax, DWORD PTR _width$[ebp]
  00bb3	7d 3f		 jge	 SHORT $LN94@load_psd_f

; 629  : 							{
; 630  : 			
; 631  : 								unsigned char
; 632  : 									pixel_data;
; 633  : 			
; 634  : 								pixel_data = fgetc ( fp );

  00bb5	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00bb8	50		 push	 eax
  00bb9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00bbf	83 c4 04	 add	 esp, 4
  00bc2	88 85 8e fa ff
	ff		 mov	 BYTE PTR _pixel_data$12[ebp], al

; 635  : 			
; 636  : 								*ptr = pixel_data;

  00bc8	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  00bce	8a 8d 8e fa ff
	ff		 mov	 cl, BYTE PTR _pixel_data$12[ebp]
  00bd4	88 08		 mov	 BYTE PTR [eax], cl

; 637  : 			
; 638  : 								ptr += psd_layers[current_layer].number_of_channels;

  00bd6	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  00be0	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _ptr$[ebp]
  00be6	03 88 14 01 00
	00		 add	 ecx, DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+276]
  00bec	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _ptr$[ebp], ecx

; 639  : 							}

  00bf2	eb a4		 jmp	 SHORT $LN45@load_psd_f
$LN94@load_psd_f:

; 640  : 						}
; 641  : 					}

  00bf4	e9 ca fd ff ff	 jmp	 $LN34@load_psd_f
$LN90@load_psd_f:

; 642  : 				}
; 643  : 			}

  00bf9	e9 bd fc ff ff	 jmp	 $LN28@load_psd_f
$LN29@load_psd_f:

; 644  : 
; 645  : 			psd_layers[current_layer].data = ( unsigned char * ) data;

  00bfe	69 85 c4 fa ff
	ff 9c 01 00 00	 imul	 eax, DWORD PTR _current_layer$27[ebp], 412
  00c08	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _data$[ebp]
  00c0e	89 88 18 01 00
	00		 mov	 DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+280], ecx

; 646  : 		}

  00c14	e9 aa fb ff ff	 jmp	 $LN22@load_psd_f
$LN23@load_psd_f:

; 647  : 
; 648  : 		{
; 649  : 
; 650  : 			int
; 651  : 				file_position;
; 652  : 
; 653  : 
; 654  : 			file_position = ftell ( fp );

  00c19	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00c1c	50		 push	 eax
  00c1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00c23	83 c4 04	 add	 esp, 4
  00c26	89 85 88 fa ff
	ff		 mov	 DWORD PTR _file_position$11[ebp], eax

; 655  : 
; 656  : 			if ( file_position & 1 )

  00c2c	8b 85 88 fa ff
	ff		 mov	 eax, DWORD PTR _file_position$11[ebp]
  00c32	83 e0 01	 and	 eax, 1
  00c35	74 0d		 je	 SHORT $LN99@load_psd_f

; 657  : 			{
; 658  : 
; 659  : 				fgetc ( fp );

  00c37	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00c3a	50		 push	 eax
  00c3b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00c41	83 c4 04	 add	 esp, 4
$LN99@load_psd_f:

; 660  : 			}
; 661  : 		}
; 662  : 
; 663  : 		//
; 664  : 		// Skip over the global layers section
; 665  : 		//
; 666  : 
; 667  : 		length = iff_int_read ( fp );

  00c44	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00c47	50		 push	 eax
  00c48	e8 00 00 00 00	 call	 ?iff_int_read@@YGHPAU_iobuf@@@Z ; iff_int_read
  00c4d	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _length$[ebp], eax

; 668  : 
; 669  : 		fseek ( fp, length, SEEK_CUR );

  00c53	6a 01		 push	 1
  00c55	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _length$[ebp]
  00c5b	50		 push	 eax
  00c5c	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  00c5f	51		 push	 ecx
  00c60	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00c66	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN78@load_psd_f:

; 670  : 	}
; 671  : 
; 672  : 	compression = ftell ( fp );

  00c69	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00c6c	50		 push	 eax
  00c6d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00c73	83 c4 04	 add	 esp, 4
  00c76	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _compression$[ebp], eax

; 673  : 
; 674  : 	//
; 675  : 	// Read in the compression
; 676  : 	//
; 677  : 
; 678  : 	compression = iff_short_int_read ( fp );

  00c7c	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00c7f	50		 push	 eax
  00c80	e8 00 00 00 00	 call	 ?iff_short_int_read@@YGFPAU_iobuf@@@Z ; iff_short_int_read
  00c85	0f bf c8	 movsx	 ecx, ax
  00c88	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _compression$[ebp], ecx

; 679  : 
; 680  : 	//
; 681  : 	// Allocate enough memory for the whole image.
; 682  : 	//
; 683  : 
; 684  : 	data = ( char * ) safe_malloc ( width * height * number_of_channels );

  00c8e	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _width$[ebp]
  00c94	0f af 85 e4 fe
	ff ff		 imul	 eax, DWORD PTR _height$[ebp]
  00c9b	0f af 85 e0 fe
	ff ff		 imul	 eax, DWORD PTR _number_of_channels$[ebp]
  00ca2	50		 push	 eax
  00ca3	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00ca8	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _data$[ebp], eax

; 685  : 
; 686  : 	ASSERT ( data );

  00cae	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR _data$[ebp], 0
  00cb5	75 1a		 jne	 SHORT $LN100@load_psd_f
  00cb7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??load_psd_file@@YGPAXPBDPAH11@Z@4JA
  00cbc	05 42 02 00 00	 add	 eax, 578		; 00000242H
  00cc1	50		 push	 eax
  00cc2	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@LMAEGLML@c?3?2users?2nhv90?2projects?2eech?2mo@
  00cc7	68 00 00 00 00	 push	 OFFSET ??_C@_04PJOLNDGD@data@
  00ccc	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN100@load_psd_f:

; 687  : 
; 688  : 	if ( compression )

  00cd1	83 bd d4 fe ff
	ff 00		 cmp	 DWORD PTR _compression$[ebp], 0
  00cd8	74 1f		 je	 SHORT $LN101@load_psd_f

; 689  : 	{
; 690  : 	
; 691  : 		//
; 692  : 		// Skip the table of byte counts
; 693  : 		//
; 694  : 	
; 695  : 		fseek ( fp, height * 2 * number_of_channels, SEEK_CUR );

  00cda	6a 01		 push	 1
  00cdc	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _height$[ebp]
  00ce2	d1 e0		 shl	 eax, 1
  00ce4	0f af 85 e0 fe
	ff ff		 imul	 eax, DWORD PTR _number_of_channels$[ebp]
  00ceb	50		 push	 eax
  00cec	8b 4d fc	 mov	 ecx, DWORD PTR _fp$[ebp]
  00cef	51		 push	 ecx
  00cf0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00cf6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN101@load_psd_f:

; 696  : 	}
; 697  : 
; 698  : 	//
; 699  : 	// Now read in the channels.
; 700  : 	//
; 701  : 
; 702  : 
; 703  : 	for ( current_channel = 0; current_channel < number_of_channels; current_channel++ )

  00cf9	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _current_channel$[ebp], 0
  00d03	eb 0f		 jmp	 SHORT $LN50@load_psd_f
$LN48@load_psd_f:
  00d05	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _current_channel$[ebp]
  00d0b	83 c0 01	 add	 eax, 1
  00d0e	89 85 ec fe ff
	ff		 mov	 DWORD PTR _current_channel$[ebp], eax
$LN50@load_psd_f:
  00d14	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _current_channel$[ebp]
  00d1a	3b 85 e0 fe ff
	ff		 cmp	 eax, DWORD PTR _number_of_channels$[ebp]
  00d20	0f 8d 1b 02 00
	00		 jge	 $LN49@load_psd_f

; 704  : 	{
; 705  : 
; 706  : 		int
; 707  : 			x,
; 708  : 			y;
; 709  : 
; 710  : 		//
; 711  : 		// There is no compression over rows.
; 712  : 		//
; 713  : 
; 714  : 		for ( y = 0; y < height; y++ )

  00d26	c7 85 80 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$9[ebp], 0
  00d30	eb 0f		 jmp	 SHORT $LN53@load_psd_f
$LN51@load_psd_f:
  00d32	8b 85 80 fa ff
	ff		 mov	 eax, DWORD PTR _y$9[ebp]
  00d38	83 c0 01	 add	 eax, 1
  00d3b	89 85 80 fa ff
	ff		 mov	 DWORD PTR _y$9[ebp], eax
$LN53@load_psd_f:
  00d41	8b 85 80 fa ff
	ff		 mov	 eax, DWORD PTR _y$9[ebp]
  00d47	3b 85 e4 fe ff
	ff		 cmp	 eax, DWORD PTR _height$[ebp]
  00d4d	0f 8d e9 01 00
	00		 jge	 $LN52@load_psd_f

; 715  : 		{
; 716  : 
; 717  : 			ptr = &data[ ( ( width * number_of_channels * y ) + current_channel ) ];

  00d53	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _width$[ebp]
  00d59	0f af 85 e0 fe
	ff ff		 imul	 eax, DWORD PTR _number_of_channels$[ebp]
  00d60	0f af 85 80 fa
	ff ff		 imul	 eax, DWORD PTR _y$9[ebp]
  00d67	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR _current_channel$[ebp]
  00d6d	03 85 f8 fe ff
	ff		 add	 eax, DWORD PTR _data$[ebp]
  00d73	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _ptr$[ebp], eax

; 718  : 
; 719  : 			if ( compression )

  00d79	83 bd d4 fe ff
	ff 00		 cmp	 DWORD PTR _compression$[ebp], 0
  00d80	0f 84 53 01 00
	00		 je	 $LN102@load_psd_f

; 720  : 			{
; 721  : 
; 722  : 				signed char
; 723  : 					control;
; 724  : 
; 725  : 				int
; 726  : 					number_of_pixels_in_run;
; 727  : 
; 728  : 				int
; 729  : 					number_of_pixels_left;
; 730  : 
; 731  : 				number_of_pixels_left = width;

  00d86	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _width$[ebp]
  00d8c	89 85 74 fa ff
	ff		 mov	 DWORD PTR _number_of_pixels_left$6[ebp], eax
$LN54@load_psd_f:

; 732  : 
; 733  : 				while ( number_of_pixels_left > 0 )

  00d92	83 bd 74 fa ff
	ff 00		 cmp	 DWORD PTR _number_of_pixels_left$6[ebp], 0
  00d99	0f 8e 38 01 00
	00		 jle	 $LN55@load_psd_f

; 734  : 				{
; 735  : 
; 736  : 					//
; 737  : 					// Read the source byte in
; 738  : 					//
; 739  : 
; 740  : 					control = fgetc ( fp );

  00d9f	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00da2	50		 push	 eax
  00da3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00da9	83 c4 04	 add	 esp, 4
  00dac	88 85 7f fa ff
	ff		 mov	 BYTE PTR _control$8[ebp], al

; 741  : 
; 742  : 					number_of_pixels_in_run = control;

  00db2	0f be 85 7f fa
	ff ff		 movsx	 eax, BYTE PTR _control$8[ebp]
  00db9	89 85 78 fa ff
	ff		 mov	 DWORD PTR _number_of_pixels_in_run$7[ebp], eax

; 743  : 
; 744  : 					if ( number_of_pixels_in_run >= 0 )

  00dbf	83 bd 78 fa ff
	ff 00		 cmp	 DWORD PTR _number_of_pixels_in_run$7[ebp], 0
  00dc6	7c 7a		 jl	 SHORT $LN104@load_psd_f

; 745  : 					{
; 746  : 
; 747  : 						int
; 748  : 							count;
; 749  : 
; 750  : 						//
; 751  : 						// Copy the next ( number_of_pixels_in_run + 1 ) bytes literally.
; 752  : 						//
; 753  : 
; 754  : 						for ( count = 0; count <= number_of_pixels_in_run; count++ )

  00dc8	c7 85 70 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$5[ebp], 0
  00dd2	eb 0f		 jmp	 SHORT $LN58@load_psd_f
$LN56@load_psd_f:
  00dd4	8b 85 70 fa ff
	ff		 mov	 eax, DWORD PTR _count$5[ebp]
  00dda	83 c0 01	 add	 eax, 1
  00ddd	89 85 70 fa ff
	ff		 mov	 DWORD PTR _count$5[ebp], eax
$LN58@load_psd_f:
  00de3	8b 85 70 fa ff
	ff		 mov	 eax, DWORD PTR _count$5[ebp]
  00de9	3b 85 78 fa ff
	ff		 cmp	 eax, DWORD PTR _number_of_pixels_in_run$7[ebp]
  00def	7f 35		 jg	 SHORT $LN57@load_psd_f

; 755  : 						{
; 756  : 
; 757  : 							unsigned char
; 758  : 								pixel_data;
; 759  : 
; 760  : 							pixel_data = fgetc ( fp );

  00df1	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00df4	50		 push	 eax
  00df5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00dfb	83 c4 04	 add	 esp, 4
  00dfe	88 85 6f fa ff
	ff		 mov	 BYTE PTR _pixel_data$4[ebp], al

; 761  : 
; 762  : 							*ptr = pixel_data;

  00e04	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  00e0a	8a 8d 6f fa ff
	ff		 mov	 cl, BYTE PTR _pixel_data$4[ebp]
  00e10	88 08		 mov	 BYTE PTR [eax], cl

; 763  : 
; 764  : 							ptr += number_of_channels;

  00e12	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  00e18	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _number_of_channels$[ebp]
  00e1e	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _ptr$[ebp], eax

; 765  : 						}

  00e24	eb ae		 jmp	 SHORT $LN56@load_psd_f
$LN57@load_psd_f:

; 766  : 
; 767  : 						number_of_pixels_left -= ( number_of_pixels_in_run + 1 );

  00e26	8b 85 78 fa ff
	ff		 mov	 eax, DWORD PTR _number_of_pixels_in_run$7[ebp]
  00e2c	83 c0 01	 add	 eax, 1
  00e2f	8b 8d 74 fa ff
	ff		 mov	 ecx, DWORD PTR _number_of_pixels_left$6[ebp]
  00e35	2b c8		 sub	 ecx, eax
  00e37	89 8d 74 fa ff
	ff		 mov	 DWORD PTR _number_of_pixels_left$6[ebp], ecx
  00e3d	e9 90 00 00 00	 jmp	 $LN107@load_psd_f
$LN104@load_psd_f:

; 768  : 					}
; 769  : 					else if ( number_of_pixels_in_run != -128 )

  00e42	83 bd 78 fa ff
	ff 80		 cmp	 DWORD PTR _number_of_pixels_in_run$7[ebp], -128 ; ffffff80H
  00e49	0f 84 83 00 00
	00		 je	 $LN107@load_psd_f

; 770  : 					{
; 771  : 
; 772  : 						int
; 773  : 							count;
; 774  : 
; 775  : 						unsigned char
; 776  : 							pixel_data;
; 777  : 
; 778  : 						//
; 779  : 						// Repeat the next byte ( ( -control ) + 1 ) times
; 780  : 						//
; 781  : 
; 782  : 						number_of_pixels_in_run = -number_of_pixels_in_run;

  00e4f	8b 85 78 fa ff
	ff		 mov	 eax, DWORD PTR _number_of_pixels_in_run$7[ebp]
  00e55	f7 d8		 neg	 eax
  00e57	89 85 78 fa ff
	ff		 mov	 DWORD PTR _number_of_pixels_in_run$7[ebp], eax

; 783  : 
; 784  : 						pixel_data = fgetc ( fp );

  00e5d	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00e60	50		 push	 eax
  00e61	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00e67	83 c4 04	 add	 esp, 4
  00e6a	88 85 67 fa ff
	ff		 mov	 BYTE PTR _pixel_data$2[ebp], al

; 785  : 
; 786  : 						for ( count = 0; count <= number_of_pixels_in_run; count++ )

  00e70	c7 85 68 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$3[ebp], 0
  00e7a	eb 0f		 jmp	 SHORT $LN61@load_psd_f
$LN59@load_psd_f:
  00e7c	8b 85 68 fa ff
	ff		 mov	 eax, DWORD PTR _count$3[ebp]
  00e82	83 c0 01	 add	 eax, 1
  00e85	89 85 68 fa ff
	ff		 mov	 DWORD PTR _count$3[ebp], eax
$LN61@load_psd_f:
  00e8b	8b 85 68 fa ff
	ff		 mov	 eax, DWORD PTR _count$3[ebp]
  00e91	3b 85 78 fa ff
	ff		 cmp	 eax, DWORD PTR _number_of_pixels_in_run$7[ebp]
  00e97	7f 22		 jg	 SHORT $LN60@load_psd_f

; 787  : 						{
; 788  : 
; 789  : 							*ptr = pixel_data;

  00e99	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  00e9f	8a 8d 67 fa ff
	ff		 mov	 cl, BYTE PTR _pixel_data$2[ebp]
  00ea5	88 08		 mov	 BYTE PTR [eax], cl

; 790  : 
; 791  : 							ptr += number_of_channels;

  00ea7	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  00ead	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _number_of_channels$[ebp]
  00eb3	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _ptr$[ebp], eax

; 792  : 						}

  00eb9	eb c1		 jmp	 SHORT $LN59@load_psd_f
$LN60@load_psd_f:

; 793  : 
; 794  : 						number_of_pixels_left -= ( number_of_pixels_in_run + 1 );

  00ebb	8b 85 78 fa ff
	ff		 mov	 eax, DWORD PTR _number_of_pixels_in_run$7[ebp]
  00ec1	83 c0 01	 add	 eax, 1
  00ec4	8b 8d 74 fa ff
	ff		 mov	 ecx, DWORD PTR _number_of_pixels_left$6[ebp]
  00eca	2b c8		 sub	 ecx, eax
  00ecc	89 8d 74 fa ff
	ff		 mov	 DWORD PTR _number_of_pixels_left$6[ebp], ecx
$LN107@load_psd_f:

; 795  : 					}
; 796  : 
; 797  : 					if ( number_of_pixels_left < 0 )
; 798  : 					{
; 799  : 
; 800  : //						BREAKOUT ();
; 801  : 					}
; 802  : 				}

  00ed2	e9 bb fe ff ff	 jmp	 $LN54@load_psd_f
$LN55@load_psd_f:

; 803  : 			}
; 804  : 			else

  00ed7	eb 5e		 jmp	 SHORT $LN103@load_psd_f
$LN102@load_psd_f:

; 805  : 			{
; 806  : 
; 807  : 				for ( x = 0; x < width; x++ )

  00ed9	c7 85 84 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$10[ebp], 0
  00ee3	eb 0f		 jmp	 SHORT $LN64@load_psd_f
$LN62@load_psd_f:
  00ee5	8b 85 84 fa ff
	ff		 mov	 eax, DWORD PTR _x$10[ebp]
  00eeb	83 c0 01	 add	 eax, 1
  00eee	89 85 84 fa ff
	ff		 mov	 DWORD PTR _x$10[ebp], eax
$LN64@load_psd_f:
  00ef4	8b 85 84 fa ff
	ff		 mov	 eax, DWORD PTR _x$10[ebp]
  00efa	3b 85 e8 fe ff
	ff		 cmp	 eax, DWORD PTR _width$[ebp]
  00f00	7d 35		 jge	 SHORT $LN103@load_psd_f

; 808  : 				{
; 809  : 
; 810  : 					unsigned char
; 811  : 						pixel_data;
; 812  : 
; 813  : 					pixel_data = fgetc ( fp );

  00f02	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00f05	50		 push	 eax
  00f06	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00f0c	83 c4 04	 add	 esp, 4
  00f0f	88 85 66 fa ff
	ff		 mov	 BYTE PTR _pixel_data$1[ebp], al

; 814  : 
; 815  : 					*ptr = pixel_data;

  00f15	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  00f1b	8a 8d 66 fa ff
	ff		 mov	 cl, BYTE PTR _pixel_data$1[ebp]
  00f21	88 08		 mov	 BYTE PTR [eax], cl

; 816  : 
; 817  : 					ptr += number_of_channels;

  00f23	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  00f29	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _number_of_channels$[ebp]
  00f2f	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _ptr$[ebp], eax

; 818  : 				}

  00f35	eb ae		 jmp	 SHORT $LN62@load_psd_f
$LN103@load_psd_f:

; 819  : 			}
; 820  : 		}

  00f37	e9 f6 fd ff ff	 jmp	 $LN51@load_psd_f
$LN52@load_psd_f:

; 821  : 	}

  00f3c	e9 c4 fd ff ff	 jmp	 $LN48@load_psd_f
$LN49@load_psd_f:

; 822  : 
; 823  : 	//
; 824  : 	// Close the file
; 825  : 	//
; 826  : 
; 827  : 	fclose ( fp );

  00f41	8b 45 fc	 mov	 eax, DWORD PTR _fp$[ebp]
  00f44	50		 push	 eax
  00f45	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00f4b	83 c4 04	 add	 esp, 4

; 828  : 
; 829  : 	//
; 830  : 	// Set the return values.
; 831  : 	//
; 832  : 
; 833  : 	*width_return = width;

  00f4e	8b 45 0c	 mov	 eax, DWORD PTR _width_return$[ebp]
  00f51	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _width$[ebp]
  00f57	89 08		 mov	 DWORD PTR [eax], ecx

; 834  : 
; 835  : 	*height_return = height;

  00f59	8b 45 10	 mov	 eax, DWORD PTR _height_return$[ebp]
  00f5c	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _height$[ebp]
  00f62	89 08		 mov	 DWORD PTR [eax], ecx

; 836  : 
; 837  : 	*number_of_channels_return = number_of_channels;

  00f64	8b 45 14	 mov	 eax, DWORD PTR _number_of_channels_return$[ebp]
  00f67	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _number_of_channels$[ebp]
  00f6d	89 08		 mov	 DWORD PTR [eax], ecx

; 838  : 
; 839  : 	return ( data );

  00f6f	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _data$[ebp]

; 840  : }

  00f75	5f		 pop	 edi
  00f76	5e		 pop	 esi
  00f77	5b		 pop	 ebx
  00f78	8b e5		 mov	 esp, ebp
  00f7a	5d		 pop	 ebp
  00f7b	c2 10 00	 ret	 16			; 00000010H
?load_psd_file@@YGPAXPBDPAH11@Z ENDP			; load_psd_file
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\graphics\psdread.c
;	COMDAT ?initialise_psd_layers@@YGXXZ
_TEXT	SEGMENT
_count$ = -4						; size = 4
?initialise_psd_layers@@YGXXZ PROC			; initialise_psd_layers, COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 92   : 
; 93   : 	int
; 94   : 		count;
; 95   : 
; 96   : 	for ( count = 0; count < MAX_PSD_LAYERS; count++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@initialise
$LN2@initialise:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@initialise:
  0001b	83 7d fc 10	 cmp	 DWORD PTR _count$[ebp], 16 ; 00000010H
  0001f	7d 13		 jge	 SHORT $LN1@initialise

; 97   : 	{
; 98   : 
; 99   : 		psd_layers[count].data = NULL;

  00021	69 45 fc 9c 01
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 412
  00028	c7 80 18 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?psd_layers@@3PAUPSD_LAYER_INFO@@A[eax+280], 0

; 100  : 	}

  00032	eb de		 jmp	 SHORT $LN2@initialise
$LN1@initialise:

; 101  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?initialise_psd_layers@@YGXXZ ENDP			; initialise_psd_layers
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1459 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1460 :         #pragma warning(push)
; 1461 :         #pragma warning(disable: 4996) // Deprecation
; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1463 :         #pragma warning(pop)
; 1464 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH
  00035	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00038	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003c	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003e	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00045	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00047	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  0004a	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004d	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1395 :     }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
