; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\system\joystick.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?number_of_joystick_devices@@3HA		; number_of_joystick_devices
PUBLIC	?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A	; joystick_devices
PUBLIC	?AxisInfo@@3PAUAxisInfo_t@@A			; AxisInfo
PUBLIC	?AxisCount@@3HA					; AxisCount
_BSS	SEGMENT
?number_of_joystick_devices@@3HA DD 01H DUP (?)		; number_of_joystick_devices
?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A DD 01H DUP (?) ; joystick_devices
?AxisInfo@@3PAUAxisInfo_t@@A DB 0800H DUP (?)		; AxisInfo
?AxisCount@@3HA DD 01H DUP (?)				; AxisCount
_BSS	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?initialise_joysticks@@YGXXZ			; initialise_joysticks
PUBLIC	?read_joystick_values@@YGXH@Z			; read_joystick_values
PUBLIC	?set_joystick_force_feedback_forces@@YGHHHH@Z	; set_joystick_force_feedback_forces
PUBLIC	?get_joystick_axis@@YGHHH@Z			; get_joystick_axis
PUBLIC	?get_joystick_hat@@YG?AW4JOYSTICK_HAT_POSITION@@PAUJOYSTICK_DEVICE_INFO@@H@Z ; get_joystick_hat
PUBLIC	?get_joystick_button@@YGHPAUJOYSTICK_DEVICE_INFO@@H@Z ; get_joystick_button
PUBLIC	?GetGUIDString@@YGXHPAD@Z			; GetGUIDString
PUBLIC	?change_joystick_properties@@YGXXZ		; change_joystick_properties
PUBLIC	?ShutdownAxisInformation@@YGXXZ			; ShutdownAxisInformation
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_08CPOKIBJK@Keyboard@			; `string'
PUBLIC	??_C@_0CM@LDPKIMDO@Unable?5to?5query?5a?5joystick?5for?5@ ; `string'
PUBLIC	??_C@_0BO@CEANPPEN@Got?5a?5force?5feedback?5joystick@ ; `string'
PUBLIC	??_C@_0CI@HKLOMIJ@Unable?5to?5set?5data?5format?5on?5a?5@ ; `string'
PUBLIC	??_C@_0DN@GOIOLFJH@Unable?5to?5set?5cooperative?5level@ ; `string'
PUBLIC	??_C@_0DM@BIHIEKCG@Unable?5to?5set?5autocentring?5off?5@ ; `string'
PUBLIC	??_C@_0DC@EGJMODKL@Unable?5to?5create?5a?5force?5feedba@ ; `string'
PUBLIC	??_C@_0CO@BCNOGLJF@Unable?5to?5set?5cooperative?5level@ ; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	?__LINE__Var@?0??set_joystick_force_feedback_forces@@YGHHHH@Z@4JA ; `set_joystick_force_feedback_forces'::`1'::__LINE__Var
PUBLIC	??_C@_0DH@PAODIEFD@c?3?2users?2nhv90?2projects?2eech?2mo@ ; `string'
PUBLIC	??_C@_0DF@OEPJJLBP@joystick_devices?$FLjoystick_devic@ ; `string'
PUBLIC	??_C@_0EJ@NAONHGHM@joystick_devices?$FLjoystick_devic@ ; `string'
PUBLIC	??_C@_0CM@OGFGLELM@Unable?5to?5start?5a?5force?5feedbac@ ; `string'
PUBLIC	??_C@_0DD@HCHIMAAG@Unable?5to?5acquire?5Force?5feedbac@ ; `string'
PUBLIC	??_C@_0CH@MBPILHNJ@Problems?5setting?5effect?5paramet@ ; `string'
PUBLIC	??_C@_0BE@EBAEEKFN@?$HL?$CF8?48X?9?$CF4?44X?9?$CF4?44X?9@ ; `string'
PUBLIC	??_C@_05NHNNBPJA@?$CF2?42X@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN@				; `string'
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_sqrt:PROC
EXTRN	?process_assert@@YGXPBD0H@Z:PROC		; process_assert
EXTRN	?debug_log@@YAXPBDZZ:PROC			; debug_log
EXTRN	?get_dinput_error_message@@YGPBDJ@Z:PROC	; get_dinput_error_message
EXTRN	?create_joystick_event@@YGXHHW4BUTTON_STATES@@@Z:PROC ; create_joystick_event
EXTRN	?safe_malloc_memory@@YGPAXI@Z:PROC		; safe_malloc_memory
EXTRN	_IID_IDirectInputDevice7A:BYTE
EXTRN	_GUID_ConstantForce:BYTE
EXTRN	_c_dfDIJoystick:BYTE
EXTRN	?application_window@@3PAUHWND__@@A:DWORD	; application_window
EXTRN	?direct_input@@3PAUIDirectInput7A@@A:DWORD	; direct_input
EXTRN	?command_line_eo_zoom_joystick_index@@3HA:DWORD	; command_line_eo_zoom_joystick_index
EXTRN	?command_line_eo_zoom_joystick_axis@@3HA:DWORD	; command_line_eo_zoom_joystick_axis
EXTRN	?command_line_field_of_view_joystick_index@@3HA:DWORD ; command_line_field_of_view_joystick_index
EXTRN	?command_line_field_of_view_joystick_axis@@3HA:DWORD ; command_line_field_of_view_joystick_axis
EXTRN	?command_line_cyclic_joystick_index@@3HA:DWORD	; command_line_cyclic_joystick_index
EXTRN	?command_line_collective_joystick_index@@3HA:DWORD ; command_line_collective_joystick_index
EXTRN	?command_line_collective_joystick_axis@@3HA:DWORD ; command_line_collective_joystick_axis
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NHNNBPJA@?$CF2?42X@
CONST	SEGMENT
??_C@_05NHNNBPJA@?$CF2?42X@ DB '%2.2X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EBAEEKFN@?$HL?$CF8?48X?9?$CF4?44X?9?$CF4?44X?9@
CONST	SEGMENT
??_C@_0BE@EBAEEKFN@?$HL?$CF8?48X?9?$CF4?44X?9?$CF4?44X?9@ DB '{%8.8X-%4.4'
	DB	'X-%4.4X-', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MBPILHNJ@Problems?5setting?5effect?5paramet@
CONST	SEGMENT
??_C@_0CH@MBPILHNJ@Problems?5setting?5effect?5paramet@ DB 'Problems setti'
	DB	'ng effect parameters: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@HCHIMAAG@Unable?5to?5acquire?5Force?5feedbac@
CONST	SEGMENT
??_C@_0DD@HCHIMAAG@Unable?5to?5acquire?5Force?5feedbac@ DB 'Unable to acq'
	DB	'uire Force feedback effect status: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OGFGLELM@Unable?5to?5start?5a?5force?5feedbac@
CONST	SEGMENT
??_C@_0CM@OGFGLELM@Unable?5to?5start?5a?5force?5feedbac@ DB 'Unable to st'
	DB	'art a force feedback effect: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@NAONHGHM@joystick_devices?$FLjoystick_devic@
CONST	SEGMENT
??_C@_0EJ@NAONHGHM@joystick_devices?$FLjoystick_devic@ DB 'joystick_devic'
	DB	'es[joystick_device_index].joystick_supports_force_feedback', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@OEPJJLBP@joystick_devices?$FLjoystick_devic@
CONST	SEGMENT
??_C@_0DF@OEPJJLBP@joystick_devices?$FLjoystick_devic@ DB 'joystick_devic'
	DB	'es[joystick_device_index].input_device', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PAODIEFD@c?3?2users?2nhv90?2projects?2eech?2mo@
CONST	SEGMENT
??_C@_0DH@PAODIEFD@c?3?2users?2nhv90?2projects?2eech?2mo@ DB 'c:\users\nh'
	DB	'v90\projects\eech\modules\system\joystick.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??set_joystick_force_feedback_forces@@YGHHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??set_joystick_force_feedback_forces@@YGHHHH@Z@4JA DD 0493H ; `set_joystick_force_feedback_forces'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BCNOGLJF@Unable?5to?5set?5cooperative?5level@
CONST	SEGMENT
??_C@_0CO@BCNOGLJF@Unable?5to?5set?5cooperative?5level@ DB 'Unable to set'
	DB	' cooperative level on a joystick', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EGJMODKL@Unable?5to?5create?5a?5force?5feedba@
CONST	SEGMENT
??_C@_0DC@EGJMODKL@Unable?5to?5create?5a?5force?5feedba@ DB 'Unable to cr'
	DB	'eate a force feedback joystick effect', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BIHIEKCG@Unable?5to?5set?5autocentring?5off?5@
CONST	SEGMENT
??_C@_0DM@BIHIEKCG@Unable?5to?5set?5autocentring?5off?5@ DB 'Unable to se'
	DB	't autocentring off on a force feedback joystick', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GOIOLFJH@Unable?5to?5set?5cooperative?5level@
CONST	SEGMENT
??_C@_0DN@GOIOLFJH@Unable?5to?5set?5cooperative?5level@ DB 'Unable to set'
	DB	' cooperative level on a force feedback joystick', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HKLOMIJ@Unable?5to?5set?5data?5format?5on?5a?5@
CONST	SEGMENT
??_C@_0CI@HKLOMIJ@Unable?5to?5set?5data?5format?5on?5a?5@ DB 'Unable to s'
	DB	'et data format on a joystick', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CEANPPEN@Got?5a?5force?5feedback?5joystick@
CONST	SEGMENT
??_C@_0BO@CEANPPEN@Got?5a?5force?5feedback?5joystick@ DB 'Got a force fee'
	DB	'dback joystick', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LDPKIMDO@Unable?5to?5query?5a?5joystick?5for?5@
CONST	SEGMENT
??_C@_0CM@LDPKIMDO@Unable?5to?5query?5a?5joystick?5for?5@ DB 'Unable to q'
	DB	'uery a joystick for capabilities', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CPOKIBJK@Keyboard@
CONST	SEGMENT
??_C@_08CPOKIBJK@Keyboard@ DB 'Keyboard', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\joystick.c
;	COMDAT ?ShutdownAxisInformation@@YGXXZ
_TEXT	SEGMENT
_i$ = -4						; size = 4
?ShutdownAxisInformation@@YGXXZ PROC			; ShutdownAxisInformation, COMDAT

; 1503 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1504 : 	int i = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 1505 : 
; 1506 : 	for (i = 1; i < AxisCount; i++)	// '0' is keyboard and was not created on the heap

  00010	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00017	eb 09		 jmp	 SHORT $LN4@ShutdownAx
$LN2@ShutdownAx:
  00019	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@ShutdownAx:
  00022	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00025	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  0002b	7d 28		 jge	 SHORT $LN1@ShutdownAx

; 1507 : 	{
; 1508 : 		free(AxisInfo[i].AxisName);

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00030	c1 e0 04	 shl	 eax, 4
  00033	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax]
  00039	51		 push	 ecx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00040	83 c4 04	 add	 esp, 4

; 1509 : 		AxisInfo[i].AxisName = 0;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00046	c1 e0 04	 shl	 eax, 4
  00049	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax], 0

; 1510 : 	}

  00053	eb c4		 jmp	 SHORT $LN2@ShutdownAx
$LN1@ShutdownAx:

; 1511 : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?ShutdownAxisInformation@@YGXXZ ENDP			; ShutdownAxisInformation
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\joystick.c
;	COMDAT ?axis_has_deadzone@@YGHHH@Z
_TEXT	SEGMENT
_retval$ = -4						; size = 4
_deviceIndex$ = 8					; size = 4
_deviceAxis$ = 12					; size = 4
?axis_has_deadzone@@YGHHH@Z PROC			; axis_has_deadzone, COMDAT

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 123  : 	BOOL retval;
; 124  : 
; 125  : 	if ((deviceIndex == command_line_eo_zoom_joystick_index) && (deviceAxis == command_line_eo_zoom_joystick_axis))

  00009	8b 45 08	 mov	 eax, DWORD PTR _deviceIndex$[ebp]
  0000c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?command_line_eo_zoom_joystick_index@@3HA ; command_line_eo_zoom_joystick_index
  00012	75 14		 jne	 SHORT $LN2@axis_has_d
  00014	8b 45 0c	 mov	 eax, DWORD PTR _deviceAxis$[ebp]
  00017	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?command_line_eo_zoom_joystick_axis@@3HA ; command_line_eo_zoom_joystick_axis
  0001d	75 09		 jne	 SHORT $LN2@axis_has_d

; 126  : 	{
; 127  : 		retval = FALSE;

  0001f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _retval$[ebp], 0
  00026	eb 45		 jmp	 SHORT $LN3@axis_has_d
$LN2@axis_has_d:

; 128  : 	}
; 129  : 	else if ((deviceIndex == command_line_collective_joystick_index) && (deviceAxis == command_line_collective_joystick_axis))

  00028	8b 45 08	 mov	 eax, DWORD PTR _deviceIndex$[ebp]
  0002b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?command_line_collective_joystick_index@@3HA ; command_line_collective_joystick_index
  00031	75 14		 jne	 SHORT $LN4@axis_has_d
  00033	8b 45 0c	 mov	 eax, DWORD PTR _deviceAxis$[ebp]
  00036	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?command_line_collective_joystick_axis@@3HA ; command_line_collective_joystick_axis
  0003c	75 09		 jne	 SHORT $LN4@axis_has_d

; 130  : 	{
; 131  : 		retval = FALSE;

  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _retval$[ebp], 0
  00045	eb 26		 jmp	 SHORT $LN3@axis_has_d
$LN4@axis_has_d:

; 132  : 	}
; 133  : 	else if ((deviceIndex == command_line_field_of_view_joystick_index) && (deviceAxis == command_line_field_of_view_joystick_axis))

  00047	8b 45 08	 mov	 eax, DWORD PTR _deviceIndex$[ebp]
  0004a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?command_line_field_of_view_joystick_index@@3HA ; command_line_field_of_view_joystick_index
  00050	75 14		 jne	 SHORT $LN6@axis_has_d
  00052	8b 45 0c	 mov	 eax, DWORD PTR _deviceAxis$[ebp]
  00055	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?command_line_field_of_view_joystick_axis@@3HA ; command_line_field_of_view_joystick_axis
  0005b	75 09		 jne	 SHORT $LN6@axis_has_d

; 134  : 	{
; 135  : 		retval = FALSE;

  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _retval$[ebp], 0

; 136  : 	}
; 137  : 	else

  00064	eb 07		 jmp	 SHORT $LN3@axis_has_d
$LN6@axis_has_d:

; 138  : 	{
; 139  : 		retval = TRUE;

  00066	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _retval$[ebp], 1
$LN3@axis_has_d:

; 140  : 	}
; 141  : 
; 142  : 	return retval;

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _retval$[ebp]

; 143  : }

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 08 00	 ret	 8
?axis_has_deadzone@@YGHHH@Z ENDP			; axis_has_deadzone
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\joystick.c
;	COMDAT ?enumerate_joystick_devices@@YGHPBUDIDEVICEINSTANCEA@@PAX@Z
_TEXT	SEGMENT
_constant_force$1 = -492				; size = 4
_joystick_force_directions$2 = -488			; size = 8
_joystick_force_axes$3 = -480				; size = 8
_effect$4 = -472					; size = 56
_device2_effect$ = -416					; size = 4
_device_capabilities$ = -412				; size = 44
_device_part$ = -368					; size = 316
_device_property$ = -52					; size = 20
_device_range$ = -32					; size = 24
_device$ = -8						; size = 4
_di_err$ = -4						; size = 4
_device_instance$ = 8					; size = 4
_user_data$ = 12					; size = 4
?enumerate_joystick_devices@@YGHPBUDIDEVICEINSTANCEA@@PAX@Z PROC ; enumerate_joystick_devices, COMDAT

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 02 00
	00		 sub	 esp, 556		; 0000022cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 270  : 
; 271  : 	HRESULT
; 272  : 		di_err;
; 273  : 
; 274  : 	LPDIRECTINPUTDEVICE7
; 275  : 		device;
; 276  : 
; 277  :    DIPROPRANGE
; 278  : 		device_range;
; 279  : 
; 280  : 	DIPROPDWORD
; 281  : 		device_property;
; 282  : 
; 283  : 	DIDEVICEOBJECTINSTANCE
; 284  : 		device_part;
; 285  : 
; 286  : 	DIDEVCAPS
; 287  : 		device_capabilities;
; 288  : 
; 289  : 	LPDIRECTINPUTEFFECT
; 290  : 		device2_effect;
; 291  : 
; 292  : 	//
; 293  : 	// Create the device
; 294  : 	//
; 295  : 
; 296  : 	di_err = IDirectInput7_CreateDeviceEx (direct_input, GUID_PREFIX device_instance->guidInstance, GUID_PREFIX IID_IDirectInputDevice7, ( LPVOID * ) &device, NULL);

  0000c	6a 00		 push	 0
  0000e	8d 45 f8	 lea	 eax, DWORD PTR _device$[ebp]
  00011	50		 push	 eax
  00012	68 00 00 00 00	 push	 OFFSET _IID_IDirectInputDevice7A
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _device_instance$[ebp]
  0001a	83 c1 04	 add	 ecx, 4
  0001d	51		 push	 ecx
  0001e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?direct_input@@3PAUIDirectInput7A@@A ; direct_input
  00024	8b 02		 mov	 eax, DWORD PTR [edx]
  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?direct_input@@3PAUIDirectInput7A@@A ; direct_input
  0002c	51		 push	 ecx
  0002d	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00030	ff d2		 call	 edx
  00032	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 297  : 
; 298  : 	if (di_err != DI_OK)

  00035	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  00039	74 0a		 je	 SHORT $LN2@enumerate_

; 299  : 	{
; 300  : 
; 301  : 		return (DIENUM_CONTINUE);

  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	e9 f1 12 00 00	 jmp	 $LN1@enumerate_
$LN2@enumerate_:

; 302  : 	}
; 303  : 
; 304  : 	//
; 305  : 	// Get the capabilities of the joystick
; 306  : 	//
; 307  : 
; 308  : 	device_capabilities.dwSize = sizeof (device_capabilities);

  00045	c7 85 64 fe ff
	ff 2c 00 00 00	 mov	 DWORD PTR _device_capabilities$[ebp], 44 ; 0000002cH

; 309  : 
; 310  : 	di_err = IDirectInputDevice7_GetCapabilities (device, &device_capabilities);

  0004f	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _device_capabilities$[ebp]
  00055	50		 push	 eax
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00062	ff d1		 call	 ecx
  00064	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 311  : 
; 312  : 	if (di_err != DI_OK)

  00067	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  0006b	74 25		 je	 SHORT $LN3@enumerate_

; 313  : 	{
; 314  : 
; 315  : 		debug_log ("Unable to query a joystick for capabilities");

  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LDPKIMDO@Unable?5to?5query?5a?5joystick?5for?5@
  00072	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00077	83 c4 04	 add	 esp, 4

; 316  : 
; 317  : 		IDirectInputDevice7_Release (device);

  0007a	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  0007d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007f	8b 55 f8	 mov	 edx, DWORD PTR _device$[ebp]
  00082	52		 push	 edx
  00083	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00086	ff d0		 call	 eax

; 318  : 
; 319  : 		return (DIENUM_CONTINUE);

  00088	b8 01 00 00 00	 mov	 eax, 1
  0008d	e9 a4 12 00 00	 jmp	 $LN1@enumerate_
$LN3@enumerate_:

; 320  : 	}
; 321  : 
; 322  : 	//
; 323  : 	// If this force feedback ready ?
; 324  : 	//
; 325  : 
; 326  : 	if (device_capabilities.dwFlags & DIDC_FORCEFEEDBACK)

  00092	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _device_capabilities$[ebp+4]
  00098	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0009d	74 0d		 je	 SHORT $LN4@enumerate_

; 327  : 	{
; 328  : 
; 329  : 		debug_log ("Got a force feedback joystick");

  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@CEANPPEN@Got?5a?5force?5feedback?5joystick@
  000a4	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  000a9	83 c4 04	 add	 esp, 4
$LN4@enumerate_:

; 330  : 	}
; 331  : 
; 332  : 	//
; 333  : 	// First, the data format
; 334  : 	//
; 335  : 
; 336  : 	di_err = IDirectInputDevice7_SetDataFormat (device, &c_dfDIJoystick);

  000ac	68 00 00 00 00	 push	 OFFSET _c_dfDIJoystick
  000b1	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  000b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b6	8b 55 f8	 mov	 edx, DWORD PTR _device$[ebp]
  000b9	52		 push	 edx
  000ba	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  000bd	ff d0		 call	 eax
  000bf	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 337  : 
; 338  : 	if (di_err != DI_OK)

  000c2	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  000c6	74 25		 je	 SHORT $LN5@enumerate_

; 339  : 	{
; 340  : 
; 341  : 		debug_log ("Unable to set data format on a joystick");

  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HKLOMIJ@Unable?5to?5set?5data?5format?5on?5a?5@
  000cd	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  000d2	83 c4 04	 add	 esp, 4

; 342  : 
; 343  : 		IDirectInputDevice7_Release (device);

  000d5	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  000d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000da	8b 55 f8	 mov	 edx, DWORD PTR _device$[ebp]
  000dd	52		 push	 edx
  000de	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000e1	ff d0		 call	 eax

; 344  : 
; 345  : 		return (DIENUM_CONTINUE);

  000e3	b8 01 00 00 00	 mov	 eax, 1
  000e8	e9 49 12 00 00	 jmp	 $LN1@enumerate_
$LN5@enumerate_:

; 346  : 	}
; 347  : 
; 348  : 	//
; 349  : 	// Next the cooperative level
; 350  : 	//
; 351  : 
; 352  : 	device2_effect = NULL;

  000ed	c7 85 60 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _device2_effect$[ebp], 0

; 353  : 
; 354  : 	if (device_capabilities.dwFlags & DIDC_FORCEFEEDBACK)

  000f7	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _device_capabilities$[ebp+4]
  000fd	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00102	0f 84 da 01 00
	00		 je	 $LN6@enumerate_

; 355  : 	{
; 356  : 	
; 357  : 		DIEFFECT
; 358  : 			effect;
; 359  : 
; 360  : 		DWORD
; 361  : 			joystick_force_axes[NUMBER_OF_FORCE_FEEDBACK_AXES];
; 362  : 
; 363  : 		LONG
; 364  : 			joystick_force_directions[NUMBER_OF_FORCE_FEEDBACK_AXES];
; 365  : 
; 366  : 		DICONSTANTFORCE
; 367  : 			constant_force;
; 368  : 		
; 369  : 		di_err = IDirectInputDevice7_SetCooperativeLevel (device, application_window, DISCL_EXCLUSIVE | DISCL_FOREGROUND);

  00108	6a 05		 push	 5
  0010a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  0010f	50		 push	 eax
  00110	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00113	8b 11		 mov	 edx, DWORD PTR [ecx]
  00115	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00118	50		 push	 eax
  00119	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  0011c	ff d1		 call	 ecx
  0011e	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 370  : 	
; 371  : 		if (di_err != DI_OK)

  00121	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  00125	74 25		 je	 SHORT $LN8@enumerate_

; 372  : 		{
; 373  : 	
; 374  : 			debug_log ("Unable to set cooperative level on a force feedback joystick");

  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@GOIOLFJH@Unable?5to?5set?5cooperative?5level@
  0012c	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00131	83 c4 04	 add	 esp, 4

; 375  : 	
; 376  : 			IDirectInputDevice7_Release (device);

  00134	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00137	8b 08		 mov	 ecx, DWORD PTR [eax]
  00139	8b 55 f8	 mov	 edx, DWORD PTR _device$[ebp]
  0013c	52		 push	 edx
  0013d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00140	ff d0		 call	 eax

; 377  : 	
; 378  : 			return (DIENUM_CONTINUE);

  00142	b8 01 00 00 00	 mov	 eax, 1
  00147	e9 ea 11 00 00	 jmp	 $LN1@enumerate_
$LN8@enumerate_:

; 379  : 		}
; 380  : 
; 381  : 		//
; 382  : 		// Set the auto-centring mechanism off
; 383  : 		//
; 384  : 
; 385  : 		device_property.diph.dwSize = sizeof (DIPROPDWORD);

  0014c	c7 45 cc 14 00
	00 00		 mov	 DWORD PTR _device_property$[ebp], 20 ; 00000014H

; 386  : 		device_property.diph.dwHeaderSize = sizeof (DIPROPHEADER);

  00153	c7 45 d0 10 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+4], 16 ; 00000010H

; 387  : 		device_property.diph.dwObj = 0;

  0015a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+8], 0

; 388  : 		device_property.diph.dwHow = DIPH_DEVICE;

  00161	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+12], 0

; 389  : 		device_property.dwData = TRUE;

  00168	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 1

; 390  : 
; 391  : 		di_err = IDirectInputDevice7_SetProperty (device, DIPROP_AUTOCENTER, &device_property.diph);

  0016f	8d 45 cc	 lea	 eax, DWORD PTR _device_property$[ebp]
  00172	50		 push	 eax
  00173	6a 09		 push	 9
  00175	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00178	8b 11		 mov	 edx, DWORD PTR [ecx]
  0017a	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  0017d	50		 push	 eax
  0017e	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00181	ff d1		 call	 ecx
  00183	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 392  : 
; 393  : 		if (di_err != DI_OK)

  00186	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  0018a	74 25		 je	 SHORT $LN9@enumerate_

; 394  : 		{
; 395  : 	
; 396  : 			debug_log ("Unable to set autocentring off on a force feedback joystick");

  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BIHIEKCG@Unable?5to?5set?5autocentring?5off?5@
  00191	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00196	83 c4 04	 add	 esp, 4

; 397  : 	
; 398  : 			IDirectInputDevice7_Release (device);

  00199	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  0019c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019e	8b 55 f8	 mov	 edx, DWORD PTR _device$[ebp]
  001a1	52		 push	 edx
  001a2	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001a5	ff d0		 call	 eax

; 399  : 	
; 400  : 			return (DIENUM_CONTINUE);

  001a7	b8 01 00 00 00	 mov	 eax, 1
  001ac	e9 85 11 00 00	 jmp	 $LN1@enumerate_
$LN9@enumerate_:

; 401  : 		}
; 402  : 
; 403  : 		//
; 404  : 		// Create an effect for this joystick
; 405  : 		//
; 406  : 
; 407  : 		joystick_force_axes[0] = DIJOFS_X;

  001b1	b8 04 00 00 00	 mov	 eax, 4
  001b6	6b c8 00	 imul	 ecx, eax, 0
  001b9	c7 84 0d 20 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _joystick_force_axes$3[ebp+ecx], 0

; 408  : 		joystick_force_axes[1] = DIJOFS_Y;

  001c4	b8 04 00 00 00	 mov	 eax, 4
  001c9	c1 e0 00	 shl	 eax, 0
  001cc	c7 84 05 20 fe
	ff ff 04 00 00
	00		 mov	 DWORD PTR _joystick_force_axes$3[ebp+eax], 4

; 409  : 
; 410  : 		joystick_force_directions[0] = 0;

  001d7	b8 04 00 00 00	 mov	 eax, 4
  001dc	6b c8 00	 imul	 ecx, eax, 0
  001df	c7 84 0d 18 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _joystick_force_directions$2[ebp+ecx], 0

; 411  : 		joystick_force_directions[1] = 0;

  001ea	b8 04 00 00 00	 mov	 eax, 4
  001ef	c1 e0 00	 shl	 eax, 0
  001f2	c7 84 05 18 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _joystick_force_directions$2[ebp+eax], 0

; 412  : 
; 413  : 		constant_force.lMagnitude = 0;

  001fd	c7 85 14 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _constant_force$1[ebp], 0

; 414  : 
; 415  : 		effect.dwSize = sizeof (effect);

  00207	c7 85 28 fe ff
	ff 38 00 00 00	 mov	 DWORD PTR _effect$4[ebp], 56 ; 00000038H

; 416  : 		effect.dwFlags = DIEFF_CARTESIAN | DIEFF_OBJECTOFFSETS;

  00211	c7 85 2c fe ff
	ff 12 00 00 00	 mov	 DWORD PTR _effect$4[ebp+4], 18 ; 00000012H

; 417  : 		effect.dwDuration = INFINITE;

  0021b	c7 85 30 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _effect$4[ebp+8], -1

; 418  : 		effect.dwSamplePeriod = 0;

  00225	c7 85 34 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _effect$4[ebp+12], 0

; 419  : 		effect.dwGain = DI_FFNOMINALMAX;

  0022f	c7 85 38 fe ff
	ff 10 27 00 00	 mov	 DWORD PTR _effect$4[ebp+16], 10000 ; 00002710H

; 420  : 		effect.dwTriggerButton = DIEB_NOTRIGGER;

  00239	c7 85 3c fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _effect$4[ebp+20], -1

; 421  : 		effect.dwTriggerRepeatInterval = 0;

  00243	c7 85 40 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _effect$4[ebp+24], 0

; 422  : 		effect.cAxes = NUMBER_OF_FORCE_FEEDBACK_AXES;

  0024d	c7 85 44 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _effect$4[ebp+28], 2

; 423  : 		effect.rgdwAxes = joystick_force_axes;

  00257	8d 85 20 fe ff
	ff		 lea	 eax, DWORD PTR _joystick_force_axes$3[ebp]
  0025d	89 85 48 fe ff
	ff		 mov	 DWORD PTR _effect$4[ebp+32], eax

; 424  : 		effect.rglDirection = joystick_force_directions;

  00263	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _joystick_force_directions$2[ebp]
  00269	89 85 4c fe ff
	ff		 mov	 DWORD PTR _effect$4[ebp+36], eax

; 425  : 		effect.lpEnvelope = 0;

  0026f	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _effect$4[ebp+40], 0

; 426  : 		effect.cbTypeSpecificParams = sizeof (constant_force);

  00279	c7 85 54 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR _effect$4[ebp+44], 4

; 427  : 		effect.lpvTypeSpecificParams = &constant_force;

  00283	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _constant_force$1[ebp]
  00289	89 85 58 fe ff
	ff		 mov	 DWORD PTR _effect$4[ebp+48], eax

; 428  : 
; 429  : 		di_err = IDirectInputDevice7_CreateEffect (device, GUID_PREFIX GUID_ConstantForce, &effect, &device2_effect, NULL);

  0028f	6a 00		 push	 0
  00291	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _device2_effect$[ebp]
  00297	50		 push	 eax
  00298	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR _effect$4[ebp]
  0029e	51		 push	 ecx
  0029f	68 00 00 00 00	 push	 OFFSET _GUID_ConstantForce
  002a4	8b 55 f8	 mov	 edx, DWORD PTR _device$[ebp]
  002a7	8b 02		 mov	 eax, DWORD PTR [edx]
  002a9	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  002ac	51		 push	 ecx
  002ad	8b 50 48	 mov	 edx, DWORD PTR [eax+72]
  002b0	ff d2		 call	 edx
  002b2	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 430  : 
; 431  : 		if (di_err != DI_OK)

  002b5	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  002b9	74 25		 je	 SHORT $LN10@enumerate_

; 432  : 		{
; 433  : 	
; 434  : 			debug_log ("Unable to create a force feedback joystick effect");

  002bb	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@EGJMODKL@Unable?5to?5create?5a?5force?5feedba@
  002c0	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  002c5	83 c4 04	 add	 esp, 4

; 435  : 	
; 436  : 			IDirectInputDevice7_Release (device);

  002c8	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  002cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  002cd	8b 55 f8	 mov	 edx, DWORD PTR _device$[ebp]
  002d0	52		 push	 edx
  002d1	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  002d4	ff d0		 call	 eax

; 437  : 	
; 438  : 			return (DIENUM_CONTINUE);

  002d6	b8 01 00 00 00	 mov	 eax, 1
  002db	e9 56 10 00 00	 jmp	 $LN1@enumerate_
$LN10@enumerate_:

; 439  : 		}
; 440  : 	}
; 441  : 	else

  002e0	eb 44		 jmp	 SHORT $LN7@enumerate_
$LN6@enumerate_:

; 442  : 	{
; 443  : 	
; 444  : 		di_err = IDirectInputDevice7_SetCooperativeLevel (device, application_window, DISCL_NONEXCLUSIVE | DISCL_FOREGROUND);

  002e2	6a 06		 push	 6
  002e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  002e9	50		 push	 eax
  002ea	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  002ed	8b 11		 mov	 edx, DWORD PTR [ecx]
  002ef	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  002f2	50		 push	 eax
  002f3	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  002f6	ff d1		 call	 ecx
  002f8	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 445  : 	
; 446  : 		if (di_err != DI_OK)

  002fb	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  002ff	74 25		 je	 SHORT $LN7@enumerate_

; 447  : 		{
; 448  : 	
; 449  : 			debug_log ("Unable to set cooperative level on a joystick");

  00301	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@BCNOGLJF@Unable?5to?5set?5cooperative?5level@
  00306	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0030b	83 c4 04	 add	 esp, 4

; 450  : 	
; 451  : 			IDirectInputDevice7_Release (device);

  0030e	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00311	8b 08		 mov	 ecx, DWORD PTR [eax]
  00313	8b 55 f8	 mov	 edx, DWORD PTR _device$[ebp]
  00316	52		 push	 edx
  00317	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0031a	ff d0		 call	 eax

; 452  : 	
; 453  : 			return (DIENUM_CONTINUE);

  0031c	b8 01 00 00 00	 mov	 eax, 1
  00321	e9 10 10 00 00	 jmp	 $LN1@enumerate_
$LN7@enumerate_:

; 454  : 		}
; 455  : 	}
; 456  : 
; 457  : 	//
; 458  : 	// Initialise the device part for the next lot of queries
; 459  : 	//
; 460  : 
; 461  : 	device_part.dwSize = sizeof (DIDEVICEOBJECTINSTANCE);

  00326	c7 85 90 fe ff
	ff 3c 01 00 00	 mov	 DWORD PTR _device_part$[ebp], 316 ; 0000013cH

; 462  : 
; 463  : 	//
; 464  : 	// Initialise the range structure
; 465  : 	//
; 466  : 
; 467  : 	device_range.diph.dwSize = sizeof (device_range);

  00330	c7 45 e0 18 00
	00 00		 mov	 DWORD PTR _device_range$[ebp], 24 ; 00000018H

; 468  : 	device_range.diph.dwHeaderSize = sizeof (device_range.diph);

  00337	c7 45 e4 10 00
	00 00		 mov	 DWORD PTR _device_range$[ebp+4], 16 ; 00000010H

; 469  : 	device_range.diph.dwHow = DIPH_BYOFFSET;

  0033e	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _device_range$[ebp+12], 1

; 470  : 	device_range.lMin = JOYSTICK_AXIS_MINIMUM;

  00345	c7 45 f0 f0 d8
	ff ff		 mov	 DWORD PTR _device_range$[ebp+16], -10000 ; ffffd8f0H

; 471  : 	device_range.lMax = JOYSTICK_AXIS_MAXIMUM;

  0034c	c7 45 f4 10 27
	00 00		 mov	 DWORD PTR _device_range$[ebp+20], 10000 ; 00002710H

; 472  : 
; 473  : 	//
; 474  : 	// Set the dead zones for all the axis to be the same (for now).
; 475  : 	// Note: when setting the deadzone, units are specified in the thousandths, so 20% = 2000/10000
; 476  : 	//
; 477  : 
; 478  :    device_property.diph.dwSize = sizeof (device_property);

  00353	c7 45 cc 14 00
	00 00		 mov	 DWORD PTR _device_property$[ebp], 20 ; 00000014H

; 479  :    device_property.diph.dwHeaderSize = sizeof(device_property.diph);

  0035a	c7 45 d0 10 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+4], 16 ; 00000010H

; 480  :    device_property.diph.dwHow = DIPH_BYOFFSET;

  00361	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+12], 1

; 481  :    device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);

  00368	c7 45 dc d0 07
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 2000 ; 000007d0H

; 482  : 
; 483  : 	//
; 484  : 	// Mark all axis to be invalid
; 485  : 	//
; 486  : 
; 487  : 	joystick_devices[number_of_joystick_devices].joystick_xaxis_valid = FALSE;

  0036f	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00379	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0037f	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00383	83 e2 fe	 and	 edx, -2			; fffffffeH
  00386	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00390	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00396	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 488  : 	joystick_devices[number_of_joystick_devices].joystick_yaxis_valid = FALSE;

  0039a	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  003a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  003aa	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  003ae	83 e2 fd	 and	 edx, -3			; fffffffdH
  003b1	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  003bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  003c1	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 489  : 	joystick_devices[number_of_joystick_devices].joystick_zaxis_valid = FALSE;

  003c5	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  003cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  003d5	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  003d9	83 e2 fb	 and	 edx, -5			; fffffffbH
  003dc	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  003e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  003ec	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 490  : 	joystick_devices[number_of_joystick_devices].joystick_rxaxis_valid = FALSE;

  003f0	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  003fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00400	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00404	83 e2 f7	 and	 edx, -9			; fffffff7H
  00407	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00411	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00417	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 491  : 	joystick_devices[number_of_joystick_devices].joystick_ryaxis_valid = FALSE;

  0041b	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00425	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0042b	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  0042f	83 e2 ef	 and	 edx, -17		; ffffffefH
  00432	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  0043c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00442	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 492  : 	joystick_devices[number_of_joystick_devices].joystick_rzaxis_valid = FALSE;

  00446	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00450	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00456	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  0045a	83 e2 df	 and	 edx, -33		; ffffffdfH
  0045d	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00467	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0046d	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 493  : 	joystick_devices[number_of_joystick_devices].joystick_slider0axis_valid = FALSE;

  00471	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  0047b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00481	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00485	83 e2 bf	 and	 edx, -65		; ffffffbfH
  00488	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00492	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00498	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 494  : 	joystick_devices[number_of_joystick_devices].joystick_slider1axis_valid = FALSE;

  0049c	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  004a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  004ac	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  004b0	81 e2 7f ff ff
	ff		 and	 edx, -129		; ffffff7fH
  004b6	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  004c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  004c6	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 495  : 
; 496  : 	//
; 497  : 	// Initialise the X axis (if there is one)
; 498  : 	//
; 499  : 
; 500  : 	di_err = IDirectInputDevice7_GetObjectInfo (device, &device_part, DIJOFS_X, DIPH_BYOFFSET);

  004ca	6a 01		 push	 1
  004cc	6a 00		 push	 0
  004ce	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp]
  004d4	50		 push	 eax
  004d5	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  004d8	8b 11		 mov	 edx, DWORD PTR [ecx]
  004da	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  004dd	50		 push	 eax
  004de	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  004e1	ff d1		 call	 ecx
  004e3	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 501  : 
; 502  : 	if (di_err == DI_OK)

  004e6	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  004ea	0f 85 72 01 00
	00		 jne	 $LN12@enumerate_

; 503  : 	{
; 504  : #if 0	// Retro 12Dez2004
; 505  : 		device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);
; 506  : #else
; 507  : 		if ( TRUE == axis_has_deadzone (number_of_joystick_devices, 0))

  004f0	6a 00		 push	 0
  004f2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  004f7	50		 push	 eax
  004f8	e8 00 00 00 00	 call	 ?axis_has_deadzone@@YGHHH@Z ; axis_has_deadzone
  004fd	83 f8 01	 cmp	 eax, 1
  00500	75 09		 jne	 SHORT $LN13@enumerate_

; 508  : 			device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);

  00502	c7 45 dc d0 07
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 2000 ; 000007d0H

; 509  : 		else

  00509	eb 07		 jmp	 SHORT $LN14@enumerate_
$LN13@enumerate_:

; 510  : 			device_property.dwData = 0;

  0050b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 0
$LN14@enumerate_:

; 511  : #endif
; 512  : 
; 513  : 		joystick_devices[number_of_joystick_devices].joystick_xaxis_valid = TRUE;

  00512	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  0051c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00522	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00526	83 ca 01	 or	 edx, 1
  00529	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00533	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00539	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 514  : 
; 515  : 		device_range.diph.dwObj = DIJOFS_X;

  0053d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _device_range$[ebp+8], 0

; 516  : 		device_property.diph.dwObj = DIJOFS_X;

  00544	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+8], 0

; 517  : 	
; 518  : 		IDirectInputDevice7_SetProperty (device, DIPROP_RANGE, &device_range.diph);

  0054b	8d 45 e0	 lea	 eax, DWORD PTR _device_range$[ebp]
  0054e	50		 push	 eax
  0054f	6a 04		 push	 4
  00551	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00554	8b 11		 mov	 edx, DWORD PTR [ecx]
  00556	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00559	50		 push	 eax
  0055a	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  0055d	ff d1		 call	 ecx

; 519  : 		IDirectInputDevice7_SetProperty (device, DIPROP_DEADZONE, &device_property.diph);

  0055f	8d 45 cc	 lea	 eax, DWORD PTR _device_property$[ebp]
  00562	50		 push	 eax
  00563	6a 05		 push	 5
  00565	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00568	8b 11		 mov	 edx, DWORD PTR [ecx]
  0056a	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  0056d	50		 push	 eax
  0056e	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00571	ff d1		 call	 ecx

; 520  : 
; 521  : 		// Retro 10Jul2004 start
; 522  : 		AxisInfo[AxisCount].axis = 0;

  00573	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00578	c1 e0 04	 shl	 eax, 4
  0057b	c7 80 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+8], 0

; 523  : 		AxisInfo[AxisCount].device = number_of_joystick_devices;

  00585	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  0058a	c1 e0 04	 shl	 eax, 4
  0058d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  00593	89 88 04 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+4], ecx

; 524  : 		AxisInfo[AxisCount].AxisName = (char*) malloc(strlen(device_instance->tszProductName)+strlen(": ")+strlen(device_part.tszName)+1);

  00599	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  0059c	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  005a1	50		 push	 eax
  005a2	e8 00 00 00 00	 call	 _strlen
  005a7	83 c4 04	 add	 esp, 4
  005aa	8b f0		 mov	 esi, eax
  005ac	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  005b1	e8 00 00 00 00	 call	 _strlen
  005b6	83 c4 04	 add	 esp, 4
  005b9	03 f0		 add	 esi, eax
  005bb	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _device_part$[ebp+32]
  005c1	51		 push	 ecx
  005c2	e8 00 00 00 00	 call	 _strlen
  005c7	83 c4 04	 add	 esp, 4
  005ca	8d 54 06 01	 lea	 edx, DWORD PTR [esi+eax+1]
  005ce	52		 push	 edx
  005cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  005d5	83 c4 04	 add	 esp, 4
  005d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  005de	c1 e1 04	 shl	 ecx, 4
  005e1	89 81 00 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx], eax

; 525  : 		strcpy(AxisInfo[AxisCount].AxisName,device_instance->tszProductName);

  005e7	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  005ea	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  005ef	50		 push	 eax
  005f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  005f6	c1 e1 04	 shl	 ecx, 4
  005f9	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  005ff	52		 push	 edx
  00600	e8 00 00 00 00	 call	 _strcpy
  00605	83 c4 08	 add	 esp, 8

; 526  : 		strcat(AxisInfo[AxisCount].AxisName,": ");

  00608	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  0060d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00612	c1 e0 04	 shl	 eax, 4
  00615	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax]
  0061b	51		 push	 ecx
  0061c	e8 00 00 00 00	 call	 _strcat
  00621	83 c4 08	 add	 esp, 8

; 527  : 		strcat(AxisInfo[AxisCount].AxisName,device_part.tszName);

  00624	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp+32]
  0062a	50		 push	 eax
  0062b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00631	c1 e1 04	 shl	 ecx, 4
  00634	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  0063a	52		 push	 edx
  0063b	e8 00 00 00 00	 call	 _strcat
  00640	83 c4 08	 add	 esp, 8

; 528  : 		AxisInfo[AxisCount].inUse = FALSE;

  00643	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00648	c1 e0 04	 shl	 eax, 4
  0064b	c7 80 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+12], 0

; 529  : 		AxisCount++;

  00655	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  0065a	83 c0 01	 add	 eax, 1
  0065d	a3 00 00 00 00	 mov	 DWORD PTR ?AxisCount@@3HA, eax ; AxisCount
$LN12@enumerate_:

; 530  : 		// Retro 10Jul2004 end
; 531  : 	}
; 532  : 
; 533  : 	//
; 534  : 	// Initialise the Y axis (if there is one)
; 535  : 	//
; 536  : 
; 537  : 	di_err = IDirectInputDevice7_GetObjectInfo (device, &device_part, DIJOFS_Y, DIPH_BYOFFSET);

  00662	6a 01		 push	 1
  00664	6a 04		 push	 4
  00666	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp]
  0066c	50		 push	 eax
  0066d	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00670	8b 11		 mov	 edx, DWORD PTR [ecx]
  00672	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00675	50		 push	 eax
  00676	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00679	ff d1		 call	 ecx
  0067b	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 538  : 
; 539  : 	if (di_err == DI_OK)

  0067e	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  00682	0f 85 72 01 00
	00		 jne	 $LN15@enumerate_

; 540  : 	{
; 541  : #if 0	// Retro 12Dez2004
; 542  : 		device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);
; 543  : #else
; 544  : 		if ( TRUE == axis_has_deadzone (number_of_joystick_devices, 1))

  00688	6a 01		 push	 1
  0068a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  0068f	50		 push	 eax
  00690	e8 00 00 00 00	 call	 ?axis_has_deadzone@@YGHHH@Z ; axis_has_deadzone
  00695	83 f8 01	 cmp	 eax, 1
  00698	75 09		 jne	 SHORT $LN16@enumerate_

; 545  : 			device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);

  0069a	c7 45 dc d0 07
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 2000 ; 000007d0H

; 546  : 		else

  006a1	eb 07		 jmp	 SHORT $LN17@enumerate_
$LN16@enumerate_:

; 547  : 			device_property.dwData = 0;

  006a3	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 0
$LN17@enumerate_:

; 548  : #endif
; 549  : 
; 550  : 		joystick_devices[number_of_joystick_devices].joystick_yaxis_valid = TRUE;

  006aa	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  006b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  006ba	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  006be	83 ca 02	 or	 edx, 2
  006c1	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  006cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  006d1	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 551  : 
; 552  : 		device_range.diph.dwObj = DIJOFS_Y;

  006d5	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR _device_range$[ebp+8], 4

; 553  : 		device_property.diph.dwObj = DIJOFS_Y;

  006dc	c7 45 d4 04 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+8], 4

; 554  : 	
; 555  : 		IDirectInputDevice7_SetProperty (device, DIPROP_RANGE, &device_range.diph);

  006e3	8d 45 e0	 lea	 eax, DWORD PTR _device_range$[ebp]
  006e6	50		 push	 eax
  006e7	6a 04		 push	 4
  006e9	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  006ec	8b 11		 mov	 edx, DWORD PTR [ecx]
  006ee	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  006f1	50		 push	 eax
  006f2	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  006f5	ff d1		 call	 ecx

; 556  : 		IDirectInputDevice7_SetProperty (device, DIPROP_DEADZONE, &device_property.diph);

  006f7	8d 45 cc	 lea	 eax, DWORD PTR _device_property$[ebp]
  006fa	50		 push	 eax
  006fb	6a 05		 push	 5
  006fd	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00700	8b 11		 mov	 edx, DWORD PTR [ecx]
  00702	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00705	50		 push	 eax
  00706	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00709	ff d1		 call	 ecx

; 557  : 
; 558  : 		// Retro 10Jul2004 start
; 559  : 		AxisInfo[AxisCount].axis = 1;

  0070b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00710	c1 e0 04	 shl	 eax, 4
  00713	c7 80 08 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+8], 1

; 560  : 		AxisInfo[AxisCount].device = number_of_joystick_devices;

  0071d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00722	c1 e0 04	 shl	 eax, 4
  00725	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  0072b	89 88 04 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+4], ecx

; 561  : 		AxisInfo[AxisCount].AxisName = (char*) malloc(strlen(device_instance->tszProductName)+strlen(": ")+strlen(device_part.tszName)+1);

  00731	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  00734	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00739	50		 push	 eax
  0073a	e8 00 00 00 00	 call	 _strlen
  0073f	83 c4 04	 add	 esp, 4
  00742	8b f0		 mov	 esi, eax
  00744	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  00749	e8 00 00 00 00	 call	 _strlen
  0074e	83 c4 04	 add	 esp, 4
  00751	03 f0		 add	 esi, eax
  00753	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _device_part$[ebp+32]
  00759	51		 push	 ecx
  0075a	e8 00 00 00 00	 call	 _strlen
  0075f	83 c4 04	 add	 esp, 4
  00762	8d 54 06 01	 lea	 edx, DWORD PTR [esi+eax+1]
  00766	52		 push	 edx
  00767	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0076d	83 c4 04	 add	 esp, 4
  00770	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00776	c1 e1 04	 shl	 ecx, 4
  00779	89 81 00 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx], eax

; 562  : 		strcpy(AxisInfo[AxisCount].AxisName,device_instance->tszProductName);

  0077f	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  00782	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00787	50		 push	 eax
  00788	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  0078e	c1 e1 04	 shl	 ecx, 4
  00791	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  00797	52		 push	 edx
  00798	e8 00 00 00 00	 call	 _strcpy
  0079d	83 c4 08	 add	 esp, 8

; 563  : 		strcat(AxisInfo[AxisCount].AxisName,": ");

  007a0	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  007a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  007aa	c1 e0 04	 shl	 eax, 4
  007ad	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax]
  007b3	51		 push	 ecx
  007b4	e8 00 00 00 00	 call	 _strcat
  007b9	83 c4 08	 add	 esp, 8

; 564  : 		strcat(AxisInfo[AxisCount].AxisName,device_part.tszName);

  007bc	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp+32]
  007c2	50		 push	 eax
  007c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  007c9	c1 e1 04	 shl	 ecx, 4
  007cc	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  007d2	52		 push	 edx
  007d3	e8 00 00 00 00	 call	 _strcat
  007d8	83 c4 08	 add	 esp, 8

; 565  : 		AxisInfo[AxisCount].inUse = FALSE;

  007db	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  007e0	c1 e0 04	 shl	 eax, 4
  007e3	c7 80 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+12], 0

; 566  : 		AxisCount++;

  007ed	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  007f2	83 c0 01	 add	 eax, 1
  007f5	a3 00 00 00 00	 mov	 DWORD PTR ?AxisCount@@3HA, eax ; AxisCount
$LN15@enumerate_:

; 567  : 		// Retro 10Jul2004 end
; 568  : 	}
; 569  : 
; 570  : 	//
; 571  : 	// Initialise the Z axis (if there is one)
; 572  : 	//
; 573  : 
; 574  : 	di_err = IDirectInputDevice7_GetObjectInfo (device, &device_part, DIJOFS_Z, DIPH_BYOFFSET);

  007fa	6a 01		 push	 1
  007fc	6a 08		 push	 8
  007fe	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp]
  00804	50		 push	 eax
  00805	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00808	8b 11		 mov	 edx, DWORD PTR [ecx]
  0080a	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  0080d	50		 push	 eax
  0080e	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00811	ff d1		 call	 ecx
  00813	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 575  : 
; 576  : 	if (di_err == DI_OK)

  00816	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  0081a	0f 85 72 01 00
	00		 jne	 $LN18@enumerate_

; 577  : 	{
; 578  : 
; 579  : 		//
; 580  : 		// The Z axis required a dead zone of ZERO (its the collective)
; 581  : 		//
; 582  : 
; 583  : #if 0	// Retro 12Dez2004
; 584  : 		device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);
; 585  : #else
; 586  : 		if ( TRUE == axis_has_deadzone (number_of_joystick_devices, 2))

  00820	6a 02		 push	 2
  00822	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  00827	50		 push	 eax
  00828	e8 00 00 00 00	 call	 ?axis_has_deadzone@@YGHHH@Z ; axis_has_deadzone
  0082d	83 f8 01	 cmp	 eax, 1
  00830	75 09		 jne	 SHORT $LN19@enumerate_

; 587  : 			device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);

  00832	c7 45 dc d0 07
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 2000 ; 000007d0H

; 588  : 		else

  00839	eb 07		 jmp	 SHORT $LN20@enumerate_
$LN19@enumerate_:

; 589  : 			device_property.dwData = 0;

  0083b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 0
$LN20@enumerate_:

; 590  : #endif
; 591  : 
; 592  : 		joystick_devices[number_of_joystick_devices].joystick_zaxis_valid = TRUE;

  00842	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  0084c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00852	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00856	83 ca 04	 or	 edx, 4
  00859	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00863	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00869	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 593  : 
; 594  : 		device_range.diph.dwObj = DIJOFS_Z;

  0086d	c7 45 e8 08 00
	00 00		 mov	 DWORD PTR _device_range$[ebp+8], 8

; 595  : 		device_property.diph.dwObj = DIJOFS_Z;

  00874	c7 45 d4 08 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+8], 8

; 596  : 	
; 597  : 		IDirectInputDevice7_SetProperty (device, DIPROP_RANGE, &device_range.diph);

  0087b	8d 45 e0	 lea	 eax, DWORD PTR _device_range$[ebp]
  0087e	50		 push	 eax
  0087f	6a 04		 push	 4
  00881	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00884	8b 11		 mov	 edx, DWORD PTR [ecx]
  00886	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00889	50		 push	 eax
  0088a	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  0088d	ff d1		 call	 ecx

; 598  : 		IDirectInputDevice7_SetProperty (device, DIPROP_DEADZONE, &device_property.diph);

  0088f	8d 45 cc	 lea	 eax, DWORD PTR _device_property$[ebp]
  00892	50		 push	 eax
  00893	6a 05		 push	 5
  00895	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00898	8b 11		 mov	 edx, DWORD PTR [ecx]
  0089a	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  0089d	50		 push	 eax
  0089e	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  008a1	ff d1		 call	 ecx

; 599  : 
; 600  : 		// Retro 10Jul2004 start
; 601  : 		AxisInfo[AxisCount].axis = 2;

  008a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  008a8	c1 e0 04	 shl	 eax, 4
  008ab	c7 80 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+8], 2

; 602  : 		AxisInfo[AxisCount].device = number_of_joystick_devices;

  008b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  008ba	c1 e0 04	 shl	 eax, 4
  008bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  008c3	89 88 04 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+4], ecx

; 603  : 		AxisInfo[AxisCount].AxisName = (char*) malloc(strlen(device_instance->tszProductName)+strlen(": ")+strlen(device_part.tszName)+1);

  008c9	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  008cc	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  008d1	50		 push	 eax
  008d2	e8 00 00 00 00	 call	 _strlen
  008d7	83 c4 04	 add	 esp, 4
  008da	8b f0		 mov	 esi, eax
  008dc	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  008e1	e8 00 00 00 00	 call	 _strlen
  008e6	83 c4 04	 add	 esp, 4
  008e9	03 f0		 add	 esi, eax
  008eb	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _device_part$[ebp+32]
  008f1	51		 push	 ecx
  008f2	e8 00 00 00 00	 call	 _strlen
  008f7	83 c4 04	 add	 esp, 4
  008fa	8d 54 06 01	 lea	 edx, DWORD PTR [esi+eax+1]
  008fe	52		 push	 edx
  008ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00905	83 c4 04	 add	 esp, 4
  00908	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  0090e	c1 e1 04	 shl	 ecx, 4
  00911	89 81 00 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx], eax

; 604  : 		strcpy(AxisInfo[AxisCount].AxisName,device_instance->tszProductName);

  00917	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  0091a	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  0091f	50		 push	 eax
  00920	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00926	c1 e1 04	 shl	 ecx, 4
  00929	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  0092f	52		 push	 edx
  00930	e8 00 00 00 00	 call	 _strcpy
  00935	83 c4 08	 add	 esp, 8

; 605  : 		strcat(AxisInfo[AxisCount].AxisName,": ");

  00938	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  0093d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00942	c1 e0 04	 shl	 eax, 4
  00945	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax]
  0094b	51		 push	 ecx
  0094c	e8 00 00 00 00	 call	 _strcat
  00951	83 c4 08	 add	 esp, 8

; 606  : 		strcat(AxisInfo[AxisCount].AxisName,device_part.tszName);

  00954	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp+32]
  0095a	50		 push	 eax
  0095b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00961	c1 e1 04	 shl	 ecx, 4
  00964	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  0096a	52		 push	 edx
  0096b	e8 00 00 00 00	 call	 _strcat
  00970	83 c4 08	 add	 esp, 8

; 607  : 		AxisInfo[AxisCount].inUse = FALSE;

  00973	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00978	c1 e0 04	 shl	 eax, 4
  0097b	c7 80 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+12], 0

; 608  : 		AxisCount++;

  00985	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  0098a	83 c0 01	 add	 eax, 1
  0098d	a3 00 00 00 00	 mov	 DWORD PTR ?AxisCount@@3HA, eax ; AxisCount
$LN18@enumerate_:

; 609  : 		// Retro 10Jul2004 end
; 610  : 	}
; 611  : 
; 612  : 	//
; 613  : 	// Initialise the Rx axis (if there is one)
; 614  : 	//
; 615  : 
; 616  : 	di_err = IDirectInputDevice7_GetObjectInfo (device, &device_part, DIJOFS_RX, DIPH_BYOFFSET);

  00992	6a 01		 push	 1
  00994	6a 0c		 push	 12			; 0000000cH
  00996	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp]
  0099c	50		 push	 eax
  0099d	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  009a0	8b 11		 mov	 edx, DWORD PTR [ecx]
  009a2	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  009a5	50		 push	 eax
  009a6	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  009a9	ff d1		 call	 ecx
  009ab	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 617  : 
; 618  : 	if (di_err == DI_OK)

  009ae	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  009b2	0f 85 72 01 00
	00		 jne	 $LN21@enumerate_

; 619  : 	{
; 620  : #if 0	// Retro 12Dez2004
; 621  : 		device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);
; 622  : #else
; 623  : 		if ( TRUE == axis_has_deadzone (number_of_joystick_devices, 3))

  009b8	6a 03		 push	 3
  009ba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  009bf	50		 push	 eax
  009c0	e8 00 00 00 00	 call	 ?axis_has_deadzone@@YGHHH@Z ; axis_has_deadzone
  009c5	83 f8 01	 cmp	 eax, 1
  009c8	75 09		 jne	 SHORT $LN22@enumerate_

; 624  : 			device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);

  009ca	c7 45 dc d0 07
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 2000 ; 000007d0H

; 625  : 		else

  009d1	eb 07		 jmp	 SHORT $LN23@enumerate_
$LN22@enumerate_:

; 626  : 			device_property.dwData = 0;

  009d3	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 0
$LN23@enumerate_:

; 627  : #endif
; 628  : 
; 629  : 		joystick_devices[number_of_joystick_devices].joystick_rxaxis_valid = TRUE;

  009da	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  009e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  009ea	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  009ee	83 ca 08	 or	 edx, 8
  009f1	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  009fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00a01	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 630  : 
; 631  : 		device_range.diph.dwObj = DIJOFS_RX;

  00a05	c7 45 e8 0c 00
	00 00		 mov	 DWORD PTR _device_range$[ebp+8], 12 ; 0000000cH

; 632  : 		device_property.diph.dwObj = DIJOFS_RX;

  00a0c	c7 45 d4 0c 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+8], 12 ; 0000000cH

; 633  : 	
; 634  : 		IDirectInputDevice7_SetProperty (device, DIPROP_RANGE, &device_range.diph);

  00a13	8d 45 e0	 lea	 eax, DWORD PTR _device_range$[ebp]
  00a16	50		 push	 eax
  00a17	6a 04		 push	 4
  00a19	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00a1c	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a1e	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00a21	50		 push	 eax
  00a22	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00a25	ff d1		 call	 ecx

; 635  : 		IDirectInputDevice7_SetProperty (device, DIPROP_DEADZONE, &device_property.diph);

  00a27	8d 45 cc	 lea	 eax, DWORD PTR _device_property$[ebp]
  00a2a	50		 push	 eax
  00a2b	6a 05		 push	 5
  00a2d	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00a30	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a32	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00a35	50		 push	 eax
  00a36	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00a39	ff d1		 call	 ecx

; 636  : 
; 637  : 		// Retro 10Jul2004 start
; 638  : 		AxisInfo[AxisCount].axis = 3;

  00a3b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00a40	c1 e0 04	 shl	 eax, 4
  00a43	c7 80 08 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+8], 3

; 639  : 		AxisInfo[AxisCount].device = number_of_joystick_devices;

  00a4d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00a52	c1 e0 04	 shl	 eax, 4
  00a55	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  00a5b	89 88 04 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+4], ecx

; 640  : 		AxisInfo[AxisCount].AxisName = (char*) malloc(strlen(device_instance->tszProductName)+strlen(": ")+strlen(device_part.tszName)+1);

  00a61	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  00a64	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00a69	50		 push	 eax
  00a6a	e8 00 00 00 00	 call	 _strlen
  00a6f	83 c4 04	 add	 esp, 4
  00a72	8b f0		 mov	 esi, eax
  00a74	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  00a79	e8 00 00 00 00	 call	 _strlen
  00a7e	83 c4 04	 add	 esp, 4
  00a81	03 f0		 add	 esi, eax
  00a83	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _device_part$[ebp+32]
  00a89	51		 push	 ecx
  00a8a	e8 00 00 00 00	 call	 _strlen
  00a8f	83 c4 04	 add	 esp, 4
  00a92	8d 54 06 01	 lea	 edx, DWORD PTR [esi+eax+1]
  00a96	52		 push	 edx
  00a97	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00a9d	83 c4 04	 add	 esp, 4
  00aa0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00aa6	c1 e1 04	 shl	 ecx, 4
  00aa9	89 81 00 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx], eax

; 641  : 		strcpy(AxisInfo[AxisCount].AxisName,device_instance->tszProductName);

  00aaf	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  00ab2	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00ab7	50		 push	 eax
  00ab8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00abe	c1 e1 04	 shl	 ecx, 4
  00ac1	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  00ac7	52		 push	 edx
  00ac8	e8 00 00 00 00	 call	 _strcpy
  00acd	83 c4 08	 add	 esp, 8

; 642  : 		strcat(AxisInfo[AxisCount].AxisName,": ");

  00ad0	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  00ad5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00ada	c1 e0 04	 shl	 eax, 4
  00add	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax]
  00ae3	51		 push	 ecx
  00ae4	e8 00 00 00 00	 call	 _strcat
  00ae9	83 c4 08	 add	 esp, 8

; 643  : 		strcat(AxisInfo[AxisCount].AxisName,device_part.tszName);

  00aec	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp+32]
  00af2	50		 push	 eax
  00af3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00af9	c1 e1 04	 shl	 ecx, 4
  00afc	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  00b02	52		 push	 edx
  00b03	e8 00 00 00 00	 call	 _strcat
  00b08	83 c4 08	 add	 esp, 8

; 644  : 		AxisInfo[AxisCount].inUse = FALSE;

  00b0b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00b10	c1 e0 04	 shl	 eax, 4
  00b13	c7 80 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+12], 0

; 645  : 		AxisCount++;

  00b1d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00b22	83 c0 01	 add	 eax, 1
  00b25	a3 00 00 00 00	 mov	 DWORD PTR ?AxisCount@@3HA, eax ; AxisCount
$LN21@enumerate_:

; 646  : 		// Retro 10Jul2004 end
; 647  : 	}
; 648  : 
; 649  : 	//
; 650  : 	// Initialise the Ry axis (if there is one)
; 651  : 	//
; 652  : 
; 653  : 	di_err = IDirectInputDevice7_GetObjectInfo (device, &device_part, DIJOFS_RY, DIPH_BYOFFSET);

  00b2a	6a 01		 push	 1
  00b2c	6a 10		 push	 16			; 00000010H
  00b2e	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp]
  00b34	50		 push	 eax
  00b35	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00b38	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b3a	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00b3d	50		 push	 eax
  00b3e	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00b41	ff d1		 call	 ecx
  00b43	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 654  : 
; 655  : 	if (di_err == DI_OK)

  00b46	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  00b4a	0f 85 72 01 00
	00		 jne	 $LN24@enumerate_

; 656  : 	{
; 657  : #if 0	// Retro 12Dez2004
; 658  : 		device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);
; 659  : #else
; 660  : 		if ( TRUE == axis_has_deadzone (number_of_joystick_devices, 4))

  00b50	6a 04		 push	 4
  00b52	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  00b57	50		 push	 eax
  00b58	e8 00 00 00 00	 call	 ?axis_has_deadzone@@YGHHH@Z ; axis_has_deadzone
  00b5d	83 f8 01	 cmp	 eax, 1
  00b60	75 09		 jne	 SHORT $LN25@enumerate_

; 661  : 			device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);

  00b62	c7 45 dc d0 07
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 2000 ; 000007d0H

; 662  : 		else

  00b69	eb 07		 jmp	 SHORT $LN26@enumerate_
$LN25@enumerate_:

; 663  : 			device_property.dwData = 0;

  00b6b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 0
$LN26@enumerate_:

; 664  : #endif
; 665  : 		joystick_devices[number_of_joystick_devices].joystick_ryaxis_valid = TRUE;

  00b72	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00b7c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00b82	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00b86	83 ca 10	 or	 edx, 16			; 00000010H
  00b89	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00b93	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00b99	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 666  : 
; 667  : 		device_range.diph.dwObj = DIJOFS_RY;

  00b9d	c7 45 e8 10 00
	00 00		 mov	 DWORD PTR _device_range$[ebp+8], 16 ; 00000010H

; 668  : 		device_property.diph.dwObj = DIJOFS_RY;

  00ba4	c7 45 d4 10 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+8], 16 ; 00000010H

; 669  : 	
; 670  : 		IDirectInputDevice7_SetProperty (device, DIPROP_RANGE, &device_range.diph);

  00bab	8d 45 e0	 lea	 eax, DWORD PTR _device_range$[ebp]
  00bae	50		 push	 eax
  00baf	6a 04		 push	 4
  00bb1	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00bb4	8b 11		 mov	 edx, DWORD PTR [ecx]
  00bb6	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00bb9	50		 push	 eax
  00bba	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00bbd	ff d1		 call	 ecx

; 671  : 		IDirectInputDevice7_SetProperty (device, DIPROP_DEADZONE, &device_property.diph);

  00bbf	8d 45 cc	 lea	 eax, DWORD PTR _device_property$[ebp]
  00bc2	50		 push	 eax
  00bc3	6a 05		 push	 5
  00bc5	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00bc8	8b 11		 mov	 edx, DWORD PTR [ecx]
  00bca	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00bcd	50		 push	 eax
  00bce	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00bd1	ff d1		 call	 ecx

; 672  : 
; 673  : 		// Retro 10Jul2004 start
; 674  : 		AxisInfo[AxisCount].axis = 4;

  00bd3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00bd8	c1 e0 04	 shl	 eax, 4
  00bdb	c7 80 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+8], 4

; 675  : 		AxisInfo[AxisCount].device = number_of_joystick_devices;

  00be5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00bea	c1 e0 04	 shl	 eax, 4
  00bed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  00bf3	89 88 04 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+4], ecx

; 676  : 		AxisInfo[AxisCount].AxisName = (char*) malloc(strlen(device_instance->tszProductName)+strlen(": ")+strlen(device_part.tszName)+1);

  00bf9	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  00bfc	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00c01	50		 push	 eax
  00c02	e8 00 00 00 00	 call	 _strlen
  00c07	83 c4 04	 add	 esp, 4
  00c0a	8b f0		 mov	 esi, eax
  00c0c	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  00c11	e8 00 00 00 00	 call	 _strlen
  00c16	83 c4 04	 add	 esp, 4
  00c19	03 f0		 add	 esi, eax
  00c1b	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _device_part$[ebp+32]
  00c21	51		 push	 ecx
  00c22	e8 00 00 00 00	 call	 _strlen
  00c27	83 c4 04	 add	 esp, 4
  00c2a	8d 54 06 01	 lea	 edx, DWORD PTR [esi+eax+1]
  00c2e	52		 push	 edx
  00c2f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00c35	83 c4 04	 add	 esp, 4
  00c38	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00c3e	c1 e1 04	 shl	 ecx, 4
  00c41	89 81 00 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx], eax

; 677  : 		strcpy(AxisInfo[AxisCount].AxisName,device_instance->tszProductName);

  00c47	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  00c4a	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00c4f	50		 push	 eax
  00c50	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00c56	c1 e1 04	 shl	 ecx, 4
  00c59	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  00c5f	52		 push	 edx
  00c60	e8 00 00 00 00	 call	 _strcpy
  00c65	83 c4 08	 add	 esp, 8

; 678  : 		strcat(AxisInfo[AxisCount].AxisName,": ");

  00c68	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  00c6d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00c72	c1 e0 04	 shl	 eax, 4
  00c75	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax]
  00c7b	51		 push	 ecx
  00c7c	e8 00 00 00 00	 call	 _strcat
  00c81	83 c4 08	 add	 esp, 8

; 679  : 		strcat(AxisInfo[AxisCount].AxisName,device_part.tszName);

  00c84	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp+32]
  00c8a	50		 push	 eax
  00c8b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00c91	c1 e1 04	 shl	 ecx, 4
  00c94	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  00c9a	52		 push	 edx
  00c9b	e8 00 00 00 00	 call	 _strcat
  00ca0	83 c4 08	 add	 esp, 8

; 680  : 		AxisInfo[AxisCount].inUse = FALSE;

  00ca3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00ca8	c1 e0 04	 shl	 eax, 4
  00cab	c7 80 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+12], 0

; 681  : 		AxisCount++;

  00cb5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00cba	83 c0 01	 add	 eax, 1
  00cbd	a3 00 00 00 00	 mov	 DWORD PTR ?AxisCount@@3HA, eax ; AxisCount
$LN24@enumerate_:

; 682  : 		// Retro 10Jul2004 end
; 683  : 	}
; 684  : 
; 685  : 	//
; 686  : 	// Initialise the Rz axis (if there is one)
; 687  : 	//
; 688  : 
; 689  : 	di_err = IDirectInputDevice7_GetObjectInfo (device, &device_part, DIJOFS_RZ, DIPH_BYOFFSET);

  00cc2	6a 01		 push	 1
  00cc4	6a 14		 push	 20			; 00000014H
  00cc6	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp]
  00ccc	50		 push	 eax
  00ccd	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00cd0	8b 11		 mov	 edx, DWORD PTR [ecx]
  00cd2	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00cd5	50		 push	 eax
  00cd6	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00cd9	ff d1		 call	 ecx
  00cdb	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 690  : 
; 691  : 	if (di_err == DI_OK)

  00cde	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  00ce2	0f 85 72 01 00
	00		 jne	 $LN27@enumerate_

; 692  : 	{
; 693  : #if 0	// Retro 12Dez2004
; 694  : 		device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);
; 695  : #else
; 696  : 		if ( TRUE == axis_has_deadzone (number_of_joystick_devices, 5))

  00ce8	6a 05		 push	 5
  00cea	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  00cef	50		 push	 eax
  00cf0	e8 00 00 00 00	 call	 ?axis_has_deadzone@@YGHHH@Z ; axis_has_deadzone
  00cf5	83 f8 01	 cmp	 eax, 1
  00cf8	75 09		 jne	 SHORT $LN28@enumerate_

; 697  : 			device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);

  00cfa	c7 45 dc d0 07
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 2000 ; 000007d0H

; 698  : 		else

  00d01	eb 07		 jmp	 SHORT $LN29@enumerate_
$LN28@enumerate_:

; 699  : 			device_property.dwData = 0;

  00d03	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 0
$LN29@enumerate_:

; 700  : #endif
; 701  : 		joystick_devices[number_of_joystick_devices].joystick_rzaxis_valid = TRUE;

  00d0a	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00d14	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00d1a	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00d1e	83 ca 20	 or	 edx, 32			; 00000020H
  00d21	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00d2b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00d31	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 702  : 
; 703  : 		device_range.diph.dwObj = DIJOFS_RZ;

  00d35	c7 45 e8 14 00
	00 00		 mov	 DWORD PTR _device_range$[ebp+8], 20 ; 00000014H

; 704  : 		device_property.diph.dwObj = DIJOFS_RZ;

  00d3c	c7 45 d4 14 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+8], 20 ; 00000014H

; 705  : 	
; 706  : 		IDirectInputDevice7_SetProperty (device, DIPROP_RANGE, &device_range.diph);

  00d43	8d 45 e0	 lea	 eax, DWORD PTR _device_range$[ebp]
  00d46	50		 push	 eax
  00d47	6a 04		 push	 4
  00d49	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00d4c	8b 11		 mov	 edx, DWORD PTR [ecx]
  00d4e	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00d51	50		 push	 eax
  00d52	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00d55	ff d1		 call	 ecx

; 707  : 		IDirectInputDevice7_SetProperty (device, DIPROP_DEADZONE, &device_property.diph);

  00d57	8d 45 cc	 lea	 eax, DWORD PTR _device_property$[ebp]
  00d5a	50		 push	 eax
  00d5b	6a 05		 push	 5
  00d5d	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00d60	8b 11		 mov	 edx, DWORD PTR [ecx]
  00d62	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00d65	50		 push	 eax
  00d66	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00d69	ff d1		 call	 ecx

; 708  : 
; 709  : 		// Retro 10Jul2004 start
; 710  : 		AxisInfo[AxisCount].axis = 5;

  00d6b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00d70	c1 e0 04	 shl	 eax, 4
  00d73	c7 80 08 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+8], 5

; 711  : 		AxisInfo[AxisCount].device = number_of_joystick_devices;

  00d7d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00d82	c1 e0 04	 shl	 eax, 4
  00d85	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  00d8b	89 88 04 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+4], ecx

; 712  : 		AxisInfo[AxisCount].AxisName = (char*) malloc(strlen(device_instance->tszProductName)+strlen(": ")+strlen(device_part.tszName)+1);

  00d91	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  00d94	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00d99	50		 push	 eax
  00d9a	e8 00 00 00 00	 call	 _strlen
  00d9f	83 c4 04	 add	 esp, 4
  00da2	8b f0		 mov	 esi, eax
  00da4	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  00da9	e8 00 00 00 00	 call	 _strlen
  00dae	83 c4 04	 add	 esp, 4
  00db1	03 f0		 add	 esi, eax
  00db3	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _device_part$[ebp+32]
  00db9	51		 push	 ecx
  00dba	e8 00 00 00 00	 call	 _strlen
  00dbf	83 c4 04	 add	 esp, 4
  00dc2	8d 54 06 01	 lea	 edx, DWORD PTR [esi+eax+1]
  00dc6	52		 push	 edx
  00dc7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00dcd	83 c4 04	 add	 esp, 4
  00dd0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00dd6	c1 e1 04	 shl	 ecx, 4
  00dd9	89 81 00 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx], eax

; 713  : 		strcpy(AxisInfo[AxisCount].AxisName,device_instance->tszProductName);

  00ddf	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  00de2	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00de7	50		 push	 eax
  00de8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00dee	c1 e1 04	 shl	 ecx, 4
  00df1	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  00df7	52		 push	 edx
  00df8	e8 00 00 00 00	 call	 _strcpy
  00dfd	83 c4 08	 add	 esp, 8

; 714  : 		strcat(AxisInfo[AxisCount].AxisName,": ");

  00e00	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  00e05	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00e0a	c1 e0 04	 shl	 eax, 4
  00e0d	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax]
  00e13	51		 push	 ecx
  00e14	e8 00 00 00 00	 call	 _strcat
  00e19	83 c4 08	 add	 esp, 8

; 715  : 		strcat(AxisInfo[AxisCount].AxisName,device_part.tszName);

  00e1c	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp+32]
  00e22	50		 push	 eax
  00e23	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00e29	c1 e1 04	 shl	 ecx, 4
  00e2c	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  00e32	52		 push	 edx
  00e33	e8 00 00 00 00	 call	 _strcat
  00e38	83 c4 08	 add	 esp, 8

; 716  : 		AxisInfo[AxisCount].inUse = FALSE;

  00e3b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00e40	c1 e0 04	 shl	 eax, 4
  00e43	c7 80 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+12], 0

; 717  : 		AxisCount++;

  00e4d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00e52	83 c0 01	 add	 eax, 1
  00e55	a3 00 00 00 00	 mov	 DWORD PTR ?AxisCount@@3HA, eax ; AxisCount
$LN27@enumerate_:

; 718  : 		// Retro 10Jul2004 end
; 719  : 	}
; 720  : 
; 721  : 	//
; 722  : 	// Initialise the Slider0 axis (if there is one)
; 723  : 	//
; 724  : 
; 725  : 	di_err = IDirectInputDevice7_GetObjectInfo (device, &device_part, DIJOFS_SLIDER(0), DIPH_BYOFFSET);

  00e5a	6a 01		 push	 1
  00e5c	6a 18		 push	 24			; 00000018H
  00e5e	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp]
  00e64	50		 push	 eax
  00e65	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00e68	8b 11		 mov	 edx, DWORD PTR [ecx]
  00e6a	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00e6d	50		 push	 eax
  00e6e	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00e71	ff d1		 call	 ecx
  00e73	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 726  : 
; 727  : 	if (di_err == DI_OK)

  00e76	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  00e7a	0f 85 72 01 00
	00		 jne	 $LN30@enumerate_

; 728  : 	{
; 729  : #if 0	// Retro 12Dez2004
; 730  : 		device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);
; 731  : #else
; 732  : 		if ( TRUE == axis_has_deadzone (number_of_joystick_devices, 6))

  00e80	6a 06		 push	 6
  00e82	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  00e87	50		 push	 eax
  00e88	e8 00 00 00 00	 call	 ?axis_has_deadzone@@YGHHH@Z ; axis_has_deadzone
  00e8d	83 f8 01	 cmp	 eax, 1
  00e90	75 09		 jne	 SHORT $LN31@enumerate_

; 733  : 			device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);

  00e92	c7 45 dc d0 07
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 2000 ; 000007d0H

; 734  : 		else

  00e99	eb 07		 jmp	 SHORT $LN32@enumerate_
$LN31@enumerate_:

; 735  : 			device_property.dwData = 0;

  00e9b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 0
$LN32@enumerate_:

; 736  : #endif
; 737  : 		joystick_devices[number_of_joystick_devices].joystick_slider0axis_valid = TRUE;

  00ea2	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00eac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00eb2	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00eb6	83 ca 40	 or	 edx, 64			; 00000040H
  00eb9	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  00ec3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00ec9	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 738  : 
; 739  : 		device_range.diph.dwObj = DIJOFS_SLIDER(0);

  00ecd	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR _device_range$[ebp+8], 24 ; 00000018H

; 740  : 		device_property.diph.dwObj = DIJOFS_SLIDER(0);

  00ed4	c7 45 d4 18 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+8], 24 ; 00000018H

; 741  : 	
; 742  : 		IDirectInputDevice7_SetProperty (device, DIPROP_RANGE, &device_range.diph);

  00edb	8d 45 e0	 lea	 eax, DWORD PTR _device_range$[ebp]
  00ede	50		 push	 eax
  00edf	6a 04		 push	 4
  00ee1	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00ee4	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ee6	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00ee9	50		 push	 eax
  00eea	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00eed	ff d1		 call	 ecx

; 743  : 		IDirectInputDevice7_SetProperty (device, DIPROP_DEADZONE, &device_property.diph);

  00eef	8d 45 cc	 lea	 eax, DWORD PTR _device_property$[ebp]
  00ef2	50		 push	 eax
  00ef3	6a 05		 push	 5
  00ef5	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  00ef8	8b 11		 mov	 edx, DWORD PTR [ecx]
  00efa	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  00efd	50		 push	 eax
  00efe	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00f01	ff d1		 call	 ecx

; 744  : 
; 745  : 		// Retro 10Jul2004 start
; 746  : 		AxisInfo[AxisCount].axis = 6;

  00f03	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00f08	c1 e0 04	 shl	 eax, 4
  00f0b	c7 80 08 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+8], 6

; 747  : 		AxisInfo[AxisCount].device = number_of_joystick_devices;

  00f15	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00f1a	c1 e0 04	 shl	 eax, 4
  00f1d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  00f23	89 88 04 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+4], ecx

; 748  : 		AxisInfo[AxisCount].AxisName = (char*) malloc(strlen(device_instance->tszProductName)+strlen(": ")+strlen(device_part.tszName)+1);

  00f29	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  00f2c	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00f31	50		 push	 eax
  00f32	e8 00 00 00 00	 call	 _strlen
  00f37	83 c4 04	 add	 esp, 4
  00f3a	8b f0		 mov	 esi, eax
  00f3c	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  00f41	e8 00 00 00 00	 call	 _strlen
  00f46	83 c4 04	 add	 esp, 4
  00f49	03 f0		 add	 esi, eax
  00f4b	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _device_part$[ebp+32]
  00f51	51		 push	 ecx
  00f52	e8 00 00 00 00	 call	 _strlen
  00f57	83 c4 04	 add	 esp, 4
  00f5a	8d 54 06 01	 lea	 edx, DWORD PTR [esi+eax+1]
  00f5e	52		 push	 edx
  00f5f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00f65	83 c4 04	 add	 esp, 4
  00f68	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00f6e	c1 e1 04	 shl	 ecx, 4
  00f71	89 81 00 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx], eax

; 749  : 		strcpy(AxisInfo[AxisCount].AxisName,device_instance->tszProductName);

  00f77	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  00f7a	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00f7f	50		 push	 eax
  00f80	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00f86	c1 e1 04	 shl	 ecx, 4
  00f89	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  00f8f	52		 push	 edx
  00f90	e8 00 00 00 00	 call	 _strcpy
  00f95	83 c4 08	 add	 esp, 8

; 750  : 		strcat(AxisInfo[AxisCount].AxisName,": ");

  00f98	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  00f9d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00fa2	c1 e0 04	 shl	 eax, 4
  00fa5	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax]
  00fab	51		 push	 ecx
  00fac	e8 00 00 00 00	 call	 _strcat
  00fb1	83 c4 08	 add	 esp, 8

; 751  : 		strcat(AxisInfo[AxisCount].AxisName,device_part.tszName);

  00fb4	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp+32]
  00fba	50		 push	 eax
  00fbb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00fc1	c1 e1 04	 shl	 ecx, 4
  00fc4	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  00fca	52		 push	 edx
  00fcb	e8 00 00 00 00	 call	 _strcat
  00fd0	83 c4 08	 add	 esp, 8

; 752  : 		AxisInfo[AxisCount].inUse = FALSE;

  00fd3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00fd8	c1 e0 04	 shl	 eax, 4
  00fdb	c7 80 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+12], 0

; 753  : 		AxisCount++;

  00fe5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00fea	83 c0 01	 add	 eax, 1
  00fed	a3 00 00 00 00	 mov	 DWORD PTR ?AxisCount@@3HA, eax ; AxisCount
$LN30@enumerate_:

; 754  : 		// Retro 10Jul2004 end
; 755  : 	}
; 756  : 
; 757  : 	//
; 758  : 	// Initialise the Slider1 axis (if there is one)
; 759  : 	//
; 760  : 
; 761  : 	di_err = IDirectInputDevice7_GetObjectInfo (device, &device_part, DIJOFS_SLIDER(1), DIPH_BYOFFSET);

  00ff2	6a 01		 push	 1
  00ff4	6a 1c		 push	 28			; 0000001cH
  00ff6	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp]
  00ffc	50		 push	 eax
  00ffd	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  01000	8b 11		 mov	 edx, DWORD PTR [ecx]
  01002	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  01005	50		 push	 eax
  01006	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  01009	ff d1		 call	 ecx
  0100b	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 762  : 
; 763  : 	if (di_err == DI_OK)

  0100e	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  01012	0f 85 75 01 00
	00		 jne	 $LN33@enumerate_

; 764  : 	{
; 765  : #if 0	// Retro 12Dez2004
; 766  : 		device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);
; 767  : #else
; 768  : 		if ( TRUE == axis_has_deadzone (number_of_joystick_devices, 7))

  01018	6a 07		 push	 7
  0101a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  0101f	50		 push	 eax
  01020	e8 00 00 00 00	 call	 ?axis_has_deadzone@@YGHHH@Z ; axis_has_deadzone
  01025	83 f8 01	 cmp	 eax, 1
  01028	75 09		 jne	 SHORT $LN34@enumerate_

; 769  : 			device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);

  0102a	c7 45 dc d0 07
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 2000 ; 000007d0H

; 770  : 		else

  01031	eb 07		 jmp	 SHORT $LN35@enumerate_
$LN34@enumerate_:

; 771  : 			device_property.dwData = 0;

  01033	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+16], 0
$LN35@enumerate_:

; 772  : #endif
; 773  : 		joystick_devices[number_of_joystick_devices].joystick_slider1axis_valid = TRUE;

  0103a	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  01044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0104a	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  0104e	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  01054	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  0105e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  01064	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 774  : 
; 775  : 		device_range.diph.dwObj = DIJOFS_SLIDER(1);

  01068	c7 45 e8 1c 00
	00 00		 mov	 DWORD PTR _device_range$[ebp+8], 28 ; 0000001cH

; 776  : 		device_property.diph.dwObj = DIJOFS_SLIDER(1);

  0106f	c7 45 d4 1c 00
	00 00		 mov	 DWORD PTR _device_property$[ebp+8], 28 ; 0000001cH

; 777  : 	
; 778  : 		IDirectInputDevice7_SetProperty (device, DIPROP_RANGE, &device_range.diph);

  01076	8d 45 e0	 lea	 eax, DWORD PTR _device_range$[ebp]
  01079	50		 push	 eax
  0107a	6a 04		 push	 4
  0107c	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  0107f	8b 11		 mov	 edx, DWORD PTR [ecx]
  01081	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  01084	50		 push	 eax
  01085	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  01088	ff d1		 call	 ecx

; 779  : 		IDirectInputDevice7_SetProperty (device, DIPROP_DEADZONE, &device_property.diph);

  0108a	8d 45 cc	 lea	 eax, DWORD PTR _device_property$[ebp]
  0108d	50		 push	 eax
  0108e	6a 05		 push	 5
  01090	8b 4d f8	 mov	 ecx, DWORD PTR _device$[ebp]
  01093	8b 11		 mov	 edx, DWORD PTR [ecx]
  01095	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  01098	50		 push	 eax
  01099	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  0109c	ff d1		 call	 ecx

; 780  : 
; 781  : 		// Retro 10Jul2004 start
; 782  : 		AxisInfo[AxisCount].axis = 7;

  0109e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  010a3	c1 e0 04	 shl	 eax, 4
  010a6	c7 80 08 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+8], 7

; 783  : 		AxisInfo[AxisCount].device = number_of_joystick_devices;

  010b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  010b5	c1 e0 04	 shl	 eax, 4
  010b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  010be	89 88 04 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+4], ecx

; 784  : 		AxisInfo[AxisCount].AxisName = (char*) malloc(strlen(device_instance->tszProductName)+strlen(": ")+strlen(device_part.tszName)+1);

  010c4	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  010c7	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  010cc	50		 push	 eax
  010cd	e8 00 00 00 00	 call	 _strlen
  010d2	83 c4 04	 add	 esp, 4
  010d5	8b f0		 mov	 esi, eax
  010d7	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  010dc	e8 00 00 00 00	 call	 _strlen
  010e1	83 c4 04	 add	 esp, 4
  010e4	03 f0		 add	 esi, eax
  010e6	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _device_part$[ebp+32]
  010ec	51		 push	 ecx
  010ed	e8 00 00 00 00	 call	 _strlen
  010f2	83 c4 04	 add	 esp, 4
  010f5	8d 54 06 01	 lea	 edx, DWORD PTR [esi+eax+1]
  010f9	52		 push	 edx
  010fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  01100	83 c4 04	 add	 esp, 4
  01103	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  01109	c1 e1 04	 shl	 ecx, 4
  0110c	89 81 00 00 00
	00		 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx], eax

; 785  : 		strcpy(AxisInfo[AxisCount].AxisName,device_instance->tszProductName);

  01112	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  01115	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  0111a	50		 push	 eax
  0111b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  01121	c1 e1 04	 shl	 ecx, 4
  01124	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  0112a	52		 push	 edx
  0112b	e8 00 00 00 00	 call	 _strcpy
  01130	83 c4 08	 add	 esp, 8

; 786  : 		strcat(AxisInfo[AxisCount].AxisName,": ");

  01133	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  01138	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  0113d	c1 e0 04	 shl	 eax, 4
  01140	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax]
  01146	51		 push	 ecx
  01147	e8 00 00 00 00	 call	 _strcat
  0114c	83 c4 08	 add	 esp, 8

; 787  : 		strcat(AxisInfo[AxisCount].AxisName,device_part.tszName);

  0114f	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _device_part$[ebp+32]
  01155	50		 push	 eax
  01156	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AxisCount@@3HA ; AxisCount
  0115c	c1 e1 04	 shl	 ecx, 4
  0115f	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[ecx]
  01165	52		 push	 edx
  01166	e8 00 00 00 00	 call	 _strcat
  0116b	83 c4 08	 add	 esp, 8

; 788  : 		AxisInfo[AxisCount].inUse = FALSE;

  0116e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  01173	c1 e0 04	 shl	 eax, 4
  01176	c7 80 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+12], 0

; 789  : 		AxisCount++;

  01180	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  01185	83 c0 01	 add	 eax, 1
  01188	a3 00 00 00 00	 mov	 DWORD PTR ?AxisCount@@3HA, eax ; AxisCount
$LN33@enumerate_:

; 790  : 		// Retro 10Jul2004 end
; 791  : 	}
; 792  : 
; 793  : 	//
; 794  : 	// Parse the capabilities
; 795  : 	//
; 796  : 
; 797  : 	joystick_devices[number_of_joystick_devices].number_of_buttons = device_capabilities.dwButtons;

  0118d	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  01197	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0119d	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _device_capabilities$[ebp+16]
  011a3	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx

; 798  : 
; 799  : 	//
; 800  : 	// Acquire the joystick
; 801  : 	//
; 802  : 
; 803  : 	di_err = IDirectInputDevice7_Acquire (device);

  011a7	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  011aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  011ac	8b 55 f8	 mov	 edx, DWORD PTR _device$[ebp]
  011af	52		 push	 edx
  011b0	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  011b3	ff d0		 call	 eax
  011b5	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 804  : 
; 805  : 	if (di_err != DI_OK)

  011b8	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  011bc	74 18		 je	 SHORT $LN36@enumerate_

; 806  : 	{
; 807  : 
; 808  : 		//
; 809  : 		// Failed to acquire the device - release it.
; 810  : 		//
; 811  : 
; 812  : //		debug_log ("Unable to acquire the device for a joystick");
; 813  : 
; 814  : 		IDirectInputDevice7_Release (device);

  011be	8b 45 f8	 mov	 eax, DWORD PTR _device$[ebp]
  011c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  011c3	8b 55 f8	 mov	 edx, DWORD PTR _device$[ebp]
  011c6	52		 push	 edx
  011c7	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  011ca	ff d0		 call	 eax

; 815  : 
; 816  : 		return (DIENUM_CONTINUE);

  011cc	b8 01 00 00 00	 mov	 eax, 1
  011d1	e9 60 01 00 00	 jmp	 $LN1@enumerate_
$LN36@enumerate_:

; 817  : 	}
; 818  : 
; 819  : 	//
; 820  : 	// Store this device in the array
; 821  : 	//
; 822  : 
; 823  : 	joystick_devices[number_of_joystick_devices].input_device = device;

  011d6	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  011e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  011e6	8b 55 f8	 mov	 edx, DWORD PTR _device$[ebp]
  011e9	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 824  : 	joystick_devices[number_of_joystick_devices].input_effect = device2_effect;

  011ec	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  011f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  011fc	8b 95 60 fe ff
	ff		 mov	 edx, DWORD PTR _device2_effect$[ebp]
  01202	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx

; 825  : 	joystick_devices[number_of_joystick_devices].joystick_supports_force_feedback = FALSE;

  01206	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  01210	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  01216	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  0121a	81 e2 ff fe ff
	ff		 and	 edx, -257		; fffffeffH
  01220	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  0122a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  01230	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 826  : 	joystick_devices[number_of_joystick_devices].joystick_has_pov = FALSE;

  01234	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  0123e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  01244	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  01248	81 e2 ff fd ff
	ff		 and	 edx, -513		; fffffdffH
  0124e	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  01258	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0125e	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 827  : 
; 828  : 	if (device_capabilities.dwFlags & DIDC_FORCEFEEDBACK)

  01262	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _device_capabilities$[ebp+4]
  01268	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0126d	74 2e		 je	 SHORT $LN37@enumerate_

; 829  : 	{
; 830  : 
; 831  : 		joystick_devices[number_of_joystick_devices].joystick_supports_force_feedback = TRUE;

  0126f	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  01279	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0127f	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  01283	81 ca 00 01 00
	00		 or	 edx, 256		; 00000100H
  01289	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  01293	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  01299	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx
$LN37@enumerate_:

; 832  : 	}
; 833  : 
; 834  : 	if (device_capabilities.dwPOVs > 0)

  0129d	83 bd 78 fe ff
	ff 00		 cmp	 DWORD PTR _device_capabilities$[ebp+20], 0
  012a4	76 2e		 jbe	 SHORT $LN38@enumerate_

; 835  : 	{
; 836  : 
; 837  : 		joystick_devices[number_of_joystick_devices].joystick_has_pov = TRUE;

  012a6	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  012b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  012b6	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  012ba	81 ca 00 02 00
	00		 or	 edx, 512		; 00000200H
  012c0	69 05 00 00 00
	00 b0 08 00 00	 imul	 eax, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  012ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  012d0	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx
$LN38@enumerate_:

; 838  : 	}
; 839  : 
; 840  : 	//
; 841  : 	// Copy the name of the device
; 842  : 	//
; 843  : 
; 844  : 	strcpy (joystick_devices[number_of_joystick_devices].device_name, device_instance->tszInstanceName);

  012d4	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  012d7	83 c0 28	 add	 eax, 40			; 00000028H
  012da	50		 push	 eax
  012db	69 0d 00 00 00
	00 b0 08 00 00	 imul	 ecx, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  012e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  012eb	8d 84 0a b0 00
	00 00		 lea	 eax, DWORD PTR [edx+ecx+176]
  012f2	50		 push	 eax
  012f3	e8 00 00 00 00	 call	 _strcpy
  012f8	83 c4 08	 add	 esp, 8

; 845  : 
; 846  : 	strcpy (joystick_devices[number_of_joystick_devices].device_product_name, device_instance->tszProductName);

  012fb	8b 45 08	 mov	 eax, DWORD PTR _device_instance$[ebp]
  012fe	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  01303	50		 push	 eax
  01304	69 0d 00 00 00
	00 b0 08 00 00	 imul	 ecx, DWORD PTR ?number_of_joystick_devices@@3HA, 2224 ; number_of_joystick_devices
  0130e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  01314	8d 84 0a b0 04
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1200]
  0131b	50		 push	 eax
  0131c	e8 00 00 00 00	 call	 _strcpy
  01321	83 c4 08	 add	 esp, 8

; 847  : 
; 848  : #if DEBUG_MODULE
; 849  : 
; 850  : 	debug_log ("Got joystick device %s, %s", device_instance->tszInstanceName, device_instance->tszProductName);
; 851  : 
; 852  : #endif
; 853  : 
; 854  : 	number_of_joystick_devices++;

  01324	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  01329	83 c0 01	 add	 eax, 1
  0132c	a3 00 00 00 00	 mov	 DWORD PTR ?number_of_joystick_devices@@3HA, eax ; number_of_joystick_devices

; 855  : 
; 856  : 	return (DIENUM_CONTINUE);

  01331	b8 01 00 00 00	 mov	 eax, 1
$LN1@enumerate_:

; 857  : }

  01336	5f		 pop	 edi
  01337	5e		 pop	 esi
  01338	5b		 pop	 ebx
  01339	8b e5		 mov	 esp, ebp
  0133b	5d		 pop	 ebp
  0133c	c2 08 00	 ret	 8
?enumerate_joystick_devices@@YGHPBUDIDEVICEINSTANCEA@@PAX@Z ENDP ; enumerate_joystick_devices
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\joystick.c
;	COMDAT ?change_joystick_properties@@YGXXZ
_TEXT	SEGMENT
_numOffsets$ = -392					; size = 4
_offsets$ = -388					; size = 32
_device_property$ = -356				; size = 20
_device_part$ = -336					; size = 316
_device$ = -20						; size = 4
_di_err$ = -16						; size = 4
_axisCount$ = -12					; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
?change_joystick_properties@@YGXXZ PROC			; change_joystick_properties, COMDAT

; 867  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 01 00
	00		 sub	 esp, 456		; 000001c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 868  : 	int
; 869  : 		i, j, axisCount;
; 870  : 
; 871  : 	HRESULT
; 872  : 		di_err;
; 873  : 
; 874  : 	LPDIRECTINPUTDEVICE7
; 875  : 		device;
; 876  : 
; 877  : 	DIDEVICEOBJECTINSTANCE
; 878  : 		device_part;
; 879  : 
; 880  : 	DIPROPDWORD
; 881  : 		device_property;
; 882  : 
; 883  : 	int offsets[] = { DIJOFS_X, DIJOFS_Y, DIJOFS_Z, DIJOFS_RX, DIJOFS_RY, DIJOFS_RZ, DIJOFS_SLIDER(0), DIJOFS_SLIDER(1) };

  0000c	c7 85 7c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _offsets$[ebp], 0
  00016	c7 85 80 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR _offsets$[ebp+4], 4
  00020	c7 85 84 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR _offsets$[ebp+8], 8
  0002a	c7 85 88 fe ff
	ff 0c 00 00 00	 mov	 DWORD PTR _offsets$[ebp+12], 12 ; 0000000cH
  00034	c7 85 8c fe ff
	ff 10 00 00 00	 mov	 DWORD PTR _offsets$[ebp+16], 16 ; 00000010H
  0003e	c7 85 90 fe ff
	ff 14 00 00 00	 mov	 DWORD PTR _offsets$[ebp+20], 20 ; 00000014H
  00048	c7 85 94 fe ff
	ff 18 00 00 00	 mov	 DWORD PTR _offsets$[ebp+24], 24 ; 00000018H
  00052	c7 85 98 fe ff
	ff 1c 00 00 00	 mov	 DWORD PTR _offsets$[ebp+28], 28 ; 0000001cH

; 884  : 	const int numOffsets = sizeof(offsets)/sizeof(offsets[0]);

  0005c	c7 85 78 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR _numOffsets$[ebp], 8

; 885  : 
; 886  : 	//
; 887  : 	// Initialise the device part for the next lot of queries
; 888  : 	//
; 889  : 
; 890  : 	device_part.dwSize = sizeof (DIDEVICEOBJECTINSTANCE);

  00066	c7 85 b0 fe ff
	ff 3c 01 00 00	 mov	 DWORD PTR _device_part$[ebp], 316 ; 0000013cH

; 891  : 
; 892  : 	//
; 893  : 	// Set the dead zones for all the axis to be the same (for now).
; 894  : 	// Note: when setting the deadzone, units are specified in the thousandths, so 20% = 2000/10000
; 895  : 	//
; 896  : 
; 897  : 	device_property.diph.dwSize = sizeof (device_property);

  00070	c7 85 9c fe ff
	ff 14 00 00 00	 mov	 DWORD PTR _device_property$[ebp], 20 ; 00000014H

; 898  : 	device_property.diph.dwHeaderSize = sizeof(device_property.diph);

  0007a	c7 85 a0 fe ff
	ff 10 00 00 00	 mov	 DWORD PTR _device_property$[ebp+4], 16 ; 00000010H

; 899  : 	device_property.diph.dwHow = DIPH_BYOFFSET;

  00084	c7 85 a8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _device_property$[ebp+12], 1

; 900  : 	device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);

  0008e	c7 85 ac fe ff
	ff d0 07 00 00	 mov	 DWORD PTR _device_property$[ebp+16], 2000 ; 000007d0H

; 901  : 
; 902  : 	axisCount = 0;

  00098	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _axisCount$[ebp], 0

; 903  : 
; 904  : 	for (i = 0; i < number_of_joystick_devices; i++)

  0009f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000a6	eb 09		 jmp	 SHORT $LN4@change_joy
$LN2@change_joy:
  000a8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ab	83 c0 01	 add	 eax, 1
  000ae	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@change_joy:
  000b1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  000ba	0f 8d bc 00 00
	00		 jge	 $LN1@change_joy

; 905  : 	{
; 906  : 		device = joystick_devices[i].input_device;

  000c0	69 45 fc b0 08
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 2224
  000c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  000cd	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000d0	89 55 ec	 mov	 DWORD PTR _device$[ebp], edx

; 907  : 
; 908  : 		for (j = 0; j < numOffsets; j++)

  000d3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000da	eb 09		 jmp	 SHORT $LN7@change_joy
$LN5@change_joy:
  000dc	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  000df	83 c0 01	 add	 eax, 1
  000e2	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN7@change_joy:
  000e5	83 7d f8 08	 cmp	 DWORD PTR _j$[ebp], 8
  000e9	0f 8d 88 00 00
	00		 jge	 $LN6@change_joy

; 909  : 		{
; 910  : 			//
; 911  : 			// Check if there is an axis with the given offset, if yes then look if it should have a deadzone and apply
; 912  : 			//
; 913  : 
; 914  : 			di_err = IDirectInputDevice7_GetObjectInfo (device, &device_part, offsets[j], DIPH_BYOFFSET);

  000ef	6a 01		 push	 1
  000f1	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  000f4	8b 8c 85 7c fe
	ff ff		 mov	 ecx, DWORD PTR _offsets$[ebp+eax*4]
  000fb	51		 push	 ecx
  000fc	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR _device_part$[ebp]
  00102	52		 push	 edx
  00103	8b 45 ec	 mov	 eax, DWORD PTR _device$[ebp]
  00106	8b 08		 mov	 ecx, DWORD PTR [eax]
  00108	8b 55 ec	 mov	 edx, DWORD PTR _device$[ebp]
  0010b	52		 push	 edx
  0010c	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  0010f	ff d0		 call	 eax
  00111	89 45 f0	 mov	 DWORD PTR _di_err$[ebp], eax

; 915  : 
; 916  : 			if (di_err == DI_OK)

  00114	83 7d f0 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  00118	75 58		 jne	 SHORT $LN8@change_joy

; 917  : 			{
; 918  : 				if ( TRUE == axis_has_deadzone (i, j))

  0011a	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0011d	50		 push	 eax
  0011e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00121	51		 push	 ecx
  00122	e8 00 00 00 00	 call	 ?axis_has_deadzone@@YGHHH@Z ; axis_has_deadzone
  00127	83 f8 01	 cmp	 eax, 1
  0012a	75 0c		 jne	 SHORT $LN9@change_joy

; 919  : 					device_property.dwData = (int) (JOYSTICK_AXIS_DEADZONE * 10000.0);

  0012c	c7 85 ac fe ff
	ff d0 07 00 00	 mov	 DWORD PTR _device_property$[ebp+16], 2000 ; 000007d0H

; 920  : 				else

  00136	eb 0a		 jmp	 SHORT $LN10@change_joy
$LN9@change_joy:

; 921  : 					device_property.dwData = 0;

  00138	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _device_property$[ebp+16], 0
$LN10@change_joy:

; 922  : 
; 923  : 				device_property.diph.dwObj = offsets[j];

  00142	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00145	8b 8c 85 7c fe
	ff ff		 mov	 ecx, DWORD PTR _offsets$[ebp+eax*4]
  0014c	89 8d a4 fe ff
	ff		 mov	 DWORD PTR _device_property$[ebp+8], ecx

; 924  : 				IDirectInputDevice7_SetProperty (device, DIPROP_DEADZONE, &device_property.diph);

  00152	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _device_property$[ebp]
  00158	50		 push	 eax
  00159	6a 05		 push	 5
  0015b	8b 4d ec	 mov	 ecx, DWORD PTR _device$[ebp]
  0015e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00160	8b 45 ec	 mov	 eax, DWORD PTR _device$[ebp]
  00163	50		 push	 eax
  00164	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00167	ff d1		 call	 ecx

; 925  : 
; 926  : 				axisCount++;

  00169	8b 45 f4	 mov	 eax, DWORD PTR _axisCount$[ebp]
  0016c	83 c0 01	 add	 eax, 1
  0016f	89 45 f4	 mov	 DWORD PTR _axisCount$[ebp], eax
$LN8@change_joy:

; 927  : 			}
; 928  : 		}

  00172	e9 65 ff ff ff	 jmp	 $LN5@change_joy
$LN6@change_joy:

; 929  : 	}

  00177	e9 2c ff ff ff	 jmp	 $LN2@change_joy
$LN1@change_joy:

; 930  : 	
; 931  : }

  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c3		 ret	 0
?change_joystick_properties@@YGXXZ ENDP			; change_joystick_properties
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\joystick.c
;	COMDAT ?GetGUIDString@@YGXHPAD@Z
_TEXT	SEGMENT
_i$ = -1104						; size = 4
_strTemp2$ = -1100					; size = 260
_strTemp$ = -840					; size = 260
_devInst$ = -580					; size = 580
_iDevice$ = 8						; size = 4
_theString$ = 12					; size = 4
?GetGUIDString@@YGXHPAD@Z PROC				; GetGUIDString, COMDAT

; 1461 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 05 00
	00		 sub	 esp, 1296		; 00000510H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1462 : #ifdef WIN32
; 1463 : 	DIDEVICEINSTANCE devInst;
; 1464 : 	char strTemp[MAX_PATH];
; 1465 : 	char strTemp2[MAX_PATH];
; 1466 : 	int i;
; 1467 : 
; 1468 : 	if ((iDevice < 0)||(iDevice >= number_of_joystick_devices))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iDevice$[ebp], 0
  00010	7c 0b		 jl	 SHORT $LN9@GetGUIDStr
  00012	8b 45 08	 mov	 eax, DWORD PTR _iDevice$[ebp]
  00015	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  0001b	7c 05		 jl	 SHORT $LN8@GetGUIDStr
$LN9@GetGUIDStr:

; 1469 : 		return;

  0001d	e9 68 01 00 00	 jmp	 $LN1@GetGUIDStr
$LN8@GetGUIDStr:

; 1470 : 
; 1471 : 	if (!theString)

  00022	83 7d 0c 00	 cmp	 DWORD PTR _theString$[ebp], 0
  00026	75 05		 jne	 SHORT $LN10@GetGUIDStr

; 1472 : 		return;

  00028	e9 5d 01 00 00	 jmp	 $LN1@GetGUIDStr
$LN10@GetGUIDStr:

; 1473 : 
; 1474 : 	devInst.dwSize = sizeof(DIDEVICEINSTANCE);

  0002d	c7 85 bc fd ff
	ff 44 02 00 00	 mov	 DWORD PTR _devInst$[ebp], 580 ; 00000244H

; 1475 : 	IDirectInputDevice7_GetDeviceInfo(joystick_devices[iDevice].input_device, &devInst);

  00037	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _devInst$[ebp]
  0003d	50		 push	 eax
  0003e	69 4d 08 b0 08
	00 00		 imul	 ecx, DWORD PTR _iDevice$[ebp], 2224
  00045	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0004b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0004e	69 4d 08 b0 08
	00 00		 imul	 ecx, DWORD PTR _iDevice$[ebp], 2224
  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0005b	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  0005e	8b 10		 mov	 edx, DWORD PTR [eax]
  00060	51		 push	 ecx
  00061	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00064	ff d0		 call	 eax

; 1476 : 
; 1477 : 	sprintf(strTemp,"{%8.8X-%4.4X-%4.4X-",	devInst.guidProduct.Data1,

  00066	0f b7 85 d6 fd
	ff ff		 movzx	 eax, WORD PTR _devInst$[ebp+26]
  0006d	50		 push	 eax
  0006e	0f b7 8d d4 fd
	ff ff		 movzx	 ecx, WORD PTR _devInst$[ebp+24]
  00075	51		 push	 ecx
  00076	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR _devInst$[ebp+20]
  0007c	52		 push	 edx
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@EBAEEKFN@?$HL?$CF8?48X?9?$CF4?44X?9?$CF4?44X?9@
  00082	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _strTemp$[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _sprintf
  0008e	83 c4 14	 add	 esp, 20			; 00000014H

; 1478 : 											devInst.guidProduct.Data2,
; 1479 : 											devInst.guidProduct.Data3);
; 1480 : 
; 1481 : 	for (i = 0; i < 2; i++)

  00091	c7 85 b0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0009b	eb 0f		 jmp	 SHORT $LN4@GetGUIDStr
$LN2@GetGUIDStr:
  0009d	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000a3	83 c0 01	 add	 eax, 1
  000a6	89 85 b0 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@GetGUIDStr:
  000ac	83 bd b0 fb ff
	ff 02		 cmp	 DWORD PTR _i$[ebp], 2
  000b3	7d 3b		 jge	 SHORT $LN3@GetGUIDStr

; 1482 : 	{
; 1483 : 		sprintf(strTemp2,"%2.2X",devInst.guidProduct.Data4[i]);

  000b5	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000bb	0f b6 8c 05 d8
	fd ff ff	 movzx	 ecx, BYTE PTR _devInst$[ebp+eax+28]
  000c3	51		 push	 ecx
  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_05NHNNBPJA@?$CF2?42X@
  000c9	8d 95 b4 fb ff
	ff		 lea	 edx, DWORD PTR _strTemp2$[ebp]
  000cf	52		 push	 edx
  000d0	e8 00 00 00 00	 call	 _sprintf
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1484 : 		strcat(strTemp,strTemp2);

  000d8	8d 85 b4 fb ff
	ff		 lea	 eax, DWORD PTR _strTemp2$[ebp]
  000de	50		 push	 eax
  000df	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR _strTemp$[ebp]
  000e5	51		 push	 ecx
  000e6	e8 00 00 00 00	 call	 _strcat
  000eb	83 c4 08	 add	 esp, 8

; 1485 : 	}

  000ee	eb ad		 jmp	 SHORT $LN2@GetGUIDStr
$LN3@GetGUIDStr:

; 1486 : 	strcat(strTemp,"-");

  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_01JOAMLHOP@?9@
  000f5	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _strTemp$[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 _strcat
  00101	83 c4 08	 add	 esp, 8

; 1487 : 	for (i = 2; i < 8; i++)

  00104	c7 85 b0 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR _i$[ebp], 2
  0010e	eb 0f		 jmp	 SHORT $LN7@GetGUIDStr
$LN5@GetGUIDStr:
  00110	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00116	83 c0 01	 add	 eax, 1
  00119	89 85 b0 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN7@GetGUIDStr:
  0011f	83 bd b0 fb ff
	ff 08		 cmp	 DWORD PTR _i$[ebp], 8
  00126	7d 3b		 jge	 SHORT $LN6@GetGUIDStr

; 1488 : 	{
; 1489 : 		sprintf(strTemp2,"%2.2X",devInst.guidProduct.Data4[i]);

  00128	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0012e	0f b6 8c 05 d8
	fd ff ff	 movzx	 ecx, BYTE PTR _devInst$[ebp+eax+28]
  00136	51		 push	 ecx
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_05NHNNBPJA@?$CF2?42X@
  0013c	8d 95 b4 fb ff
	ff		 lea	 edx, DWORD PTR _strTemp2$[ebp]
  00142	52		 push	 edx
  00143	e8 00 00 00 00	 call	 _sprintf
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1490 : 		strcat(strTemp,strTemp2);

  0014b	8d 85 b4 fb ff
	ff		 lea	 eax, DWORD PTR _strTemp2$[ebp]
  00151	50		 push	 eax
  00152	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR _strTemp$[ebp]
  00158	51		 push	 ecx
  00159	e8 00 00 00 00	 call	 _strcat
  0015e	83 c4 08	 add	 esp, 8

; 1491 : 	}

  00161	eb ad		 jmp	 SHORT $LN5@GetGUIDStr
$LN6@GetGUIDStr:

; 1492 : 	strcat(strTemp,"}");

  00163	68 00 00 00 00	 push	 OFFSET ??_C@_01CELHOKLL@?$HN@
  00168	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _strTemp$[ebp]
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 _strcat
  00174	83 c4 08	 add	 esp, 8

; 1493 : 
; 1494 : 	strcpy(theString,strTemp);

  00177	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _strTemp$[ebp]
  0017d	50		 push	 eax
  0017e	8b 4d 0c	 mov	 ecx, DWORD PTR _theString$[ebp]
  00181	51		 push	 ecx
  00182	e8 00 00 00 00	 call	 _strcpy
  00187	83 c4 08	 add	 esp, 8
$LN1@GetGUIDStr:

; 1495 : #endif
; 1496 : }

  0018a	5f		 pop	 edi
  0018b	5e		 pop	 esi
  0018c	5b		 pop	 ebx
  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c2 08 00	 ret	 8
?GetGUIDString@@YGXHPAD@Z ENDP				; GetGUIDString
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\joystick.c
;	COMDAT ?get_joystick_button@@YGHPAUJOYSTICK_DEVICE_INFO@@H@Z
_TEXT	SEGMENT
_stick$ = 8						; size = 4
_index$ = 12						; size = 4
?get_joystick_button@@YGHPAUJOYSTICK_DEVICE_INFO@@H@Z PROC ; get_joystick_button, COMDAT

; 1437 : int get_joystick_button(joystick_device_info *stick, int index) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1438 : 
; 1439 : #ifdef WIN32
; 1440 : 
; 1441 : 	if( index >= 0 && index < 32 )

  00009	83 7d 0c 00	 cmp	 DWORD PTR _index$[ebp], 0
  0000d	7c 17		 jl	 SHORT $LN2@get_joysti
  0000f	83 7d 0c 20	 cmp	 DWORD PTR _index$[ebp], 32 ; 00000020H
  00013	7d 11		 jge	 SHORT $LN2@get_joysti

; 1442 : 		return stick->joystick_state.rgbButtons[ index ];

  00015	8b 45 08	 mov	 eax, DWORD PTR _stick$[ebp]
  00018	03 45 0c	 add	 eax, DWORD PTR _index$[ebp]
  0001b	0f b6 80 90 00
	00 00		 movzx	 eax, BYTE PTR [eax+144]
  00022	eb 04		 jmp	 SHORT $LN1@get_joysti

; 1443 : 
; 1444 : #else
; 1445 : 
; 1446 : 	if( index >= 0 && index < stick->number_of_buttons )
; 1447 : 		return stick->joystick_state.buttons[ index ];
; 1448 : 
; 1449 : #endif
; 1450 : 
; 1451 : 	else

  00024	eb 02		 jmp	 SHORT $LN1@get_joysti
$LN2@get_joysti:

; 1452 : 		return 0;

  00026	33 c0		 xor	 eax, eax
$LN1@get_joysti:

; 1453 : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?get_joystick_button@@YGHPAUJOYSTICK_DEVICE_INFO@@H@Z ENDP ; get_joystick_button
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\joystick.c
;	COMDAT ?get_joystick_hat@@YG?AW4JOYSTICK_HAT_POSITION@@PAUJOYSTICK_DEVICE_INFO@@H@Z
_TEXT	SEGMENT
_pos$ = -4						; size = 4
_stick$ = 8						; size = 4
_index$ = 12						; size = 4
?get_joystick_hat@@YG?AW4JOYSTICK_HAT_POSITION@@PAUJOYSTICK_DEVICE_INFO@@H@Z PROC ; get_joystick_hat, COMDAT

; 1382 : joystick_hat_position get_joystick_hat(joystick_device_info *stick, int index) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1383 : 	// TODO: Add support for diagonal directions
; 1384 : 
; 1385 : #ifdef WIN32
; 1386 : 
; 1387 : 	DWORD
; 1388 : 		pos;
; 1389 : 
; 1390 : 	if( stick->joystick_has_pov && index >= 0 && index < 4 ) {

  00009	8b 45 08	 mov	 eax, DWORD PTR _stick$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	c1 e9 09	 shr	 ecx, 9
  00012	83 e1 01	 and	 ecx, 1
  00015	74 7b		 je	 SHORT $LN2@get_joysti
  00017	83 7d 0c 00	 cmp	 DWORD PTR _index$[ebp], 0
  0001b	7c 75		 jl	 SHORT $LN2@get_joysti
  0001d	83 7d 0c 04	 cmp	 DWORD PTR _index$[ebp], 4
  00021	7d 6f		 jge	 SHORT $LN2@get_joysti

; 1391 : 		pos = stick->joystick_state.rgdwPOV[ index ];

  00023	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _stick$[ebp]
  00029	8b 94 81 80 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+128]
  00030	89 55 fc	 mov	 DWORD PTR _pos$[ebp], edx

; 1392 : 
; 1393 : 		if (LOWORD (pos) == 0xFFFF)

  00033	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  00036	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003b	0f b7 c8	 movzx	 ecx, ax
  0003e	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  00044	75 06		 jne	 SHORT $LN3@get_joysti

; 1394 : 			return HAT_CENTERED;

  00046	33 c0		 xor	 eax, eax
  00048	eb 4a		 jmp	 SHORT $LN1@get_joysti
  0004a	eb 46		 jmp	 SHORT $LN2@get_joysti
$LN3@get_joysti:

; 1395 : 		else if (pos < 45 * DI_DEGREES)

  0004c	81 7d fc 94 11
	00 00		 cmp	 DWORD PTR _pos$[ebp], 4500 ; 00001194H
  00053	73 09		 jae	 SHORT $LN5@get_joysti

; 1396 : 			return HAT_UP;

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	eb 38		 jmp	 SHORT $LN1@get_joysti
  0005c	eb 34		 jmp	 SHORT $LN2@get_joysti
$LN5@get_joysti:

; 1397 : 		else if (pos < 135 * DI_DEGREES)

  0005e	81 7d fc bc 34
	00 00		 cmp	 DWORD PTR _pos$[ebp], 13500 ; 000034bcH
  00065	73 09		 jae	 SHORT $LN7@get_joysti

; 1398 : 			return HAT_RIGHT;

  00067	b8 02 00 00 00	 mov	 eax, 2
  0006c	eb 26		 jmp	 SHORT $LN1@get_joysti
  0006e	eb 22		 jmp	 SHORT $LN2@get_joysti
$LN7@get_joysti:

; 1399 : 		else if (pos < 225 * DI_DEGREES)

  00070	81 7d fc e4 57
	00 00		 cmp	 DWORD PTR _pos$[ebp], 22500 ; 000057e4H
  00077	73 09		 jae	 SHORT $LN9@get_joysti

; 1400 : 			return HAT_DOWN;

  00079	b8 03 00 00 00	 mov	 eax, 3
  0007e	eb 14		 jmp	 SHORT $LN1@get_joysti
  00080	eb 10		 jmp	 SHORT $LN2@get_joysti
$LN9@get_joysti:

; 1401 : 		else if (pos < 315 * DI_DEGREES)

  00082	81 7d fc 0c 7b
	00 00		 cmp	 DWORD PTR _pos$[ebp], 31500 ; 00007b0cH
  00089	73 07		 jae	 SHORT $LN2@get_joysti

; 1402 : 			return HAT_LEFT;

  0008b	b8 04 00 00 00	 mov	 eax, 4
  00090	eb 02		 jmp	 SHORT $LN1@get_joysti
$LN2@get_joysti:

; 1403 : 	}
; 1404 : 
; 1405 : #else
; 1406 : 
; 1407 : 	Uint8
; 1408 : 		pos;
; 1409 : 
; 1410 : 	if( index >= 0 && index < stick->number_of_hats ) {
; 1411 : 		pos = stick->joystick_state.hats[ index ];
; 1412 : 
; 1413 : 		switch( pos ) {
; 1414 : 		case SDL_HAT_UP:
; 1415 : 			return HAT_UP;
; 1416 : 		case SDL_HAT_LEFT:
; 1417 : 			return HAT_LEFT;
; 1418 : 		case SDL_HAT_DOWN:
; 1419 : 			return HAT_DOWN;
; 1420 : 		case SDL_HAT_RIGHT:
; 1421 : 			return HAT_RIGHT;
; 1422 : 		default:
; 1423 : 		case SDL_HAT_CENTERED:
; 1424 : 			return HAT_CENTERED;
; 1425 : 		}			
; 1426 : 	}
; 1427 : #endif
; 1428 : 
; 1429 : 	return HAT_CENTERED;

  00092	33 c0		 xor	 eax, eax
$LN1@get_joysti:

; 1430 : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
?get_joystick_hat@@YG?AW4JOYSTICK_HAT_POSITION@@PAUJOYSTICK_DEVICE_INFO@@H@Z ENDP ; get_joystick_hat
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\joystick.c
;	COMDAT ?get_joystick_axis@@YGHHH@Z
_TEXT	SEGMENT
tv68 = -68						; size = 4
_joystick_index$ = 8					; size = 4
_axis$ = 12						; size = 4
?get_joystick_axis@@YGHHH@Z PROC			; get_joystick_axis, COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1296 : //	read_joystick_values(joystick_index); // Jabberwock 031120 Some joystick values were not read at all!
; 1297 : 
; 1298 : 	// Retro 10Jul2004
; 1299 : 	if ((joystick_index < 0)||(joystick_index > number_of_joystick_devices))

  00009	83 7d 08 00	 cmp	 DWORD PTR _joystick_index$[ebp], 0
  0000d	7c 0b		 jl	 SHORT $LN5@get_joysti
  0000f	8b 45 08	 mov	 eax, DWORD PTR _joystick_index$[ebp]
  00012	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  00018	7e 07		 jle	 SHORT $LN4@get_joysti
$LN5@get_joysti:

; 1300 : 		return 0;

  0001a	33 c0		 xor	 eax, eax
  0001c	e9 c7 01 00 00	 jmp	 $LN1@get_joysti
$LN4@get_joysti:

; 1301 : 	if ((axis < 0)||(axis > 7))

  00021	83 7d 0c 00	 cmp	 DWORD PTR _axis$[ebp], 0
  00025	7c 06		 jl	 SHORT $LN7@get_joysti
  00027	83 7d 0c 07	 cmp	 DWORD PTR _axis$[ebp], 7
  0002b	7e 07		 jle	 SHORT $LN6@get_joysti
$LN7@get_joysti:

; 1302 : 		return 0;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 b4 01 00 00	 jmp	 $LN1@get_joysti
$LN6@get_joysti:

; 1303 : 	// Retro 10Jul2004 end
; 1304 : 
; 1305 : #ifdef WIN32
; 1306 : 	switch (axis) {

  00034	8b 45 0c	 mov	 eax, DWORD PTR _axis$[ebp]
  00037	89 45 bc	 mov	 DWORD PTR tv68[ebp], eax
  0003a	83 7d bc 07	 cmp	 DWORD PTR tv68[ebp], 7
  0003e	0f 87 a2 01 00
	00		 ja	 $LN2@get_joysti
  00044	8b 4d bc	 mov	 ecx, DWORD PTR tv68[ebp]
  00047	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN25@get_joysti[ecx*4]
$LN8@get_joysti:

; 1307 : 	case 0:
; 1308 : 		if (joystick_devices[joystick_index].joystick_xaxis_valid)

  0004e	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0005b	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  0005f	83 e2 01	 and	 edx, 1
  00062	74 16		 je	 SHORT $LN9@get_joysti

; 1309 : 		{
; 1310 : 			return joystick_devices[joystick_index].joystick_state.lX;

  00064	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  0006b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00071	8b 44 01 60	 mov	 eax, DWORD PTR [ecx+eax+96]
  00075	e9 6e 01 00 00	 jmp	 $LN1@get_joysti
$LN9@get_joysti:

; 1311 : 		}
; 1312 : 		break;

  0007a	e9 67 01 00 00	 jmp	 $LN2@get_joysti
$LN10@get_joysti:

; 1313 : 				
; 1314 : 	case 1:
; 1315 : 		if (joystick_devices[joystick_index].joystick_yaxis_valid)

  0007f	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  00086	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0008c	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00090	d1 ea		 shr	 edx, 1
  00092	83 e2 01	 and	 edx, 1
  00095	74 16		 je	 SHORT $LN11@get_joysti

; 1316 : 		{
; 1317 : 			return joystick_devices[joystick_index].joystick_state.lY;

  00097	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  0009e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  000a4	8b 44 01 64	 mov	 eax, DWORD PTR [ecx+eax+100]
  000a8	e9 3b 01 00 00	 jmp	 $LN1@get_joysti
$LN11@get_joysti:

; 1318 : 		}
; 1319 : 		break;

  000ad	e9 34 01 00 00	 jmp	 $LN2@get_joysti
$LN12@get_joysti:

; 1320 : 				
; 1321 : 	case 2:
; 1322 : 		if (joystick_devices[joystick_index].joystick_zaxis_valid)

  000b2	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  000bf	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  000c3	c1 ea 02	 shr	 edx, 2
  000c6	83 e2 01	 and	 edx, 1
  000c9	74 16		 je	 SHORT $LN13@get_joysti

; 1323 : 		{
; 1324 : 			return joystick_devices[joystick_index].joystick_state.lZ;

  000cb	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  000d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  000d8	8b 44 01 68	 mov	 eax, DWORD PTR [ecx+eax+104]
  000dc	e9 07 01 00 00	 jmp	 $LN1@get_joysti
$LN13@get_joysti:

; 1325 : 		}
; 1326 : 		break;

  000e1	e9 00 01 00 00	 jmp	 $LN2@get_joysti
$LN14@get_joysti:

; 1327 : 				
; 1328 : 	case 3:
; 1329 : 		if (joystick_devices[joystick_index].joystick_rxaxis_valid)

  000e6	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  000ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  000f3	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  000f7	c1 ea 03	 shr	 edx, 3
  000fa	83 e2 01	 and	 edx, 1
  000fd	74 16		 je	 SHORT $LN15@get_joysti

; 1330 : 		{
; 1331 : 			return joystick_devices[joystick_index].joystick_state.lRx;

  000ff	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  00106	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0010c	8b 44 01 6c	 mov	 eax, DWORD PTR [ecx+eax+108]
  00110	e9 d3 00 00 00	 jmp	 $LN1@get_joysti
$LN15@get_joysti:

; 1332 : 		}
; 1333 : 		break;

  00115	e9 cc 00 00 00	 jmp	 $LN2@get_joysti
$LN16@get_joysti:

; 1334 : 				
; 1335 : 	case 4:
; 1336 : 		if (joystick_devices[joystick_index].joystick_ryaxis_valid)

  0011a	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  00121	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00127	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  0012b	c1 ea 04	 shr	 edx, 4
  0012e	83 e2 01	 and	 edx, 1
  00131	74 16		 je	 SHORT $LN17@get_joysti

; 1337 : 		{
; 1338 : 			return joystick_devices[joystick_index].joystick_state.lRy;

  00133	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  0013a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00140	8b 44 01 70	 mov	 eax, DWORD PTR [ecx+eax+112]
  00144	e9 9f 00 00 00	 jmp	 $LN1@get_joysti
$LN17@get_joysti:

; 1339 : 		}
; 1340 : 		break;

  00149	e9 98 00 00 00	 jmp	 $LN2@get_joysti
$LN18@get_joysti:

; 1341 : 				
; 1342 : 	case 5:
; 1343 : 		if (joystick_devices[joystick_index].joystick_rzaxis_valid)

  0014e	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  00155	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0015b	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  0015f	c1 ea 05	 shr	 edx, 5
  00162	83 e2 01	 and	 edx, 1
  00165	74 13		 je	 SHORT $LN19@get_joysti

; 1344 : 		{
; 1345 : 			return joystick_devices[joystick_index].joystick_state.lRz;

  00167	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  0016e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00174	8b 44 01 74	 mov	 eax, DWORD PTR [ecx+eax+116]
  00178	eb 6e		 jmp	 SHORT $LN1@get_joysti
$LN19@get_joysti:

; 1346 : 		}
; 1347 : 		break;

  0017a	eb 6a		 jmp	 SHORT $LN2@get_joysti
$LN20@get_joysti:

; 1348 : 
; 1349 : 	case 6:
; 1350 : 		if (joystick_devices[joystick_index].joystick_slider0axis_valid)

  0017c	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  00183	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00189	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  0018d	c1 ea 06	 shr	 edx, 6
  00190	83 e2 01	 and	 edx, 1
  00193	74 1b		 je	 SHORT $LN21@get_joysti

; 1351 : 		{
; 1352 : 			return joystick_devices[joystick_index].joystick_state.rglSlider[0];

  00195	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  0019c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  001a2	b9 04 00 00 00	 mov	 ecx, 4
  001a7	6b d1 00	 imul	 edx, ecx, 0
  001aa	8b 44 10 78	 mov	 eax, DWORD PTR [eax+edx+120]
  001ae	eb 38		 jmp	 SHORT $LN1@get_joysti
$LN21@get_joysti:

; 1353 : 		}
; 1354 : 		break;

  001b0	eb 34		 jmp	 SHORT $LN2@get_joysti
$LN22@get_joysti:

; 1355 : 
; 1356 : 	case 7:
; 1357 : 		if (joystick_devices[joystick_index].joystick_slider1axis_valid)

  001b2	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  001b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  001bf	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  001c3	c1 ea 07	 shr	 edx, 7
  001c6	83 e2 01	 and	 edx, 1
  001c9	74 1b		 je	 SHORT $LN2@get_joysti

; 1358 : 		{
; 1359 : 			return joystick_devices[joystick_index].joystick_state.rglSlider[1];

  001cb	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_index$[ebp], 2224
  001d2	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  001d8	b9 04 00 00 00	 mov	 ecx, 4
  001dd	c1 e1 00	 shl	 ecx, 0
  001e0	8b 44 08 78	 mov	 eax, DWORD PTR [eax+ecx+120]
  001e4	eb 02		 jmp	 SHORT $LN1@get_joysti
$LN2@get_joysti:

; 1360 : 		}
; 1361 : 		break;
; 1362 : 	}
; 1363 : 
; 1364 : #else
; 1365 : 
; 1366 : 	if( joystick_index >= 0 && joystick_index < number_of_joystick_devices
; 1367 : 		  && axis >= 0 && axis < joystick_devices[joystick_index].number_of_axes ) {
; 1368 : 
; 1369 : 		return joystick_devices[joystick_index].joystick_state.axes[ axis ];
; 1370 : 	}
; 1371 : 	
; 1372 : #endif
; 1373 : 
; 1374 : 	return 0;

  001e6	33 c0		 xor	 eax, eax
$LN1@get_joysti:

; 1375 : }

  001e8	5f		 pop	 edi
  001e9	5e		 pop	 esi
  001ea	5b		 pop	 ebx
  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c2 08 00	 ret	 8
  001f1	0f 1f 00	 npad	 3
$LN25@get_joysti:
  001f4	00 00 00 00	 DD	 $LN8@get_joysti
  001f8	00 00 00 00	 DD	 $LN10@get_joysti
  001fc	00 00 00 00	 DD	 $LN12@get_joysti
  00200	00 00 00 00	 DD	 $LN14@get_joysti
  00204	00 00 00 00	 DD	 $LN16@get_joysti
  00208	00 00 00 00	 DD	 $LN18@get_joysti
  0020c	00 00 00 00	 DD	 $LN20@get_joysti
  00210	00 00 00 00	 DD	 $LN22@get_joysti
?get_joystick_axis@@YGHHH@Z ENDP			; get_joystick_axis
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\joystick.c
;	COMDAT ?set_joystick_force_feedback_forces@@YGHHHH@Z
_TEXT	SEGMENT
tv221 = -156						; size = 8
tv219 = -148						; size = 4
tv216 = -142						; size = 2
_effect_flags$ = -76					; size = 4
_effect$ = -72						; size = 56
_constant_force$ = -16					; size = 4
_forces_directions$ = -12				; size = 8
_di_err$ = -4						; size = 4
_joystick_device_index$ = 8				; size = 4
_xforce$ = 12						; size = 4
_yforce$ = 16						; size = 4
?set_joystick_force_feedback_forces@@YGHHHH@Z PROC	; set_joystick_force_feedback_forces, COMDAT

; 1171 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1172 : 
; 1173 : #ifdef WIN32
; 1174 : 	HRESULT
; 1175 : 		di_err;
; 1176 : 	
; 1177 : 	LONG
; 1178 : 		forces_directions[NUMBER_OF_FORCE_FEEDBACK_AXES];
; 1179 : 	
; 1180 : 	DICONSTANTFORCE
; 1181 : 		constant_force;
; 1182 : 
; 1183 : 	DIEFFECT
; 1184 : 		effect;
; 1185 : 
; 1186 : 	DWORD
; 1187 : 		effect_flags;
; 1188 : 
; 1189 : 	ASSERT (joystick_devices[joystick_device_index].input_device);

  0000c	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_device_index$[ebp], 2224
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00019	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  0001d	75 18		 jne	 SHORT $LN4@set_joysti
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??set_joystick_force_feedback_forces@@YGHHHH@Z@4JA
  00024	83 c0 12	 add	 eax, 18			; 00000012H
  00027	50		 push	 eax
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@PAODIEFD@c?3?2users?2nhv90?2projects?2eech?2mo@
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@OEPJJLBP@joystick_devices?$FLjoystick_devic@
  00032	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN4@set_joysti:

; 1190 : 	ASSERT (joystick_devices[joystick_device_index].joystick_supports_force_feedback);

  00037	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_device_index$[ebp], 2224
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00044	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00048	c1 ea 08	 shr	 edx, 8
  0004b	83 e2 01	 and	 edx, 1
  0004e	75 18		 jne	 SHORT $LN5@set_joysti
  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??set_joystick_force_feedback_forces@@YGHHHH@Z@4JA
  00055	83 c0 13	 add	 eax, 19			; 00000013H
  00058	50		 push	 eax
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@PAODIEFD@c?3?2users?2nhv90?2projects?2eech?2mo@
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@NAONHGHM@joystick_devices?$FLjoystick_devic@
  00063	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN5@set_joysti:

; 1191 : 
; 1192 : 	//
; 1193 : 	// Set the effect parameters
; 1194 : 	//
; 1195 : 
; 1196 : 	forces_directions[0] = xforce;

  00068	b8 04 00 00 00	 mov	 eax, 4
  0006d	6b c8 00	 imul	 ecx, eax, 0
  00070	8b 55 0c	 mov	 edx, DWORD PTR _xforce$[ebp]
  00073	89 54 0d f4	 mov	 DWORD PTR _forces_directions$[ebp+ecx], edx

; 1197 : 	forces_directions[1] = yforce;

  00077	b8 04 00 00 00	 mov	 eax, 4
  0007c	c1 e0 00	 shl	 eax, 0
  0007f	8b 4d 10	 mov	 ecx, DWORD PTR _yforce$[ebp]
  00082	89 4c 05 f4	 mov	 DWORD PTR _forces_directions$[ebp+eax], ecx

; 1198 : 
; 1199 : 	constant_force.lMagnitude = (DWORD) sqrt ((double) xforce * (double) xforce + (double) yforce * (double) yforce);

  00086	f2 0f 2a 45 0c	 cvtsi2sd xmm0, DWORD PTR _xforce$[ebp]
  0008b	f2 0f 2a 4d 0c	 cvtsi2sd xmm1, DWORD PTR _xforce$[ebp]
  00090	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00094	f2 0f 2a 4d 10	 cvtsi2sd xmm1, DWORD PTR _yforce$[ebp]
  00099	f2 0f 2a 55 10	 cvtsi2sd xmm2, DWORD PTR _yforce$[ebp]
  0009e	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  000a2	f2 0f 58 c1	 addsd	 xmm0, xmm1
  000a6	83 ec 08	 sub	 esp, 8
  000a9	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000ae	e8 00 00 00 00	 call	 _sqrt
  000b3	83 c4 08	 add	 esp, 8
  000b6	d9 bd 72 ff ff
	ff		 fnstcw	 WORD PTR tv216[ebp]
  000bc	0f b7 85 72 ff
	ff ff		 movzx	 eax, WORD PTR tv216[ebp]
  000c3	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000c8	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv219[ebp], eax
  000ce	d9 ad 6c ff ff
	ff		 fldcw	 WORD PTR tv219[ebp]
  000d4	df bd 64 ff ff
	ff		 fistp	 QWORD PTR tv221[ebp]
  000da	d9 ad 72 ff ff
	ff		 fldcw	 WORD PTR tv216[ebp]
  000e0	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv221[ebp]
  000e6	89 45 f0	 mov	 DWORD PTR _constant_force$[ebp], eax

; 1200 : 	
; 1201 : 	effect.dwSize = sizeof (effect);

  000e9	c7 45 b8 38 00
	00 00		 mov	 DWORD PTR _effect$[ebp], 56 ; 00000038H

; 1202 : 	effect.dwFlags = DIEFF_CARTESIAN | DIEFF_OBJECTOFFSETS;

  000f0	c7 45 bc 12 00
	00 00		 mov	 DWORD PTR _effect$[ebp+4], 18 ; 00000012H

; 1203 : 	effect.cAxes = NUMBER_OF_FORCE_FEEDBACK_AXES;

  000f7	c7 45 d4 02 00
	00 00		 mov	 DWORD PTR _effect$[ebp+28], 2

; 1204 : 	effect.rglDirection = forces_directions;

  000fe	8d 45 f4	 lea	 eax, DWORD PTR _forces_directions$[ebp]
  00101	89 45 dc	 mov	 DWORD PTR _effect$[ebp+36], eax

; 1205 : 	effect.lpEnvelope = 0;

  00104	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _effect$[ebp+40], 0

; 1206 : 	effect.cbTypeSpecificParams = sizeof (constant_force);

  0010b	c7 45 e4 04 00
	00 00		 mov	 DWORD PTR _effect$[ebp+44], 4

; 1207 : 	effect.lpvTypeSpecificParams = &constant_force;

  00112	8d 45 f0	 lea	 eax, DWORD PTR _constant_force$[ebp]
  00115	89 45 e8	 mov	 DWORD PTR _effect$[ebp+48], eax

; 1208 : 
; 1209 : 	//
; 1210 : 	// If the effect isn't playing - play it
; 1211 : 	//
; 1212 : 
; 1213 : 	di_err = DIERR_NOTDOWNLOADED;

  00118	c7 45 fc 03 02
	04 80		 mov	 DWORD PTR _di_err$[ebp], -2147220989 ; 80040203H
$LN2@set_joysti:

; 1214 : 
; 1215 : 	while (di_err == DIERR_NOTDOWNLOADED)

  0011f	81 7d fc 03 02
	04 80		 cmp	 DWORD PTR _di_err$[ebp], -2147220989 ; 80040203H
  00126	0f 85 eb 00 00
	00		 jne	 $LN3@set_joysti

; 1216 : 	{
; 1217 : 	
; 1218 : 		di_err = IDirectInputEffect_GetEffectStatus (joystick_devices[joystick_device_index].input_effect, &effect_flags);

  0012c	8d 45 b4	 lea	 eax, DWORD PTR _effect_flags$[ebp]
  0012f	50		 push	 eax
  00130	69 4d 08 b0 08
	00 00		 imul	 ecx, DWORD PTR _joystick_device_index$[ebp], 2224
  00137	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0013d	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  00141	69 4d 08 b0 08
	00 00		 imul	 ecx, DWORD PTR _joystick_device_index$[ebp], 2224
  00148	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0014e	8b 4c 0a 04	 mov	 ecx, DWORD PTR [edx+ecx+4]
  00152	8b 10		 mov	 edx, DWORD PTR [eax]
  00154	51		 push	 ecx
  00155	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00158	ff d0		 call	 eax
  0015a	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 1219 : 	
; 1220 : 		if (di_err == DI_OK)

  0015d	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  00161	75 5f		 jne	 SHORT $LN6@set_joysti

; 1221 : 		{
; 1222 : 	
; 1223 : 			if (!(effect_flags & DIEGES_PLAYING))

  00163	8b 45 b4	 mov	 eax, DWORD PTR _effect_flags$[ebp]
  00166	83 e0 01	 and	 eax, 1
  00169	75 55		 jne	 SHORT $LN9@set_joysti

; 1224 : 			{
; 1225 : 	
; 1226 : 				//
; 1227 : 				// Start the effect
; 1228 : 				//
; 1229 : 	
; 1230 : 				di_err = IDirectInputEffect_Start (joystick_devices[joystick_device_index].input_effect, 1, 0);

  0016b	6a 00		 push	 0
  0016d	6a 01		 push	 1
  0016f	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_device_index$[ebp], 2224
  00176	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0017c	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00180	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_device_index$[ebp], 2224
  00187	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0018d	8b 44 01 04	 mov	 eax, DWORD PTR [ecx+eax+4]
  00191	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00193	50		 push	 eax
  00194	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00197	ff d2		 call	 edx
  00199	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 1231 : 	
; 1232 : 				if (di_err != DI_OK)

  0019c	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  001a0	74 1e		 je	 SHORT $LN9@set_joysti

; 1233 : 				{
; 1234 : 	
; 1235 : 					debug_log ("Unable to start a force feedback effect: %s", get_dinput_error_message (di_err));

  001a2	8b 45 fc	 mov	 eax, DWORD PTR _di_err$[ebp]
  001a5	50		 push	 eax
  001a6	e8 00 00 00 00	 call	 ?get_dinput_error_message@@YGPBDJ@Z ; get_dinput_error_message
  001ab	50		 push	 eax
  001ac	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OGFGLELM@Unable?5to?5start?5a?5force?5feedbac@
  001b1	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  001b6	83 c4 08	 add	 esp, 8

; 1236 : 	
; 1237 : 					return (FALSE);

  001b9	33 c0		 xor	 eax, eax
  001bb	e9 b9 00 00 00	 jmp	 $LN1@set_joysti
$LN9@set_joysti:

; 1238 : 				}
; 1239 : 			}
; 1240 : 		}
; 1241 : 		else

  001c0	eb 50		 jmp	 SHORT $LN11@set_joysti
$LN6@set_joysti:

; 1242 : 		{
; 1243 : 	
; 1244 : 			if (di_err == DIERR_NOTDOWNLOADED)

  001c2	81 7d fc 03 02
	04 80		 cmp	 DWORD PTR _di_err$[ebp], -2147220989 ; 80040203H
  001c9	75 2c		 jne	 SHORT $LN10@set_joysti

; 1245 : 			{
; 1246 : 	
; 1247 : 				IDirectInputEffect_Download (joystick_devices[joystick_device_index].input_effect);

  001cb	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_device_index$[ebp], 2224
  001d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  001d8	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  001dc	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_device_index$[ebp], 2224
  001e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  001e9	8b 44 01 04	 mov	 eax, DWORD PTR [ecx+eax+4]
  001ed	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001ef	50		 push	 eax
  001f0	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  001f3	ff d2		 call	 edx

; 1248 : 			}
; 1249 : 			else

  001f5	eb 1b		 jmp	 SHORT $LN11@set_joysti
$LN10@set_joysti:

; 1250 : 			{
; 1251 : 		
; 1252 : 				debug_log ("Unable to acquire Force feedback effect status: %s", get_dinput_error_message (di_err));

  001f7	8b 45 fc	 mov	 eax, DWORD PTR _di_err$[ebp]
  001fa	50		 push	 eax
  001fb	e8 00 00 00 00	 call	 ?get_dinput_error_message@@YGPBDJ@Z ; get_dinput_error_message
  00200	50		 push	 eax
  00201	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@HCHIMAAG@Unable?5to?5acquire?5Force?5feedbac@
  00206	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0020b	83 c4 08	 add	 esp, 8

; 1253 : 		
; 1254 : 				return (FALSE);

  0020e	33 c0		 xor	 eax, eax
  00210	eb 67		 jmp	 SHORT $LN1@set_joysti
$LN11@set_joysti:

; 1255 : 			}
; 1256 : 		}
; 1257 : 	}

  00212	e9 08 ff ff ff	 jmp	 $LN2@set_joysti
$LN3@set_joysti:

; 1258 : 
; 1259 : 	//
; 1260 : 	// now set the new parameters and start the effect immediately.
; 1261 : 	//
; 1262 : 
; 1263 : 	di_err = IDirectInputEffect_SetParameters (joystick_devices[joystick_device_index].input_effect,

  00217	68 40 01 00 00	 push	 320			; 00000140H
  0021c	8d 45 b8	 lea	 eax, DWORD PTR _effect$[ebp]
  0021f	50		 push	 eax
  00220	69 4d 08 b0 08
	00 00		 imul	 ecx, DWORD PTR _joystick_device_index$[ebp], 2224
  00227	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0022d	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  00231	69 4d 08 b0 08
	00 00		 imul	 ecx, DWORD PTR _joystick_device_index$[ebp], 2224
  00238	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  0023e	8b 4c 0a 04	 mov	 ecx, DWORD PTR [edx+ecx+4]
  00242	8b 10		 mov	 edx, DWORD PTR [eax]
  00244	51		 push	 ecx
  00245	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00248	ff d0		 call	 eax
  0024a	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 1264 : 																	&effect, DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS);
; 1265 : 
; 1266 : 	if (di_err != DI_OK)

  0024d	83 7d fc 00	 cmp	 DWORD PTR _di_err$[ebp], 0
  00251	74 21		 je	 SHORT $LN12@set_joysti

; 1267 : 	{
; 1268 : 
; 1269 : 		if (di_err != DI_DOWNLOADSKIPPED)

  00253	83 7d fc 03	 cmp	 DWORD PTR _di_err$[ebp], 3
  00257	74 1b		 je	 SHORT $LN14@set_joysti

; 1270 : 		{
; 1271 : 	
; 1272 : 			debug_log ("Problems setting effect parameters: %s", get_dinput_error_message (di_err));

  00259	8b 45 fc	 mov	 eax, DWORD PTR _di_err$[ebp]
  0025c	50		 push	 eax
  0025d	e8 00 00 00 00	 call	 ?get_dinput_error_message@@YGPBDJ@Z ; get_dinput_error_message
  00262	50		 push	 eax
  00263	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MBPILHNJ@Problems?5setting?5effect?5paramet@
  00268	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0026d	83 c4 08	 add	 esp, 8

; 1273 : 	
; 1274 : 			return (FALSE);

  00270	33 c0		 xor	 eax, eax
  00272	eb 05		 jmp	 SHORT $LN1@set_joysti
$LN14@set_joysti:
$LN12@set_joysti:

; 1275 : 		}
; 1276 : 	}
; 1277 : 	else
; 1278 : 	{
; 1279 : 
; 1280 : 		//debug_log ("Set force feedback effect");
; 1281 : 	}
; 1282 : 
; 1283 : 	return (TRUE);

  00274	b8 01 00 00 00	 mov	 eax, 1
$LN1@set_joysti:

; 1284 : #endif
; 1285 : }

  00279	5f		 pop	 edi
  0027a	5e		 pop	 esi
  0027b	5b		 pop	 ebx
  0027c	8b e5		 mov	 esp, ebp
  0027e	5d		 pop	 ebp
  0027f	c2 0c 00	 ret	 12			; 0000000cH
?set_joystick_force_feedback_forces@@YGHHHH@Z ENDP	; set_joystick_force_feedback_forces
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\joystick.c
;	COMDAT ?read_joystick_values@@YGXH@Z
_TEXT	SEGMENT
_button_count$ = -12					; size = 4
_joystick$ = -8						; size = 4
_di_err$ = -4						; size = 4
_joystick_device_index$ = 8				; size = 4
?read_joystick_values@@YGXH@Z PROC			; read_joystick_values, COMDAT

; 938  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 939  : 
; 940  : #ifdef WIN32
; 941  : 	HRESULT
; 942  : 		di_err;
; 943  : #else
; 944  : 	int
; 945  : 		i;
; 946  : #endif
; 947  : 
; 948  : 	joystick_device_info
; 949  : 		*joystick;
; 950  : 
; 951  : 	int
; 952  : 		button_count;
; 953  : 
; 954  : #if 0
; 955  : 	FILE* fp;
; 956  : #endif
; 957  : 
; 958  : //	if ((joystick_device_index >= 0) && (joystick_device_index < number_of_joystick_devices))
; 959  : 	for (joystick_device_index = 0; joystick_device_index < number_of_joystick_devices; joystick_device_index++)

  00009	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _joystick_device_index$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@read_joyst
$LN2@read_joyst:
  00012	8b 45 08	 mov	 eax, DWORD PTR _joystick_device_index$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 08	 mov	 DWORD PTR _joystick_device_index$[ebp], eax
$LN4@read_joyst:
  0001b	8b 45 08	 mov	 eax, DWORD PTR _joystick_device_index$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_joystick_devices@@3HA ; number_of_joystick_devices
  00024	0f 8d 7a 01 00
	00		 jge	 $LN1@read_joyst

; 960  : 	{
; 961  : 	
; 962  : 		joystick = &joystick_devices[joystick_device_index];

  0002a	69 45 08 b0 08
	00 00		 imul	 eax, DWORD PTR _joystick_device_index$[ebp], 2224
  00031	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A ; joystick_devices
  00037	89 45 f8	 mov	 DWORD PTR _joystick$[ebp], eax

; 963  : 	
; 964  : 		//
; 965  : 		// Read the joystick values
; 966  : 		//
; 967  : 	
; 968  : 		if ((joystick) && (joystick->input_device))

  0003a	0f 84 5f 01 00
	00		 je	 $LN8@read_joyst
  00040	8b 45 f8	 mov	 eax, DWORD PTR _joystick$[ebp]
  00043	83 38 00	 cmp	 DWORD PTR [eax], 0
  00046	0f 84 53 01 00
	00		 je	 $LN8@read_joyst

; 969  : 		{
; 970  : 		
; 971  : 			//
; 972  : 			// Copy the current values to the last values
; 973  : 			//
; 974  : 		
; 975  : 			joystick->joystick_last_state = joystick->joystick_state;

  0004c	8b 75 f8	 mov	 esi, DWORD PTR _joystick$[ebp]
  0004f	83 c6 60	 add	 esi, 96			; 00000060H
  00052	8b 7d f8	 mov	 edi, DWORD PTR _joystick$[ebp]
  00055	83 c7 10	 add	 edi, 16			; 00000010H
  00058	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0005d	f3 a5		 rep movsd

; 976  : 		
; 977  : 			//
; 978  : 			// Now, poll the device
; 979  : 			//
; 980  : 		
; 981  : #ifdef WIN32
; 982  : 			di_err = IDirectInputDevice7_Poll (joystick->input_device);

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _joystick$[ebp]
  00062	8b 08		 mov	 ecx, DWORD PTR [eax]
  00064	8b 55 f8	 mov	 edx, DWORD PTR _joystick$[ebp]
  00067	8b 02		 mov	 eax, DWORD PTR [edx]
  00069	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0006b	50		 push	 eax
  0006c	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  0006f	ff d2		 call	 edx
  00071	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 983  : 		
; 984  : 			if ((di_err == DIERR_INPUTLOST) || (di_err == DIERR_NOTACQUIRED))

  00074	81 7d fc 1e 00
	07 80		 cmp	 DWORD PTR _di_err$[ebp], -2147024866 ; 8007001eH
  0007b	74 09		 je	 SHORT $LN10@read_joyst
  0007d	81 7d fc 0c 00
	07 80		 cmp	 DWORD PTR _di_err$[ebp], -2147024884 ; 8007000cH
  00084	75 2a		 jne	 SHORT $LN12@read_joyst
$LN10@read_joyst:

; 985  : 			{
; 986  : 		
; 987  : 				di_err = IDirectInputDevice7_Acquire (joystick->input_device);

  00086	8b 45 f8	 mov	 eax, DWORD PTR _joystick$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	8b 55 f8	 mov	 edx, DWORD PTR _joystick$[ebp]
  0008e	8b 02		 mov	 eax, DWORD PTR [edx]
  00090	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00092	50		 push	 eax
  00093	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00096	ff d2		 call	 edx
  00098	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 988  : 		
; 989  : 				if (di_err != DI_OK)
; 990  : 				{
; 991  : 		
; 992  : //					debug_log ("Unable to acquire joystick device: %s", get_dinput_error_message (di_err));
; 993  : 				}
; 994  : 		
; 995  : 				di_err = IDirectInputDevice7_Poll (joystick->input_device);

  0009b	8b 45 f8	 mov	 eax, DWORD PTR _joystick$[ebp]
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	8b 55 f8	 mov	 edx, DWORD PTR _joystick$[ebp]
  000a3	8b 02		 mov	 eax, DWORD PTR [edx]
  000a5	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000a7	50		 push	 eax
  000a8	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  000ab	ff d2		 call	 edx
  000ad	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax
$LN12@read_joyst:

; 996  : 			}
; 997  : 		
; 998  : 			if ((di_err != DI_OK) && (di_err != S_FALSE))
; 999  : 			{
; 1000 : 		
; 1001 : //				debug_log ("Unable to poll joystick device: %s (%d)", get_dinput_error_message (di_err), di_err);
; 1002 : 		
; 1003 : //				return;
; 1004 : 			}
; 1005 : 		
; 1006 : 			//
; 1007 : 			// Finally, read the state
; 1008 : 			//
; 1009 : 		
; 1010 : 			di_err = IDirectInputDevice7_GetDeviceState (joystick->input_device, sizeof (DIJOYSTATE), &joystick->joystick_state);

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _joystick$[ebp]
  000b3	83 c0 60	 add	 eax, 96			; 00000060H
  000b6	50		 push	 eax
  000b7	6a 50		 push	 80			; 00000050H
  000b9	8b 4d f8	 mov	 ecx, DWORD PTR _joystick$[ebp]
  000bc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000be	8b 45 f8	 mov	 eax, DWORD PTR _joystick$[ebp]
  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	8b 12		 mov	 edx, DWORD PTR [edx]
  000c5	51		 push	 ecx
  000c6	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000c9	ff d0		 call	 eax
  000cb	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax

; 1011 : 		
; 1012 : 			if ((di_err == DIERR_INPUTLOST) || (di_err == DIERR_NOTACQUIRED))

  000ce	81 7d fc 1e 00
	07 80		 cmp	 DWORD PTR _di_err$[ebp], -2147024866 ; 8007001eH
  000d5	74 09		 je	 SHORT $LN14@read_joyst
  000d7	81 7d fc 0c 00
	07 80		 cmp	 DWORD PTR _di_err$[ebp], -2147024884 ; 8007000cH
  000de	75 30		 jne	 SHORT $LN15@read_joyst
$LN14@read_joyst:

; 1013 : 			{
; 1014 : 		
; 1015 : 				IDirectInputDevice7_Acquire (joystick->input_device);

  000e0	8b 45 f8	 mov	 eax, DWORD PTR _joystick$[ebp]
  000e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e5	8b 55 f8	 mov	 edx, DWORD PTR _joystick$[ebp]
  000e8	8b 02		 mov	 eax, DWORD PTR [edx]
  000ea	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000ec	50		 push	 eax
  000ed	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000f0	ff d2		 call	 edx

; 1016 : 		
; 1017 : 				di_err = IDirectInputDevice7_GetDeviceState (joystick->input_device, sizeof (DIJOYSTATE), &joystick->joystick_state);

  000f2	8b 45 f8	 mov	 eax, DWORD PTR _joystick$[ebp]
  000f5	83 c0 60	 add	 eax, 96			; 00000060H
  000f8	50		 push	 eax
  000f9	6a 50		 push	 80			; 00000050H
  000fb	8b 4d f8	 mov	 ecx, DWORD PTR _joystick$[ebp]
  000fe	8b 11		 mov	 edx, DWORD PTR [ecx]
  00100	8b 45 f8	 mov	 eax, DWORD PTR _joystick$[ebp]
  00103	8b 08		 mov	 ecx, DWORD PTR [eax]
  00105	8b 12		 mov	 edx, DWORD PTR [edx]
  00107	51		 push	 ecx
  00108	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0010b	ff d0		 call	 eax
  0010d	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax
$LN15@read_joyst:

; 1018 : 			}
; 1019 : 		
; 1020 : 			if (di_err != DI_OK)
; 1021 : 			{
; 1022 : 		
; 1023 : //				debug_log ("Unable to read joystick device state");
; 1024 : 		
; 1025 : //				return;
; 1026 : 			}
; 1027 : 
; 1028 : 			//
; 1029 : 			// Generate any button events
; 1030 : 			//
; 1031 : 			if (command_line_cyclic_joystick_index != -1)	// Retro 18Jul2004 FIXME

  00110	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?command_line_cyclic_joystick_index@@3HA, -1 ; command_line_cyclic_joystick_index
  00117	0f 84 82 00 00
	00		 je	 $LN8@read_joyst

; 1032 : 			if (joystick_device_index == command_line_cyclic_joystick_index)	// Retro 18Jul2004 FIXME

  0011d	8b 45 08	 mov	 eax, DWORD PTR _joystick_device_index$[ebp]
  00120	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?command_line_cyclic_joystick_index@@3HA ; command_line_cyclic_joystick_index
  00126	75 77		 jne	 SHORT $LN8@read_joyst

; 1033 : 			for (button_count = 0; button_count < joystick->number_of_buttons; button_count++)

  00128	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _button_count$[ebp], 0
  0012f	eb 09		 jmp	 SHORT $LN7@read_joyst
$LN5@read_joyst:
  00131	8b 45 f4	 mov	 eax, DWORD PTR _button_count$[ebp]
  00134	83 c0 01	 add	 eax, 1
  00137	89 45 f4	 mov	 DWORD PTR _button_count$[ebp], eax
$LN7@read_joyst:
  0013a	8b 45 f8	 mov	 eax, DWORD PTR _joystick$[ebp]
  0013d	8b 4d f4	 mov	 ecx, DWORD PTR _button_count$[ebp]
  00140	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00143	7d 5a		 jge	 SHORT $LN8@read_joyst

; 1034 : 			{
; 1035 : 				if (button_count > 31)	// Retro 8Jan2004 - X52 Kludge..

  00145	83 7d f4 1f	 cmp	 DWORD PTR _button_count$[ebp], 31 ; 0000001fH
  00149	7e 02		 jle	 SHORT $LN18@read_joyst

; 1036 : 				{
; 1037 : 					continue;

  0014b	eb e4		 jmp	 SHORT $LN5@read_joyst
$LN18@read_joyst:

; 1038 : 				}
; 1039 : 
; 1040 : 				if (joystick->joystick_last_state.rgbButtons[button_count] != joystick->joystick_state.rgbButtons[button_count])

  0014d	8b 45 f8	 mov	 eax, DWORD PTR _joystick$[ebp]
  00150	03 45 f4	 add	 eax, DWORD PTR _button_count$[ebp]
  00153	0f b6 48 40	 movzx	 ecx, BYTE PTR [eax+64]
  00157	8b 55 f8	 mov	 edx, DWORD PTR _joystick$[ebp]
  0015a	03 55 f4	 add	 edx, DWORD PTR _button_count$[ebp]
  0015d	0f b6 82 90 00
	00 00		 movzx	 eax, BYTE PTR [edx+144]
  00164	3b c8		 cmp	 ecx, eax
  00166	74 35		 je	 SHORT $LN19@read_joyst

; 1041 : 				{
; 1042 : 		
; 1043 : 					if (joystick->joystick_state.rgbButtons[button_count] & 0x80)

  00168	8b 45 f8	 mov	 eax, DWORD PTR _joystick$[ebp]
  0016b	03 45 f4	 add	 eax, DWORD PTR _button_count$[ebp]
  0016e	0f b6 88 90 00
	00 00		 movzx	 ecx, BYTE PTR [eax+144]
  00175	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0017b	74 11		 je	 SHORT $LN20@read_joyst

; 1044 : 					{
; 1045 : 		
; 1046 : 						//
; 1047 : 						// Generate a button pressed event
; 1048 : 						//
; 1049 : 		
; 1050 : 						create_joystick_event (joystick_device_index, button_count, BUTTON_STATE_DOWN);

  0017d	6a 02		 push	 2
  0017f	8b 45 f4	 mov	 eax, DWORD PTR _button_count$[ebp]
  00182	50		 push	 eax
  00183	8b 4d 08	 mov	 ecx, DWORD PTR _joystick_device_index$[ebp]
  00186	51		 push	 ecx
  00187	e8 00 00 00 00	 call	 ?create_joystick_event@@YGXHHW4BUTTON_STATES@@@Z ; create_joystick_event

; 1051 : 					}
; 1052 : 					else

  0018c	eb 0f		 jmp	 SHORT $LN19@read_joyst
$LN20@read_joyst:

; 1053 : 					{
; 1054 : 		
; 1055 : 						//
; 1056 : 						// Generate a button released event
; 1057 : 						//
; 1058 : 		
; 1059 : 						create_joystick_event (joystick_device_index, button_count, BUTTON_STATE_UP);

  0018e	6a 01		 push	 1
  00190	8b 45 f4	 mov	 eax, DWORD PTR _button_count$[ebp]
  00193	50		 push	 eax
  00194	8b 4d 08	 mov	 ecx, DWORD PTR _joystick_device_index$[ebp]
  00197	51		 push	 ecx
  00198	e8 00 00 00 00	 call	 ?create_joystick_event@@YGXHHW4BUTTON_STATES@@@Z ; create_joystick_event
$LN19@read_joyst:

; 1060 : 					}
; 1061 : 				}
; 1062 : 			}

  0019d	eb 92		 jmp	 SHORT $LN5@read_joyst
$LN8@read_joyst:

; 1063 : 
; 1064 : #else
; 1065 : 		
; 1066 : 			//
; 1067 : 			// Read the state
; 1068 : 			//
; 1069 : 		
; 1070 : 			for(i = 0; i < joystick->number_of_buttons; i++)
; 1071 : 				joystick->joystick_state.buttons[ i ] = SDL_JoystickGetButton(joystick->input_device, i);
; 1072 : 
; 1073 : 			for(i = 0; i < joystick->number_of_axes; i++)
; 1074 : 				joystick->joystick_state.axes[ i ] = SDL_JoystickGetAxis(joystick->input_device, i);
; 1075 : 
; 1076 : 			for(i = 0; i < joystick->number_of_buttons; i++)
; 1077 : 				joystick->joystick_state.hats[ i ] = SDL_JoystickGetHat(joystick->input_device, i);
; 1078 : 
; 1079 : 			//
; 1080 : 			// Generate any button events
; 1081 : 			//
; 1082 : 		
; 1083 : 			for (button_count = 0; button_count < joystick->number_of_buttons; button_count++)
; 1084 : 			{
; 1085 : 		
; 1086 : 				if (joystick->joystick_last_state.buttons[button_count] != joystick->joystick_state.buttons[button_count])
; 1087 : 				{
; 1088 : 		
; 1089 : 					if (joystick->joystick_state.buttons[button_count] == 1)
; 1090 : 					{
; 1091 : 		
; 1092 : 						//
; 1093 : 						// Generate a button pressed event
; 1094 : 						//
; 1095 : 		
; 1096 : 						create_joystick_event (joystick_device_index, button_count, BUTTON_STATE_DOWN);
; 1097 : 					}
; 1098 : 					else
; 1099 : 					{
; 1100 : 		
; 1101 : 						//
; 1102 : 						// Generate a button released event
; 1103 : 						//
; 1104 : 		
; 1105 : 						create_joystick_event (joystick_device_index, button_count, BUTTON_STATE_UP);
; 1106 : 					}
; 1107 : 				}
; 1108 : 			}
; 1109 : #endif
; 1110 : 
; 1111 : 		}
; 1112 : #if 0
; 1113 : #ifdef WIN32
; 1114 : 		//
; 1115 : 		// Hack for Win2k problems of putting the Z axis data into Slider0 member
; 1116 : 		//
; 1117 : 
; 1118 : 		if ((!joystick->joystick_zaxis_valid) && (joystick->joystick_slider0axis_valid))
; 1119 : 		{
; 1120 : 
; 1121 : 			joystick->joystick_state.lZ = joystick->joystick_state.rglSlider[0];
; 1122 : 		}
; 1123 : #endif
; 1124 : #endif
; 1125 : 		//
; 1126 : 		// Values are in here!
; 1127 : 		//
; 1128 : 	
; 1129 : #if DEBUG_MODULE
; 1130 : 	
; 1131 : 		if (joystick->joystick_xaxis_valid) debug_log ("Joystick Xaxis: %d", joystick->joystick_state.lX);
; 1132 : 		if (joystick->joystick_yaxis_valid) debug_log ("Joystick Yaxis: %d", joystick->joystick_state.lY);
; 1133 : 		if (joystick->joystick_zaxis_valid) debug_log ("Joystick Zaxis: %d", joystick->joystick_state.lZ);
; 1134 : 		if (joystick->joystick_rxaxis_valid) debug_log ("Joystick RXaxis: %d", joystick->joystick_state.lRx);
; 1135 : 		if (joystick->joystick_ryaxis_valid) debug_log ("Joystick RYaxis: %d", joystick->joystick_state.lRy);
; 1136 : 		if (joystick->joystick_rzaxis_valid) debug_log ("Joystick RZaxis: %d", joystick->joystick_state.lRz);
; 1137 : 	
; 1138 : #endif
; 1139 : 	}

  0019f	e9 6e fe ff ff	 jmp	 $LN2@read_joyst
$LN1@read_joyst:

; 1140 : 
; 1141 : #if 0
; 1142 : 	fp = fopen("stickresult.txt","at");
; 1143 : 	{
; 1144 : 		int i = 0;
; 1145 : 
; 1146 : 		for (i = 0; i < number_of_joystick_devices; i++)
; 1147 : 		{
; 1148 : 			fprintf(fp,"--> %i\n",i);
; 1149 : 
; 1150 : 			fprintf(fp,"%i\n",joystick_devices[i].joystick_state.lX);
; 1151 : 			fprintf(fp,"%i\n",joystick_devices[i].joystick_state.lY);
; 1152 : 			fprintf(fp,"%i\n",joystick_devices[i].joystick_state.lZ);
; 1153 : 			fprintf(fp,"%i\n",joystick_devices[i].joystick_state.lRx);
; 1154 : 			fprintf(fp,"%i\n",joystick_devices[i].joystick_state.lRy);
; 1155 : 			fprintf(fp,"%i\n",joystick_devices[i].joystick_state.lRz);
; 1156 : 			fprintf(fp,"%i\n",joystick_devices[i].joystick_state.rglSlider[0]);
; 1157 : 			fprintf(fp,"%i\n",joystick_devices[i].joystick_state.rglSlider[1]);
; 1158 : 			
; 1159 : 			fprintf(fp,"-----------------------\n");
; 1160 : 		}
; 1161 : 	}
; 1162 : 	fclose(fp);
; 1163 : #endif
; 1164 : }

  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
  001a6	5b		 pop	 ebx
  001a7	8b e5		 mov	 esp, ebp
  001a9	5d		 pop	 ebp
  001aa	c2 04 00	 ret	 4
?read_joystick_values@@YGXH@Z ENDP			; read_joystick_values
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\joystick.c
;	COMDAT ?initialise_joysticks@@YGXXZ
_TEXT	SEGMENT
_di_err$ = -4						; size = 4
?initialise_joysticks@@YGXXZ PROC			; initialise_joysticks, COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 151  : 
; 152  : #ifdef WIN32
; 153  : 	HRESULT
; 154  : 		di_err;
; 155  : #endif
; 156  : 
; 157  : 	//
; 158  : 	// Allocate joystick device array
; 159  : 	//
; 160  : 
; 161  : 	joystick_devices = (joystick_device_info *) safe_malloc (sizeof (joystick_device_info) * MAXIMUM_JOYSTICK_DEVICES);

  00009	68 00 8b 00 00	 push	 35584			; 00008b00H
  0000e	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00013	a3 00 00 00 00	 mov	 DWORD PTR ?joystick_devices@@3PAUJOYSTICK_DEVICE_INFO@@A, eax ; joystick_devices

; 162  : 
; 163  : 	//
; 164  : 	// First, enumerate all the joysticks that are available
; 165  : 	//
; 166  : 
; 167  : 	number_of_joystick_devices = 0;

  00018	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?number_of_joystick_devices@@3HA, 0 ; number_of_joystick_devices

; 168  : 
; 169  : 	// Retro 10Jul2004
; 170  : 	AxisInfo[AxisCount].axis = -1;

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00027	c1 e0 04	 shl	 eax, 4
  0002a	c7 80 08 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+8], -1

; 171  : 	AxisInfo[AxisCount].device = -1;

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  00039	c1 e0 04	 shl	 eax, 4
  0003c	c7 80 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+4], -1

; 172  : 	AxisInfo[AxisCount].AxisName = "Keyboard";

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  0004b	c1 e0 04	 shl	 eax, 4
  0004e	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax], OFFSET ??_C@_08CPOKIBJK@Keyboard@

; 173  : 	AxisInfo[AxisCount].inUse = FALSE;	// keyboard is ALWAYS 'not in use' for our purposes

  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  0005d	c1 e0 04	 shl	 eax, 4
  00060	c7 80 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?AxisInfo@@3PAUAxisInfo_t@@A[eax+12], 0

; 174  : 	AxisCount++;

  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?AxisCount@@3HA ; AxisCount
  0006f	83 c0 01	 add	 eax, 1
  00072	a3 00 00 00 00	 mov	 DWORD PTR ?AxisCount@@3HA, eax ; AxisCount

; 175  : 	// Retro 10Jul2004 end
; 176  : 
; 177  : #ifdef WIN32
; 178  : 	if (direct_input)

  00077	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?direct_input@@3PAUIDirectInput7A@@A, 0 ; direct_input
  0007e	74 21		 je	 SHORT $LN1@initialise

; 179  : 	{
; 180  : 
; 181  : 		di_err = IDirectInput7_EnumDevices (direct_input, DIDEVTYPE_JOYSTICK, enumerate_joystick_devices, NULL, DIEDFL_ATTACHEDONLY);

  00080	6a 01		 push	 1
  00082	6a 00		 push	 0
  00084	68 00 00 00 00	 push	 OFFSET ?enumerate_joystick_devices@@YGHPBUDIDEVICEINSTANCEA@@PAX@Z ; enumerate_joystick_devices
  00089	6a 04		 push	 4
  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?direct_input@@3PAUIDirectInput7A@@A ; direct_input
  00090	8b 08		 mov	 ecx, DWORD PTR [eax]
  00092	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?direct_input@@3PAUIDirectInput7A@@A ; direct_input
  00098	52		 push	 edx
  00099	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0009c	ff d0		 call	 eax
  0009e	89 45 fc	 mov	 DWORD PTR _di_err$[ebp], eax
$LN1@initialise:

; 182  : 
; 183  : 		if (di_err != DI_OK)
; 184  : 		{
; 185  : 
; 186  : //			debug_log ("Unable to enumerate any joystick devices");
; 187  : 		}
; 188  : 	}
; 189  : 
; 190  : #else
; 191  : 
; 192  : 	if( setup_sdl_joysticks() != 0 ) {
; 193  : 		debug_log ("No joystick devices found");
; 194  : 	}
; 195  : #endif
; 196  : }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
?initialise_joysticks@@YGXXZ ENDP			; initialise_joysticks
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1459 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1460 :         #pragma warning(push)
; 1461 :         #pragma warning(disable: 4996) // Deprecation
; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1463 :         #pragma warning(pop)
; 1464 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH
  00035	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00038	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003c	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003e	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00045	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00047	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  0004a	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004d	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1395 :     }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
