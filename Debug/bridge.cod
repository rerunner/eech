; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\aphavoc\source\entity\special\bridge\bridge.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?valid_warzone_bridges@@3PADA			; valid_warzone_bridges
_BSS	SEGMENT
?valid_warzone_bridges@@3PADA DB 08H DUP (?)		; valid_warzone_bridges
_BSS	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_asinf
PUBLIC	_fabsf
PUBLIC	?asin@@YGMM@Z					; asin
PUBLIC	?fabs@@YGMM@Z					; fabs
PUBLIC	?initialise_valid_warzone_bridge_database@@YGXXZ ; initialise_valid_warzone_bridge_database
PUBLIC	?create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z	; create_bridge
PUBLIC	?create_local_bridge_entities@@YGXW4PACK_MODES@@@Z ; create_local_bridge_entities
PUBLIC	?get_most_suitable_bridge_type@@YGHPAUVEC3D@@0M@Z ; get_most_suitable_bridge_type
PUBLIC	?get_bridge_max_leg_height@@YGMPAUVEC3D@@0H@Z	; get_bridge_max_leg_height
PUBLIC	?repair_client_server_bridge_entity@@YGXPAUENTITY@@@Z ; repair_client_server_bridge_entity
PUBLIC	?repair_local_bridge_entity@@YGXPAUENTITY@@@Z	; repair_local_bridge_entity
PUBLIC	??$max@M@std@@YGABMABM0@Z			; std::max<float>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	?__LINE__Var@?0??initialise_valid_warzone_bridge_database@@YGXXZ@4JA ; `initialise_valid_warzone_bridge_database'::`1'::__LINE__Var
PUBLIC	??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@ ; `string'
PUBLIC	??_C@_0CC@EEKIOPJL@get_valid_current_game_session?5@ ; `string'
PUBLIC	??_C@_0BB@OMLBFHIA@route?2bridge?4pop@		; `string'
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0BI@NHAOLFJJ@result?5?$DN?$DN?5FILE_TAG_TYPE@ ; `string'
PUBLIC	?__LINE__Var@?0??create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z@4JA ; `create_bridge'::`1'::__LINE__Var
PUBLIC	??_C@_0DI@HECDIEBL@?$CI?5type?5?$DO?$DN?50?5?$CJ?5?$CG?$CG?5?$CI?5type?5?$DM?5NUM_E@ ; `string'
PUBLIC	?__LINE__Var@?0??create_local_bridge_entities@@YGXW4PACK_MODES@@@Z@4JA ; `create_local_bridge_entities'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FNDIHPEG@route?2bridge?4dat@		; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	?__LINE__Var@?0??get_actual_bridge_length@@YGMPAUVEC3D@@0H00PAH@Z@4JA ; `get_actual_bridge_length'::`1'::__LINE__Var
PUBLIC	??_C@_0CB@MFJOCBNL@mid_section_pattern_length?5?$DO?50?4@ ; `string'
PUBLIC	?__LINE__Var@?0??get_most_suitable_bridge_type@@YGHPAUVEC3D@@0M@Z@4JA ; `get_most_suitable_bridge_type'::`1'::__LINE__Var
PUBLIC	??_C@_0N@HLKEMMPI@end1?5?$CG?$CG?5end2@		; `string'
PUBLIC	??_C@_0EA@NBHJHDC@BRIDGE?3?5suitable?5type?5counter?5?$DN@ ; `string'
PUBLIC	??_C@_0BA@FOLJKOPJ@best_type?5?$CB?$DN?5?91@	; `string'
PUBLIC	??_C@_0BO@LAGOEHEJ@BRIDGE?5?3?5No?5Valid?5Types?5Found@ ; `string'
PUBLIC	?__LINE__Var@?0??get_bridge_max_leg_height@@YGMPAUVEC3D@@0H@Z@4JA ; `get_bridge_max_leg_height'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??repair_client_server_bridge_entity@@YGXPAUENTITY@@@Z@4JA ; `repair_client_server_bridge_entity'::`1'::__LINE__Var
PUBLIC	??_C@_02LFNMGJAP@en@				; `string'
PUBLIC	??_C@_0CJ@DMBLBJBK@get_comms_model?5?$CI?$CJ?5?$DN?$DN?5COMMS_MOD@ ; `string'
PUBLIC	?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA ; `repair_local_bridge_entity'::`1'::__LINE__Var
PUBLIC	??_C@_0FA@GFPAOEKN@BRIDGE?3?5Repairin?5bridge?5and?5rou@ ; `string'
PUBLIC	??_C@_0BD@FEEMDEPI@invalid?5comparator@		; `string'
PUBLIC	??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@ ; `string'
PUBLIC	??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ ; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@7f7fffff
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_memset:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	_asin:PROC
EXTRN	_fabs:PROC
EXTRN	?process_assert@@YGXPBD0H@Z:PROC		; process_assert
EXTRN	?debug_fatal@@YAXPBDZZ:PROC			; debug_fatal
EXTRN	?debug_log@@YAXPBDZZ:PROC			; debug_log
EXTRN	?file_exist@@YGHPBD@Z:PROC			; file_exist
EXTRN	?safe_fopen@@YGPAU_iobuf@@PBD0@Z:PROC		; safe_fopen
EXTRN	?safe_fclose@@YGHPAU_iobuf@@@Z:PROC		; safe_fclose
EXTRN	?normalise_3d_vector@@YGMPAUVEC3D@@@Z:PROC	; normalise_3d_vector
EXTRN	?get_heading_and_pitch_from_3d_unit_vector@@YGXPBUVEC3D@@PAM1@Z:PROC ; get_heading_and_pitch_from_3d_unit_vector
EXTRN	?get_3d_range@@YGMPBUVEC3D@@0@Z:PROC		; get_3d_range
EXTRN	?get_next_file_tag@@YGHPAU_iobuf@@QAPBDH@Z:PROC	; get_next_file_tag
EXTRN	?check_next_file_tag@@YGHPAU_iobuf@@QAPBDH@Z:PROC ; check_next_file_tag
EXTRN	?get_next_file_enum@@YGHPAU_iobuf@@QAPBDH@Z:PROC ; get_next_file_enum
EXTRN	?get_3d_terrain_point_data@@YGMMMPAUTERRAIN_3D_POINT_DATA@@@Z:PROC ; get_3d_terrain_point_data
EXTRN	?create_local_entity@@YAPAUENTITY@@W4ENTITY_TYPES@@HZZ:PROC ; create_local_entity
EXTRN	?transmit_entity_comms_message@@YAXW4ENTITY_COMMS_MESSAGES@@PAUENTITY@@ZZ:PROC ; transmit_entity_comms_message
EXTRN	?repair_local_segment_entity@@YGXPAUENTITY@@@Z:PROC ; repair_local_segment_entity
EXTRN	?set_road_link_breaks@@YGHHHH@Z:PROC		; set_road_link_breaks
EXTRN	?get_road_link_breaks@@YGHHH@Z:PROC		; get_road_link_breaks
EXTRN	?entity_sub_type_bridge_names@@3PAPBDA:BYTE	; entity_sub_type_bridge_names
EXTRN	?null_entity_pointer_message@@3PBDB:DWORD	; null_entity_pointer_message
EXTRN	?system_comms_model@@3W4COMMS_MODEL_TYPES@@A:DWORD ; system_comms_model
EXTRN	?overload_invalid_list_type_message@@3PBDB:DWORD ; overload_invalid_list_type_message
EXTRN	?fn_get_local_entity_first_child@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA:BYTE ; fn_get_local_entity_first_child
EXTRN	?fn_get_local_entity_child_succ@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA:BYTE ; fn_get_local_entity_child_succ
EXTRN	?overload_invalid_float_type_message@@3PBDB:DWORD ; overload_invalid_float_type_message
EXTRN	?fn_set_local_entity_float_value@@3PAY0KP@P6GXPAUENTITY@@W4FLOAT_TYPES@@M@ZA:BYTE ; fn_set_local_entity_float_value
EXTRN	?overload_invalid_int_type_message@@3PBDB:DWORD	; overload_invalid_int_type_message
EXTRN	?fn_set_local_entity_int_value@@3PAY0BBH@P6GXPAUENTITY@@W4INT_TYPES@@H@ZA:BYTE ; fn_set_local_entity_int_value
EXTRN	?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA:BYTE ; fn_get_local_entity_int_value
EXTRN	?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A:BYTE ; segment_database
EXTRN	?bridge_database@@3PAUBRIDGE_DATA@@A:BYTE	; bridge_database
EXTRN	?application_tag_strings@@3PAPBDA:BYTE		; application_tag_strings
EXTRN	?current_game_session@@3PAUSESSION_LIST_DATA_TYPE@@A:DWORD ; current_game_session
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+38
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
CONST	SEGMENT
??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@
CONST	SEGMENT
??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@ DB 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'm', 00H, 'a', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 'l', 00H
	DB	'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\algorithm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FEEMDEPI@invalid?5comparator@
CONST	SEGMENT
??_C@_0BD@FEEMDEPI@invalid?5comparator@ DB 'invalid comparator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@GFPAOEKN@BRIDGE?3?5Repairin?5bridge?5and?5rou@
CONST	SEGMENT
??_C@_0FA@GFPAOEKN@BRIDGE?3?5Repairin?5bridge?5and?5rou@ DB 'BRIDGE: Repa'
	DB	'irin bridge and route between %d and %d... broken bridge coun'
	DB	't = %d', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA DD 037bH ; `repair_local_bridge_entity'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CJ@DMBLBJBK@get_comms_model?5?$CI?$CJ?5?$DN?$DN?5COMMS_MOD@
CONST	SEGMENT
??_C@_0CJ@DMBLBJBK@get_comms_model?5?$CI?$CJ?5?$DN?$DN?5COMMS_MOD@ DB 'ge'
	DB	't_comms_model () == COMMS_MODEL_SERVER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02LFNMGJAP@en@
CONST	SEGMENT
??_C@_02LFNMGJAP@en@ DB 'en', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??repair_client_server_bridge_entity@@YGXPAUENTITY@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??repair_client_server_bridge_entity@@YGXPAUENTITY@@@Z@4JA DD 036cH ; `repair_client_server_bridge_entity'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??get_bridge_max_leg_height@@YGMPAUVEC3D@@0H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??get_bridge_max_leg_height@@YGMPAUVEC3D@@0H@Z@4JA DD 0320H ; `get_bridge_max_leg_height'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BO@LAGOEHEJ@BRIDGE?5?3?5No?5Valid?5Types?5Found@
CONST	SEGMENT
??_C@_0BO@LAGOEHEJ@BRIDGE?5?3?5No?5Valid?5Types?5Found@ DB 'BRIDGE : No V'
	DB	'alid Types Found', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOLJKOPJ@best_type?5?$CB?$DN?5?91@
CONST	SEGMENT
??_C@_0BA@FOLJKOPJ@best_type?5?$CB?$DN?5?91@ DB 'best_type != -1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@NBHJHDC@BRIDGE?3?5suitable?5type?5counter?5?$DN@
CONST	SEGMENT
??_C@_0EA@NBHJHDC@BRIDGE?3?5suitable?5type?5counter?5?$DN@ DB 'BRIDGE: su'
	DB	'itable type counter = %d, but no suitable types found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HLKEMMPI@end1?5?$CG?$CG?5end2@
CONST	SEGMENT
??_C@_0N@HLKEMMPI@end1?5?$CG?$CG?5end2@ DB 'end1 && end2', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??get_most_suitable_bridge_type@@YGHPAUVEC3D@@0M@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??get_most_suitable_bridge_type@@YGHPAUVEC3D@@0M@Z@4JA DD 023cH ; `get_most_suitable_bridge_type'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CB@MFJOCBNL@mid_section_pattern_length?5?$DO?50?4@
CONST	SEGMENT
??_C@_0CB@MFJOCBNL@mid_section_pattern_length?5?$DO?50?4@ DB 'mid_section'
	DB	'_pattern_length > 0.0', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??get_actual_bridge_length@@YGMPAUVEC3D@@0H00PAH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??get_actual_bridge_length@@YGMPAUVEC3D@@0H00PAH@Z@4JA DD 01ceH ; `get_actual_bridge_length'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FNDIHPEG@route?2bridge?4dat@
CONST	SEGMENT
??_C@_0BB@FNDIHPEG@route?2bridge?4dat@ DB 'route\bridge.dat', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??create_local_bridge_entities@@YGXW4PACK_MODES@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??create_local_bridge_entities@@YGXW4PACK_MODES@@@Z@4JA DD 016bH ; `create_local_bridge_entities'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DI@HECDIEBL@?$CI?5type?5?$DO?$DN?50?5?$CJ?5?$CG?$CG?5?$CI?5type?5?$DM?5NUM_E@
CONST	SEGMENT
??_C@_0DI@HECDIEBL@?$CI?5type?5?$DO?$DN?50?5?$CJ?5?$CG?$CG?5?$CI?5type?5?$DM?5NUM_E@ DB '('
	DB	' type >= 0 ) && ( type < NUM_ENTITY_SUB_TYPE_BRIDGES )', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z@4JA DD 0b3H ; `create_bridge'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@NHAOLFJJ@result?5?$DN?$DN?5FILE_TAG_TYPE@
CONST	SEGMENT
??_C@_0BI@NHAOLFJJ@result?5?$DN?$DN?5FILE_TAG_TYPE@ DB 'result == FILE_TA'
	DB	'G_TYPE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs@ DB '%s\%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OMLBFHIA@route?2bridge?4pop@
CONST	SEGMENT
??_C@_0BB@OMLBFHIA@route?2bridge?4pop@ DB 'route\bridge.pop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EEKIOPJL@get_valid_current_game_session?5@
CONST	SEGMENT
??_C@_0CC@EEKIOPJL@get_valid_current_game_session?5@ DB 'get_valid_curren'
	DB	't_game_session ()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
CONST	SEGMENT
??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@ DB 'c:\users\nh'
	DB	'v90\projects\eech\aphavoc\source\entity\special\bridge\bridge'
	DB	'.c', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??initialise_valid_warzone_bridge_database@@YGXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??initialise_valid_warzone_bridge_database@@YGXXZ@4JA DD 05dH ; `initialise_valid_warzone_bridge_database'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
;	COMDAT ??$max@M@std@@YGABMABM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@M@std@@YGABMABM0@Z PROC				; std::max<float>, COMDAT

; 5387 : 	{	// return larger of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5388 : 	if (_Left < _Right)

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00013	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00016	76 64		 jbe	 SHORT $LN8@max
$LN4@max:

; 5389 : 		{
; 5390 : 		_STL_ASSERT(!(_Right < _Left), "invalid comparator");

  00018	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00022	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00025	77 02		 ja	 SHORT $LN9@max
  00027	eb 4a		 jmp	 SHORT $LN6@max
$LN9@max:
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FEEMDEPI@invalid?5comparator@
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00033	6a 00		 push	 0
  00035	68 0e 15 00 00	 push	 5390			; 0000150eH
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  0003f	6a 02		 push	 2
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00047	83 c4 18	 add	 esp, 24			; 00000018H
  0004a	83 f8 01	 cmp	 eax, 1
  0004d	75 01		 jne	 SHORT $LN12@max
  0004f	cc		 int	 3
$LN12@max:
  00050	6a 00		 push	 0
  00052	68 0e 15 00 00	 push	 5390			; 0000150eH
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0006c	83 c4 14	 add	 esp, 20			; 00000014H
  0006f	33 c0		 xor	 eax, eax
  00071	75 b6		 jne	 SHORT $LN9@max
$LN6@max:
  00073	33 c0		 xor	 eax, eax
  00075	75 a1		 jne	 SHORT $LN4@max

; 5391 : 		return (_Right);

  00077	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0007a	eb 03		 jmp	 SHORT $LN1@max
$LN8@max:

; 5392 : 		}
; 5393 : 
; 5394 : 	return (_Left);

  0007c	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
$LN1@max:

; 5395 : 	}

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
??$max@M@std@@YGABMABM0@Z ENDP				; std::max<float>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\bridge\bridge.c
;	COMDAT ?get_actual_bridge_length@@YGMPAUVEC3D@@0H00PAH@Z
_TEXT	SEGMENT
_segment_type$ = -64					; size = 4
_mid_point$ = -60					; size = 12
_raw_vector$ = -48					; size = 12
_num_mid_sections$ = -36				; size = 4
_element_loop$ = -32					; size = 4
_mid_section_pattern_length$ = -28			; size = 4
_actual_length$ = -24					; size = 4
_raw_length$ = -20					; size = 4
_end_length$ = -16					; size = 4
_start_length$ = -12					; size = 4
_mid_length$ = -8					; size = 4
_bridge_info$ = -4					; size = 4
_end1$ = 8						; size = 4
_end2$ = 12						; size = 4
_type$ = 16						; size = 4
_actual_start$ = 20					; size = 4
_actual_end$ = 24					; size = 4
_return_num_mid_sections$ = 28				; size = 4
?get_actual_bridge_length@@YGMPAUVEC3D@@0H00PAH@Z PROC	; get_actual_bridge_length, COMDAT

; 462  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 463  : 	const bridge_data
; 464  : 		*bridge_info;
; 465  : 
; 466  : 	float
; 467  : 		mid_length,
; 468  : 		start_length,
; 469  : 		end_length,
; 470  : 		raw_length,
; 471  : 		actual_length,
; 472  : 		mid_section_pattern_length;
; 473  : 
; 474  : 	int
; 475  : 		element_loop,
; 476  : 		num_mid_sections;
; 477  : 
; 478  : 	vec3d
; 479  : 		raw_vector,
; 480  : 		mid_point;
; 481  : 
; 482  : 	bridge_segment_types
; 483  : 		segment_type;
; 484  : 
; 485  : 	ASSERT( ( type >= 0 ) && ( type < NUM_ENTITY_SUB_TYPE_BRIDGES ) );

  0000c	83 7d 10 00	 cmp	 DWORD PTR _type$[ebp], 0
  00010	7c 06		 jl	 SHORT $LN6@get_actual
  00012	83 7d 10 08	 cmp	 DWORD PTR _type$[ebp], 8
  00016	7c 18		 jl	 SHORT $LN5@get_actual
$LN6@get_actual:
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??get_actual_bridge_length@@YGMPAUVEC3D@@0H00PAH@Z@4JA
  0001d	83 c0 17	 add	 eax, 23			; 00000017H
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HECDIEBL@?$CI?5type?5?$DO?$DN?50?5?$CJ?5?$CG?$CG?5?$CI?5type?5?$DM?5NUM_E@
  0002b	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN5@get_actual:

; 486  : 
; 487  : 	bridge_info = &bridge_database[ type ];

  00030	6b 45 10 28	 imul	 eax, DWORD PTR _type$[ebp], 40
  00034	05 00 00 00 00	 add	 eax, OFFSET ?bridge_database@@3PAUBRIDGE_DATA@@A ; bridge_database
  00039	89 45 fc	 mov	 DWORD PTR _bridge_info$[ebp], eax

; 488  : 
; 489  : 	//
; 490  : 	// find the length of the mid section pattern
; 491  : 	//
; 492  : 
; 493  : 	mid_section_pattern_length = 0.0;

  0003c	0f 57 c0	 xorps	 xmm0, xmm0
  0003f	f3 0f 11 45 e4	 movss	 DWORD PTR _mid_section_pattern_length$[ebp], xmm0

; 494  : 
; 495  : 	for ( element_loop = 0 ; element_loop < bridge_info->num_elements_in_mid_section_pattern ; element_loop ++ )

  00044	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _element_loop$[ebp], 0
  0004b	eb 09		 jmp	 SHORT $LN4@get_actual
$LN2@get_actual:
  0004d	8b 45 e0	 mov	 eax, DWORD PTR _element_loop$[ebp]
  00050	83 c0 01	 add	 eax, 1
  00053	89 45 e0	 mov	 DWORD PTR _element_loop$[ebp], eax
$LN4@get_actual:
  00056	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _bridge_info$[ebp]
  0005e	66 23 41 20	 and	 ax, WORD PTR [ecx+32]
  00062	0f b7 d0	 movzx	 edx, ax
  00065	39 55 e0	 cmp	 DWORD PTR _element_loop$[ebp], edx
  00068	7d 27		 jge	 SHORT $LN3@get_actual

; 496  : 	{
; 497  : 		segment_type = bridge_info->mid_section_type[ element_loop ];

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _bridge_info$[ebp]
  0006d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00070	8b 55 e0	 mov	 edx, DWORD PTR _element_loop$[ebp]
  00073	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00076	89 45 c0	 mov	 DWORD PTR _segment_type$[ebp], eax

; 498  : 
; 499  : 		mid_section_pattern_length += bridge_segment_length( segment_type );

  00079	6b 45 c0 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  0007d	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _mid_section_pattern_length$[ebp]
  00082	f3 0f 58 80 18
	00 00 00	 addss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+24]
  0008a	f3 0f 11 45 e4	 movss	 DWORD PTR _mid_section_pattern_length$[ebp], xmm0

; 500  : 	}

  0008f	eb bc		 jmp	 SHORT $LN2@get_actual
$LN3@get_actual:

; 501  : 
; 502  : 	ASSERT( mid_section_pattern_length > 0.0 );

  00091	f3 0f 5a 45 e4	 cvtss2sd xmm0, DWORD PTR _mid_section_pattern_length$[ebp]
  00096	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  0009e	77 18		 ja	 SHORT $LN7@get_actual
  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??get_actual_bridge_length@@YGMPAUVEC3D@@0H00PAH@Z@4JA
  000a5	83 c0 28	 add	 eax, 40			; 00000028H
  000a8	50		 push	 eax
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MFJOCBNL@mid_section_pattern_length?5?$DO?50?4@
  000b3	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN7@get_actual:

; 503  : 
; 504  : 	//
; 505  : 	// find the length between the two points
; 506  : 	//
; 507  : 
; 508  : 	raw_vector.x = end2->x - end1->x;

  000b8	8b 45 0c	 mov	 eax, DWORD PTR _end2$[ebp]
  000bb	8b 4d 08	 mov	 ecx, DWORD PTR _end1$[ebp]
  000be	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000c2	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  000c6	f3 0f 11 45 d0	 movss	 DWORD PTR _raw_vector$[ebp], xmm0

; 509  : 	raw_vector.y = end2->y - end1->y;

  000cb	8b 45 0c	 mov	 eax, DWORD PTR _end2$[ebp]
  000ce	8b 4d 08	 mov	 ecx, DWORD PTR _end1$[ebp]
  000d1	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000d6	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  000db	f3 0f 11 45 d4	 movss	 DWORD PTR _raw_vector$[ebp+4], xmm0

; 510  : 	raw_vector.z = end2->z - end1->z;

  000e0	8b 45 0c	 mov	 eax, DWORD PTR _end2$[ebp]
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _end1$[ebp]
  000e6	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000eb	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  000f0	f3 0f 11 45 d8	 movss	 DWORD PTR _raw_vector$[ebp+8], xmm0

; 511  : 
; 512  : 	mid_point.x = end1->x + ( raw_vector.x * 0.5 );

  000f5	8b 45 08	 mov	 eax, DWORD PTR _end1$[ebp]
  000f8	f3 0f 5a 00	 cvtss2sd xmm0, DWORD PTR [eax]
  000fc	f3 0f 5a 4d d0	 cvtss2sd xmm1, DWORD PTR _raw_vector$[ebp]
  00101	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe0000000000000
  00109	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0010d	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00111	f3 0f 11 45 c4	 movss	 DWORD PTR _mid_point$[ebp], xmm0

; 513  : 	mid_point.y = end1->y + ( raw_vector.y * 0.5 );

  00116	8b 45 08	 mov	 eax, DWORD PTR _end1$[ebp]
  00119	f3 0f 5a 40 04	 cvtss2sd xmm0, DWORD PTR [eax+4]
  0011e	f3 0f 5a 4d d4	 cvtss2sd xmm1, DWORD PTR _raw_vector$[ebp+4]
  00123	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe0000000000000
  0012b	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0012f	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00133	f3 0f 11 45 c8	 movss	 DWORD PTR _mid_point$[ebp+4], xmm0

; 514  : 	mid_point.z = end1->z + ( raw_vector.z * 0.5 );

  00138	8b 45 08	 mov	 eax, DWORD PTR _end1$[ebp]
  0013b	f3 0f 5a 40 08	 cvtss2sd xmm0, DWORD PTR [eax+8]
  00140	f3 0f 5a 4d d8	 cvtss2sd xmm1, DWORD PTR _raw_vector$[ebp+8]
  00145	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe0000000000000
  0014d	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00151	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00155	f3 0f 11 45 cc	 movss	 DWORD PTR _mid_point$[ebp+8], xmm0

; 515  : 
; 516  : 	raw_length = normalise_3d_vector( &raw_vector );

  0015a	8d 45 d0	 lea	 eax, DWORD PTR _raw_vector$[ebp]
  0015d	50		 push	 eax
  0015e	e8 00 00 00 00	 call	 ?normalise_3d_vector@@YGMPAUVEC3D@@@Z ; normalise_3d_vector
  00163	d9 5d ec	 fstp	 DWORD PTR _raw_length$[ebp]

; 517  : 
; 518  : 	//
; 519  : 	// find the length left after the start and end sections are considered
; 520  : 	//
; 521  : 
; 522  : 	start_length = bridge_segment_length( bridge_info->start_section_type );

  00166	8b 45 fc	 mov	 eax, DWORD PTR _bridge_info$[ebp]
  00169	6b 08 28	 imul	 ecx, DWORD PTR [eax], 40
  0016c	f3 0f 10 81 18
	00 00 00	 movss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[ecx+24]
  00174	f3 0f 11 45 f4	 movss	 DWORD PTR _start_length$[ebp], xmm0

; 523  : 
; 524  : 	end_length = bridge_segment_length( bridge_info->end_section_type );

  00179	8b 45 fc	 mov	 eax, DWORD PTR _bridge_info$[ebp]
  0017c	6b 48 04 28	 imul	 ecx, DWORD PTR [eax+4], 40
  00180	f3 0f 10 81 18
	00 00 00	 movss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[ecx+24]
  00188	f3 0f 11 45 f0	 movss	 DWORD PTR _end_length$[ebp], xmm0

; 525  : 
; 526  : 	mid_length = raw_length - ( start_length * 0.5 );

  0018d	f3 0f 5a 45 ec	 cvtss2sd xmm0, DWORD PTR _raw_length$[ebp]
  00192	f3 0f 5a 4d f4	 cvtss2sd xmm1, DWORD PTR _start_length$[ebp]
  00197	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe0000000000000
  0019f	f2 0f 5c c1	 subsd	 xmm0, xmm1
  001a3	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001a7	f3 0f 11 45 f8	 movss	 DWORD PTR _mid_length$[ebp], xmm0

; 527  : 
; 528  : 	mid_length -= ( end_length * 0.5 );

  001ac	f3 0f 5a 45 f0	 cvtss2sd xmm0, DWORD PTR _end_length$[ebp]
  001b1	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  001b9	f3 0f 5a 4d f8	 cvtss2sd xmm1, DWORD PTR _mid_length$[ebp]
  001be	f2 0f 5c c8	 subsd	 xmm1, xmm0
  001c2	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  001c6	f3 0f 11 45 f8	 movss	 DWORD PTR _mid_length$[ebp], xmm0

; 529  : 
; 530  : 	if ( mid_length <= 0.0 )

  001cb	f3 0f 5a 45 f8	 cvtss2sd xmm0, DWORD PTR _mid_length$[ebp]
  001d0	0f 57 c9	 xorps	 xmm1, xmm1
  001d3	66 0f 2f c8	 comisd	 xmm1, xmm0
  001d7	72 09		 jb	 SHORT $LN8@get_actual

; 531  : 	{
; 532  : 		num_mid_sections = 0;

  001d9	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _num_mid_sections$[ebp], 0

; 533  : 	}
; 534  : 	else

  001e0	eb 14		 jmp	 SHORT $LN9@get_actual
$LN8@get_actual:

; 535  : 	{
; 536  : 		num_mid_sections = (int)( mid_length / mid_section_pattern_length ) + 1;

  001e2	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _mid_length$[ebp]
  001e7	f3 0f 5e 45 e4	 divss	 xmm0, DWORD PTR _mid_section_pattern_length$[ebp]
  001ec	f3 0f 2c c0	 cvttss2si eax, xmm0
  001f0	83 c0 01	 add	 eax, 1
  001f3	89 45 dc	 mov	 DWORD PTR _num_mid_sections$[ebp], eax
$LN9@get_actual:

; 537  : 	}
; 538  : 
; 539  : 	actual_length = ( start_length * 0.5 ) + ( end_length * 0.5 ) + ( mid_section_pattern_length * num_mid_sections );

  001f6	f3 0f 5a 45 f4	 cvtss2sd xmm0, DWORD PTR _start_length$[ebp]
  001fb	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00203	f3 0f 5a 4d f0	 cvtss2sd xmm1, DWORD PTR _end_length$[ebp]
  00208	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe0000000000000
  00210	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00214	f3 0f 2a 4d dc	 cvtsi2ss xmm1, DWORD PTR _num_mid_sections$[ebp]
  00219	f3 0f 59 4d e4	 mulss	 xmm1, DWORD PTR _mid_section_pattern_length$[ebp]
  0021e	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  00222	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00226	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0022a	f3 0f 11 45 e8	 movss	 DWORD PTR _actual_length$[ebp], xmm0

; 540  : 
; 541  : 	//
; 542  : 	// find actual start and end points
; 543  : 	//
; 544  : 
; 545  : 	if (actual_start)

  0022f	83 7d 14 00	 cmp	 DWORD PTR _actual_start$[ebp], 0
  00233	0f 84 80 00 00
	00		 je	 $LN10@get_actual

; 546  : 	{
; 547  : 		actual_start->x = mid_point.x - ( raw_vector.x * ( actual_length * 0.5 ) );

  00239	f3 0f 5a 45 c4	 cvtss2sd xmm0, DWORD PTR _mid_point$[ebp]
  0023e	f3 0f 5a 4d d0	 cvtss2sd xmm1, DWORD PTR _raw_vector$[ebp]
  00243	f3 0f 5a 55 e8	 cvtss2sd xmm2, DWORD PTR _actual_length$[ebp]
  00248	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR __real@3fe0000000000000
  00250	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00254	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00258	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0025c	8b 45 14	 mov	 eax, DWORD PTR _actual_start$[ebp]
  0025f	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 548  : 		actual_start->y = mid_point.y - ( raw_vector.y * ( actual_length * 0.5 ) );

  00263	f3 0f 5a 45 c8	 cvtss2sd xmm0, DWORD PTR _mid_point$[ebp+4]
  00268	f3 0f 5a 4d d4	 cvtss2sd xmm1, DWORD PTR _raw_vector$[ebp+4]
  0026d	f3 0f 5a 55 e8	 cvtss2sd xmm2, DWORD PTR _actual_length$[ebp]
  00272	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR __real@3fe0000000000000
  0027a	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0027e	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00282	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00286	8b 45 14	 mov	 eax, DWORD PTR _actual_start$[ebp]
  00289	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 549  : 		actual_start->z = mid_point.z - ( raw_vector.z * ( actual_length * 0.5 ) );

  0028e	f3 0f 5a 45 cc	 cvtss2sd xmm0, DWORD PTR _mid_point$[ebp+8]
  00293	f3 0f 5a 4d d8	 cvtss2sd xmm1, DWORD PTR _raw_vector$[ebp+8]
  00298	f3 0f 5a 55 e8	 cvtss2sd xmm2, DWORD PTR _actual_length$[ebp]
  0029d	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR __real@3fe0000000000000
  002a5	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  002a9	f2 0f 5c c1	 subsd	 xmm0, xmm1
  002ad	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  002b1	8b 45 14	 mov	 eax, DWORD PTR _actual_start$[ebp]
  002b4	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
$LN10@get_actual:

; 550  : 	}
; 551  : 
; 552  : 	if (actual_end)

  002b9	83 7d 18 00	 cmp	 DWORD PTR _actual_end$[ebp], 0
  002bd	0f 84 80 00 00
	00		 je	 $LN11@get_actual

; 553  : 	{
; 554  : 		actual_end->x = mid_point.x + ( raw_vector.x * ( actual_length * 0.5 ) );

  002c3	f3 0f 5a 45 c4	 cvtss2sd xmm0, DWORD PTR _mid_point$[ebp]
  002c8	f3 0f 5a 4d d0	 cvtss2sd xmm1, DWORD PTR _raw_vector$[ebp]
  002cd	f3 0f 5a 55 e8	 cvtss2sd xmm2, DWORD PTR _actual_length$[ebp]
  002d2	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR __real@3fe0000000000000
  002da	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  002de	f2 0f 58 c1	 addsd	 xmm0, xmm1
  002e2	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  002e6	8b 45 18	 mov	 eax, DWORD PTR _actual_end$[ebp]
  002e9	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 555  : 		actual_end->y = mid_point.y + ( raw_vector.y * ( actual_length * 0.5 ) );

  002ed	f3 0f 5a 45 c8	 cvtss2sd xmm0, DWORD PTR _mid_point$[ebp+4]
  002f2	f3 0f 5a 4d d4	 cvtss2sd xmm1, DWORD PTR _raw_vector$[ebp+4]
  002f7	f3 0f 5a 55 e8	 cvtss2sd xmm2, DWORD PTR _actual_length$[ebp]
  002fc	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR __real@3fe0000000000000
  00304	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00308	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0030c	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00310	8b 45 18	 mov	 eax, DWORD PTR _actual_end$[ebp]
  00313	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 556  : 		actual_end->z = mid_point.z + ( raw_vector.z * ( actual_length * 0.5 ) );

  00318	f3 0f 5a 45 cc	 cvtss2sd xmm0, DWORD PTR _mid_point$[ebp+8]
  0031d	f3 0f 5a 4d d8	 cvtss2sd xmm1, DWORD PTR _raw_vector$[ebp+8]
  00322	f3 0f 5a 55 e8	 cvtss2sd xmm2, DWORD PTR _actual_length$[ebp]
  00327	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR __real@3fe0000000000000
  0032f	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00333	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00337	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0033b	8b 45 18	 mov	 eax, DWORD PTR _actual_end$[ebp]
  0033e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
$LN11@get_actual:

; 557  : 	}
; 558  : 
; 559  : 	if (return_num_mid_sections)

  00343	83 7d 1c 00	 cmp	 DWORD PTR _return_num_mid_sections$[ebp], 0
  00347	74 08		 je	 SHORT $LN12@get_actual

; 560  : 	{
; 561  : 		(*return_num_mid_sections) = num_mid_sections;

  00349	8b 45 1c	 mov	 eax, DWORD PTR _return_num_mid_sections$[ebp]
  0034c	8b 4d dc	 mov	 ecx, DWORD PTR _num_mid_sections$[ebp]
  0034f	89 08		 mov	 DWORD PTR [eax], ecx
$LN12@get_actual:

; 562  : 	}
; 563  : 
; 564  : 	return actual_length;

  00351	d9 45 e8	 fld	 DWORD PTR _actual_length$[ebp]

; 565  : }

  00354	5f		 pop	 edi
  00355	5e		 pop	 esi
  00356	5b		 pop	 ebx
  00357	8b e5		 mov	 esp, ebp
  00359	5d		 pop	 ebp
  0035a	c2 18 00	 ret	 24			; 00000018H
?get_actual_bridge_length@@YGMPAUVEC3D@@0H00PAH@Z ENDP	; get_actual_bridge_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\bridge\bridge.c
;	COMDAT ?repair_local_bridge_entity@@YGXPAUENTITY@@@Z
_TEXT	SEGMENT
tv197 = -88						; size = 4
tv177 = -88						; size = 4
tv157 = -88						; size = 4
tv137 = -88						; size = 4
tv83 = -88						; size = 4
tv189 = -84						; size = 4
tv169 = -84						; size = 4
tv149 = -84						; size = 4
tv129 = -84						; size = 4
tv75 = -84						; size = 4
_segment$ = -16						; size = 4
_count$ = -12						; size = 4
_end_node$ = -8						; size = 4
_start_node$ = -4					; size = 4
_en$ = 8						; size = 4
?repair_local_bridge_entity@@YGXPAUENTITY@@@Z PROC	; repair_local_bridge_entity, COMDAT

; 891  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 892  : 
; 893  : 	int
; 894  : 		start_node,
; 895  : 		end_node,
; 896  : 		count;
; 897  : 
; 898  : 	entity
; 899  : 		*segment;
; 900  : 
; 901  : 	ASSERT (en);

  00009	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN4@repair_loc
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA
  00014	83 c0 0a	 add	 eax, 10			; 0000000aH
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02LFNMGJAP@en@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN4@repair_loc:

; 902  : 
; 903  : 	//
; 904  : 	// repair segments
; 905  : 	//
; 906  : 
; 907  : 	segment = get_local_entity_first_child (en, LIST_TYPE_SEGMENT);

  00027	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  0002b	74 0a		 je	 SHORT $LN6@repair_loc
  0002d	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	89 4d ac	 mov	 DWORD PTR tv75[ebp], ecx
  00035	eb 21		 jmp	 SHORT $LN7@repair_loc
$LN6@repair_loc:
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA
  0003d	83 c2 10	 add	 edx, 16			; 00000010H
  00040	52		 push	 edx
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00051	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN7@repair_loc:
  00058	b9 01 00 00 00	 mov	 ecx, 1
  0005d	85 c9		 test	 ecx, ecx
  0005f	74 09		 je	 SHORT $LN8@repair_loc
  00061	c7 45 a8 23 00
	00 00		 mov	 DWORD PTR tv83[ebp], 35	; 00000023H
  00068	eb 21		 jmp	 SHORT $LN9@repair_loc
$LN8@repair_loc:
  0006a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA
  00070	83 c2 10	 add	 edx, 16			; 00000010H
  00073	52		 push	 edx
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00084	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$LN9@repair_loc:
  0008b	6a 23		 push	 35			; 00000023H
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  00090	51		 push	 ecx
  00091	69 55 ac b4 00
	00 00		 imul	 edx, DWORD PTR tv75[ebp], 180
  00098	8b 45 a8	 mov	 eax, DWORD PTR tv83[ebp]
  0009b	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_first_child@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  000a2	ff d1		 call	 ecx
  000a4	89 45 f0	 mov	 DWORD PTR _segment$[ebp], eax
$LN2@repair_loc:

; 908  : 
; 909  : 	while (segment)

  000a7	83 7d f0 00	 cmp	 DWORD PTR _segment$[ebp], 0
  000ab	0f 84 8e 00 00
	00		 je	 $LN3@repair_loc

; 910  : 	{
; 911  : 		repair_local_segment_entity (segment);

  000b1	8b 45 f0	 mov	 eax, DWORD PTR _segment$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?repair_local_segment_entity@@YGXPAUENTITY@@@Z ; repair_local_segment_entity

; 912  : 
; 913  : 		segment = get_local_entity_child_succ (segment, LIST_TYPE_SEGMENT);

  000ba	83 7d f0 00	 cmp	 DWORD PTR _segment$[ebp], 0
  000be	74 0a		 je	 SHORT $LN10@repair_loc
  000c0	8b 45 f0	 mov	 eax, DWORD PTR _segment$[ebp]
  000c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c5	89 4d ac	 mov	 DWORD PTR tv129[ebp], ecx
  000c8	eb 21		 jmp	 SHORT $LN11@repair_loc
$LN10@repair_loc:
  000ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA
  000d0	83 c2 16	 add	 edx, 22			; 00000016H
  000d3	52		 push	 edx
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  000e4	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
$LN11@repair_loc:
  000eb	b9 01 00 00 00	 mov	 ecx, 1
  000f0	85 c9		 test	 ecx, ecx
  000f2	74 09		 je	 SHORT $LN12@repair_loc
  000f4	c7 45 a8 23 00
	00 00		 mov	 DWORD PTR tv137[ebp], 35 ; 00000023H
  000fb	eb 21		 jmp	 SHORT $LN13@repair_loc
$LN12@repair_loc:
  000fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA
  00103	83 c2 16	 add	 edx, 22			; 00000016H
  00106	52		 push	 edx
  00107	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  0010c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_list_type_message@@3PBDB ; overload_invalid_list_type_message
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00117	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], 0
$LN13@repair_loc:
  0011e	6a 23		 push	 35			; 00000023H
  00120	8b 4d f0	 mov	 ecx, DWORD PTR _segment$[ebp]
  00123	51		 push	 ecx
  00124	69 55 ac b4 00
	00 00		 imul	 edx, DWORD PTR tv129[ebp], 180
  0012b	8b 45 a8	 mov	 eax, DWORD PTR tv137[ebp]
  0012e	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_child_succ@@3PAY0CN@P6GPAUENTITY@@PAU1@W4LIST_TYPES@@@ZA[edx+eax*4]
  00135	ff d1		 call	 ecx
  00137	89 45 f0	 mov	 DWORD PTR _segment$[ebp], eax

; 914  : 	}

  0013a	e9 68 ff ff ff	 jmp	 $LN2@repair_loc
$LN3@repair_loc:

; 915  : 
; 916  : 	//
; 917  : 	// set bridge alive flag
; 918  : 	//
; 919  : 
; 920  : 	set_local_entity_int_value (en, INT_TYPE_ALIVE, TRUE);

  0013f	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  00143	74 0a		 je	 SHORT $LN14@repair_loc
  00145	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00148	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014a	89 4d ac	 mov	 DWORD PTR tv149[ebp], ecx
  0014d	eb 21		 jmp	 SHORT $LN15@repair_loc
$LN14@repair_loc:
  0014f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA
  00155	83 c2 1d	 add	 edx, 29			; 0000001dH
  00158	52		 push	 edx
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  0015e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  00169	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv149[ebp], 0
$LN15@repair_loc:
  00170	b9 01 00 00 00	 mov	 ecx, 1
  00175	85 c9		 test	 ecx, ecx
  00177	74 09		 je	 SHORT $LN16@repair_loc
  00179	c7 45 a8 07 00
	00 00		 mov	 DWORD PTR tv157[ebp], 7
  00180	eb 21		 jmp	 SHORT $LN17@repair_loc
$LN16@repair_loc:
  00182	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA
  00188	83 c2 1d	 add	 edx, 29			; 0000001dH
  0018b	52		 push	 edx
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00191	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0019c	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv157[ebp], 0
$LN17@repair_loc:
  001a3	6a 01		 push	 1
  001a5	6a 07		 push	 7
  001a7	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  001aa	51		 push	 ecx
  001ab	69 55 ac 5c 04
	00 00		 imul	 edx, DWORD PTR tv149[ebp], 1116
  001b2	8b 45 a8	 mov	 eax, DWORD PTR tv157[ebp]
  001b5	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_set_local_entity_int_value@@3PAY0BBH@P6GXPAUENTITY@@W4INT_TYPES@@H@ZA[edx+eax*4]
  001bc	ff d1		 call	 ecx

; 921  : 
; 922  : 	//
; 923  : 	// repair the link between nodes
; 924  : 	//
; 925  : 
; 926  : 	start_node = get_local_entity_int_value (en, INT_TYPE_START_NODE);

  001be	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  001c2	74 0a		 je	 SHORT $LN18@repair_loc
  001c4	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  001c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c9	89 4d ac	 mov	 DWORD PTR tv169[ebp], ecx
  001cc	eb 21		 jmp	 SHORT $LN19@repair_loc
$LN18@repair_loc:
  001ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA
  001d4	83 c2 23	 add	 edx, 35			; 00000023H
  001d7	52		 push	 edx
  001d8	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  001dd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  001e2	50		 push	 eax
  001e3	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  001e8	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv169[ebp], 0
$LN19@repair_loc:
  001ef	b9 01 00 00 00	 mov	 ecx, 1
  001f4	85 c9		 test	 ecx, ecx
  001f6	74 09		 je	 SHORT $LN20@repair_loc
  001f8	c7 45 a8 ca 00
	00 00		 mov	 DWORD PTR tv177[ebp], 202 ; 000000caH
  001ff	eb 21		 jmp	 SHORT $LN21@repair_loc
$LN20@repair_loc:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA
  00207	83 c2 23	 add	 edx, 35			; 00000023H
  0020a	52		 push	 edx
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00210	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  00215	50		 push	 eax
  00216	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0021b	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv177[ebp], 0
$LN21@repair_loc:
  00222	68 ca 00 00 00	 push	 202			; 000000caH
  00227	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  0022a	51		 push	 ecx
  0022b	69 55 ac 5c 04
	00 00		 imul	 edx, DWORD PTR tv169[ebp], 1116
  00232	8b 45 a8	 mov	 eax, DWORD PTR tv177[ebp]
  00235	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[edx+eax*4]
  0023c	ff d1		 call	 ecx
  0023e	89 45 fc	 mov	 DWORD PTR _start_node$[ebp], eax

; 927  : 
; 928  : 	end_node = get_local_entity_int_value (en, INT_TYPE_END_NODE);

  00241	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  00245	74 0a		 je	 SHORT $LN22@repair_loc
  00247	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  0024a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024c	89 4d ac	 mov	 DWORD PTR tv189[ebp], ecx
  0024f	eb 21		 jmp	 SHORT $LN23@repair_loc
$LN22@repair_loc:
  00251	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA
  00257	83 c2 25	 add	 edx, 37			; 00000025H
  0025a	52		 push	 edx
  0025b	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00260	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0026b	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv189[ebp], 0
$LN23@repair_loc:
  00272	b9 01 00 00 00	 mov	 ecx, 1
  00277	85 c9		 test	 ecx, ecx
  00279	74 09		 je	 SHORT $LN24@repair_loc
  0027b	c7 45 a8 32 00
	00 00		 mov	 DWORD PTR tv197[ebp], 50 ; 00000032H
  00282	eb 21		 jmp	 SHORT $LN25@repair_loc
$LN24@repair_loc:
  00284	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??repair_local_bridge_entity@@YGXPAUENTITY@@@Z@4JA
  0028a	83 c2 25	 add	 edx, 37			; 00000025H
  0028d	52		 push	 edx
  0028e	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00293	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_int_type_message@@3PBDB ; overload_invalid_int_type_message
  00298	50		 push	 eax
  00299	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0029e	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv197[ebp], 0
$LN25@repair_loc:
  002a5	6a 32		 push	 50			; 00000032H
  002a7	8b 4d 08	 mov	 ecx, DWORD PTR _en$[ebp]
  002aa	51		 push	 ecx
  002ab	69 55 ac 5c 04
	00 00		 imul	 edx, DWORD PTR tv189[ebp], 1116
  002b2	8b 45 a8	 mov	 eax, DWORD PTR tv197[ebp]
  002b5	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_get_local_entity_int_value@@3PAY0BBH@P6GHPAUENTITY@@W4INT_TYPES@@@ZA[edx+eax*4]
  002bc	ff d1		 call	 ecx
  002be	89 45 f8	 mov	 DWORD PTR _end_node$[ebp], eax

; 929  : 
; 930  : 	count = get_road_link_breaks (start_node, end_node);

  002c1	8b 45 f8	 mov	 eax, DWORD PTR _end_node$[ebp]
  002c4	50		 push	 eax
  002c5	8b 4d fc	 mov	 ecx, DWORD PTR _start_node$[ebp]
  002c8	51		 push	 ecx
  002c9	e8 00 00 00 00	 call	 ?get_road_link_breaks@@YGHHH@Z ; get_road_link_breaks
  002ce	89 45 f4	 mov	 DWORD PTR _count$[ebp], eax

; 931  : 
; 932  : 	count --;

  002d1	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  002d4	83 e8 01	 sub	 eax, 1
  002d7	89 45 f4	 mov	 DWORD PTR _count$[ebp], eax

; 933  : 
; 934  : 	set_road_link_breaks (start_node, end_node, count);

  002da	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  002dd	50		 push	 eax
  002de	8b 4d f8	 mov	 ecx, DWORD PTR _end_node$[ebp]
  002e1	51		 push	 ecx
  002e2	8b 55 fc	 mov	 edx, DWORD PTR _start_node$[ebp]
  002e5	52		 push	 edx
  002e6	e8 00 00 00 00	 call	 ?set_road_link_breaks@@YGHHHH@Z ; set_road_link_breaks

; 935  : 
; 936  : 	debug_log ("BRIDGE: Repairin bridge and route between %d and %d... broken bridge count = %d", count);

  002eb	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  002ee	50		 push	 eax
  002ef	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@GFPAOEKN@BRIDGE?3?5Repairin?5bridge?5and?5rou@
  002f4	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  002f9	83 c4 08	 add	 esp, 8

; 937  : }

  002fc	5f		 pop	 edi
  002fd	5e		 pop	 esi
  002fe	5b		 pop	 ebx
  002ff	8b e5		 mov	 esp, ebp
  00301	5d		 pop	 ebp
  00302	c2 04 00	 ret	 4
?repair_local_bridge_entity@@YGXPAUENTITY@@@Z ENDP	; repair_local_bridge_entity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\bridge\bridge.c
;	COMDAT ?repair_client_server_bridge_entity@@YGXPAUENTITY@@@Z
_TEXT	SEGMENT
_en$ = 8						; size = 4
?repair_client_server_bridge_entity@@YGXPAUENTITY@@@Z PROC ; repair_client_server_bridge_entity, COMDAT

; 876  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 877  : 	ASSERT (en);

  00009	83 7d 08 00	 cmp	 DWORD PTR _en$[ebp], 0
  0000d	75 18		 jne	 SHORT $LN2@repair_cli
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??repair_client_server_bridge_entity@@YGXPAUENTITY@@@Z@4JA
  00014	83 c0 01	 add	 eax, 1
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02LFNMGJAP@en@
  00022	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN2@repair_cli:

; 878  : 
; 879  : 	ASSERT (get_comms_model () == COMMS_MODEL_SERVER);

  00027	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?system_comms_model@@3W4COMMS_MODEL_TYPES@@A, 0 ; system_comms_model
  0002e	74 18		 je	 SHORT $LN3@repair_cli
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??repair_client_server_bridge_entity@@YGXPAUENTITY@@@Z@4JA
  00035	83 c0 03	 add	 eax, 3
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DMBLBJBK@get_comms_model?5?$CI?$CJ?5?$DN?$DN?5COMMS_MOD@
  00043	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN3@repair_cli:

; 880  : 
; 881  : 	repair_local_bridge_entity (en);

  00048	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?repair_local_bridge_entity@@YGXPAUENTITY@@@Z ; repair_local_bridge_entity

; 882  : 
; 883  : 	transmit_entity_comms_message (ENTITY_COMMS_REPAIR_BRIDGE_ENTITY, en);

  00051	8b 45 08	 mov	 eax, DWORD PTR _en$[ebp]
  00054	50		 push	 eax
  00055	6a 2a		 push	 42			; 0000002aH
  00057	e8 00 00 00 00	 call	 ?transmit_entity_comms_message@@YAXW4ENTITY_COMMS_MESSAGES@@PAUENTITY@@ZZ ; transmit_entity_comms_message
  0005c	83 c4 08	 add	 esp, 8

; 884  : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?repair_client_server_bridge_entity@@YGXPAUENTITY@@@Z ENDP ; repair_client_server_bridge_entity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\bridge\bridge.c
;	COMDAT ?get_bridge_max_leg_height@@YGMPAUVEC3D@@0H@Z
_TEXT	SEGMENT
tv294 = -152						; size = 4
$T1 = -148						; size = 4
_segment_type$ = -80					; size = 4
_raw_vector$ = -76					; size = 12
_pos$ = -64						; size = 12
_end$ = -52						; size = 12
_start$ = -40						; size = 12
_num_mid_sections$ = -28				; size = 4
_section_loop$ = -24					; size = 4
_element_loop$ = -20					; size = 4
_max_leg_height$ = -16					; size = 4
_actual_length$ = -12					; size = 4
_start_length$ = -8					; size = 4
_bridge_info$ = -4					; size = 4
_end1$ = 8						; size = 4
_end2$ = 12						; size = 4
_type$ = 16						; size = 4
?get_bridge_max_leg_height@@YGMPAUVEC3D@@0H@Z PROC	; get_bridge_max_leg_height, COMDAT

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 801  : 
; 802  : 	const bridge_data
; 803  : 		*bridge_info;
; 804  : 
; 805  : 	float
; 806  : 		start_length,
; 807  : 		actual_length,
; 808  : 		max_leg_height;
; 809  : 
; 810  : 	int
; 811  : 		element_loop,
; 812  : 		section_loop,
; 813  : 		num_mid_sections;
; 814  : 
; 815  : 	vec3d
; 816  : 		start,
; 817  : 		end,
; 818  : 		pos,
; 819  : 		raw_vector;
; 820  : 
; 821  : 	bridge_segment_types
; 822  : 		segment_type;
; 823  : 
; 824  : 	ASSERT( ( type >= 0 ) && ( type < NUM_ENTITY_SUB_TYPE_BRIDGES ) );

  0000c	83 7d 10 00	 cmp	 DWORD PTR _type$[ebp], 0
  00010	7c 06		 jl	 SHORT $LN9@get_bridge
  00012	83 7d 10 08	 cmp	 DWORD PTR _type$[ebp], 8
  00016	7c 18		 jl	 SHORT $LN8@get_bridge
$LN9@get_bridge:
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??get_bridge_max_leg_height@@YGMPAUVEC3D@@0H@Z@4JA
  0001d	83 c0 18	 add	 eax, 24			; 00000018H
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HECDIEBL@?$CI?5type?5?$DO?$DN?50?5?$CJ?5?$CG?$CG?5?$CI?5type?5?$DM?5NUM_E@
  0002b	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN8@get_bridge:

; 825  : 
; 826  : 	bridge_info = &bridge_database[ type ];

  00030	6b 45 10 28	 imul	 eax, DWORD PTR _type$[ebp], 40
  00034	05 00 00 00 00	 add	 eax, OFFSET ?bridge_database@@3PAUBRIDGE_DATA@@A ; bridge_database
  00039	89 45 fc	 mov	 DWORD PTR _bridge_info$[ebp], eax

; 827  : 
; 828  : 	max_leg_height = 0.0;

  0003c	0f 57 c0	 xorps	 xmm0, xmm0
  0003f	f3 0f 11 45 f0	 movss	 DWORD PTR _max_leg_height$[ebp], xmm0

; 829  : 
; 830  : 	//
; 831  : 	// get adjusted start and end points
; 832  : 	//
; 833  : 
; 834  : 	actual_length = get_actual_bridge_length (end1, end2, type, &start, &end, &num_mid_sections);

  00044	8d 45 e4	 lea	 eax, DWORD PTR _num_mid_sections$[ebp]
  00047	50		 push	 eax
  00048	8d 4d cc	 lea	 ecx, DWORD PTR _end$[ebp]
  0004b	51		 push	 ecx
  0004c	8d 55 d8	 lea	 edx, DWORD PTR _start$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 10	 mov	 eax, DWORD PTR _type$[ebp]
  00053	50		 push	 eax
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _end2$[ebp]
  00057	51		 push	 ecx
  00058	8b 55 08	 mov	 edx, DWORD PTR _end1$[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 ?get_actual_bridge_length@@YGMPAUVEC3D@@0H00PAH@Z ; get_actual_bridge_length
  00061	d9 5d f4	 fstp	 DWORD PTR _actual_length$[ebp]

; 835  : 
; 836  : 	raw_vector.x = end2->x - end1->x;

  00064	8b 45 0c	 mov	 eax, DWORD PTR _end2$[ebp]
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _end1$[ebp]
  0006a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0006e	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00072	f3 0f 11 45 b4	 movss	 DWORD PTR _raw_vector$[ebp], xmm0

; 837  : 	raw_vector.y = end2->y - end1->y;

  00077	8b 45 0c	 mov	 eax, DWORD PTR _end2$[ebp]
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _end1$[ebp]
  0007d	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00082	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00087	f3 0f 11 45 b8	 movss	 DWORD PTR _raw_vector$[ebp+4], xmm0

; 838  : 	raw_vector.z = end2->z - end1->z;

  0008c	8b 45 0c	 mov	 eax, DWORD PTR _end2$[ebp]
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _end1$[ebp]
  00092	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00097	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0009c	f3 0f 11 45 bc	 movss	 DWORD PTR _raw_vector$[ebp+8], xmm0

; 839  : 
; 840  : 	normalise_3d_vector( &raw_vector );

  000a1	8d 45 b4	 lea	 eax, DWORD PTR _raw_vector$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?normalise_3d_vector@@YGMPAUVEC3D@@@Z ; normalise_3d_vector
  000aa	dd d8		 fstp	 ST(0)

; 841  : 
; 842  : 	start_length = bridge_segment_length( bridge_info->start_section_type );

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _bridge_info$[ebp]
  000af	6b 08 28	 imul	 ecx, DWORD PTR [eax], 40
  000b2	f3 0f 10 81 18
	00 00 00	 movss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[ecx+24]
  000ba	f3 0f 11 45 f8	 movss	 DWORD PTR _start_length$[ebp], xmm0

; 843  : 
; 844  : 	pos.x = start.x + ( raw_vector.x * start_length * 0.5 );

  000bf	f3 0f 5a 45 d8	 cvtss2sd xmm0, DWORD PTR _start$[ebp]
  000c4	f3 0f 10 4d b4	 movss	 xmm1, DWORD PTR _raw_vector$[ebp]
  000c9	f3 0f 59 4d f8	 mulss	 xmm1, DWORD PTR _start_length$[ebp]
  000ce	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  000d2	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe0000000000000
  000da	f2 0f 58 c1	 addsd	 xmm0, xmm1
  000de	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  000e2	f3 0f 11 45 c0	 movss	 DWORD PTR _pos$[ebp], xmm0

; 845  : 	pos.y = start.y + ( raw_vector.y * start_length * 0.5 );

  000e7	f3 0f 5a 45 dc	 cvtss2sd xmm0, DWORD PTR _start$[ebp+4]
  000ec	f3 0f 10 4d b8	 movss	 xmm1, DWORD PTR _raw_vector$[ebp+4]
  000f1	f3 0f 59 4d f8	 mulss	 xmm1, DWORD PTR _start_length$[ebp]
  000f6	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  000fa	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe0000000000000
  00102	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00106	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0010a	f3 0f 11 45 c4	 movss	 DWORD PTR _pos$[ebp+4], xmm0

; 846  : 	pos.z = start.z + ( raw_vector.z * start_length * 0.5 );

  0010f	f3 0f 5a 45 e0	 cvtss2sd xmm0, DWORD PTR _start$[ebp+8]
  00114	f3 0f 10 4d bc	 movss	 xmm1, DWORD PTR _raw_vector$[ebp+8]
  00119	f3 0f 59 4d f8	 mulss	 xmm1, DWORD PTR _start_length$[ebp]
  0011e	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  00122	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe0000000000000
  0012a	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0012e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00132	f3 0f 11 45 c8	 movss	 DWORD PTR _pos$[ebp+8], xmm0

; 847  : 
; 848  : 	for ( section_loop = 0 ; section_loop < num_mid_sections ; section_loop ++ )

  00137	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _section_loop$[ebp], 0
  0013e	eb 09		 jmp	 SHORT $LN4@get_bridge
$LN2@get_bridge:
  00140	8b 45 e8	 mov	 eax, DWORD PTR _section_loop$[ebp]
  00143	83 c0 01	 add	 eax, 1
  00146	89 45 e8	 mov	 DWORD PTR _section_loop$[ebp], eax
$LN4@get_bridge:
  00149	8b 45 e8	 mov	 eax, DWORD PTR _section_loop$[ebp]
  0014c	3b 45 e4	 cmp	 eax, DWORD PTR _num_mid_sections$[ebp]
  0014f	0f 8d ae 01 00
	00		 jge	 $LN3@get_bridge

; 849  : 	{
; 850  : 
; 851  : 		for ( element_loop = 0 ; element_loop < bridge_info->num_elements_in_mid_section_pattern ; element_loop ++ )

  00155	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _element_loop$[ebp], 0
  0015c	eb 09		 jmp	 SHORT $LN7@get_bridge
$LN5@get_bridge:
  0015e	8b 45 ec	 mov	 eax, DWORD PTR _element_loop$[ebp]
  00161	83 c0 01	 add	 eax, 1
  00164	89 45 ec	 mov	 DWORD PTR _element_loop$[ebp], eax
$LN7@get_bridge:
  00167	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0016c	8b 4d fc	 mov	 ecx, DWORD PTR _bridge_info$[ebp]
  0016f	66 23 41 20	 and	 ax, WORD PTR [ecx+32]
  00173	0f b7 d0	 movzx	 edx, ax
  00176	39 55 ec	 cmp	 DWORD PTR _element_loop$[ebp], edx
  00179	0f 8d 7f 01 00
	00		 jge	 $LN6@get_bridge

; 852  : 		{
; 853  : 
; 854  : 			segment_type = bridge_info->mid_section_type[ element_loop ];

  0017f	8b 45 fc	 mov	 eax, DWORD PTR _bridge_info$[ebp]
  00182	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00185	8b 55 ec	 mov	 edx, DWORD PTR _element_loop$[ebp]
  00188	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0018b	89 45 b0	 mov	 DWORD PTR _segment_type$[ebp], eax

; 855  : 
; 856  : 			pos.x += ( raw_vector.x * bridge_segment_length( segment_type ) * 0.5 );

  0018e	6b 45 b0 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  00192	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _raw_vector$[ebp]
  00197	f3 0f 59 80 18
	00 00 00	 mulss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+24]
  0019f	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  001a3	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  001ab	f3 0f 5a 4d c0	 cvtss2sd xmm1, DWORD PTR _pos$[ebp]
  001b0	f2 0f 58 c8	 addsd	 xmm1, xmm0
  001b4	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  001b8	f3 0f 11 45 c0	 movss	 DWORD PTR _pos$[ebp], xmm0

; 857  : 			pos.y += ( raw_vector.y * bridge_segment_length( segment_type ) * 0.5 );

  001bd	6b 45 b0 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  001c1	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _raw_vector$[ebp+4]
  001c6	f3 0f 59 80 18
	00 00 00	 mulss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+24]
  001ce	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  001d2	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  001da	f3 0f 5a 4d c4	 cvtss2sd xmm1, DWORD PTR _pos$[ebp+4]
  001df	f2 0f 58 c8	 addsd	 xmm1, xmm0
  001e3	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  001e7	f3 0f 11 45 c4	 movss	 DWORD PTR _pos$[ebp+4], xmm0

; 858  : 			pos.z += ( raw_vector.z * bridge_segment_length( segment_type ) * 0.5 );

  001ec	6b 45 b0 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  001f0	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _raw_vector$[ebp+8]
  001f5	f3 0f 59 80 18
	00 00 00	 mulss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+24]
  001fd	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00201	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00209	f3 0f 5a 4d c8	 cvtss2sd xmm1, DWORD PTR _pos$[ebp+8]
  0020e	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00212	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  00216	f3 0f 11 45 c8	 movss	 DWORD PTR _pos$[ebp+8], xmm0

; 859  : 
; 860  : 			max_leg_height = max( max_leg_height, ( pos.y - get_3d_terrain_elevation( pos.x, pos.z ) ) );

  0021b	6a 00		 push	 0
  0021d	51		 push	 ecx
  0021e	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _pos$[ebp+8]
  00223	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00228	51		 push	 ecx
  00229	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _pos$[ebp]
  0022e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00233	e8 00 00 00 00	 call	 ?get_3d_terrain_point_data@@YGMMMPAUTERRAIN_3D_POINT_DATA@@@Z ; get_3d_terrain_point_data
  00238	d9 9d 68 ff ff
	ff		 fstp	 DWORD PTR tv294[ebp]
  0023e	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  00243	f3 0f 5c 85 68
	ff ff ff	 subss	 xmm0, DWORD PTR tv294[ebp]
  0024b	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR $T1[ebp], xmm0
  00253	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00259	50		 push	 eax
  0025a	8d 4d f0	 lea	 ecx, DWORD PTR _max_leg_height$[ebp]
  0025d	51		 push	 ecx
  0025e	e8 00 00 00 00	 call	 ??$max@M@std@@YGABMABM0@Z ; std::max<float>
  00263	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00267	f3 0f 11 45 f0	 movss	 DWORD PTR _max_leg_height$[ebp], xmm0

; 861  : 
; 862  : 			pos.x += ( raw_vector.x * bridge_segment_length( segment_type ) * 0.5 );

  0026c	6b 45 b0 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  00270	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _raw_vector$[ebp]
  00275	f3 0f 59 80 18
	00 00 00	 mulss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+24]
  0027d	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00281	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00289	f3 0f 5a 4d c0	 cvtss2sd xmm1, DWORD PTR _pos$[ebp]
  0028e	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00292	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  00296	f3 0f 11 45 c0	 movss	 DWORD PTR _pos$[ebp], xmm0

; 863  : 			pos.y += ( raw_vector.y * bridge_segment_length( segment_type ) * 0.5 );

  0029b	6b 45 b0 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  0029f	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _raw_vector$[ebp+4]
  002a4	f3 0f 59 80 18
	00 00 00	 mulss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+24]
  002ac	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  002b0	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  002b8	f3 0f 5a 4d c4	 cvtss2sd xmm1, DWORD PTR _pos$[ebp+4]
  002bd	f2 0f 58 c8	 addsd	 xmm1, xmm0
  002c1	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  002c5	f3 0f 11 45 c4	 movss	 DWORD PTR _pos$[ebp+4], xmm0

; 864  : 			pos.z += ( raw_vector.z * bridge_segment_length( segment_type ) * 0.5 );

  002ca	6b 45 b0 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  002ce	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _raw_vector$[ebp+8]
  002d3	f3 0f 59 80 18
	00 00 00	 mulss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+24]
  002db	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  002df	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  002e7	f3 0f 5a 4d c8	 cvtss2sd xmm1, DWORD PTR _pos$[ebp+8]
  002ec	f2 0f 58 c8	 addsd	 xmm1, xmm0
  002f0	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  002f4	f3 0f 11 45 c8	 movss	 DWORD PTR _pos$[ebp+8], xmm0

; 865  : 		}

  002f9	e9 60 fe ff ff	 jmp	 $LN5@get_bridge
$LN6@get_bridge:

; 866  : 	}

  002fe	e9 3d fe ff ff	 jmp	 $LN2@get_bridge
$LN3@get_bridge:

; 867  : 
; 868  : 	return max_leg_height;

  00303	d9 45 f0	 fld	 DWORD PTR _max_leg_height$[ebp]

; 869  : }

  00306	5f		 pop	 edi
  00307	5e		 pop	 esi
  00308	5b		 pop	 ebx
  00309	8b e5		 mov	 esp, ebp
  0030b	5d		 pop	 ebp
  0030c	c2 0c 00	 ret	 12			; 0000000cH
?get_bridge_max_leg_height@@YGMPAUVEC3D@@0H@Z ENDP	; get_bridge_max_leg_height
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\bridge\bridge.c
;	COMDAT ?get_most_suitable_bridge_type@@YGHPAUVEC3D@@0M@Z
_TEXT	SEGMENT
_best_type$1 = -124					; size = 4
_best_span_difference$2 = -120				; size = 4
_span_difference$3 = -116				; size = 4
_v$ = -112						; size = 12
_num_suitable_types$ = -100				; size = 4
_suitability$ = -96					; size = 32
_actual_span$ = -64					; size = 32
_slope$ = -32						; size = 4
_max_depth$ = -28					; size = 4
_min_depth$ = -24					; size = 4
_max_span$ = -20					; size = 4
_min_span$ = -16					; size = 4
_span$ = -12						; size = 4
_d$ = -8						; size = 4
_type$ = -4						; size = 4
_end1$ = 8						; size = 4
_end2$ = 12						; size = 4
_largest_depth$ = 16					; size = 4
?get_most_suitable_bridge_type@@YGHPAUVEC3D@@0M@Z PROC	; get_most_suitable_bridge_type, COMDAT

; 572  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec bc 00 00
	00		 sub	 esp, 188		; 000000bcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 573  : 	entity_sub_types
; 574  : 		type;
; 575  : 
; 576  : 	float
; 577  : 		d,
; 578  : 		span,
; 579  : 		min_span,
; 580  : 		max_span,
; 581  : 		min_depth,
; 582  : 		max_depth,
; 583  : 		slope;
; 584  : 
; 585  : 	float
; 586  : 		actual_span [NUM_ENTITY_SUB_TYPE_BRIDGES];
; 587  : 
; 588  : 	int
; 589  : 		suitability [NUM_ENTITY_SUB_TYPE_BRIDGES];
; 590  : 
; 591  : 	int
; 592  : 		num_suitable_types;
; 593  : 
; 594  : 	vec3d
; 595  : 		v;
; 596  : 
; 597  : 	ASSERT (end1 && end2);

  0000c	83 7d 08 00	 cmp	 DWORD PTR _end1$[ebp], 0
  00010	74 06		 je	 SHORT $LN18@get_most_s
  00012	83 7d 0c 00	 cmp	 DWORD PTR _end2$[ebp], 0
  00016	75 18		 jne	 SHORT $LN17@get_most_s
$LN18@get_most_s:
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??get_most_suitable_bridge_type@@YGHPAUVEC3D@@0M@Z@4JA
  0001d	83 c0 19	 add	 eax, 25			; 00000019H
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HLKEMMPI@end1?5?$CG?$CG?5end2@
  0002b	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN17@get_most_s:

; 598  : 
; 599  : 	d = get_3d_range (end1, end2);

  00030	8b 45 0c	 mov	 eax, DWORD PTR _end2$[ebp]
  00033	50		 push	 eax
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _end1$[ebp]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ?get_3d_range@@YGMPBUVEC3D@@0@Z ; get_3d_range
  0003d	d9 5d f8	 fstp	 DWORD PTR _d$[ebp]

; 600  : 
; 601  : 	memset (suitability, 0, sizeof (int) * NUM_ENTITY_SUB_TYPE_BRIDGES);

  00040	6a 20		 push	 32			; 00000020H
  00042	6a 00		 push	 0
  00044	8d 45 a0	 lea	 eax, DWORD PTR _suitability$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _memset
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 602  : 
; 603  : 	num_suitable_types = 0;

  00050	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _num_suitable_types$[ebp], 0

; 604  : 
; 605  : 	//
; 606  : 	// assess span length and warzone validity
; 607  : 	//
; 608  : 
; 609  : 	for (type = 0; type < NUM_ENTITY_SUB_TYPE_BRIDGES; type ++)

  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _type$[ebp], 0
  0005e	eb 09		 jmp	 SHORT $LN4@get_most_s
$LN2@get_most_s:
  00060	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  00063	83 c0 01	 add	 eax, 1
  00066	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax
$LN4@get_most_s:
  00069	83 7d fc 08	 cmp	 DWORD PTR _type$[ebp], 8
  0006d	0f 8d a5 00 00
	00		 jge	 $LN3@get_most_s

; 610  : 	{
; 611  : 		if ((bridge_database [type].valid_bridge_type) && (valid_warzone_bridges [type]))

  00073	6b 45 fc 28	 imul	 eax, DWORD PTR _type$[ebp], 40
  00077	66 8b 88 20 00
	00 00		 mov	 cx, WORD PTR ?bridge_database@@3PAUBRIDGE_DATA@@A[eax+32]
  0007e	66 c1 e9 0f	 shr	 cx, 15			; 0000000fH
  00082	66 83 e1 01	 and	 cx, 1
  00086	0f b7 d1	 movzx	 edx, cx
  00089	85 d2		 test	 edx, edx
  0008b	0f 84 82 00 00
	00		 je	 $LN19@get_most_s
  00091	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  00094	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR ?valid_warzone_bridges@@3PADA[eax]
  0009b	85 c9		 test	 ecx, ecx
  0009d	74 74		 je	 SHORT $LN19@get_most_s

; 612  : 		{
; 613  : 			span = get_actual_bridge_length (end1, end2, type, NULL, NULL, NULL);

  0009f	6a 00		 push	 0
  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 0c	 mov	 ecx, DWORD PTR _end2$[ebp]
  000ac	51		 push	 ecx
  000ad	8b 55 08	 mov	 edx, DWORD PTR _end1$[ebp]
  000b0	52		 push	 edx
  000b1	e8 00 00 00 00	 call	 ?get_actual_bridge_length@@YGMPAUVEC3D@@0H00PAH@Z ; get_actual_bridge_length
  000b6	d9 5d f4	 fstp	 DWORD PTR _span$[ebp]

; 614  : 
; 615  : 			min_span = bridge_database [type].min_suitable_span;

  000b9	6b 45 fc 28	 imul	 eax, DWORD PTR _type$[ebp], 40
  000bd	f3 0f 10 80 0c
	00 00 00	 movss	 xmm0, DWORD PTR ?bridge_database@@3PAUBRIDGE_DATA@@A[eax+12]
  000c5	f3 0f 11 45 f0	 movss	 DWORD PTR _min_span$[ebp], xmm0

; 616  : 			max_span = bridge_database [type].max_suitable_span;

  000ca	6b 45 fc 28	 imul	 eax, DWORD PTR _type$[ebp], 40
  000ce	f3 0f 10 80 10
	00 00 00	 movss	 xmm0, DWORD PTR ?bridge_database@@3PAUBRIDGE_DATA@@A[eax+16]
  000d6	f3 0f 11 45 ec	 movss	 DWORD PTR _max_span$[ebp], xmm0

; 617  : 
; 618  : 			if ((span >= min_span) && (span <= max_span))

  000db	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _span$[ebp]
  000e0	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _min_span$[ebp]
  000e4	72 1f		 jb	 SHORT $LN20@get_most_s
  000e6	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _max_span$[ebp]
  000eb	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _span$[ebp]
  000ef	72 14		 jb	 SHORT $LN20@get_most_s

; 619  : 			{
; 620  : 				suitability [type] = TRUE;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  000f4	c7 44 85 a0 01
	00 00 00	 mov	 DWORD PTR _suitability$[ebp+eax*4], 1

; 621  : 
; 622  : 				num_suitable_types ++;

  000fc	8b 45 9c	 mov	 eax, DWORD PTR _num_suitable_types$[ebp]
  000ff	83 c0 01	 add	 eax, 1
  00102	89 45 9c	 mov	 DWORD PTR _num_suitable_types$[ebp], eax
$LN20@get_most_s:

; 623  : 			}
; 624  : 
; 625  : 			actual_span [type] = span;

  00105	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  00108	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _span$[ebp]
  0010d	f3 0f 11 44 85
	c0		 movss	 DWORD PTR _actual_span$[ebp+eax*4], xmm0
$LN19@get_most_s:

; 626  : 		}
; 627  : 	}

  00113	e9 48 ff ff ff	 jmp	 $LN2@get_most_s
$LN3@get_most_s:

; 628  : 
; 629  : 	if (num_suitable_types == 0)

  00118	83 7d 9c 00	 cmp	 DWORD PTR _num_suitable_types$[ebp], 0
  0011c	75 0a		 jne	 SHORT $LN21@get_most_s

; 630  : 	{
; 631  : 		#if DEBUG_MODULE
; 632  : 
; 633  : 		debug_log ("BRIDGE : NO SUITABLE TYPE FOUND ( span = %f )", d);
; 634  : 
; 635  : 		#endif
; 636  : 
; 637  : 		return ENTITY_SUB_TYPE_BRIDGE_GIRDER;

  0011e	b8 05 00 00 00	 mov	 eax, 5
  00123	e9 30 02 00 00	 jmp	 $LN1@get_most_s
$LN21@get_most_s:

; 638  : 	}
; 639  : 
; 640  : 	//
; 641  : 	// assess max distance down to water
; 642  : 	//
; 643  : 
; 644  : 	for (type = 0; type < NUM_ENTITY_SUB_TYPE_BRIDGES; type ++)

  00128	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _type$[ebp], 0
  0012f	eb 09		 jmp	 SHORT $LN7@get_most_s
$LN5@get_most_s:
  00131	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  00134	83 c0 01	 add	 eax, 1
  00137	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax
$LN7@get_most_s:
  0013a	83 7d fc 08	 cmp	 DWORD PTR _type$[ebp], 8
  0013e	7d 5a		 jge	 SHORT $LN6@get_most_s

; 645  : 	{
; 646  : 		if (!suitability [type])

  00140	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  00143	83 7c 85 a0 00	 cmp	 DWORD PTR _suitability$[ebp+eax*4], 0
  00148	75 02		 jne	 SHORT $LN22@get_most_s

; 647  : 		{
; 648  : 			continue;

  0014a	eb e5		 jmp	 SHORT $LN5@get_most_s
$LN22@get_most_s:

; 649  : 		}
; 650  : 
; 651  : 		min_depth = bridge_database [type].min_suitable_depth;

  0014c	6b 45 fc 28	 imul	 eax, DWORD PTR _type$[ebp], 40
  00150	f3 0f 10 80 14
	00 00 00	 movss	 xmm0, DWORD PTR ?bridge_database@@3PAUBRIDGE_DATA@@A[eax+20]
  00158	f3 0f 11 45 e8	 movss	 DWORD PTR _min_depth$[ebp], xmm0

; 652  : 		max_depth = bridge_database [type].max_suitable_depth;

  0015d	6b 45 fc 28	 imul	 eax, DWORD PTR _type$[ebp], 40
  00161	f3 0f 10 80 18
	00 00 00	 movss	 xmm0, DWORD PTR ?bridge_database@@3PAUBRIDGE_DATA@@A[eax+24]
  00169	f3 0f 11 45 e4	 movss	 DWORD PTR _max_depth$[ebp], xmm0

; 653  : 
; 654  : 		if ((largest_depth < min_depth) || (largest_depth > max_depth))

  0016e	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _min_depth$[ebp]
  00173	0f 2f 45 10	 comiss	 xmm0, DWORD PTR _largest_depth$[ebp]
  00177	77 0b		 ja	 SHORT $LN24@get_most_s
  00179	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _largest_depth$[ebp]
  0017e	0f 2f 45 e4	 comiss	 xmm0, DWORD PTR _max_depth$[ebp]
  00182	76 14		 jbe	 SHORT $LN23@get_most_s
$LN24@get_most_s:

; 655  : 		{
; 656  : 			suitability [type] = FALSE;

  00184	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  00187	c7 44 85 a0 00
	00 00 00	 mov	 DWORD PTR _suitability$[ebp+eax*4], 0

; 657  : 
; 658  : 			num_suitable_types --;

  0018f	8b 45 9c	 mov	 eax, DWORD PTR _num_suitable_types$[ebp]
  00192	83 e8 01	 sub	 eax, 1
  00195	89 45 9c	 mov	 DWORD PTR _num_suitable_types$[ebp], eax
$LN23@get_most_s:

; 659  : 		}
; 660  : 	}

  00198	eb 97		 jmp	 SHORT $LN5@get_most_s
$LN6@get_most_s:

; 661  : 
; 662  : 	if (num_suitable_types == 0)

  0019a	83 7d 9c 00	 cmp	 DWORD PTR _num_suitable_types$[ebp], 0
  0019e	75 0a		 jne	 SHORT $LN25@get_most_s

; 663  : 	{
; 664  : 		#if DEBUG_MODULE
; 665  : 
; 666  : 		debug_log ("BRIDGE : NO SUITABLE TYPE FOUND ( span = %f, depth = %f )", d, largest_depth);
; 667  : 
; 668  : 		#endif
; 669  : 
; 670  : 		return ENTITY_SUB_TYPE_BRIDGE_GIRDER;

  001a0	b8 05 00 00 00	 mov	 eax, 5
  001a5	e9 ae 01 00 00	 jmp	 $LN1@get_most_s
$LN25@get_most_s:

; 671  : 	}
; 672  : 
; 673  : 	//
; 674  : 	// assess bridge slope
; 675  : 	//
; 676  : 
; 677  : 	v.x = end2->x - end1->x;

  001aa	8b 45 0c	 mov	 eax, DWORD PTR _end2$[ebp]
  001ad	8b 4d 08	 mov	 ecx, DWORD PTR _end1$[ebp]
  001b0	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001b4	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  001b8	f3 0f 11 45 90	 movss	 DWORD PTR _v$[ebp], xmm0

; 678  : 	v.y = end2->y - end1->y;

  001bd	8b 45 0c	 mov	 eax, DWORD PTR _end2$[ebp]
  001c0	8b 4d 08	 mov	 ecx, DWORD PTR _end1$[ebp]
  001c3	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001c8	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  001cd	f3 0f 11 45 94	 movss	 DWORD PTR _v$[ebp+4], xmm0

; 679  : 	v.z = end2->z - end1->z;

  001d2	8b 45 0c	 mov	 eax, DWORD PTR _end2$[ebp]
  001d5	8b 4d 08	 mov	 ecx, DWORD PTR _end1$[ebp]
  001d8	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001dd	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  001e2	f3 0f 11 45 98	 movss	 DWORD PTR _v$[ebp+8], xmm0

; 680  : 
; 681  : 	normalise_3d_vector (&v);

  001e7	8d 45 90	 lea	 eax, DWORD PTR _v$[ebp]
  001ea	50		 push	 eax
  001eb	e8 00 00 00 00	 call	 ?normalise_3d_vector@@YGMPAUVEC3D@@@Z ; normalise_3d_vector
  001f0	dd d8		 fstp	 ST(0)

; 682  : 
; 683  : 	slope = fabs (asin (v.y));

  001f2	51		 push	 ecx
  001f3	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _v$[ebp+4]
  001f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fd	e8 00 00 00 00	 call	 ?asin@@YGMM@Z		; asin
  00202	51		 push	 ecx
  00203	d9 1c 24	 fstp	 DWORD PTR [esp]
  00206	e8 00 00 00 00	 call	 ?fabs@@YGMM@Z		; fabs
  0020b	d9 5d e0	 fstp	 DWORD PTR _slope$[ebp]

; 684  : 
; 685  : 	for (type = 0; type < NUM_ENTITY_SUB_TYPE_BRIDGES; type ++)

  0020e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _type$[ebp], 0
  00215	eb 09		 jmp	 SHORT $LN10@get_most_s
$LN8@get_most_s:
  00217	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  0021a	83 c0 01	 add	 eax, 1
  0021d	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax
$LN10@get_most_s:
  00220	83 7d fc 08	 cmp	 DWORD PTR _type$[ebp], 8
  00224	7d 34		 jge	 SHORT $LN9@get_most_s

; 686  : 	{
; 687  : 		if (!suitability [type])

  00226	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  00229	83 7c 85 a0 00	 cmp	 DWORD PTR _suitability$[ebp+eax*4], 0
  0022e	75 02		 jne	 SHORT $LN26@get_most_s

; 688  : 		{
; 689  : 			continue;

  00230	eb e5		 jmp	 SHORT $LN8@get_most_s
$LN26@get_most_s:

; 690  : 		}
; 691  : 
; 692  : //		debug_log ("BRIDGE : %s max suitable slope = %f, actual slope = %f", entity_sub_type_bridge_names [type], deg (bridge_database [type].max_suitable_slope), deg (slope));
; 693  : 
; 694  : 		if (slope > bridge_database [type].max_suitable_slope)

  00232	6b 45 fc 28	 imul	 eax, DWORD PTR _type$[ebp], 40
  00236	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _slope$[ebp]
  0023b	0f 2f 80 1c 00
	00 00		 comiss	 xmm0, DWORD PTR ?bridge_database@@3PAUBRIDGE_DATA@@A[eax+28]
  00242	76 14		 jbe	 SHORT $LN27@get_most_s

; 695  : 		{
; 696  : //			debug_log ("          Failed");
; 697  : 
; 698  : 			suitability [type] = FALSE;

  00244	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  00247	c7 44 85 a0 00
	00 00 00	 mov	 DWORD PTR _suitability$[ebp+eax*4], 0

; 699  : 
; 700  : 			num_suitable_types --;

  0024f	8b 45 9c	 mov	 eax, DWORD PTR _num_suitable_types$[ebp]
  00252	83 e8 01	 sub	 eax, 1
  00255	89 45 9c	 mov	 DWORD PTR _num_suitable_types$[ebp], eax
$LN27@get_most_s:

; 701  : 		}
; 702  : 	}

  00258	eb bd		 jmp	 SHORT $LN8@get_most_s
$LN9@get_most_s:

; 703  : 
; 704  : 	if (num_suitable_types == 0)

  0025a	83 7d 9c 00	 cmp	 DWORD PTR _num_suitable_types$[ebp], 0
  0025e	75 0a		 jne	 SHORT $LN28@get_most_s

; 705  : 	{
; 706  : 		#if DEBUG_MODULE
; 707  : 
; 708  : 		debug_log ("BRIDGE : NO SUITABLE TYPE FOUND ( span = %f, depth = %f, slope = %f )", d, largest_depth, deg (slope));
; 709  : 
; 710  : 		#endif
; 711  : 
; 712  : 		return ENTITY_SUB_TYPE_BRIDGE_GIRDER;

  00260	b8 05 00 00 00	 mov	 eax, 5
  00265	e9 ee 00 00 00	 jmp	 $LN1@get_most_s
$LN28@get_most_s:

; 713  : 	}
; 714  : 
; 715  : 	//
; 716  : 	// end of criteria checks
; 717  : 	//
; 718  : 
; 719  : 	if (num_suitable_types == 1)

  0026a	83 7d 9c 01	 cmp	 DWORD PTR _num_suitable_types$[ebp], 1
  0026e	75 42		 jne	 SHORT $LN29@get_most_s

; 720  : 	{
; 721  : 		//
; 722  : 		// trivial case
; 723  : 		//
; 724  : 
; 725  : 		for (type = 0; type < NUM_ENTITY_SUB_TYPE_BRIDGES; type ++)

  00270	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _type$[ebp], 0
  00277	eb 09		 jmp	 SHORT $LN13@get_most_s
$LN11@get_most_s:
  00279	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  0027c	83 c0 01	 add	 eax, 1
  0027f	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax
$LN13@get_most_s:
  00282	83 7d fc 08	 cmp	 DWORD PTR _type$[ebp], 8
  00286	7d 14		 jge	 SHORT $LN12@get_most_s

; 726  : 		{
; 727  : 			if (suitability [type])

  00288	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  0028b	83 7c 85 a0 00	 cmp	 DWORD PTR _suitability$[ebp+eax*4], 0
  00290	74 08		 je	 SHORT $LN31@get_most_s

; 728  : 			{
; 729  : 				#if DEBUG_MODULE
; 730  : 
; 731  : 				debug_log ("BRIDGE : Single suitable type ( %s )", entity_sub_type_bridge_names [type]);
; 732  : 
; 733  : 				#endif
; 734  : 
; 735  : 				return type;

  00292	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  00295	e9 be 00 00 00	 jmp	 $LN1@get_most_s
$LN31@get_most_s:

; 736  : 			}
; 737  : 		}

  0029a	eb dd		 jmp	 SHORT $LN11@get_most_s
$LN12@get_most_s:

; 738  : 
; 739  : 		debug_fatal ("BRIDGE: suitable type counter = %d, but no suitable types found", num_suitable_types);

  0029c	8b 45 9c	 mov	 eax, DWORD PTR _num_suitable_types$[ebp]
  0029f	50		 push	 eax
  002a0	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@NBHJHDC@BRIDGE?3?5suitable?5type?5counter?5?$DN@
  002a5	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  002aa	83 c4 08	 add	 esp, 8

; 740  : 	}
; 741  : 	else

  002ad	e9 94 00 00 00	 jmp	 $LN30@get_most_s
$LN29@get_most_s:

; 742  : 	{
; 743  : 		//
; 744  : 		// find best fit
; 745  : 		//
; 746  : 
; 747  : 		float
; 748  : 			span_difference,
; 749  : 			best_span_difference;
; 750  : 
; 751  : 		int
; 752  : 			best_type;
; 753  : 
; 754  : 		best_type = -1;

  002b2	c7 45 84 ff ff
	ff ff		 mov	 DWORD PTR _best_type$1[ebp], -1

; 755  : 
; 756  : 		best_span_difference = FLT_MAX;

  002b9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  002c1	f3 0f 11 45 88	 movss	 DWORD PTR _best_span_difference$2[ebp], xmm0

; 757  : 
; 758  : 		for (type = 0; type < NUM_ENTITY_SUB_TYPE_BRIDGES; type ++)

  002c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _type$[ebp], 0
  002cd	eb 09		 jmp	 SHORT $LN16@get_most_s
$LN14@get_most_s:
  002cf	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  002d2	83 c0 01	 add	 eax, 1
  002d5	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax
$LN16@get_most_s:
  002d8	83 7d fc 08	 cmp	 DWORD PTR _type$[ebp], 8
  002dc	7d 43		 jge	 SHORT $LN15@get_most_s

; 759  : 		{
; 760  : 			if (suitability [type])

  002de	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  002e1	83 7c 85 a0 00	 cmp	 DWORD PTR _suitability$[ebp+eax*4], 0
  002e6	74 37		 je	 SHORT $LN33@get_most_s

; 761  : 			{
; 762  : 				span_difference = fabs (actual_span [type] - d);

  002e8	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  002eb	f3 0f 10 44 85
	c0		 movss	 xmm0, DWORD PTR _actual_span$[ebp+eax*4]
  002f1	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR _d$[ebp]
  002f6	51		 push	 ecx
  002f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002fc	e8 00 00 00 00	 call	 ?fabs@@YGMM@Z		; fabs
  00301	d9 5d 8c	 fstp	 DWORD PTR _span_difference$3[ebp]

; 763  : 
; 764  : 				if (span_difference < best_span_difference)

  00304	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _best_span_difference$2[ebp]
  00309	0f 2f 45 8c	 comiss	 xmm0, DWORD PTR _span_difference$3[ebp]
  0030d	76 10		 jbe	 SHORT $LN33@get_most_s

; 765  : 				{
; 766  : 					best_type = type;

  0030f	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  00312	89 45 84	 mov	 DWORD PTR _best_type$1[ebp], eax

; 767  : 
; 768  : 					best_span_difference = span_difference;

  00315	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _span_difference$3[ebp]
  0031a	f3 0f 11 45 88	 movss	 DWORD PTR _best_span_difference$2[ebp], xmm0
$LN33@get_most_s:

; 769  : 				}
; 770  : 
; 771  : 				#if DEBUG_MODULE
; 772  : 
; 773  : 				debug_log ("BRIDGE : Multiple suitable types ( %s ) - sd = %f", entity_sub_type_bridge_names [type], span_difference);
; 774  : 
; 775  : 				#endif
; 776  : 			}
; 777  : 		}

  0031f	eb ae		 jmp	 SHORT $LN14@get_most_s
$LN15@get_most_s:

; 778  : 
; 779  : 		ASSERT (best_type != -1);

  00321	83 7d 84 ff	 cmp	 DWORD PTR _best_type$1[ebp], -1
  00325	75 1a		 jne	 SHORT $LN34@get_most_s
  00327	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??get_most_suitable_bridge_type@@YGHPAUVEC3D@@0M@Z@4JA
  0032c	05 cf 00 00 00	 add	 eax, 207		; 000000cfH
  00331	50		 push	 eax
  00332	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00337	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOLJKOPJ@best_type?5?$CB?$DN?5?91@
  0033c	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN34@get_most_s:

; 780  : 
; 781  : 		#if DEBUG_MODULE
; 782  : 
; 783  : 		debug_log ("BRIDGE : Best type ( %s ) - sd = %f", entity_sub_type_bridge_names [best_type], best_span_difference);
; 784  : 
; 785  : 		#endif
; 786  : 
; 787  : 		return best_type;

  00341	8b 45 84	 mov	 eax, DWORD PTR _best_type$1[ebp]
  00344	eb 12		 jmp	 SHORT $LN1@get_most_s
$LN30@get_most_s:

; 788  : 	}
; 789  : 
; 790  : 	debug_fatal ("BRIDGE : No Valid Types Found");

  00346	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LAGOEHEJ@BRIDGE?5?3?5No?5Valid?5Types?5Found@
  0034b	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  00350	83 c4 04	 add	 esp, 4

; 791  : 
; 792  : 	return ENTITY_SUB_TYPE_BRIDGE_GIRDER;

  00353	b8 05 00 00 00	 mov	 eax, 5
$LN1@get_most_s:

; 793  : }

  00358	5f		 pop	 edi
  00359	5e		 pop	 esi
  0035a	5b		 pop	 ebx
  0035b	8b e5		 mov	 esp, ebp
  0035d	5d		 pop	 ebp
  0035e	c2 0c 00	 ret	 12			; 0000000cH
?get_most_suitable_bridge_type@@YGHPAUVEC3D@@0M@Z ENDP	; get_most_suitable_bridge_type
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\bridge\bridge.c
;	COMDAT ?create_local_bridge_entities@@YGXW4PACK_MODES@@@Z
_TEXT	SEGMENT
_first_bridge_entity$ = -572				; size = 4
_max_leg_height$ = -568					; size = 4
_end2$ = -564						; size = 12
_end1$ = -552						; size = 12
_end_node$ = -540					; size = 4
_start_node$ = -536					; size = 4
_number_of_bridges$ = -532				; size = 4
_loop$ = -528						; size = 4
_fp$ = -524						; size = 4
_current_session$ = -520				; size = 4
_filename$ = -516					; size = 512
_type$ = -4						; size = 4
_pack_mode$ = 8						; size = 4
?create_local_bridge_entities@@YGXW4PACK_MODES@@@Z PROC	; create_local_bridge_entities, COMDAT

; 363  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec bc 02 00
	00		 sub	 esp, 700		; 000002bcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 364  : 	entity_sub_types
; 365  : 		type;
; 366  : 
; 367  : 	char
; 368  : 		filename [512];
; 369  : 
; 370  : 	session_list_data_type
; 371  : 		*current_session;
; 372  : 
; 373  : 	FILE
; 374  : 		*fp;
; 375  : 
; 376  : 	int
; 377  : 		loop,
; 378  : 		number_of_bridges,
; 379  : 		start_node,
; 380  : 		end_node;
; 381  : 
; 382  : 	vec3d
; 383  : 		end1,
; 384  : 		end2;
; 385  : 
; 386  : 	float
; 387  : 		max_leg_height;
; 388  : 
; 389  : 	entity
; 390  : 		*first_bridge_entity;
; 391  : 
; 392  : 	if (pack_mode == PACK_MODE_BROWSE_SESSION)

  0000c	83 7d 08 02	 cmp	 DWORD PTR _pack_mode$[ebp], 2
  00010	75 05		 jne	 SHORT $LN5@create_loc

; 393  : 	{
; 394  : 
; 395  : 		return;

  00012	e9 18 02 00 00	 jmp	 $LN1@create_loc
$LN5@create_loc:

; 396  : 	}
; 397  : 
; 398  : 	first_bridge_entity = NULL;

  00017	c7 85 c4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _first_bridge_entity$[ebp], 0

; 399  : 
; 400  : 	if (command_line_run_mode == RUN_MODE_AITOOL)
; 401  : 	{
; 402  : 		//return;
; 403  : 	}
; 404  : 
; 405  : 	ASSERT (get_valid_current_game_session ());

  00021	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?current_game_session@@3PAUSESSION_LIST_DATA_TYPE@@A, 0 ; current_game_session
  00028	75 18		 jne	 SHORT $LN7@create_loc
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??create_local_bridge_entities@@YGXW4PACK_MODES@@@Z@4JA
  0002f	83 c0 2a	 add	 eax, 42			; 0000002aH
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@EEKIOPJL@get_valid_current_game_session?5@
  0003d	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN7@create_loc:

; 406  : 
; 407  : 	current_session = get_current_game_session ();

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?current_game_session@@3PAUSESSION_LIST_DATA_TYPE@@A ; current_game_session
  00047	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _current_session$[ebp], eax

; 408  : 
; 409  : 	sprintf (filename, "%s\\%s", current_session->data_path, BRIDGE_DATA_FILENAME);

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FNDIHPEG@route?2bridge?4dat@
  00052	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _current_session$[ebp]
  00058	83 c0 1c	 add	 eax, 28			; 0000001cH
  0005b	50		 push	 eax
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
  00061	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _filename$[ebp]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _sprintf
  0006d	83 c4 10	 add	 esp, 16			; 00000010H

; 410  : 
; 411  : 	if (!file_exist (filename))

  00070	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?file_exist@@YGHPBD@Z	; file_exist
  0007c	85 c0		 test	 eax, eax
  0007e	75 05		 jne	 SHORT $LN8@create_loc

; 412  : 	{
; 413  : 		return;

  00080	e9 aa 01 00 00	 jmp	 $LN1@create_loc
$LN8@create_loc:

; 414  : 	}
; 415  : 
; 416  : 	fp = safe_fopen (filename, "rb");

  00085	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  0008a	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ?safe_fopen@@YGPAU_iobuf@@PBD0@Z ; safe_fopen
  00096	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _fp$[ebp], eax

; 417  : 
; 418  : 	fread (&number_of_bridges, sizeof (int), 1, fp);

  0009c	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  000a2	50		 push	 eax
  000a3	6a 01		 push	 1
  000a5	6a 04		 push	 4
  000a7	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _number_of_bridges$[ebp]
  000ad	51		 push	 ecx
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000b4	83 c4 10	 add	 esp, 16			; 00000010H

; 419  : 
; 420  : 	for (loop = 0; loop < number_of_bridges; loop ++)

  000b7	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _loop$[ebp], 0
  000c1	eb 0f		 jmp	 SHORT $LN4@create_loc
$LN2@create_loc:
  000c3	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _loop$[ebp]
  000c9	83 c0 01	 add	 eax, 1
  000cc	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _loop$[ebp], eax
$LN4@create_loc:
  000d2	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _loop$[ebp]
  000d8	3b 85 ec fd ff
	ff		 cmp	 eax, DWORD PTR _number_of_bridges$[ebp]
  000de	0f 8d 3f 01 00
	00		 jge	 $LN3@create_loc

; 421  : 	{
; 422  : 		fread (&end1, sizeof (vec3d), 1, fp);

  000e4	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  000ea	50		 push	 eax
  000eb	6a 01		 push	 1
  000ed	6a 0c		 push	 12			; 0000000cH
  000ef	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _end1$[ebp]
  000f5	51		 push	 ecx
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000fc	83 c4 10	 add	 esp, 16			; 00000010H

; 423  : 
; 424  : 		fread (&end2, sizeof (vec3d), 1, fp);

  000ff	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  00105	50		 push	 eax
  00106	6a 01		 push	 1
  00108	6a 0c		 push	 12			; 0000000cH
  0010a	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _end2$[ebp]
  00110	51		 push	 ecx
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00117	83 c4 10	 add	 esp, 16			; 00000010H

; 425  : 
; 426  : 		fread (&start_node, sizeof (int), 1, fp);

  0011a	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  00120	50		 push	 eax
  00121	6a 01		 push	 1
  00123	6a 04		 push	 4
  00125	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _start_node$[ebp]
  0012b	51		 push	 ecx
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00132	83 c4 10	 add	 esp, 16			; 00000010H

; 427  : 
; 428  : 		fread (&end_node, sizeof (int), 1, fp);

  00135	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  0013b	50		 push	 eax
  0013c	6a 01		 push	 1
  0013e	6a 04		 push	 4
  00140	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _end_node$[ebp]
  00146	51		 push	 ecx
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0014d	83 c4 10	 add	 esp, 16			; 00000010H

; 429  : 
; 430  : 		fread (&type, sizeof (int), 1, fp);

  00150	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  00156	50		 push	 eax
  00157	6a 01		 push	 1
  00159	6a 04		 push	 4
  0015b	8d 4d fc	 lea	 ecx, DWORD PTR _type$[ebp]
  0015e	51		 push	 ecx
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00165	83 c4 10	 add	 esp, 16			; 00000010H

; 431  : 
; 432  : 		fread (&max_leg_height, sizeof (float), 1, fp);

  00168	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  0016e	50		 push	 eax
  0016f	6a 01		 push	 1
  00171	6a 04		 push	 4
  00173	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR _max_leg_height$[ebp]
  00179	51		 push	 ecx
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00180	83 c4 10	 add	 esp, 16			; 00000010H

; 433  : 
; 434  : 		type = get_most_suitable_bridge_type (&end1, &end2, max_leg_height);

  00183	51		 push	 ecx
  00184	f3 0f 10 85 c8
	fd ff ff	 movss	 xmm0, DWORD PTR _max_leg_height$[ebp]
  0018c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00191	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _end2$[ebp]
  00197	50		 push	 eax
  00198	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _end1$[ebp]
  0019e	51		 push	 ecx
  0019f	e8 00 00 00 00	 call	 ?get_most_suitable_bridge_type@@YGHPAUVEC3D@@0M@Z ; get_most_suitable_bridge_type
  001a4	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 435  : 
; 436  : 		if (!first_bridge_entity)

  001a7	83 bd c4 fd ff
	ff 00		 cmp	 DWORD PTR _first_bridge_entity$[ebp], 0
  001ae	75 3b		 jne	 SHORT $LN9@create_loc

; 437  : 		{
; 438  : 
; 439  : 			first_bridge_entity = create_bridge (&end1, &end2, start_node, end_node, type, max_leg_height);

  001b0	51		 push	 ecx
  001b1	f3 0f 10 85 c8
	fd ff ff	 movss	 xmm0, DWORD PTR _max_leg_height$[ebp]
  001b9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001be	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  001c1	50		 push	 eax
  001c2	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _end_node$[ebp]
  001c8	51		 push	 ecx
  001c9	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _start_node$[ebp]
  001cf	52		 push	 edx
  001d0	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _end2$[ebp]
  001d6	50		 push	 eax
  001d7	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _end1$[ebp]
  001dd	51		 push	 ecx
  001de	e8 00 00 00 00	 call	 ?create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z ; create_bridge
  001e3	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _first_bridge_entity$[ebp], eax

; 440  : 		}
; 441  : 		else

  001e9	eb 33		 jmp	 SHORT $LN10@create_loc
$LN9@create_loc:

; 442  : 		{
; 443  : 
; 444  : 			create_bridge (&end1, &end2, start_node, end_node, type, max_leg_height);

  001eb	51		 push	 ecx
  001ec	f3 0f 10 85 c8
	fd ff ff	 movss	 xmm0, DWORD PTR _max_leg_height$[ebp]
  001f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f9	8b 45 fc	 mov	 eax, DWORD PTR _type$[ebp]
  001fc	50		 push	 eax
  001fd	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _end_node$[ebp]
  00203	51		 push	 ecx
  00204	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _start_node$[ebp]
  0020a	52		 push	 edx
  0020b	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _end2$[ebp]
  00211	50		 push	 eax
  00212	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _end1$[ebp]
  00218	51		 push	 ecx
  00219	e8 00 00 00 00	 call	 ?create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z ; create_bridge
$LN10@create_loc:

; 445  : 		}
; 446  : 	}

  0021e	e9 a0 fe ff ff	 jmp	 $LN2@create_loc
$LN3@create_loc:

; 447  : 
; 448  : 	safe_fclose (fp);

  00223	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _fp$[ebp]
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 ?safe_fclose@@YGHPAU_iobuf@@@Z ; safe_fclose
$LN1@create_loc:

; 449  : 
; 450  : 	#if DEBUG_MODULE
; 451  : 
; 452  : 	debug_log ("BR_CREAT: creating bridge: Start entity %d", get_local_entity_index (first_bridge_entity));
; 453  : 
; 454  : 	#endif
; 455  : }

  0022f	5f		 pop	 edi
  00230	5e		 pop	 esi
  00231	5b		 pop	 ebx
  00232	8b e5		 mov	 esp, ebp
  00234	5d		 pop	 ebp
  00235	c2 04 00	 ret	 4
?create_local_bridge_entities@@YGXW4PACK_MODES@@@Z ENDP	; create_local_bridge_entities
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\bridge\bridge.c
;	COMDAT ?create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z
_TEXT	SEGMENT
tv420 = -164						; size = 4
tv400 = -164						; size = 4
tv412 = -160						; size = 4
tv392 = -160						; size = 4
_segment_type$ = -92					; size = 4
_raw_vector$ = -88					; size = 12
_pos$ = -76						; size = 12
_end$ = -64						; size = 12
_start$ = -52						; size = 12
_num_mid_sections$ = -40				; size = 4
_section_loop$ = -36					; size = 4
_element_loop$ = -32					; size = 4
_actual_length$ = -28					; size = 4
_start_length$ = -24					; size = 4
_heading$ = -20						; size = 4
_pitch$ = -16						; size = 4
_bridge_entity$ = -12					; size = 4
_segment_entity$ = -8					; size = 4
_bridge_info$ = -4					; size = 4
_end1$ = 8						; size = 4
_end2$ = 12						; size = 4
_start_node$ = 16					; size = 4
_end_node$ = 20						; size = 4
_type$ = 24						; size = 4
_max_leg_height$ = 28					; size = 4
?create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z PROC	; create_bridge, COMDAT

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 180  : 
; 181  : 	const bridge_data
; 182  : 		*bridge_info;
; 183  : 
; 184  : 	entity
; 185  : 		*segment_entity,
; 186  : 		*bridge_entity;
; 187  : 
; 188  : 	float
; 189  : 		pitch,
; 190  : 		heading,
; 191  : 		start_length,
; 192  : 		actual_length;
; 193  : 
; 194  : 	int
; 195  : 		element_loop,
; 196  : 		section_loop,
; 197  : 		num_mid_sections;
; 198  : 
; 199  : 	vec3d
; 200  : 		start,
; 201  : 		end,
; 202  : 		pos,
; 203  : 		raw_vector;
; 204  : 
; 205  : 	bridge_segment_types
; 206  : 		segment_type;
; 207  : 
; 208  : 	ASSERT( ( type >= 0 ) && ( type < NUM_ENTITY_SUB_TYPE_BRIDGES ) );

  0000c	83 7d 18 00	 cmp	 DWORD PTR _type$[ebp], 0
  00010	7c 06		 jl	 SHORT $LN9@create_bri
  00012	83 7d 18 08	 cmp	 DWORD PTR _type$[ebp], 8
  00016	7c 18		 jl	 SHORT $LN8@create_bri
$LN9@create_bri:
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z@4JA
  0001d	83 c0 1d	 add	 eax, 29			; 0000001dH
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HECDIEBL@?$CI?5type?5?$DO?$DN?50?5?$CJ?5?$CG?$CG?5?$CI?5type?5?$DM?5NUM_E@
  0002b	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN8@create_bri:

; 209  : 
; 210  : 	bridge_info = &bridge_database[ type ];

  00030	6b 45 18 28	 imul	 eax, DWORD PTR _type$[ebp], 40
  00034	05 00 00 00 00	 add	 eax, OFFSET ?bridge_database@@3PAUBRIDGE_DATA@@A ; bridge_database
  00039	89 45 fc	 mov	 DWORD PTR _bridge_info$[ebp], eax

; 211  : 
; 212  : 	#if DEBUG_MODULE
; 213  : 
; 214  : 	debug_log ("BRIDGE : Creating Bridge type %s between nodes %d and %d ( max leg height = %.2f )", entity_sub_type_bridge_names [type], start_node, end_node, max_leg_height);
; 215  : 
; 216  : 	#endif
; 217  : 
; 218  : 	//
; 219  : 	// get adjusted start and end points
; 220  : 	//
; 221  : 
; 222  : 	actual_length = get_actual_bridge_length (end1, end2, type, &start, &end, &num_mid_sections);

  0003c	8d 45 d8	 lea	 eax, DWORD PTR _num_mid_sections$[ebp]
  0003f	50		 push	 eax
  00040	8d 4d c0	 lea	 ecx, DWORD PTR _end$[ebp]
  00043	51		 push	 ecx
  00044	8d 55 cc	 lea	 edx, DWORD PTR _start$[ebp]
  00047	52		 push	 edx
  00048	8b 45 18	 mov	 eax, DWORD PTR _type$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _end2$[ebp]
  0004f	51		 push	 ecx
  00050	8b 55 08	 mov	 edx, DWORD PTR _end1$[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 ?get_actual_bridge_length@@YGMPAUVEC3D@@0H00PAH@Z ; get_actual_bridge_length
  00059	d9 5d e4	 fstp	 DWORD PTR _actual_length$[ebp]

; 223  : 
; 224  : 	raw_vector.x = end2->x - end1->x;

  0005c	8b 45 0c	 mov	 eax, DWORD PTR _end2$[ebp]
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _end1$[ebp]
  00062	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00066	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0006a	f3 0f 11 45 a8	 movss	 DWORD PTR _raw_vector$[ebp], xmm0

; 225  : 	raw_vector.y = end2->y - end1->y;

  0006f	8b 45 0c	 mov	 eax, DWORD PTR _end2$[ebp]
  00072	8b 4d 08	 mov	 ecx, DWORD PTR _end1$[ebp]
  00075	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0007a	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0007f	f3 0f 11 45 ac	 movss	 DWORD PTR _raw_vector$[ebp+4], xmm0

; 226  : 	raw_vector.z = end2->z - end1->z;

  00084	8b 45 0c	 mov	 eax, DWORD PTR _end2$[ebp]
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _end1$[ebp]
  0008a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0008f	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00094	f3 0f 11 45 b0	 movss	 DWORD PTR _raw_vector$[ebp+8], xmm0

; 227  : 
; 228  : 	normalise_3d_vector( &raw_vector );

  00099	8d 45 a8	 lea	 eax, DWORD PTR _raw_vector$[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?normalise_3d_vector@@YGMPAUVEC3D@@@Z ; normalise_3d_vector
  000a2	dd d8		 fstp	 ST(0)

; 229  : 
; 230  : 	//
; 231  : 	// calculate heading and pitch for the segments
; 232  : 	//
; 233  : 
; 234  : 	get_heading_and_pitch_from_3d_unit_vector( &raw_vector, &heading, &pitch );

  000a4	8d 45 f0	 lea	 eax, DWORD PTR _pitch$[ebp]
  000a7	50		 push	 eax
  000a8	8d 4d ec	 lea	 ecx, DWORD PTR _heading$[ebp]
  000ab	51		 push	 ecx
  000ac	8d 55 a8	 lea	 edx, DWORD PTR _raw_vector$[ebp]
  000af	52		 push	 edx
  000b0	e8 00 00 00 00	 call	 ?get_heading_and_pitch_from_3d_unit_vector@@YGXPBUVEC3D@@PAM1@Z ; get_heading_and_pitch_from_3d_unit_vector

; 235  : 
; 236  : 	//
; 237  : 	// create bridge entity
; 238  : 	//
; 239  : 
; 240  : 	bridge_entity = create_local_entity

  000b5	6a 00		 push	 0
  000b7	f3 0f 5a 45 f0	 cvtss2sd xmm0, DWORD PTR _pitch$[ebp]
  000bc	83 ec 08	 sub	 esp, 8
  000bf	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000c4	6a 54		 push	 84			; 00000054H
  000c6	6a 04		 push	 4
  000c8	8b 45 14	 mov	 eax, DWORD PTR _end_node$[ebp]
  000cb	50		 push	 eax
  000cc	6a 32		 push	 50			; 00000032H
  000ce	6a 05		 push	 5
  000d0	8b 4d 10	 mov	 ecx, DWORD PTR _start_node$[ebp]
  000d3	51		 push	 ecx
  000d4	68 ca 00 00 00	 push	 202			; 000000caH
  000d9	6a 05		 push	 5
  000db	8b 55 18	 mov	 edx, DWORD PTR _type$[ebp]
  000de	52		 push	 edx
  000df	6a 34		 push	 52			; 00000034H
  000e1	6a 05		 push	 5
  000e3	6a ff		 push	 -1
  000e5	6a 02		 push	 2
  000e7	e8 00 00 00 00	 call	 ?create_local_entity@@YAPAUENTITY@@W4ENTITY_TYPES@@HZZ ; create_local_entity
  000ec	83 c4 40	 add	 esp, 64			; 00000040H
  000ef	89 45 f4	 mov	 DWORD PTR _bridge_entity$[ebp], eax

; 241  : 	(
; 242  : 		ENTITY_TYPE_BRIDGE,
; 243  : 		ENTITY_INDEX_DONT_CARE,
; 244  : 		ENTITY_ATTR_INT_VALUE (INT_TYPE_ENTITY_SUB_TYPE, type),
; 245  : 		ENTITY_ATTR_INT_VALUE (INT_TYPE_START_NODE, start_node),
; 246  : 		ENTITY_ATTR_INT_VALUE (INT_TYPE_END_NODE, end_node),
; 247  : 		ENTITY_ATTR_FLOAT_VALUE (FLOAT_TYPE_PITCH, pitch),
; 248  : 		ENTITY_ATTR_END
; 249  : 	);
; 250  : 
; 251  : 	//
; 252  : 	// create segments
; 253  : 	//
; 254  : 
; 255  : 	//
; 256  : 	// start segment
; 257  : 	//
; 258  : 
; 259  : 	if ( bridge_info->start_section_type != BRIDGE_SEGMENT_TYPE_NONE )

  000f2	8b 45 fc	 mov	 eax, DWORD PTR _bridge_info$[ebp]
  000f5	83 38 00	 cmp	 DWORD PTR [eax], 0
  000f8	0f 84 8a 00 00
	00		 je	 $LN10@create_bri

; 260  : 	{
; 261  : 		segment_entity = create_local_entity

  000fe	6a 00		 push	 0
  00100	8b 45 f4	 mov	 eax, DWORD PTR _bridge_entity$[ebp]
  00103	50		 push	 eax
  00104	6a 23		 push	 35			; 00000023H
  00106	6a 06		 push	 6
  00108	f3 0f 5a 45 ec	 cvtss2sd xmm0, DWORD PTR _heading$[ebp]
  0010d	83 ec 08	 sub	 esp, 8
  00110	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00115	6a 34		 push	 52			; 00000034H
  00117	6a 04		 push	 4
  00119	f3 0f 5a 45 d4	 cvtss2sd xmm0, DWORD PTR _start$[ebp+8]
  0011e	83 ec 08	 sub	 esp, 8
  00121	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00126	f3 0f 5a 45 d0	 cvtss2sd xmm0, DWORD PTR _start$[ebp+4]
  0012b	83 ec 08	 sub	 esp, 8
  0012e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00133	f3 0f 5a 45 cc	 cvtss2sd xmm0, DWORD PTR _start$[ebp]
  00138	83 ec 08	 sub	 esp, 8
  0013b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00140	6a 08		 push	 8
  00142	6a 09		 push	 9
  00144	8b 4d fc	 mov	 ecx, DWORD PTR _bridge_info$[ebp]
  00147	6b 11 28	 imul	 edx, DWORD PTR [ecx], 40
  0014a	8b 82 1c 00 00
	00		 mov	 eax, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[edx+28]
  00150	50		 push	 eax
  00151	6a 25		 push	 37			; 00000025H
  00153	6a 05		 push	 5
  00155	8b 4d fc	 mov	 ecx, DWORD PTR _bridge_info$[ebp]
  00158	6b 11 28	 imul	 edx, DWORD PTR [ecx], 40
  0015b	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[edx]
  00161	50		 push	 eax
  00162	68 92 00 00 00	 push	 146			; 00000092H
  00167	6a 05		 push	 5
  00169	8b 4d fc	 mov	 ecx, DWORD PTR _bridge_info$[ebp]
  0016c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0016e	52		 push	 edx
  0016f	6a 0f		 push	 15			; 0000000fH
  00171	6a 05		 push	 5
  00173	6a 01		 push	 1
  00175	6a 34		 push	 52			; 00000034H
  00177	6a 05		 push	 5
  00179	6a ff		 push	 -1
  0017b	6a 1a		 push	 26			; 0000001aH
  0017d	e8 00 00 00 00	 call	 ?create_local_entity@@YAPAUENTITY@@W4ENTITY_TYPES@@HZZ ; create_local_entity
  00182	83 c4 78	 add	 esp, 120		; 00000078H
  00185	89 45 f8	 mov	 DWORD PTR _segment_entity$[ebp], eax
$LN10@create_bri:

; 262  : 		(
; 263  : 			ENTITY_TYPE_SEGMENT,
; 264  : 			ENTITY_INDEX_DONT_CARE,
; 265  : 			ENTITY_ATTR_INT_VALUE (INT_TYPE_ENTITY_SUB_TYPE, ENTITY_SUB_TYPE_FIXED_BRIDGE_END_SECTION),
; 266  : 			ENTITY_ATTR_INT_VALUE (INT_TYPE_BRIDGE_SEGMENT_TYPE, bridge_info->start_section_type),
; 267  : 			ENTITY_ATTR_INT_VALUE (INT_TYPE_OBJECT_3D_SHAPE, bridge_segment_normal_object( bridge_info->start_section_type )),
; 268  : 			ENTITY_ATTR_INT_VALUE (INT_TYPE_DAMAGE_LEVEL, bridge_segment_initial_damage_level( bridge_info->start_section_type )),
; 269  : 			ENTITY_ATTR_VEC3D (VEC3D_TYPE_POSITION, start.x, start.y, start.z),
; 270  : 			ENTITY_ATTR_FLOAT_VALUE (FLOAT_TYPE_HEADING, heading),
; 271  : 			ENTITY_ATTR_PARENT (LIST_TYPE_SEGMENT, bridge_entity),
; 272  : 			ENTITY_ATTR_END
; 273  : 		);
; 274  : 	}
; 275  : 
; 276  : 	//
; 277  : 	// mid segment(s)
; 278  : 	//
; 279  : 
; 280  : 	start_length = bridge_segment_length( bridge_info->start_section_type );

  00188	8b 45 fc	 mov	 eax, DWORD PTR _bridge_info$[ebp]
  0018b	6b 08 28	 imul	 ecx, DWORD PTR [eax], 40
  0018e	f3 0f 10 81 18
	00 00 00	 movss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[ecx+24]
  00196	f3 0f 11 45 e8	 movss	 DWORD PTR _start_length$[ebp], xmm0

; 281  : 
; 282  : 	pos.x = start.x + ( raw_vector.x * start_length * 0.5 );

  0019b	f3 0f 5a 45 cc	 cvtss2sd xmm0, DWORD PTR _start$[ebp]
  001a0	f3 0f 10 4d a8	 movss	 xmm1, DWORD PTR _raw_vector$[ebp]
  001a5	f3 0f 59 4d e8	 mulss	 xmm1, DWORD PTR _start_length$[ebp]
  001aa	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  001ae	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe0000000000000
  001b6	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001ba	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001be	f3 0f 11 45 b4	 movss	 DWORD PTR _pos$[ebp], xmm0

; 283  : 	pos.y = start.y + ( raw_vector.y * start_length * 0.5 );

  001c3	f3 0f 5a 45 d0	 cvtss2sd xmm0, DWORD PTR _start$[ebp+4]
  001c8	f3 0f 10 4d ac	 movss	 xmm1, DWORD PTR _raw_vector$[ebp+4]
  001cd	f3 0f 59 4d e8	 mulss	 xmm1, DWORD PTR _start_length$[ebp]
  001d2	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  001d6	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe0000000000000
  001de	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001e2	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001e6	f3 0f 11 45 b8	 movss	 DWORD PTR _pos$[ebp+4], xmm0

; 284  : 	pos.z = start.z + ( raw_vector.z * start_length * 0.5 );

  001eb	f3 0f 5a 45 d4	 cvtss2sd xmm0, DWORD PTR _start$[ebp+8]
  001f0	f3 0f 10 4d b0	 movss	 xmm1, DWORD PTR _raw_vector$[ebp+8]
  001f5	f3 0f 59 4d e8	 mulss	 xmm1, DWORD PTR _start_length$[ebp]
  001fa	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  001fe	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe0000000000000
  00206	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0020a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0020e	f3 0f 11 45 bc	 movss	 DWORD PTR _pos$[ebp+8], xmm0

; 285  : 
; 286  : 	for ( section_loop = 0 ; section_loop < num_mid_sections ; section_loop ++ )

  00213	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _section_loop$[ebp], 0
  0021a	eb 09		 jmp	 SHORT $LN4@create_bri
$LN2@create_bri:
  0021c	8b 45 dc	 mov	 eax, DWORD PTR _section_loop$[ebp]
  0021f	83 c0 01	 add	 eax, 1
  00222	89 45 dc	 mov	 DWORD PTR _section_loop$[ebp], eax
$LN4@create_bri:
  00225	8b 45 dc	 mov	 eax, DWORD PTR _section_loop$[ebp]
  00228	3b 45 d8	 cmp	 eax, DWORD PTR _num_mid_sections$[ebp]
  0022b	0f 8d ea 01 00
	00		 jge	 $LN3@create_bri

; 287  : 	{
; 288  : 
; 289  : 		for ( element_loop = 0 ; element_loop < bridge_info->num_elements_in_mid_section_pattern ; element_loop ++ )

  00231	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _element_loop$[ebp], 0
  00238	eb 09		 jmp	 SHORT $LN7@create_bri
$LN5@create_bri:
  0023a	8b 45 e0	 mov	 eax, DWORD PTR _element_loop$[ebp]
  0023d	83 c0 01	 add	 eax, 1
  00240	89 45 e0	 mov	 DWORD PTR _element_loop$[ebp], eax
$LN7@create_bri:
  00243	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00248	8b 4d fc	 mov	 ecx, DWORD PTR _bridge_info$[ebp]
  0024b	66 23 41 20	 and	 ax, WORD PTR [ecx+32]
  0024f	0f b7 d0	 movzx	 edx, ax
  00252	39 55 e0	 cmp	 DWORD PTR _element_loop$[ebp], edx
  00255	0f 8d bb 01 00
	00		 jge	 $LN6@create_bri

; 290  : 		{
; 291  : 
; 292  : 			segment_type = bridge_info->mid_section_type[ element_loop ];

  0025b	8b 45 fc	 mov	 eax, DWORD PTR _bridge_info$[ebp]
  0025e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00261	8b 55 e0	 mov	 edx, DWORD PTR _element_loop$[ebp]
  00264	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00267	89 45 a4	 mov	 DWORD PTR _segment_type$[ebp], eax

; 293  : 
; 294  : 			pos.x += ( raw_vector.x * bridge_segment_length( segment_type ) * 0.5 );

  0026a	6b 45 a4 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  0026e	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _raw_vector$[ebp]
  00273	f3 0f 59 80 18
	00 00 00	 mulss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+24]
  0027b	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0027f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00287	f3 0f 5a 4d b4	 cvtss2sd xmm1, DWORD PTR _pos$[ebp]
  0028c	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00290	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  00294	f3 0f 11 45 b4	 movss	 DWORD PTR _pos$[ebp], xmm0

; 295  : 			pos.y += ( raw_vector.y * bridge_segment_length( segment_type ) * 0.5 );

  00299	6b 45 a4 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  0029d	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _raw_vector$[ebp+4]
  002a2	f3 0f 59 80 18
	00 00 00	 mulss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+24]
  002aa	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  002ae	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  002b6	f3 0f 5a 4d b8	 cvtss2sd xmm1, DWORD PTR _pos$[ebp+4]
  002bb	f2 0f 58 c8	 addsd	 xmm1, xmm0
  002bf	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  002c3	f3 0f 11 45 b8	 movss	 DWORD PTR _pos$[ebp+4], xmm0

; 296  : 			pos.z += ( raw_vector.z * bridge_segment_length( segment_type ) * 0.5 );

  002c8	6b 45 a4 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  002cc	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _raw_vector$[ebp+8]
  002d1	f3 0f 59 80 18
	00 00 00	 mulss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+24]
  002d9	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  002dd	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  002e5	f3 0f 5a 4d bc	 cvtss2sd xmm1, DWORD PTR _pos$[ebp+8]
  002ea	f2 0f 58 c8	 addsd	 xmm1, xmm0
  002ee	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  002f2	f3 0f 11 45 bc	 movss	 DWORD PTR _pos$[ebp+8], xmm0

; 297  : 
; 298  : 			segment_entity = create_local_entity

  002f7	6a 00		 push	 0
  002f9	8b 45 f4	 mov	 eax, DWORD PTR _bridge_entity$[ebp]
  002fc	50		 push	 eax
  002fd	6a 23		 push	 35			; 00000023H
  002ff	6a 06		 push	 6
  00301	f3 0f 5a 45 ec	 cvtss2sd xmm0, DWORD PTR _heading$[ebp]
  00306	83 ec 08	 sub	 esp, 8
  00309	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0030e	6a 34		 push	 52			; 00000034H
  00310	6a 04		 push	 4
  00312	f3 0f 5a 45 bc	 cvtss2sd xmm0, DWORD PTR _pos$[ebp+8]
  00317	83 ec 08	 sub	 esp, 8
  0031a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0031f	f3 0f 5a 45 b8	 cvtss2sd xmm0, DWORD PTR _pos$[ebp+4]
  00324	83 ec 08	 sub	 esp, 8
  00327	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0032c	f3 0f 5a 45 b4	 cvtss2sd xmm0, DWORD PTR _pos$[ebp]
  00331	83 ec 08	 sub	 esp, 8
  00334	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00339	6a 08		 push	 8
  0033b	6a 09		 push	 9
  0033d	6b 4d a4 28	 imul	 ecx, DWORD PTR _segment_type$[ebp], 40
  00341	8b 91 1c 00 00
	00		 mov	 edx, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[ecx+28]
  00347	52		 push	 edx
  00348	6a 25		 push	 37			; 00000025H
  0034a	6a 05		 push	 5
  0034c	6b 45 a4 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  00350	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax]
  00356	51		 push	 ecx
  00357	68 92 00 00 00	 push	 146			; 00000092H
  0035c	6a 05		 push	 5
  0035e	8b 55 a4	 mov	 edx, DWORD PTR _segment_type$[ebp]
  00361	52		 push	 edx
  00362	6a 0f		 push	 15			; 0000000fH
  00364	6a 05		 push	 5
  00366	6b 45 a4 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  0036a	8b 88 14 00 00
	00		 mov	 ecx, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+20]
  00370	51		 push	 ecx
  00371	6a 34		 push	 52			; 00000034H
  00373	6a 05		 push	 5
  00375	6a ff		 push	 -1
  00377	6a 1a		 push	 26			; 0000001aH
  00379	e8 00 00 00 00	 call	 ?create_local_entity@@YAPAUENTITY@@W4ENTITY_TYPES@@HZZ ; create_local_entity
  0037e	83 c4 78	 add	 esp, 120		; 00000078H
  00381	89 45 f8	 mov	 DWORD PTR _segment_entity$[ebp], eax

; 299  : 			(
; 300  : 				ENTITY_TYPE_SEGMENT,
; 301  : 				ENTITY_INDEX_DONT_CARE,
; 302  : 				ENTITY_ATTR_INT_VALUE (INT_TYPE_ENTITY_SUB_TYPE, bridge_segment_sub_type( segment_type )),
; 303  : 				ENTITY_ATTR_INT_VALUE (INT_TYPE_BRIDGE_SEGMENT_TYPE, segment_type),
; 304  : 				ENTITY_ATTR_INT_VALUE (INT_TYPE_OBJECT_3D_SHAPE, bridge_segment_normal_object( segment_type )),
; 305  : 				ENTITY_ATTR_INT_VALUE (INT_TYPE_DAMAGE_LEVEL, bridge_segment_initial_damage_level( segment_type )),
; 306  : 				ENTITY_ATTR_VEC3D (VEC3D_TYPE_POSITION, pos.x, pos.y, pos.z),
; 307  : 				ENTITY_ATTR_FLOAT_VALUE (FLOAT_TYPE_HEADING, heading),
; 308  : 				ENTITY_ATTR_PARENT (LIST_TYPE_SEGMENT, bridge_entity),
; 309  : 				ENTITY_ATTR_END
; 310  : 			);
; 311  : 
; 312  : 			pos.x += ( raw_vector.x * bridge_segment_length( segment_type ) * 0.5 );

  00384	6b 45 a4 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  00388	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _raw_vector$[ebp]
  0038d	f3 0f 59 80 18
	00 00 00	 mulss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+24]
  00395	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00399	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  003a1	f3 0f 5a 4d b4	 cvtss2sd xmm1, DWORD PTR _pos$[ebp]
  003a6	f2 0f 58 c8	 addsd	 xmm1, xmm0
  003aa	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  003ae	f3 0f 11 45 b4	 movss	 DWORD PTR _pos$[ebp], xmm0

; 313  : 			pos.y += ( raw_vector.y * bridge_segment_length( segment_type ) * 0.5 );

  003b3	6b 45 a4 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  003b7	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _raw_vector$[ebp+4]
  003bc	f3 0f 59 80 18
	00 00 00	 mulss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+24]
  003c4	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  003c8	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  003d0	f3 0f 5a 4d b8	 cvtss2sd xmm1, DWORD PTR _pos$[ebp+4]
  003d5	f2 0f 58 c8	 addsd	 xmm1, xmm0
  003d9	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  003dd	f3 0f 11 45 b8	 movss	 DWORD PTR _pos$[ebp+4], xmm0

; 314  : 			pos.z += ( raw_vector.z * bridge_segment_length( segment_type ) * 0.5 );

  003e2	6b 45 a4 28	 imul	 eax, DWORD PTR _segment_type$[ebp], 40
  003e6	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _raw_vector$[ebp+8]
  003eb	f3 0f 59 80 18
	00 00 00	 mulss	 xmm0, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[eax+24]
  003f3	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  003f7	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  003ff	f3 0f 5a 4d bc	 cvtss2sd xmm1, DWORD PTR _pos$[ebp+8]
  00404	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00408	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  0040c	f3 0f 11 45 bc	 movss	 DWORD PTR _pos$[ebp+8], xmm0

; 315  : 		}

  00411	e9 24 fe ff ff	 jmp	 $LN5@create_bri
$LN6@create_bri:

; 316  : 	}

  00416	e9 01 fe ff ff	 jmp	 $LN2@create_bri
$LN3@create_bri:

; 317  : 
; 318  : 	//
; 319  : 	// end segment
; 320  : 	//
; 321  : 
; 322  : 	if ( bridge_info->end_section_type != BRIDGE_SEGMENT_TYPE_NONE )

  0041b	8b 45 fc	 mov	 eax, DWORD PTR _bridge_info$[ebp]
  0041e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00422	0f 84 8d 00 00
	00		 je	 $LN11@create_bri

; 323  : 	{
; 324  : 		segment_entity = create_local_entity

  00428	6a 00		 push	 0
  0042a	8b 45 f4	 mov	 eax, DWORD PTR _bridge_entity$[ebp]
  0042d	50		 push	 eax
  0042e	6a 23		 push	 35			; 00000023H
  00430	6a 06		 push	 6
  00432	f3 0f 5a 45 ec	 cvtss2sd xmm0, DWORD PTR _heading$[ebp]
  00437	83 ec 08	 sub	 esp, 8
  0043a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0043f	6a 34		 push	 52			; 00000034H
  00441	6a 04		 push	 4
  00443	f3 0f 5a 45 c8	 cvtss2sd xmm0, DWORD PTR _end$[ebp+8]
  00448	83 ec 08	 sub	 esp, 8
  0044b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00450	f3 0f 5a 45 c4	 cvtss2sd xmm0, DWORD PTR _end$[ebp+4]
  00455	83 ec 08	 sub	 esp, 8
  00458	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0045d	f3 0f 5a 45 c0	 cvtss2sd xmm0, DWORD PTR _end$[ebp]
  00462	83 ec 08	 sub	 esp, 8
  00465	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0046a	6a 08		 push	 8
  0046c	6a 09		 push	 9
  0046e	8b 4d fc	 mov	 ecx, DWORD PTR _bridge_info$[ebp]
  00471	6b 51 04 28	 imul	 edx, DWORD PTR [ecx+4], 40
  00475	8b 82 1c 00 00
	00		 mov	 eax, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[edx+28]
  0047b	50		 push	 eax
  0047c	6a 25		 push	 37			; 00000025H
  0047e	6a 05		 push	 5
  00480	8b 4d fc	 mov	 ecx, DWORD PTR _bridge_info$[ebp]
  00483	6b 51 04 28	 imul	 edx, DWORD PTR [ecx+4], 40
  00487	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR ?segment_database@@3PAUBRIDGE_SEGMENT_DATA@@A[edx]
  0048d	50		 push	 eax
  0048e	68 92 00 00 00	 push	 146			; 00000092H
  00493	6a 05		 push	 5
  00495	8b 4d fc	 mov	 ecx, DWORD PTR _bridge_info$[ebp]
  00498	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0049b	52		 push	 edx
  0049c	6a 0f		 push	 15			; 0000000fH
  0049e	6a 05		 push	 5
  004a0	6a 01		 push	 1
  004a2	6a 34		 push	 52			; 00000034H
  004a4	6a 05		 push	 5
  004a6	6a ff		 push	 -1
  004a8	6a 1a		 push	 26			; 0000001aH
  004aa	e8 00 00 00 00	 call	 ?create_local_entity@@YAPAUENTITY@@W4ENTITY_TYPES@@HZZ ; create_local_entity
  004af	83 c4 78	 add	 esp, 120		; 00000078H
  004b2	89 45 f8	 mov	 DWORD PTR _segment_entity$[ebp], eax
$LN11@create_bri:

; 325  : 		(
; 326  : 			ENTITY_TYPE_SEGMENT,
; 327  : 			ENTITY_INDEX_DONT_CARE,
; 328  : 			ENTITY_ATTR_INT_VALUE (INT_TYPE_ENTITY_SUB_TYPE, ENTITY_SUB_TYPE_FIXED_BRIDGE_END_SECTION),
; 329  : 			ENTITY_ATTR_INT_VALUE (INT_TYPE_BRIDGE_SEGMENT_TYPE, bridge_info->end_section_type),
; 330  : 			ENTITY_ATTR_INT_VALUE (INT_TYPE_OBJECT_3D_SHAPE, bridge_segment_normal_object( bridge_info->end_section_type )),
; 331  : 			ENTITY_ATTR_INT_VALUE (INT_TYPE_DAMAGE_LEVEL, bridge_segment_initial_damage_level( bridge_info->end_section_type )),
; 332  : 			ENTITY_ATTR_VEC3D (VEC3D_TYPE_POSITION, end.x, end.y, end.z),
; 333  : 			ENTITY_ATTR_FLOAT_VALUE (FLOAT_TYPE_HEADING, heading),
; 334  : 			ENTITY_ATTR_PARENT (LIST_TYPE_SEGMENT, bridge_entity),
; 335  : 			ENTITY_ATTR_END
; 336  : 		);
; 337  : 	}
; 338  : 
; 339  : 	//
; 340  : 	// scale the legs
; 341  : 	//
; 342  : 
; 343  : 	if ( bridge_info->default_leg_height == 0.0 )

  004b5	8b 45 fc	 mov	 eax, DWORD PTR _bridge_info$[ebp]
  004b8	f3 0f 5a 40 08	 cvtss2sd xmm0, DWORD PTR [eax+8]
  004bd	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  004c5	9f		 lahf
  004c6	f6 c4 44	 test	 ah, 68			; 00000044H
  004c9	0f 8a a8 00 00
	00		 jp	 $LN12@create_bri

; 344  : 	{
; 345  : 		// bridge doesn't have legs
; 346  : 
; 347  : 		set_local_entity_float_value( bridge_entity, FLOAT_TYPE_SCALE, 1.0 );

  004cf	83 7d f4 00	 cmp	 DWORD PTR _bridge_entity$[ebp], 0
  004d3	74 0d		 je	 SHORT $LN15@create_bri
  004d5	8b 45 f4	 mov	 eax, DWORD PTR _bridge_entity$[ebp]
  004d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  004da	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv392[ebp], ecx
  004e0	eb 27		 jmp	 SHORT $LN16@create_bri
$LN15@create_bri:
  004e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z@4JA
  004e8	81 c2 a8 00 00
	00		 add	 edx, 168		; 000000a8H
  004ee	52		 push	 edx
  004ef	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  004f4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  004f9	50		 push	 eax
  004fa	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  004ff	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv392[ebp], 0
$LN16@create_bri:
  00509	b9 01 00 00 00	 mov	 ecx, 1
  0050e	85 c9		 test	 ecx, ecx
  00510	74 0c		 je	 SHORT $LN17@create_bri
  00512	c7 85 5c ff ff
	ff 73 00 00 00	 mov	 DWORD PTR tv400[ebp], 115 ; 00000073H
  0051c	eb 27		 jmp	 SHORT $LN18@create_bri
$LN17@create_bri:
  0051e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z@4JA
  00524	81 c2 a8 00 00
	00		 add	 edx, 168		; 000000a8H
  0052a	52		 push	 edx
  0052b	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00530	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_float_type_message@@3PBDB ; overload_invalid_float_type_message
  00535	50		 push	 eax
  00536	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  0053b	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv400[ebp], 0
$LN18@create_bri:
  00545	51		 push	 ecx
  00546	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0054e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00553	6a 73		 push	 115			; 00000073H
  00555	8b 4d f4	 mov	 ecx, DWORD PTR _bridge_entity$[ebp]
  00558	51		 push	 ecx
  00559	69 95 60 ff ff
	ff bc 02 00 00	 imul	 edx, DWORD PTR tv392[ebp], 700
  00563	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv400[ebp]
  00569	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR ?fn_set_local_entity_float_value@@3PAY0KP@P6GXPAUENTITY@@W4FLOAT_TYPES@@M@ZA[edx+eax*4]
  00570	ff d1		 call	 ecx

; 348  : 	}
; 349  : 	else

  00572	e9 a8 00 00 00	 jmp	 $LN13@create_bri
$LN12@create_bri:

; 350  : 	{
; 351  : 
; 352  : 		set_local_entity_float_value( bridge_entity, FLOAT_TYPE_SCALE, max_leg_height / bridge_info->default_leg_height );

  00577	83 7d f4 00	 cmp	 DWORD PTR _bridge_entity$[ebp], 0
  0057b	74 0d		 je	 SHORT $LN19@create_bri
  0057d	8b 45 f4	 mov	 eax, DWORD PTR _bridge_entity$[ebp]
  00580	8b 08		 mov	 ecx, DWORD PTR [eax]
  00582	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv412[ebp], ecx
  00588	eb 27		 jmp	 SHORT $LN20@create_bri
$LN19@create_bri:
  0058a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z@4JA
  00590	81 c2 ad 00 00
	00		 add	 edx, 173		; 000000adH
  00596	52		 push	 edx
  00597	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  0059c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?null_entity_pointer_message@@3PBDB ; null_entity_pointer_message
  005a1	50		 push	 eax
  005a2	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  005a7	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv412[ebp], 0
$LN20@create_bri:
  005b1	b9 01 00 00 00	 mov	 ecx, 1
  005b6	85 c9		 test	 ecx, ecx
  005b8	74 0c		 je	 SHORT $LN21@create_bri
  005ba	c7 85 5c ff ff
	ff 73 00 00 00	 mov	 DWORD PTR tv420[ebp], 115 ; 00000073H
  005c4	eb 27		 jmp	 SHORT $LN22@create_bri
$LN21@create_bri:
  005c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z@4JA
  005cc	81 c2 ad 00 00
	00		 add	 edx, 173		; 000000adH
  005d2	52		 push	 edx
  005d3	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  005d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?overload_invalid_float_type_message@@3PBDB ; overload_invalid_float_type_message
  005dd	50		 push	 eax
  005de	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
  005e3	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv420[ebp], 0
$LN22@create_bri:
  005ed	8b 4d fc	 mov	 ecx, DWORD PTR _bridge_info$[ebp]
  005f0	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _max_leg_height$[ebp]
  005f5	f3 0f 5e 41 08	 divss	 xmm0, DWORD PTR [ecx+8]
  005fa	51		 push	 ecx
  005fb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00600	6a 73		 push	 115			; 00000073H
  00602	8b 55 f4	 mov	 edx, DWORD PTR _bridge_entity$[ebp]
  00605	52		 push	 edx
  00606	69 85 60 ff ff
	ff bc 02 00 00	 imul	 eax, DWORD PTR tv412[ebp], 700
  00610	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR tv420[ebp]
  00616	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR ?fn_set_local_entity_float_value@@3PAY0KP@P6GXPAUENTITY@@W4FLOAT_TYPES@@M@ZA[eax+ecx*4]
  0061d	ff d2		 call	 edx
$LN13@create_bri:

; 353  : 	}
; 354  : 
; 355  : 	return bridge_entity;

  0061f	8b 45 f4	 mov	 eax, DWORD PTR _bridge_entity$[ebp]

; 356  : }

  00622	5f		 pop	 edi
  00623	5e		 pop	 esi
  00624	5b		 pop	 ebx
  00625	8b e5		 mov	 esp, ebp
  00627	5d		 pop	 ebp
  00628	c2 18 00	 ret	 24			; 00000018H
?create_bridge@@YGPAUENTITY@@PAUVEC3D@@0HHHM@Z ENDP	; create_bridge
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\entity\special\bridge\bridge.c
;	COMDAT ?initialise_valid_warzone_bridge_database@@YGXXZ
_TEXT	SEGMENT
tv86 = -216						; size = 4
_bridge_type$1 = -148					; size = 4
_tag$ = -144						; size = 4
_file_ptr$ = -140					; size = 4
_current_session$ = -136				; size = 4
_temp_filename$ = -132					; size = 128
_result$ = -4						; size = 4
?initialise_valid_warzone_bridge_database@@YGXXZ PROC	; initialise_valid_warzone_bridge_database, COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 94   : 
; 95   : 	int
; 96   : 		result;
; 97   : 
; 98   : 	char
; 99   : 		temp_filename [128];
; 100  : 
; 101  : 	session_list_data_type
; 102  : 		*current_session;
; 103  : 
; 104  : 	FILE
; 105  : 		*file_ptr;
; 106  : 
; 107  : 	file_tags
; 108  : 		tag;
; 109  : 
; 110  : 	memset (valid_warzone_bridges, 0, sizeof (valid_warzone_bridges));

  0000c	6a 08		 push	 8
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET ?valid_warzone_bridges@@3PADA ; valid_warzone_bridges
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 111  : 
; 112  : 	//
; 113  : 	// read in valid_bridge_warzone file
; 114  : 	//
; 115  : 
; 116  : 	ASSERT (get_valid_current_game_session ());

  0001d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?current_game_session@@3PAUSESSION_LIST_DATA_TYPE@@A, 0 ; current_game_session
  00024	75 18		 jne	 SHORT $LN8@initialise
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??initialise_valid_warzone_bridge_database@@YGXXZ@4JA
  0002b	83 c0 17	 add	 eax, 23			; 00000017H
  0002e	50		 push	 eax
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@EEKIOPJL@get_valid_current_game_session?5@
  00039	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN8@initialise:

; 117  : 
; 118  : 	current_session = get_current_game_session ();

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?current_game_session@@3PAUSESSION_LIST_DATA_TYPE@@A ; current_game_session
  00043	89 85 78 ff ff
	ff		 mov	 DWORD PTR _current_session$[ebp], eax

; 119  : 
; 120  : 	sprintf (temp_filename, "%s\\%s", current_session->data_path, VALID_BRIDGE_WARZONE_FILE);

  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OMLBFHIA@route?2bridge?4pop@
  0004e	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _current_session$[ebp]
  00054	83 c0 1c	 add	 eax, 28			; 0000001cH
  00057	50		 push	 eax
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
  0005d	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _temp_filename$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 _sprintf
  00069	83 c4 10	 add	 esp, 16			; 00000010H

; 121  : 
; 122  : 	file_ptr = safe_fopen (temp_filename, "r");

  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  00071	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _temp_filename$[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?safe_fopen@@YGPAU_iobuf@@PBD0@Z ; safe_fopen
  0007d	89 85 74 ff ff
	ff		 mov	 DWORD PTR _file_ptr$[ebp], eax

; 123  : 
; 124  : 	if (file_ptr)

  00083	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _file_ptr$[ebp], 0
  0008a	0f 84 e8 00 00
	00		 je	 $LN1@initialise
$LN2@initialise:

; 125  : 	{
; 126  : 
; 127  : 		while (TRUE)

  00090	b8 01 00 00 00	 mov	 eax, 1
  00095	85 c0		 test	 eax, eax
  00097	0f 84 db 00 00
	00		 je	 $LN1@initialise

; 128  : 		{
; 129  : 
; 130  : 			tag = (file_tags) get_next_file_tag (file_ptr, application_tag_strings, FILE_TAG_APPLICATION_LAST_TAG);

  0009d	68 af 00 00 00	 push	 175			; 000000afH
  000a2	68 00 00 00 00	 push	 OFFSET ?application_tag_strings@@3PAPBDA ; application_tag_strings
  000a7	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _file_ptr$[ebp]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ?get_next_file_tag@@YGHPAU_iobuf@@QAPBDH@Z ; get_next_file_tag
  000b3	89 85 70 ff ff
	ff		 mov	 DWORD PTR _tag$[ebp], eax

; 131  : 
; 132  : 			switch (tag)

  000b9	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _tag$[ebp]
  000bf	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv86[ebp], eax
  000c5	83 bd 28 ff ff
	ff f6		 cmp	 DWORD PTR tv86[ebp], -10 ; fffffff6H
  000cc	0f 84 8f 00 00
	00		 je	 $LN13@initialise
  000d2	83 bd 28 ff ff
	ff 09		 cmp	 DWORD PTR tv86[ebp], 9
  000d9	74 0a		 je	 SHORT $LN6@initialise
  000db	e9 93 00 00 00	 jmp	 $LN4@initialise

; 133  : 			{
; 134  : 
; 135  : 				case FILE_TAG_START:
; 136  : 				{
; 137  : 
; 138  : 					break;

  000e0	e9 8e 00 00 00	 jmp	 $LN4@initialise
$LN6@initialise:

; 139  : 				}
; 140  : 
; 141  : 				case FILE_TAG_BRIDGE:
; 142  : 				{
; 143  : 
; 144  : 					entity_sub_types
; 145  : 						bridge_type;
; 146  : 
; 147  : 					while (check_next_file_tag (file_ptr, application_tag_strings, FILE_TAG_APPLICATION_LAST_TAG) != FILE_TAG_END)

  000e5	68 af 00 00 00	 push	 175			; 000000afH
  000ea	68 00 00 00 00	 push	 OFFSET ?application_tag_strings@@3PAPBDA ; application_tag_strings
  000ef	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _file_ptr$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ?check_next_file_tag@@YGHPAU_iobuf@@QAPBDH@Z ; check_next_file_tag
  000fb	83 f8 f6	 cmp	 eax, -10		; fffffff6H
  000fe	74 5f		 je	 SHORT $LN7@initialise

; 148  : 					{
; 149  : 
; 150  : 						result = get_next_file_tag (file_ptr, application_tag_strings, FILE_TAG_APPLICATION_LAST_TAG);

  00100	68 af 00 00 00	 push	 175			; 000000afH
  00105	68 00 00 00 00	 push	 OFFSET ?application_tag_strings@@3PAPBDA ; application_tag_strings
  0010a	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _file_ptr$[ebp]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 ?get_next_file_tag@@YGHPAU_iobuf@@QAPBDH@Z ; get_next_file_tag
  00116	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax

; 151  : 
; 152  : 						ASSERT (result == FILE_TAG_TYPE);

  00119	83 7d fc e6	 cmp	 DWORD PTR _result$[ebp], -26 ; ffffffe6H
  0011d	74 18		 je	 SHORT $LN12@initialise
  0011f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??initialise_valid_warzone_bridge_database@@YGXXZ@4JA
  00124	83 c0 3b	 add	 eax, 59			; 0000003bH
  00127	50		 push	 eax
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOFEKFFG@c?3?2users?2nhv90?2projects?2eech?2ap@
  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NHAOLFJJ@result?5?$DN?$DN?5FILE_TAG_TYPE@
  00132	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN12@initialise:

; 153  : 
; 154  : 						bridge_type = get_next_file_enum (file_ptr, entity_sub_type_bridge_names, NUM_ENTITY_SUB_TYPE_BRIDGES);

  00137	6a 08		 push	 8
  00139	68 00 00 00 00	 push	 OFFSET ?entity_sub_type_bridge_names@@3PAPBDA ; entity_sub_type_bridge_names
  0013e	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _file_ptr$[ebp]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 ?get_next_file_enum@@YGHPAU_iobuf@@QAPBDH@Z ; get_next_file_enum
  0014a	89 85 6c ff ff
	ff		 mov	 DWORD PTR _bridge_type$1[ebp], eax

; 155  : 
; 156  : 						valid_warzone_bridges [bridge_type] = TRUE;

  00150	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _bridge_type$1[ebp]
  00156	c6 80 00 00 00
	00 01		 mov	 BYTE PTR ?valid_warzone_bridges@@3PADA[eax], 1

; 157  : 					}

  0015d	eb 86		 jmp	 SHORT $LN6@initialise
$LN7@initialise:

; 158  : 
; 159  : 					break;

  0015f	eb 12		 jmp	 SHORT $LN4@initialise
$LN13@initialise:

; 160  : 				}
; 161  : 
; 162  : 				case FILE_TAG_END:
; 163  : 				{
; 164  : 
; 165  : 					fclose (file_ptr);

  00161	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _file_ptr$[ebp]
  00167	50		 push	 eax
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0016e	83 c4 04	 add	 esp, 4

; 166  : 
; 167  : 					return;

  00171	eb 05		 jmp	 SHORT $LN1@initialise
$LN4@initialise:

; 168  : 				}
; 169  : 			}
; 170  : 		}

  00173	e9 18 ff ff ff	 jmp	 $LN2@initialise
$LN1@initialise:

; 171  : 	}
; 172  : }

  00178	5f		 pop	 edi
  00179	5e		 pop	 esi
  0017a	5b		 pop	 ebx
  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c3		 ret	 0
?initialise_valid_warzone_bridge_database@@YGXXZ ENDP	; initialise_valid_warzone_bridge_database
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?fabs@@YGMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?fabs@@YGMM@Z PROC					; fabs, COMDAT

; 112  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 113  : 	return (_CSTD fabsf(_Xx));

  00009	51		 push	 ecx
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
  0000f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00014	e8 00 00 00 00	 call	 _fabsf
  00019	83 c4 04	 add	 esp, 4

; 114  : 	}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?fabs@@YGMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?asin@@YGMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?asin@@YGMM@Z PROC					; asin, COMDAT

; 36   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 37   : 	return (_CSTD asinf(_Xx));

  00009	51		 push	 ecx
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
  0000f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00014	e8 00 00 00 00	 call	 _asinf
  00019	83 c4 04	 add	 esp, 4

; 38   : 	}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?asin@@YGMM@Z ENDP					; asin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv71 = -68						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 671  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 672  :             return (float)fabs(_X);

  00009	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0000e	83 ec 08	 sub	 esp, 8
  00011	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00016	e8 00 00 00 00	 call	 _fabs
  0001b	83 c4 08	 add	 esp, 8
  0001e	d9 5d bc	 fstp	 DWORD PTR tv71[ebp]
  00021	d9 45 bc	 fld	 DWORD PTR tv71[ebp]

; 673  :         }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _asinf
_TEXT	SEGMENT
tv71 = -68						; size = 4
__X$ = 8						; size = 4
_asinf	PROC						; COMDAT

; 628  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 629  :             return (float)asin(_X);

  00009	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0000e	83 ec 08	 sub	 esp, 8
  00011	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00016	e8 00 00 00 00	 call	 _asin
  0001b	83 c4 08	 add	 esp, 8
  0001e	d9 5d bc	 fstp	 DWORD PTR tv71[ebp]
  00021	d9 45 bc	 fld	 DWORD PTR tv71[ebp]

; 630  :         }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_asinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1459 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1460 :         #pragma warning(push)
; 1461 :         #pragma warning(disable: 4996) // Deprecation
; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1463 :         #pragma warning(pop)
; 1464 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH
  00035	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00038	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003c	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003e	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00045	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00047	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  0004a	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004d	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1395 :     }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
