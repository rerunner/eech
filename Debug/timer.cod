; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\system\timer.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?system_ticks@@3HC				; system_ticks
PUBLIC	?system_interrupt_timer_id@@3HA			; system_interrupt_timer_id
PUBLIC	?system_timer_id@@3HA				; system_timer_id
_BSS	SEGMENT
?system_ticks@@3HC DD 01H DUP (?)			; system_ticks
?system_interrupt_timer_id@@3HA DD 01H DUP (?)		; system_interrupt_timer_id
?system_timer_id@@3HA DD 01H DUP (?)			; system_timer_id
_BSS	ENDS
PUBLIC	?initialise_timers_system@@YGHXZ		; initialise_timers_system
PUBLIC	?create_timer_event@@YGHIIP6GXXZ@Z		; create_timer_event
PUBLIC	?destroy_timer_event@@YGHH@Z			; destroy_timer_event
PUBLIC	?system_sleep@@YGXH@Z				; system_sleep
PUBLIC	?windows_system_timer@@YGXXZ			; windows_system_timer
PUBLIC	?windows_system_timer_interrupt@@YGXIIKKK@Z	; windows_system_timer_interrupt
PUBLIC	??_C@_0CD@GABAHBKF@Timer?5resolution?3?5min?3?5?$CFd?0?5max?3@ ; `string'
PUBLIC	??_C@_0CC@FJHBGILO@Can?8t?5initialise?5the?5timer?5syst@ ; `string'
PUBLIC	??_C@_0BA@HADFCHGL@Created?5a?5timer@		; `string'
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__SetTimer@16:PROC
EXTRN	__imp__KillTimer@8:PROC
EXTRN	__imp__timeSetEvent@20:PROC
EXTRN	__imp__timeKillEvent@4:PROC
EXTRN	__imp__timeGetDevCaps@8:PROC
EXTRN	__imp__timeBeginPeriod@4:PROC
EXTRN	__imp__timeEndPeriod@4:PROC
EXTRN	?register_exit_function@@YGXP6GXXZ@Z:PROC	; register_exit_function
EXTRN	?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z:PROC ; register_system_message_function
EXTRN	?debug_log@@YAXPBDZZ:PROC			; debug_log
EXTRN	?application_window@@3PAUHWND__@@A:DWORD	; application_window
EXTRN	?application_active@@3HA:DWORD			; application_active
EXTRN	?bExiting@@3HA:DWORD				; bExiting
_BSS	SEGMENT
?number_of_timers@@3HA DD 01H DUP (?)			; number_of_timers
?timer_list@@3PAUTIMER_EVENT_STRUCT@@A DQ 010H DUP (?)	; timer_list
_BSS	ENDS
;	COMDAT ??_C@_0BA@HADFCHGL@Created?5a?5timer@
CONST	SEGMENT
??_C@_0BA@HADFCHGL@Created?5a?5timer@ DB 'Created a timer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FJHBGILO@Can?8t?5initialise?5the?5timer?5syst@
CONST	SEGMENT
??_C@_0CC@FJHBGILO@Can?8t?5initialise?5the?5timer?5syst@ DB 'Can''t initi'
	DB	'alise the timer system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GABAHBKF@Timer?5resolution?3?5min?3?5?$CFd?0?5max?3@
CONST	SEGMENT
??_C@_0CD@GABAHBKF@Timer?5resolution?3?5min?3?5?$CFd?0?5max?3@ DB 'Timer '
	DB	'resolution: min: %d, max: %d', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\timer.c
;	COMDAT ?windows_system_timer_interrupt@@YGXIIKKK@Z
_TEXT	SEGMENT
_IDEvent$ = 8						; size = 4
_uReserved$ = 12					; size = 4
_dwUser$ = 16						; size = 4
_dwReserved1$ = 20					; size = 4
_dwReserved2$ = 24					; size = 4
?windows_system_timer_interrupt@@YGXIIKKK@Z PROC	; windows_system_timer_interrupt, COMDAT

; 396  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 397  : 
; 398  : 	if ( ( !bExiting ) && ( application_active ) )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bExiting@@3HA, 0 ; bExiting
  00010	75 16		 jne	 SHORT $LN1@windows_sy
  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?application_active@@3HA, 0 ; application_active
  00019	74 0d		 je	 SHORT $LN1@windows_sy

; 399  : 	{
; 400  : 
; 401  : 		system_ticks ++;

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?system_ticks@@3HC ; system_ticks
  00020	83 c0 01	 add	 eax, 1
  00023	a3 00 00 00 00	 mov	 DWORD PTR ?system_ticks@@3HC, eax ; system_ticks
$LN1@windows_sy:

; 402  : 	}
; 403  : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 14 00	 ret	 20			; 00000014H
?windows_system_timer_interrupt@@YGXIIKKK@Z ENDP	; windows_system_timer_interrupt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\timer.c
;	COMDAT ?windows_system_timer@@YGXXZ
_TEXT	SEGMENT
?windows_system_timer@@YGXXZ PROC			; windows_system_timer, COMDAT

; 358  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 359  : 
; 360  : 	if ( !bExiting )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bExiting@@3HA, 0 ; bExiting
  00010	75 16		 jne	 SHORT $LN1@windows_sy

; 361  : 	{
; 362  : 
; 363  : 		if ( application_active )

  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?application_active@@3HA, 0 ; application_active
  00019	74 0d		 je	 SHORT $LN1@windows_sy

; 364  : 		{
; 365  : 
; 366  : 			system_ticks +=10;

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?system_ticks@@3HC ; system_ticks
  00020	83 c0 0a	 add	 eax, 10			; 0000000aH
  00023	a3 00 00 00 00	 mov	 DWORD PTR ?system_ticks@@3HC, eax ; system_ticks
$LN1@windows_sy:

; 367  : 		}
; 368  : 	}
; 369  : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?windows_system_timer@@YGXXZ ENDP			; windows_system_timer
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\timer.c
;	COMDAT ?deinitialise_timers_system@@YGXXZ
_TEXT	SEGMENT
_count$ = -4						; size = 4
?deinitialise_timers_system@@YGXXZ PROC			; deinitialise_timers_system, COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 204  : 
; 205  : 	int
; 206  : 		count;
; 207  : 
; 208  : 	for ( count = 0; count < number_of_timers; count++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@deinitiali
$LN2@deinitiali:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@deinitiali:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_timers@@3HA
  00024	7d 3c		 jge	 SHORT $LN3@deinitiali

; 209  : 	{
; 210  : 
; 211  : 		if ( timer_list[count].used )

  00026	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00029	83 3c c5 00 00
	00 00 00	 cmp	 DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8], 0
  00031	74 2d		 je	 SHORT $LN5@deinitiali

; 212  : 		{
; 213  : 
; 214  : 			timeKillEvent ( timer_list[count].id );

  00033	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00036	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8+4]
  0003d	51		 push	 ecx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeKillEvent@4

; 215  : 		
; 216  : 			timer_list[count].used = FALSE;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00047	c7 04 c5 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8], 0

; 217  : 
; 218  : 			timer_list[count].id = 0;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00055	c7 04 c5 04 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8+4], 0
$LN5@deinitiali:

; 219  : 		}
; 220  : 	}

  00060	eb b0		 jmp	 SHORT $LN2@deinitiali
$LN3@deinitiali:

; 221  : 
; 222  : 	timeEndPeriod ( 10 );

  00062	6a 0a		 push	 10			; 0000000aH
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeEndPeriod@4

; 223  : 
; 224  : //	if ( system_interrupt_timer_id )
; 225  : //	{
; 226  : //
; 227  : //		timeKillEvent ( system_interrupt_timer_id );
; 228  : //
; 229  : //		system_interrupt_timer_id = 0;
; 230  : //	}
; 231  : 
; 232  : 
; 233  : 	if ( system_timer_id )

  0006a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?system_timer_id@@3HA, 0 ; system_timer_id
  00071	74 1d		 je	 SHORT $LN1@deinitiali

; 234  : 	{
; 235  : 
; 236  : 		KillTimer ( application_window, system_timer_id );

  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR ?system_timer_id@@3HA ; system_timer_id
  00078	50		 push	 eax
  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  0007f	51		 push	 ecx
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 237  : 
; 238  : 		system_timer_id = 0;

  00086	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?system_timer_id@@3HA, 0 ; system_timer_id
$LN1@deinitiali:

; 239  : 	}
; 240  : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?deinitialise_timers_system@@YGXXZ ENDP			; deinitialise_timers_system
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\timer.c
;	COMDAT ?windows_timer_routine@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?windows_timer_routine@@YGJPAUHWND__@@IIJ@Z PROC	; windows_timer_routine, COMDAT

; 376  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 377  : 
; 378  : 	if ( !bExiting )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bExiting@@3HA, 0 ; bExiting
  00010	75 16		 jne	 SHORT $LN2@windows_ti

; 379  : 	{
; 380  : 
; 381  : 		if ( application_active )

  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?application_active@@3HA, 0 ; application_active
  00019	74 0d		 je	 SHORT $LN2@windows_ti

; 382  : 		{
; 383  : 
; 384  : 			system_ticks += 10;

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?system_ticks@@3HC ; system_ticks
  00020	83 c0 0a	 add	 eax, 10			; 0000000aH
  00023	a3 00 00 00 00	 mov	 DWORD PTR ?system_ticks@@3HC, eax ; system_ticks
$LN2@windows_ti:

; 385  : 		}
; 386  : 	}
; 387  : 
; 388  : 	return ( 0 );

  00028	33 c0		 xor	 eax, eax

; 389  : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
?windows_timer_routine@@YGJPAUHWND__@@IIJ@Z ENDP	; windows_timer_routine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\timer.c
;	COMDAT ?windows_timer_interrupt@@YGXIIKKK@Z
_TEXT	SEGMENT
_function$ = -4						; size = 4
_IDEvent$ = 8						; size = 4
_uReserved$ = 12					; size = 4
_dwUser$ = 16						; size = 4
_dwReserved1$ = 20					; size = 4
_dwReserved2$ = 24					; size = 4
?windows_timer_interrupt@@YGXIIKKK@Z PROC		; windows_timer_interrupt, COMDAT

; 335  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 336  : 
; 337  : 	void ( * function ) ( void );
; 338  : 
; 339  : 
; 340  : 	function = ( void ( * ) ( void ) ) dwUser;

  00009	8b 45 10	 mov	 eax, DWORD PTR _dwUser$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _function$[ebp], eax

; 341  : 
; 342  : 	if ( ( !bExiting ) && ( application_active ) )

  0000f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bExiting@@3HA, 0 ; bExiting
  00016	75 12		 jne	 SHORT $LN1@windows_ti
  00018	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?application_active@@3HA, 0 ; application_active
  0001f	74 09		 je	 SHORT $LN1@windows_ti

; 343  : 	{
; 344  : 
; 345  : 		if ( function )

  00021	83 7d fc 00	 cmp	 DWORD PTR _function$[ebp], 0
  00025	74 03		 je	 SHORT $LN1@windows_ti

; 346  : 		{
; 347  : 	
; 348  : 			function ();

  00027	ff 55 fc	 call	 DWORD PTR _function$[ebp]
$LN1@windows_ti:

; 349  : 		}
; 350  : 	}
; 351  : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 14 00	 ret	 20			; 00000014H
?windows_timer_interrupt@@YGXIIKKK@Z ENDP		; windows_timer_interrupt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\timer.c
;	COMDAT ?system_sleep@@YGXH@Z
_TEXT	SEGMENT
_milliseconds$ = 8					; size = 4
?system_sleep@@YGXH@Z PROC				; system_sleep, COMDAT

; 410  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 411  : 
; 412  : 	Sleep ( milliseconds );

  00009	8b 45 08	 mov	 eax, DWORD PTR _milliseconds$[ebp]
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 413  : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?system_sleep@@YGXH@Z ENDP				; system_sleep
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\timer.c
;	COMDAT ?destroy_timer_event@@YGHH@Z
_TEXT	SEGMENT
_found$ = -8						; size = 4
_count$ = -4						; size = 4
_timer_id$ = 8						; size = 4
?destroy_timer_event@@YGHH@Z PROC			; destroy_timer_event, COMDAT

; 296  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 297  : 
; 298  : 	int
; 299  : 		count,
; 300  : 		found;
; 301  : 
; 302  : 	found = FALSE;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _found$[ebp], 0

; 303  : 
; 304  : 	for ( count = 0; ( ( count < number_of_timers ) && ( !found ) ); count++ )

  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@destroy_ti
$LN2@destroy_ti:
  00019	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@destroy_ti:
  00022	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00025	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_timers@@3HA
  0002b	7d 29		 jge	 SHORT $LN3@destroy_ti
  0002d	83 7d f8 00	 cmp	 DWORD PTR _found$[ebp], 0
  00031	75 23		 jne	 SHORT $LN3@destroy_ti

; 305  : 	{
; 306  : 
; 307  : 		if ( ( timer_list[count].used ) && ( timer_list[count].id ) )

  00033	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00036	83 3c c5 00 00
	00 00 00	 cmp	 DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8], 0
  0003e	74 14		 je	 SHORT $LN5@destroy_ti
  00040	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00043	83 3c c5 04 00
	00 00 00	 cmp	 DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8+4], 0
  0004b	74 07		 je	 SHORT $LN5@destroy_ti

; 308  : 		{
; 309  : 
; 310  : 			found = TRUE;

  0004d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _found$[ebp], 1
$LN5@destroy_ti:

; 311  : 		}
; 312  : 	}

  00054	eb c3		 jmp	 SHORT $LN2@destroy_ti
$LN3@destroy_ti:

; 313  : 
; 314  : 	if ( found )

  00056	83 7d f8 00	 cmp	 DWORD PTR _found$[ebp], 0
  0005a	74 28		 je	 SHORT $LN6@destroy_ti

; 315  : 	{
; 316  : 
; 317  : 		timeKillEvent ( timer_list[count].id );

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0005f	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8+4]
  00066	51		 push	 ecx
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeKillEvent@4

; 318  : 
; 319  : 		timer_list[count].used = FALSE;

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00070	c7 04 c5 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8], 0

; 320  : 
; 321  : 		return ( TRUE );

  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	eb 04		 jmp	 SHORT $LN1@destroy_ti

; 322  : 	}
; 323  : 	else

  00082	eb 02		 jmp	 SHORT $LN1@destroy_ti
$LN6@destroy_ti:

; 324  : 	{
; 325  : 
; 326  : 		return ( FALSE );

  00084	33 c0		 xor	 eax, eax
$LN1@destroy_ti:

; 327  : 	}
; 328  : }

  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
?destroy_timer_event@@YGHH@Z ENDP			; destroy_timer_event
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\timer.c
;	COMDAT ?create_timer_event@@YGHIIP6GXXZ@Z
_TEXT	SEGMENT
_found$ = -8						; size = 4
_count$ = -4						; size = 4
_delay$ = 8						; size = 4
_resolution$ = 12					; size = 4
_function$ = 16						; size = 4
?create_timer_event@@YGHIIP6GXXZ@Z PROC			; create_timer_event, COMDAT

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 248  : 
; 249  : 	int
; 250  : 		count,
; 251  : 		found;
; 252  : 
; 253  : 	found = FALSE;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _found$[ebp], 0

; 254  : 
; 255  : 	for ( count = 0; ( ( count < MAX_NUMBER_TIMERS ) && ( !found ) ); count++ )

  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@create_tim
$LN2@create_tim:
  00019	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@create_tim:
  00022	83 7d fc 10	 cmp	 DWORD PTR _count$[ebp], 16 ; 00000010H
  00026	7d 1c		 jge	 SHORT $LN3@create_tim
  00028	83 7d f8 00	 cmp	 DWORD PTR _found$[ebp], 0
  0002c	75 16		 jne	 SHORT $LN3@create_tim

; 256  : 	{
; 257  : 
; 258  : 		if ( !timer_list[count].used )

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00031	83 3c c5 00 00
	00 00 00	 cmp	 DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8], 0
  00039	75 07		 jne	 SHORT $LN5@create_tim

; 259  : 		{
; 260  : 
; 261  : 			found = TRUE;

  0003b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _found$[ebp], 1
$LN5@create_tim:

; 262  : 		}
; 263  : 	}

  00042	eb d5		 jmp	 SHORT $LN2@create_tim
$LN3@create_tim:

; 264  : 
; 265  : 	if ( !found )

  00044	83 7d f8 00	 cmp	 DWORD PTR _found$[ebp], 0
  00048	75 04		 jne	 SHORT $LN6@create_tim

; 266  : 	{
; 267  : 
; 268  : 		return ( FALSE );

  0004a	33 c0		 xor	 eax, eax
  0004c	eb 68		 jmp	 SHORT $LN1@create_tim
$LN6@create_tim:

; 269  : 	}
; 270  : 
; 271  : 	timer_list[count].id = timeSetEvent ( delay, resolution, windows_timer_interrupt, (DWORD) function, TIME_PERIODIC );

  0004e	6a 01		 push	 1
  00050	8b 45 10	 mov	 eax, DWORD PTR _function$[ebp]
  00053	50		 push	 eax
  00054	68 00 00 00 00	 push	 OFFSET ?windows_timer_interrupt@@YGXIIKKK@Z ; windows_timer_interrupt
  00059	8b 4d 0c	 mov	 ecx, DWORD PTR _resolution$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 08	 mov	 edx, DWORD PTR _delay$[ebp]
  00060	52		 push	 edx
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeSetEvent@20
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0006a	89 04 cd 04 00
	00 00		 mov	 DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[ecx*8+4], eax

; 272  : 
; 273  : 	if ( timer_list[count].id )

  00071	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00074	83 3c c5 04 00
	00 00 00	 cmp	 DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8+4], 0
  0007c	74 36		 je	 SHORT $LN7@create_tim

; 274  : 	{
; 275  : 
; 276  : 		timer_list[count].used = TRUE;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00081	c7 04 c5 00 00
	00 00 01 00 00
	00		 mov	 DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8], 1

; 277  : 
; 278  : 		number_of_timers++;

  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_timers@@3HA
  00091	83 c0 01	 add	 eax, 1
  00094	a3 00 00 00 00	 mov	 DWORD PTR ?number_of_timers@@3HA, eax

; 279  : 
; 280  : 		debug_log ( "Created a timer" );

  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HADFCHGL@Created?5a?5timer@
  0009e	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  000a3	83 c4 04	 add	 esp, 4

; 281  : 
; 282  : 		return ( timer_list[count].id );

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000a9	8b 04 c5 04 00
	00 00		 mov	 eax, DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8+4]
  000b0	eb 04		 jmp	 SHORT $LN1@create_tim

; 283  : 	}
; 284  : 	else

  000b2	eb 02		 jmp	 SHORT $LN1@create_tim
$LN7@create_tim:

; 285  : 	{
; 286  : 
; 287  : 		return ( FALSE );

  000b4	33 c0		 xor	 eax, eax
$LN1@create_tim:

; 288  : 	}
; 289  : }

  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 0c 00	 ret	 12			; 0000000cH
?create_timer_event@@YGHIIP6GXXZ@Z ENDP			; create_timer_event
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\timer.c
;	COMDAT ?initialise_timers_system@@YGHXZ
_TEXT	SEGMENT
_tc$ = -16						; size = 8
_result$ = -8						; size = 4
_count$ = -4						; size = 4
?initialise_timers_system@@YGHXZ PROC			; initialise_timers_system, COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 132  : 
; 133  : 	int
; 134  : 		count;
; 135  : 
; 136  : 	MMRESULT
; 137  : 		result;
; 138  : 
; 139  : 	TIMECAPS
; 140  : 		tc;
; 141  : 
; 142  : 	system_ticks = 0;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?system_ticks@@3HC, 0 ; system_ticks

; 143  : 
; 144  : 	number_of_timers = 0;

  00013	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?number_of_timers@@3HA, 0

; 145  : 
; 146  : 	for ( count = 0; count < MAX_NUMBER_TIMERS; count++ )

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00024	eb 09		 jmp	 SHORT $LN4@initialise
$LN2@initialise:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@initialise:
  0002f	83 7d fc 10	 cmp	 DWORD PTR _count$[ebp], 16 ; 00000010H
  00033	7d 1e		 jge	 SHORT $LN3@initialise

; 147  : 	{
; 148  : 
; 149  : 		timer_list[count].used = FALSE;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00038	c7 04 c5 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8], 0

; 150  : 
; 151  : 		timer_list[count].id = 0;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00046	c7 04 c5 04 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?timer_list@@3PAUTIMER_EVENT_STRUCT@@A[eax*8+4], 0

; 152  : 	}

  00051	eb d3		 jmp	 SHORT $LN2@initialise
$LN3@initialise:

; 153  : 
; 154  : 	register_exit_function ( deinitialise_timers_system );

  00053	68 00 00 00 00	 push	 OFFSET ?deinitialise_timers_system@@YGXXZ ; deinitialise_timers_system
  00058	e8 00 00 00 00	 call	 ?register_exit_function@@YGXP6GXXZ@Z ; register_exit_function

; 155  : 
; 156  : 	register_system_message_function ( WM_TIMER, windows_timer_routine );

  0005d	68 00 00 00 00	 push	 OFFSET ?windows_timer_routine@@YGJPAUHWND__@@IIJ@Z ; windows_timer_routine
  00062	68 13 01 00 00	 push	 275			; 00000113H
  00067	e8 00 00 00 00	 call	 ?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z ; register_system_message_function

; 157  : 
; 158  : 	timeGetDevCaps ( &tc, sizeof ( TIMECAPS ) );

  0006c	6a 08		 push	 8
  0006e	8d 45 f0	 lea	 eax, DWORD PTR _tc$[ebp]
  00071	50		 push	 eax
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetDevCaps@8

; 159  : 
; 160  : 	debug_log ( "Timer resolution: min: %d, max: %d", tc.wPeriodMin, tc.wPeriodMax );

  00078	8b 45 f4	 mov	 eax, DWORD PTR _tc$[ebp+4]
  0007b	50		 push	 eax
  0007c	8b 4d f0	 mov	 ecx, DWORD PTR _tc$[ebp]
  0007f	51		 push	 ecx
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@GABAHBKF@Timer?5resolution?3?5min?3?5?$CFd?0?5max?3@
  00085	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 
; 162  : 	result = timeBeginPeriod ( 10 );

  0008d	6a 0a		 push	 10			; 0000000aH
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeBeginPeriod@4
  00095	89 45 f8	 mov	 DWORD PTR _result$[ebp], eax

; 163  : 
; 164  : 	if ( result == TIMERR_NOCANDO )

  00098	83 7d f8 61	 cmp	 DWORD PTR _result$[ebp], 97 ; 00000061H
  0009c	75 13		 jne	 SHORT $LN5@initialise

; 165  : 	{
; 166  : 
; 167  : 		debug_log ( "Can't initialise the timer system" );

  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@FJHBGILO@Can?8t?5initialise?5the?5timer?5syst@
  000a3	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  000a8	83 c4 04	 add	 esp, 4

; 168  : 
; 169  : 		return ( FALSE );

  000ab	33 c0		 xor	 eax, eax
  000ad	eb 28		 jmp	 SHORT $LN1@initialise

; 170  : 	}
; 171  : 	else

  000af	eb 26		 jmp	 SHORT $LN1@initialise
$LN5@initialise:

; 172  : 	{
; 173  : 
; 174  : 		system_timer_id = 1;

  000b1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?system_timer_id@@3HA, 1 ; system_timer_id

; 175  : 
; 176  : 		SetTimer ( application_window, system_timer_id, 100, NULL );

  000bb	6a 00		 push	 0
  000bd	6a 64		 push	 100			; 00000064H
  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?system_timer_id@@3HA ; system_timer_id
  000c4	50		 push	 eax
  000c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  000cb	51		 push	 ecx
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 177  : 
; 178  : 
; 179  : // DEBUG
; 180  : 
; 181  : //		system_interrupt_timer_id = timeSetEvent
; 182  : //		(
; 183  : //			10,
; 184  : //			1,
; 185  : //			windows_system_timer_interrupt,
; 186  : //			0,
; 187  : //			TIME_PERIODIC
; 188  : //		);
; 189  : 
; 190  : // DEBUG
; 191  : 	
; 192  : //		system_timer_id = create_timer_event ( 10, 1, windows_system_timer );
; 193  : 	
; 194  : 		return ( TRUE );

  000d2	b8 01 00 00 00	 mov	 eax, 1
$LN1@initialise:

; 195  : 	}
; 196  : }

  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
?initialise_timers_system@@YGHXZ ENDP			; initialise_timers_system
_TEXT	ENDS
END
