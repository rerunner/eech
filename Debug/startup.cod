; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\system\startup.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?application_window@@3PAUHWND__@@A		; application_window
PUBLIC	?application_instance@@3PAUHINSTANCE__@@A	; application_instance
PUBLIC	?application_critical_section@@3U_RTL_CRITICAL_SECTION@@A ; application_critical_section
PUBLIC	?application_active@@3HA			; application_active
PUBLIC	?bFullScreen@@3HA				; bFullScreen
PUBLIC	?bExiting@@3HA					; bExiting
PUBLIC	?application_debug_fatal@@3HA			; application_debug_fatal
PUBLIC	?application_current_directory@@3PADA		; application_current_directory
PUBLIC	?application_debug_fatal_string@@3PADA		; application_debug_fatal_string
PUBLIC	?application_window_position@@3UtagRECT@@A	; application_window_position
PUBLIC	?system_thread_id@@3KA				; system_thread_id
PUBLIC	?previous_application_instance@@3PAUHINSTANCE__@@A ; previous_application_instance
PUBLIC	?lpCmdLine@@3PADA				; lpCmdLine
PUBLIC	?nCmdShow@@3HA					; nCmdShow
PUBLIC	?application_thread_id@@3KA			; application_thread_id
PUBLIC	?application_thread_handle@@3PAXA		; application_thread_handle
PUBLIC	?main_command_line@@3PADA			; main_command_line
PUBLIC	?number_system_message_functions@@3HA		; number_system_message_functions
PUBLIC	?number_user_message_functions@@3HA		; number_user_message_functions
PUBLIC	?number_pre_activate_message_functions@@3HA	; number_pre_activate_message_functions
PUBLIC	?number_post_activate_message_functions@@3HA	; number_post_activate_message_functions
PUBLIC	?number_exit_functions@@3HA			; number_exit_functions
PUBLIC	?system_message_functions@@3PAUsystem_message_struct@@A ; system_message_functions
PUBLIC	?user_message_functions@@3PAUuser_message_struct@@A ; user_message_functions
PUBLIC	?pre_activate_message_functions@@3PAP6GXH@ZA	; pre_activate_message_functions
PUBLIC	?post_activate_message_functions@@3PAP6GXH@ZA	; post_activate_message_functions
PUBLIC	?exit_functions@@3PAUexit_struct@@A		; exit_functions
PUBLIC	?exit_message_id@@3HA				; exit_message_id
PUBLIC	?exception_codes@@3PAUEXCEPTION_DETAILS@@A	; exception_codes
PUBLIC	??_C@_0BB@KFJCFCM@Access?5violation@		; `string'
PUBLIC	??_C@_0BG@PAGJAHHI@Array?5bounds?5exceeded@	; `string'
PUBLIC	??_C@_0L@DEJAMIEF@Breakpoint@			; `string'
PUBLIC	??_C@_0BG@GMGPAKFC@Datatype?5misalignment@	; `string'
PUBLIC	??_C@_0BI@GJKKBOBF@Float?3?5Denormal?5operand@	; `string'
PUBLIC	??_C@_0BG@PEFDLEJC@Float?3?5Divide?5by?5zero@	; `string'
PUBLIC	??_C@_0BG@HELKLBBN@Float?3?5Inexact?5result@	; `string'
PUBLIC	??_C@_0BJ@LHOHGGNG@Float?3?5Invalid?5operation@	; `string'
PUBLIC	??_C@_0BA@HCJPGHEH@Float?3?5Overflow@		; `string'
PUBLIC	??_C@_0BD@JBELANKG@Float?3?5Stack?5check@	; `string'
PUBLIC	??_C@_0BB@BDIEPCPJ@Float?3?5Underflow@		; `string'
PUBLIC	??_C@_0BE@MLNNHANJ@Illegal?5instruction@	; `string'
PUBLIC	??_C@_0O@MGKDBHDE@In?5page?5error@		; `string'
PUBLIC	??_C@_0BI@KPMMLELF@Integer?3?5Divide?5by?5zero@	; `string'
PUBLIC	??_C@_0BC@JFGHICOF@Integer?3?5Overflow@		; `string'
PUBLIC	??_C@_0BE@JJMBEGLL@Invalid?5disposition@	; `string'
PUBLIC	??_C@_0BK@HJHAIOLD@Non?9continuable?5exception@	; `string'
PUBLIC	??_C@_0BH@NMGFNKEH@Privilaged?5instruction@	; `string'
PUBLIC	??_C@_0M@HBBAMPBG@Single?5step@			; `string'
PUBLIC	??_C@_0P@MGPMFBBC@Stack?5overflow@		; `string'
_BSS	SEGMENT
?application_window@@3PAUHWND__@@A DD 01H DUP (?)	; application_window
?application_instance@@3PAUHINSTANCE__@@A DD 01H DUP (?) ; application_instance
?application_critical_section@@3U_RTL_CRITICAL_SECTION@@A DB 018H DUP (?) ; application_critical_section
?bFullScreen@@3HA DD 01H DUP (?)			; bFullScreen
?bExiting@@3HA DD 01H DUP (?)				; bExiting
?application_debug_fatal@@3HA DD 01H DUP (?)		; application_debug_fatal
?application_current_directory@@3PADA DB 0400H DUP (?)	; application_current_directory
?application_debug_fatal_string@@3PADA DB 0100H DUP (?)	; application_debug_fatal_string
?application_window_position@@3UtagRECT@@A DB 010H DUP (?) ; application_window_position
?system_thread_id@@3KA DD 01H DUP (?)			; system_thread_id
?previous_application_instance@@3PAUHINSTANCE__@@A DD 01H DUP (?) ; previous_application_instance
?lpCmdLine@@3PADA DD 01H DUP (?)			; lpCmdLine
?nCmdShow@@3HA DD 01H DUP (?)				; nCmdShow
?application_thread_id@@3KA DD 01H DUP (?)		; application_thread_id
?application_thread_handle@@3PAXA DD 01H DUP (?)	; application_thread_handle
?main_command_line@@3PADA DD 01H DUP (?)		; main_command_line
?number_system_message_functions@@3HA DD 01H DUP (?)	; number_system_message_functions
?number_user_message_functions@@3HA DD 01H DUP (?)	; number_user_message_functions
?number_pre_activate_message_functions@@3HA DD 01H DUP (?) ; number_pre_activate_message_functions
?number_post_activate_message_functions@@3HA DD 01H DUP (?) ; number_post_activate_message_functions
?number_exit_functions@@3HA DD 01H DUP (?)		; number_exit_functions
	ALIGN	8

?system_message_functions@@3PAUsystem_message_struct@@A DQ 0100H DUP (?) ; system_message_functions
?user_message_functions@@3PAUuser_message_struct@@A DQ 0100H DUP (?) ; user_message_functions
?pre_activate_message_functions@@3PAP6GXH@ZA DD 0100H DUP (?) ; pre_activate_message_functions
?post_activate_message_functions@@3PAP6GXH@ZA DD 0100H DUP (?) ; post_activate_message_functions
?exit_functions@@3PAUexit_struct@@A DQ 0100H DUP (?)	; exit_functions
?exit_message_id@@3HA DD 01H DUP (?)			; exit_message_id
_BSS	ENDS
;	COMDAT ??_C@_0P@MGPMFBBC@Stack?5overflow@
CONST	SEGMENT
??_C@_0P@MGPMFBBC@Stack?5overflow@ DB 'Stack overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBAMPBG@Single?5step@
CONST	SEGMENT
??_C@_0M@HBBAMPBG@Single?5step@ DB 'Single step', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NMGFNKEH@Privilaged?5instruction@
CONST	SEGMENT
??_C@_0BH@NMGFNKEH@Privilaged?5instruction@ DB 'Privilaged instruction', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HJHAIOLD@Non?9continuable?5exception@
CONST	SEGMENT
??_C@_0BK@HJHAIOLD@Non?9continuable?5exception@ DB 'Non-continuable excep'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JJMBEGLL@Invalid?5disposition@
CONST	SEGMENT
??_C@_0BE@JJMBEGLL@Invalid?5disposition@ DB 'Invalid disposition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JFGHICOF@Integer?3?5Overflow@
CONST	SEGMENT
??_C@_0BC@JFGHICOF@Integer?3?5Overflow@ DB 'Integer: Overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KPMMLELF@Integer?3?5Divide?5by?5zero@
CONST	SEGMENT
??_C@_0BI@KPMMLELF@Integer?3?5Divide?5by?5zero@ DB 'Integer: Divide by ze'
	DB	'ro', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MGKDBHDE@In?5page?5error@
CONST	SEGMENT
??_C@_0O@MGKDBHDE@In?5page?5error@ DB 'In page error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MLNNHANJ@Illegal?5instruction@
CONST	SEGMENT
??_C@_0BE@MLNNHANJ@Illegal?5instruction@ DB 'Illegal instruction', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BDIEPCPJ@Float?3?5Underflow@
CONST	SEGMENT
??_C@_0BB@BDIEPCPJ@Float?3?5Underflow@ DB 'Float: Underflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JBELANKG@Float?3?5Stack?5check@
CONST	SEGMENT
??_C@_0BD@JBELANKG@Float?3?5Stack?5check@ DB 'Float: Stack check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HCJPGHEH@Float?3?5Overflow@
CONST	SEGMENT
??_C@_0BA@HCJPGHEH@Float?3?5Overflow@ DB 'Float: Overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LHOHGGNG@Float?3?5Invalid?5operation@
CONST	SEGMENT
??_C@_0BJ@LHOHGGNG@Float?3?5Invalid?5operation@ DB 'Float: Invalid operat'
	DB	'ion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HELKLBBN@Float?3?5Inexact?5result@
CONST	SEGMENT
??_C@_0BG@HELKLBBN@Float?3?5Inexact?5result@ DB 'Float: Inexact result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PEFDLEJC@Float?3?5Divide?5by?5zero@
CONST	SEGMENT
??_C@_0BG@PEFDLEJC@Float?3?5Divide?5by?5zero@ DB 'Float: Divide by zero', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GJKKBOBF@Float?3?5Denormal?5operand@
CONST	SEGMENT
??_C@_0BI@GJKKBOBF@Float?3?5Denormal?5operand@ DB 'Float: Denormal operan'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMGPAKFC@Datatype?5misalignment@
CONST	SEGMENT
??_C@_0BG@GMGPAKFC@Datatype?5misalignment@ DB 'Datatype misalignment', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DEJAMIEF@Breakpoint@
CONST	SEGMENT
??_C@_0L@DEJAMIEF@Breakpoint@ DB 'Breakpoint', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PAGJAHHI@Array?5bounds?5exceeded@
CONST	SEGMENT
??_C@_0BG@PAGJAHHI@Array?5bounds?5exceeded@ DB 'Array bounds exceeded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KFJCFCM@Access?5violation@
CONST	SEGMENT
??_C@_0BB@KFJCFCM@Access?5violation@ DB 'Access violation', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?application_active@@3HA DD 01H				; application_active
	ORG $+4
?exception_codes@@3PAUEXCEPTION_DETAILS@@A DD 0c0000005H ; exception_codes
	DD	FLAT:??_C@_0BB@KFJCFCM@Access?5violation@
	DD	0c000008cH
	DD	FLAT:??_C@_0BG@PAGJAHHI@Array?5bounds?5exceeded@
	DD	080000003H
	DD	FLAT:??_C@_0L@DEJAMIEF@Breakpoint@
	DD	080000002H
	DD	FLAT:??_C@_0BG@GMGPAKFC@Datatype?5misalignment@
	DD	0c000008dH
	DD	FLAT:??_C@_0BI@GJKKBOBF@Float?3?5Denormal?5operand@
	DD	0c000008eH
	DD	FLAT:??_C@_0BG@PEFDLEJC@Float?3?5Divide?5by?5zero@
	DD	0c000008fH
	DD	FLAT:??_C@_0BG@HELKLBBN@Float?3?5Inexact?5result@
	DD	0c0000090H
	DD	FLAT:??_C@_0BJ@LHOHGGNG@Float?3?5Invalid?5operation@
	DD	0c0000091H
	DD	FLAT:??_C@_0BA@HCJPGHEH@Float?3?5Overflow@
	DD	0c0000092H
	DD	FLAT:??_C@_0BD@JBELANKG@Float?3?5Stack?5check@
	DD	0c0000093H
	DD	FLAT:??_C@_0BB@BDIEPCPJ@Float?3?5Underflow@
	DD	0c000001dH
	DD	FLAT:??_C@_0BE@MLNNHANJ@Illegal?5instruction@
	DD	0c0000006H
	DD	FLAT:??_C@_0O@MGKDBHDE@In?5page?5error@
	DD	0c0000094H
	DD	FLAT:??_C@_0BI@KPMMLELF@Integer?3?5Divide?5by?5zero@
	DD	0c0000095H
	DD	FLAT:??_C@_0BC@JFGHICOF@Integer?3?5Overflow@
	DD	0c0000026H
	DD	FLAT:??_C@_0BE@JJMBEGLL@Invalid?5disposition@
	DD	0c0000025H
	DD	FLAT:??_C@_0BK@HJHAIOLD@Non?9continuable?5exception@
	DD	0c0000096H
	DD	FLAT:??_C@_0BH@NMGFNKEH@Privilaged?5instruction@
	DD	080000004H
	DD	FLAT:??_C@_0M@HBBAMPBG@Single?5step@
	DD	0c00000fdH
	DD	FLAT:??_C@_0P@MGPMFBBC@Stack?5overflow@
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_WinMain@16
PUBLIC	?deinitialise_windows@@YGXXZ			; deinitialise_windows
PUBLIC	?initialise_windows@@YGHPAUHINSTANCE__@@H@Z	; initialise_windows
PUBLIC	?register_exit_function@@YGXP6GXXZ@Z		; register_exit_function
PUBLIC	?register_user_message_function@@YGHHP6GJPAX@Z@Z ; register_user_message_function
PUBLIC	?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z ; register_system_message_function
PUBLIC	?register_pre_activate_message_function@@YGHP6GXH@Z@Z ; register_pre_activate_message_function
PUBLIC	?register_post_activate_message_function@@YGHP6GXH@Z@Z ; register_post_activate_message_function
PUBLIC	?end_application@@YGXXZ				; end_application
PUBLIC	?start_application@@YGXXZ			; start_application
PUBLIC	?create_application_window@@YGHPAUHINSTANCE__@@H@Z ; create_application_window
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_09INNEDIGD@debug?4log@			; `string'
PUBLIC	??_C@_0CD@LLJBMCPC@Software?2Razorworks?2Comanche?5Ho@ ; `string'
PUBLIC	??_C@_0BC@DEGFMGAC@Installation?5Path@		; `string'
PUBLIC	??_C@_08MCNMNMBL@?2COHOKUM@			; `string'
PUBLIC	??_C@_0M@ILFGMGPN@DEBUG?5FATAL@			; `string'
PUBLIC	??_C@_05OCIGMBIP@HELLO@				; `string'
PUBLIC	??_C@_0M@JPMDFFII@Jan?513?52021@		; `string'
PUBLIC	??_C@_0DD@BNGILHFC@Enemy?5Engaged?5RAH66?5Comanche?5Vs@ ; `string'
PUBLIC	??_C@_05DNIIFBMG@?$CFs?5?$CFs@			; `string'
PUBLIC	??_C@_0M@GPGGNAFB@APPLICATION@			; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_09LLKAIMKO@crash?4log@			; `string'
PUBLIC	??_C@_0BL@BBIBBJMA@Executable?5build?5date?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_08LEMODDON@21?300?333@			; `string'
PUBLIC	??_C@_0BM@NMNINLDG@Executable?5build?5time?3?5?$CFs?6?6@ ; `string'
PUBLIC	??_C@_0BB@JAEJENPF@Crash?5details?3?6?6@	; `string'
PUBLIC	??_C@_0BA@KPINPCDE@Location?3?5?$CF08x?6@	; `string'
PUBLIC	??_C@_0M@PDELIMI@Reason?3?5?$CFs?6@		; `string'
PUBLIC	??_C@_0CL@DNECKDHG@Tried?5to?5read?5from?5memory?5locat@ ; `string'
PUBLIC	??_C@_0CK@GDMHICGP@Tried?5to?5write?5to?5memory?5locati@ ; `string'
PUBLIC	??_C@_02PHMGELLB@?6?6@				; `string'
PUBLIC	??_C@_0BA@LNCIAMPG@Register?5dump?3?6@		; `string'
PUBLIC	??_C@_0N@PNCKCMHH@EAX?3?50x?$CF08x?6@		; `string'
PUBLIC	??_C@_0N@IKLEPOIH@EBX?3?50x?$CF08x?6@		; `string'
PUBLIC	??_C@_0N@BBBBLCOI@ECX?3?50x?$CF08x?6@		; `string'
PUBLIC	??_C@_0N@GFIJFLGH@EDX?3?50x?$CF08x?6@		; `string'
PUBLIC	??_C@_0N@KPBEAGM@EDI?3?50x?$CF08x?6@		; `string'
PUBLIC	??_C@_0N@HCHBEEBP@ESI?3?50x?$CF08x?6@		; `string'
PUBLIC	??_C@_0N@DAHHBPMC@EBP?3?50x?$CF08x?6@		; `string'
PUBLIC	??_C@_0N@KHMKLOFB@ESP?3?50x?$CF08x?6@		; `string'
PUBLIC	??_C@_0N@EBOFLLMM@EIP?3?50x?$CF08x?6@		; `string'
PUBLIC	??_C@_0BJ@BHDHPJBA@Floating?5point?5details?3?6@ ; `string'
PUBLIC	??_C@_0BG@JBOFHID@Control?5word?3?50x?$CF08x?6@	; `string'
PUBLIC	??_C@_0BF@CBPFIJDI@Status?5word?3?50x?$CF08x?6@	; `string'
PUBLIC	??_C@_0DC@CMPPFAHP@ST?$CI?$CFd?$CJ?3?5?$CF02x?$CF02x?$CF02x?$CF02x?$CF02x?$CF02@ ; `string'
PUBLIC	??_C@_0P@HPEKFOCN@?6?6Stack?5dump?3?6@		; `string'
PUBLIC	??_C@_07MNKEEDLK@?$CF08x?5?$CK?6@		; `string'
PUBLIC	??_C@_05CNOPHDHD@?$CF08x?6@			; `string'
PUBLIC	??_C@_08ENGLHMNJ@Invalid?6@			; `string'
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp___unlink:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__SetCurrentDirectoryA@4:PROC
EXTRN	__imp__GetCurrentDirectoryA@8:PROC
EXTRN	__imp__SetUnhandledExceptionFilter@4:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__SetThreadPriority@8:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__IsBadReadPtr@8:PROC
EXTRN	__imp__GetStockObject@4:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__MsgWaitForMultipleObjects@20:PROC
EXTRN	__imp__UpdateWindow@4:PROC
EXTRN	__imp__SetActiveWindow@4:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__SetCursor@4:PROC
EXTRN	__imp__ClientToScreen@8:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyA@12:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitializeEx@8:PROC
EXTRN	?initialise_cdrom_system@@YGXXZ:PROC		; initialise_cdrom_system
EXTRN	?set_fpu_exceptions@@YGXXZ:PROC			; set_fpu_exceptions
EXTRN	?set_fpu_rounding_mode_zero@@YGXXZ:PROC		; set_fpu_rounding_mode_zero
EXTRN	?generate_keyboard_events@@YGXXZ:PROC		; generate_keyboard_events
EXTRN	?generate_mouse_events@@YGXXZ:PROC		; generate_mouse_events
EXTRN	?initialise_event_system@@YGHXZ:PROC		; initialise_event_system
EXTRN	?initialise_timers_system@@YGHXZ:PROC		; initialise_timers_system
EXTRN	?initialise_file_system@@YGHXZ:PROC		; initialise_file_system
EXTRN	?initialise_memory_totals@@YGXXZ:PROC		; initialise_memory_totals
EXTRN	?get_unique_message_id@@YGHXZ:PROC		; get_unique_message_id
EXTRN	?initialise_system_thread_calling_function@@YGXXZ:PROC ; initialise_system_thread_calling_function
EXTRN	?f3d_context_leave@@YGXXZ:PROC			; f3d_context_leave
EXTRN	?application_main@@YGXHPAPAD@Z:PROC		; application_main
EXTRN	?keyboard_handle@@3PAXA:DWORD			; keyboard_handle
EXTRN	?mouse_handle@@3PAXA:DWORD			; mouse_handle
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_08ENGLHMNJ@Invalid?6@
CONST	SEGMENT
??_C@_08ENGLHMNJ@Invalid?6@ DB 'Invalid', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CNOPHDHD@?$CF08x?6@
CONST	SEGMENT
??_C@_05CNOPHDHD@?$CF08x?6@ DB '%08x', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MNKEEDLK@?$CF08x?5?$CK?6@
CONST	SEGMENT
??_C@_07MNKEEDLK@?$CF08x?5?$CK?6@ DB '%08x *', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HPEKFOCN@?6?6Stack?5dump?3?6@
CONST	SEGMENT
??_C@_0P@HPEKFOCN@?6?6Stack?5dump?3?6@ DB 0aH, 0aH, 'Stack dump:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@CMPPFAHP@ST?$CI?$CFd?$CJ?3?5?$CF02x?$CF02x?$CF02x?$CF02x?$CF02x?$CF02@
CONST	SEGMENT
??_C@_0DC@CMPPFAHP@ST?$CI?$CFd?$CJ?3?5?$CF02x?$CF02x?$CF02x?$CF02x?$CF02x?$CF02@ DB 'S'
	DB	'T(%d): %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CBPFIJDI@Status?5word?3?50x?$CF08x?6@
CONST	SEGMENT
??_C@_0BF@CBPFIJDI@Status?5word?3?50x?$CF08x?6@ DB 'Status word: 0x%08x', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JBOFHID@Control?5word?3?50x?$CF08x?6@
CONST	SEGMENT
??_C@_0BG@JBOFHID@Control?5word?3?50x?$CF08x?6@ DB 'Control word: 0x%08x', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BHDHPJBA@Floating?5point?5details?3?6@
CONST	SEGMENT
??_C@_0BJ@BHDHPJBA@Floating?5point?5details?3?6@ DB 'Floating point detai'
	DB	'ls:', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EBOFLLMM@EIP?3?50x?$CF08x?6@
CONST	SEGMENT
??_C@_0N@EBOFLLMM@EIP?3?50x?$CF08x?6@ DB 'EIP: 0x%08x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KHMKLOFB@ESP?3?50x?$CF08x?6@
CONST	SEGMENT
??_C@_0N@KHMKLOFB@ESP?3?50x?$CF08x?6@ DB 'ESP: 0x%08x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DAHHBPMC@EBP?3?50x?$CF08x?6@
CONST	SEGMENT
??_C@_0N@DAHHBPMC@EBP?3?50x?$CF08x?6@ DB 'EBP: 0x%08x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HCHBEEBP@ESI?3?50x?$CF08x?6@
CONST	SEGMENT
??_C@_0N@HCHBEEBP@ESI?3?50x?$CF08x?6@ DB 'ESI: 0x%08x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KPBEAGM@EDI?3?50x?$CF08x?6@
CONST	SEGMENT
??_C@_0N@KPBEAGM@EDI?3?50x?$CF08x?6@ DB 'EDI: 0x%08x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GFIJFLGH@EDX?3?50x?$CF08x?6@
CONST	SEGMENT
??_C@_0N@GFIJFLGH@EDX?3?50x?$CF08x?6@ DB 'EDX: 0x%08x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BBBBLCOI@ECX?3?50x?$CF08x?6@
CONST	SEGMENT
??_C@_0N@BBBBLCOI@ECX?3?50x?$CF08x?6@ DB 'ECX: 0x%08x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IKLEPOIH@EBX?3?50x?$CF08x?6@
CONST	SEGMENT
??_C@_0N@IKLEPOIH@EBX?3?50x?$CF08x?6@ DB 'EBX: 0x%08x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PNCKCMHH@EAX?3?50x?$CF08x?6@
CONST	SEGMENT
??_C@_0N@PNCKCMHH@EAX?3?50x?$CF08x?6@ DB 'EAX: 0x%08x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LNCIAMPG@Register?5dump?3?6@
CONST	SEGMENT
??_C@_0BA@LNCIAMPG@Register?5dump?3?6@ DB 'Register dump:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PHMGELLB@?6?6@
CONST	SEGMENT
??_C@_02PHMGELLB@?6?6@ DB 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GDMHICGP@Tried?5to?5write?5to?5memory?5locati@
CONST	SEGMENT
??_C@_0CK@GDMHICGP@Tried?5to?5write?5to?5memory?5locati@ DB 'Tried to wri'
	DB	'te to memory location: 0x%08x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DNECKDHG@Tried?5to?5read?5from?5memory?5locat@
CONST	SEGMENT
??_C@_0CL@DNECKDHG@Tried?5to?5read?5from?5memory?5locat@ DB 'Tried to rea'
	DB	'd from memory location: 0x%08x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PDELIMI@Reason?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0M@PDELIMI@Reason?3?5?$CFs?6@ DB 'Reason: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPINPCDE@Location?3?5?$CF08x?6@
CONST	SEGMENT
??_C@_0BA@KPINPCDE@Location?3?5?$CF08x?6@ DB 'Location: %08x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JAEJENPF@Crash?5details?3?6?6@
CONST	SEGMENT
??_C@_0BB@JAEJENPF@Crash?5details?3?6?6@ DB 'Crash details:', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NMNINLDG@Executable?5build?5time?3?5?$CFs?6?6@
CONST	SEGMENT
??_C@_0BM@NMNINLDG@Executable?5build?5time?3?5?$CFs?6?6@ DB 'Executable b'
	DB	'uild time: %s', 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LEMODDON@21?300?333@
CONST	SEGMENT
??_C@_08LEMODDON@21?300?333@ DB '21:00:33', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BBIBBJMA@Executable?5build?5date?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@BBIBBJMA@Executable?5build?5date?3?5?$CFs?6@ DB 'Executable bui'
	DB	'ld date: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09LLKAIMKO@crash?4log@
CONST	SEGMENT
??_C@_09LLKAIMKO@crash?4log@ DB 'crash.log', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPGGNAFB@APPLICATION@
CONST	SEGMENT
??_C@_0M@GPGGNAFB@APPLICATION@ DB 'APPLICATION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNIIFBMG@?$CFs?5?$CFs@
CONST	SEGMENT
??_C@_05DNIIFBMG@?$CFs?5?$CFs@ DB '%s %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BNGILHFC@Enemy?5Engaged?5RAH66?5Comanche?5Vs@
CONST	SEGMENT
??_C@_0DD@BNGILHFC@Enemy?5Engaged?5RAH66?5Comanche?5Vs@ DB 'Enemy Engaged'
	DB	' RAH66 Comanche Vs KA52 Hokum v1.15.0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JPMDFFII@Jan?513?52021@
CONST	SEGMENT
??_C@_0M@JPMDFFII@Jan?513?52021@ DB 'Jan 13 2021', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OCIGMBIP@HELLO@
CONST	SEGMENT
??_C@_05OCIGMBIP@HELLO@ DB 'HELLO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILFGMGPN@DEBUG?5FATAL@
CONST	SEGMENT
??_C@_0M@ILFGMGPN@DEBUG?5FATAL@ DB 'DEBUG FATAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MCNMNMBL@?2COHOKUM@
CONST	SEGMENT
??_C@_08MCNMNMBL@?2COHOKUM@ DB '\COHOKUM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DEGFMGAC@Installation?5Path@
CONST	SEGMENT
??_C@_0BC@DEGFMGAC@Installation?5Path@ DB 'Installation Path', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LLJBMCPC@Software?2Razorworks?2Comanche?5Ho@
CONST	SEGMENT
??_C@_0CD@LLJBMCPC@Software?2Razorworks?2Comanche?5Ho@ DB 'Software\Razor'
	DB	'works\Comanche Hokum', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09INNEDIGD@debug?4log@
CONST	SEGMENT
??_C@_09INNEDIGD@debug?4log@ DB 'debug.log', 00H	; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?application_exception_handler@@YGJPAU_EXCEPTION_POINTERS@@@Z
_TEXT	SEGMENT
tv128 = -88						; size = 4
_memory$ = -20						; size = 4
_count$ = -16						; size = 4
_fp$ = -12						; size = 4
_context_record$ = -8					; size = 4
_exception_record$ = -4					; size = 4
_lpExceptionData$ = 8					; size = 4
?application_exception_handler@@YGJPAU_EXCEPTION_POINTERS@@@Z PROC ; application_exception_handler, COMDAT

; 1280 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1281 : 
; 1282 : 	EXCEPTION_RECORD
; 1283 : 		*exception_record;
; 1284 : 
; 1285 : 	CONTEXT
; 1286 : 		*context_record;
; 1287 : 
; 1288 : 	FILE
; 1289 : 		*fp;
; 1290 : 
; 1291 : 	int
; 1292 : 		count;
; 1293 : 
; 1294 : 	DWORD
; 1295 : 		*memory;
; 1296 : 
; 1297 : 	fp = fopen ( "crash.log", "w" );

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w@
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_09LLKAIMKO@crash?4log@
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00019	83 c4 08	 add	 esp, 8
  0001c	89 45 f4	 mov	 DWORD PTR _fp$[ebp], eax

; 1298 : 
; 1299 : 	if ( fp )

  0001f	83 7d f4 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00023	0f 84 07 04 00
	00		 je	 $LN13@applicatio

; 1300 : 	{
; 1301 : 
; 1302 : 		fprintf ( fp, "Executable build date: %s\n", __DATE__ );

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JPMDFFII@Jan?513?52021@
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BBIBBJMA@Executable?5build?5date?3?5?$CFs?6@
  00033	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _fprintf
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1303 : 		fprintf ( fp, "Executable build time: %s\n\n", __TIME__ );

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_08LEMODDON@21?300?333@
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NMNINLDG@Executable?5build?5time?3?5?$CFs?6?6@
  00049	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _fprintf
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1304 : 
; 1305 : 		fprintf ( fp, "Crash details:\n\n" );

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JAEJENPF@Crash?5details?3?6?6@
  0005a	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _fprintf
  00063	83 c4 08	 add	 esp, 8

; 1306 : 
; 1307 : 		exception_record = lpExceptionData->ExceptionRecord;

  00066	8b 45 08	 mov	 eax, DWORD PTR _lpExceptionData$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	89 4d fc	 mov	 DWORD PTR _exception_record$[ebp], ecx

; 1308 : 
; 1309 : 		context_record = lpExceptionData->ContextRecord;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _lpExceptionData$[ebp]
  00071	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00074	89 4d f8	 mov	 DWORD PTR _context_record$[ebp], ecx

; 1310 : 
; 1311 : 		fprintf ( fp, "Location: %08x\n", exception_record->ExceptionAddress );

  00077	8b 45 fc	 mov	 eax, DWORD PTR _exception_record$[ebp]
  0007a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0007d	51		 push	 ecx
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KPINPCDE@Location?3?5?$CF08x?6@
  00083	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 _fprintf
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1312 : 
; 1313 : 		for ( count = 0; count < ( sizeof ( exception_codes ) / sizeof ( exception_details ) ); count++ )

  0008f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00096	eb 09		 jmp	 SHORT $LN4@applicatio
$LN2@applicatio:
  00098	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  0009b	83 c0 01	 add	 eax, 1
  0009e	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN4@applicatio:
  000a1	83 7d f0 14	 cmp	 DWORD PTR _count$[ebp], 20 ; 00000014H
  000a5	73 2f		 jae	 SHORT $LN3@applicatio

; 1314 : 		{
; 1315 : 
; 1316 : 			if ( exception_codes[count].code == exception_record->ExceptionCode )

  000a7	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _exception_record$[ebp]
  000ad	8b 14 c5 00 00
	00 00		 mov	 edx, DWORD PTR ?exception_codes@@3PAUEXCEPTION_DETAILS@@A[eax*8]
  000b4	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000b6	75 1c		 jne	 SHORT $LN14@applicatio

; 1317 : 			{
; 1318 : 
; 1319 : 				fprintf ( fp, "Reason: %s\n", exception_codes[count].reason );

  000b8	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  000bb	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR ?exception_codes@@3PAUEXCEPTION_DETAILS@@A[eax*8+4]
  000c2	51		 push	 ecx
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PDELIMI@Reason?3?5?$CFs?6@
  000c8	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 _fprintf
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@applicatio:

; 1320 : 			}
; 1321 : 		}

  000d4	eb c2		 jmp	 SHORT $LN2@applicatio
$LN3@applicatio:

; 1322 : 
; 1323 : 		switch ( exception_record->ExceptionCode )

  000d6	8b 45 fc	 mov	 eax, DWORD PTR _exception_record$[ebp]
  000d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000db	89 4d a8	 mov	 DWORD PTR tv128[ebp], ecx
  000de	81 7d a8 05 00
	00 c0		 cmp	 DWORD PTR tv128[ebp], -1073741819 ; c0000005H
  000e5	74 02		 je	 SHORT $LN15@applicatio
  000e7	eb 5f		 jmp	 SHORT $LN5@applicatio
$LN15@applicatio:

; 1324 : 		{
; 1325 : 
; 1326 : 			case EXCEPTION_ACCESS_VIOLATION:
; 1327 : 			{
; 1328 : 
; 1329 : 				if ( exception_record->NumberParameters == 2 )

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _exception_record$[ebp]
  000ec	83 78 10 02	 cmp	 DWORD PTR [eax+16], 2
  000f0	75 56		 jne	 SHORT $LN5@applicatio

; 1330 : 				{
; 1331 : 
; 1332 : 					if ( exception_record->ExceptionInformation[0] == 0 )

  000f2	b8 04 00 00 00	 mov	 eax, 4
  000f7	6b c8 00	 imul	 ecx, eax, 0
  000fa	8b 55 fc	 mov	 edx, DWORD PTR _exception_record$[ebp]
  000fd	83 7c 0a 14 00	 cmp	 DWORD PTR [edx+ecx+20], 0
  00102	75 23		 jne	 SHORT $LN17@applicatio

; 1333 : 					{
; 1334 : 
; 1335 : 						fprintf ( fp, "Tried to read from memory location: 0x%08x", exception_record->ExceptionInformation[1] );

  00104	b8 04 00 00 00	 mov	 eax, 4
  00109	c1 e0 00	 shl	 eax, 0
  0010c	8b 4d fc	 mov	 ecx, DWORD PTR _exception_record$[ebp]
  0010f	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  00113	52		 push	 edx
  00114	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@DNECKDHG@Tried?5to?5read?5from?5memory?5locat@
  00119	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _fprintf
  00122	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1336 : 					}
; 1337 : 					else

  00125	eb 21		 jmp	 SHORT $LN5@applicatio
$LN17@applicatio:

; 1338 : 					{
; 1339 : 
; 1340 : 						fprintf ( fp, "Tried to write to memory location: 0x%08x", exception_record->ExceptionInformation[1] );

  00127	b8 04 00 00 00	 mov	 eax, 4
  0012c	c1 e0 00	 shl	 eax, 0
  0012f	8b 4d fc	 mov	 ecx, DWORD PTR _exception_record$[ebp]
  00132	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  00136	52		 push	 edx
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@GDMHICGP@Tried?5to?5write?5to?5memory?5locati@
  0013c	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _fprintf
  00145	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@applicatio:

; 1341 : 					}
; 1342 : 				}
; 1343 : 
; 1344 : 				break;
; 1345 : 			}
; 1346 : 
; 1347 : 			default:
; 1348 : 			{
; 1349 : 
; 1350 : 				break;
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 : 		fprintf ( fp, "\n\n" );

  00148	68 00 00 00 00	 push	 OFFSET ??_C@_02PHMGELLB@?6?6@
  0014d	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _fprintf
  00156	83 c4 08	 add	 esp, 8

; 1355 : 
; 1356 : 		fprintf ( fp, "Register dump:\n" );

  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LNCIAMPG@Register?5dump?3?6@
  0015e	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 _fprintf
  00167	83 c4 08	 add	 esp, 8

; 1357 : 		fprintf ( fp, "EAX: 0x%08x\n", context_record->Eax );

  0016a	8b 45 f8	 mov	 eax, DWORD PTR _context_record$[ebp]
  0016d	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00173	51		 push	 ecx
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PNCKCMHH@EAX?3?50x?$CF08x?6@
  00179	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  0017c	52		 push	 edx
  0017d	e8 00 00 00 00	 call	 _fprintf
  00182	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1358 : 		fprintf ( fp, "EBX: 0x%08x\n", context_record->Ebx );

  00185	8b 45 f8	 mov	 eax, DWORD PTR _context_record$[ebp]
  00188	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0018e	51		 push	 ecx
  0018f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@IKLEPOIH@EBX?3?50x?$CF08x?6@
  00194	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  00197	52		 push	 edx
  00198	e8 00 00 00 00	 call	 _fprintf
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1359 : 		fprintf ( fp, "ECX: 0x%08x\n", context_record->Ecx );

  001a0	8b 45 f8	 mov	 eax, DWORD PTR _context_record$[ebp]
  001a3	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  001a9	51		 push	 ecx
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_0N@BBBBLCOI@ECX?3?50x?$CF08x?6@
  001af	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  001b2	52		 push	 edx
  001b3	e8 00 00 00 00	 call	 _fprintf
  001b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1360 : 		fprintf ( fp, "EDX: 0x%08x\n", context_record->Edx );

  001bb	8b 45 f8	 mov	 eax, DWORD PTR _context_record$[ebp]
  001be	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  001c4	51		 push	 ecx
  001c5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GFIJFLGH@EDX?3?50x?$CF08x?6@
  001ca	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  001cd	52		 push	 edx
  001ce	e8 00 00 00 00	 call	 _fprintf
  001d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1361 : 		fprintf ( fp, "EDI: 0x%08x\n", context_record->Edi );

  001d6	8b 45 f8	 mov	 eax, DWORD PTR _context_record$[ebp]
  001d9	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  001df	51		 push	 ecx
  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KPBEAGM@EDI?3?50x?$CF08x?6@
  001e5	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  001e8	52		 push	 edx
  001e9	e8 00 00 00 00	 call	 _fprintf
  001ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1362 : 		fprintf ( fp, "ESI: 0x%08x\n", context_record->Esi );

  001f1	8b 45 f8	 mov	 eax, DWORD PTR _context_record$[ebp]
  001f4	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  001fa	51		 push	 ecx
  001fb	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HCHBEEBP@ESI?3?50x?$CF08x?6@
  00200	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  00203	52		 push	 edx
  00204	e8 00 00 00 00	 call	 _fprintf
  00209	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1363 : 		fprintf ( fp, "EBP: 0x%08x\n", context_record->Ebp );

  0020c	8b 45 f8	 mov	 eax, DWORD PTR _context_record$[ebp]
  0020f	8b 88 b4 00 00
	00		 mov	 ecx, DWORD PTR [eax+180]
  00215	51		 push	 ecx
  00216	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DAHHBPMC@EBP?3?50x?$CF08x?6@
  0021b	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  0021e	52		 push	 edx
  0021f	e8 00 00 00 00	 call	 _fprintf
  00224	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1364 : 		fprintf ( fp, "ESP: 0x%08x\n", context_record->Esp );

  00227	8b 45 f8	 mov	 eax, DWORD PTR _context_record$[ebp]
  0022a	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  00230	51		 push	 ecx
  00231	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KHMKLOFB@ESP?3?50x?$CF08x?6@
  00236	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  00239	52		 push	 edx
  0023a	e8 00 00 00 00	 call	 _fprintf
  0023f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1365 : 		fprintf ( fp, "EIP: 0x%08x\n", context_record->Eip );

  00242	8b 45 f8	 mov	 eax, DWORD PTR _context_record$[ebp]
  00245	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [eax+184]
  0024b	51		 push	 ecx
  0024c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EBOFLLMM@EIP?3?50x?$CF08x?6@
  00251	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  00254	52		 push	 edx
  00255	e8 00 00 00 00	 call	 _fprintf
  0025a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1366 : 
; 1367 : 		fprintf ( fp, "\n\n" );

  0025d	68 00 00 00 00	 push	 OFFSET ??_C@_02PHMGELLB@?6?6@
  00262	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 _fprintf
  0026b	83 c4 08	 add	 esp, 8

; 1368 : 
; 1369 : 		fprintf ( fp, "Floating point details:\n" );

  0026e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BHDHPJBA@Floating?5point?5details?3?6@
  00273	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  00276	50		 push	 eax
  00277	e8 00 00 00 00	 call	 _fprintf
  0027c	83 c4 08	 add	 esp, 8

; 1370 : 		fprintf ( fp, "Control word: 0x%08x\n", context_record->FloatSave.ControlWord );

  0027f	8b 45 f8	 mov	 eax, DWORD PTR _context_record$[ebp]
  00282	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00285	51		 push	 ecx
  00286	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JBOFHID@Control?5word?3?50x?$CF08x?6@
  0028b	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  0028e	52		 push	 edx
  0028f	e8 00 00 00 00	 call	 _fprintf
  00294	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1371 : 		fprintf ( fp, "Status word: 0x%08x\n", context_record->FloatSave.StatusWord );

  00297	8b 45 f8	 mov	 eax, DWORD PTR _context_record$[ebp]
  0029a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0029d	51		 push	 ecx
  0029e	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@CBPFIJDI@Status?5word?3?50x?$CF08x?6@
  002a3	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  002a6	52		 push	 edx
  002a7	e8 00 00 00 00	 call	 _fprintf
  002ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1372 : 
; 1373 : 		for ( count = 0; count < 8; count++ )

  002af	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  002b6	eb 09		 jmp	 SHORT $LN9@applicatio
$LN7@applicatio:
  002b8	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  002bb	83 c0 01	 add	 eax, 1
  002be	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN9@applicatio:
  002c1	83 7d f0 08	 cmp	 DWORD PTR _count$[ebp], 8
  002c5	0f 8d 9c 00 00
	00		 jge	 $LN8@applicatio

; 1374 : 		{
; 1375 : 
; 1376 : 			fprintf ( fp, "ST(%d): %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n", count,

  002cb	6b 45 f0 0a	 imul	 eax, DWORD PTR _count$[ebp], 10
  002cf	8b 4d f8	 mov	 ecx, DWORD PTR _context_record$[ebp]
  002d2	0f b6 54 01 41	 movzx	 edx, BYTE PTR [ecx+eax+65]
  002d7	52		 push	 edx
  002d8	6b 45 f0 0a	 imul	 eax, DWORD PTR _count$[ebp], 10
  002dc	8b 4d f8	 mov	 ecx, DWORD PTR _context_record$[ebp]
  002df	0f b6 54 01 40	 movzx	 edx, BYTE PTR [ecx+eax+64]
  002e4	52		 push	 edx
  002e5	6b 45 f0 0a	 imul	 eax, DWORD PTR _count$[ebp], 10
  002e9	8b 4d f8	 mov	 ecx, DWORD PTR _context_record$[ebp]
  002ec	0f b6 54 01 3f	 movzx	 edx, BYTE PTR [ecx+eax+63]
  002f1	52		 push	 edx
  002f2	6b 45 f0 0a	 imul	 eax, DWORD PTR _count$[ebp], 10
  002f6	8b 4d f8	 mov	 ecx, DWORD PTR _context_record$[ebp]
  002f9	0f b6 54 01 3e	 movzx	 edx, BYTE PTR [ecx+eax+62]
  002fe	52		 push	 edx
  002ff	6b 45 f0 0a	 imul	 eax, DWORD PTR _count$[ebp], 10
  00303	8b 4d f8	 mov	 ecx, DWORD PTR _context_record$[ebp]
  00306	0f b6 54 01 3d	 movzx	 edx, BYTE PTR [ecx+eax+61]
  0030b	52		 push	 edx
  0030c	6b 45 f0 0a	 imul	 eax, DWORD PTR _count$[ebp], 10
  00310	8b 4d f8	 mov	 ecx, DWORD PTR _context_record$[ebp]
  00313	0f b6 54 01 3c	 movzx	 edx, BYTE PTR [ecx+eax+60]
  00318	52		 push	 edx
  00319	6b 45 f0 0a	 imul	 eax, DWORD PTR _count$[ebp], 10
  0031d	8b 4d f8	 mov	 ecx, DWORD PTR _context_record$[ebp]
  00320	0f b6 54 01 3b	 movzx	 edx, BYTE PTR [ecx+eax+59]
  00325	52		 push	 edx
  00326	6b 45 f0 0a	 imul	 eax, DWORD PTR _count$[ebp], 10
  0032a	8b 4d f8	 mov	 ecx, DWORD PTR _context_record$[ebp]
  0032d	0f b6 54 01 3a	 movzx	 edx, BYTE PTR [ecx+eax+58]
  00332	52		 push	 edx
  00333	6b 45 f0 0a	 imul	 eax, DWORD PTR _count$[ebp], 10
  00337	8b 4d f8	 mov	 ecx, DWORD PTR _context_record$[ebp]
  0033a	0f b6 54 01 39	 movzx	 edx, BYTE PTR [ecx+eax+57]
  0033f	52		 push	 edx
  00340	6b 45 f0 0a	 imul	 eax, DWORD PTR _count$[ebp], 10
  00344	8b 4d f8	 mov	 ecx, DWORD PTR _context_record$[ebp]
  00347	0f b6 54 01 38	 movzx	 edx, BYTE PTR [ecx+eax+56]
  0034c	52		 push	 edx
  0034d	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  00350	50		 push	 eax
  00351	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@CMPPFAHP@ST?$CI?$CFd?$CJ?3?5?$CF02x?$CF02x?$CF02x?$CF02x?$CF02x?$CF02@
  00356	8b 4d f4	 mov	 ecx, DWORD PTR _fp$[ebp]
  00359	51		 push	 ecx
  0035a	e8 00 00 00 00	 call	 _fprintf
  0035f	83 c4 34	 add	 esp, 52			; 00000034H

; 1377 : 											context_record->FloatSave.RegisterArea[count*10 + 0],
; 1378 : 											context_record->FloatSave.RegisterArea[count*10 + 1],
; 1379 : 											context_record->FloatSave.RegisterArea[count*10 + 2],
; 1380 : 											context_record->FloatSave.RegisterArea[count*10 + 3],
; 1381 : 											context_record->FloatSave.RegisterArea[count*10 + 4],
; 1382 : 											context_record->FloatSave.RegisterArea[count*10 + 5],
; 1383 : 											context_record->FloatSave.RegisterArea[count*10 + 6],
; 1384 : 											context_record->FloatSave.RegisterArea[count*10 + 7],
; 1385 : 											context_record->FloatSave.RegisterArea[count*10 + 8],
; 1386 : 											context_record->FloatSave.RegisterArea[count*10 + 9] );
; 1387 : 		}

  00362	e9 51 ff ff ff	 jmp	 $LN7@applicatio
$LN8@applicatio:

; 1388 : 
; 1389 : 		//
; 1390 : 		// If we wanted, we could print out the stack a little but have to check the area first
; 1391 : 		//
; 1392 : 
; 1393 : 		fprintf ( fp, "\n\nStack dump:\n" );

  00367	68 00 00 00 00	 push	 OFFSET ??_C@_0P@HPEKFOCN@?6?6Stack?5dump?3?6@
  0036c	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  0036f	50		 push	 eax
  00370	e8 00 00 00 00	 call	 _fprintf
  00375	83 c4 08	 add	 esp, 8

; 1394 : 
; 1395 : 		memory = ( DWORD * ) context_record->Esp;

  00378	8b 45 f8	 mov	 eax, DWORD PTR _context_record$[ebp]
  0037b	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  00381	89 4d ec	 mov	 DWORD PTR _memory$[ebp], ecx

; 1396 : 
; 1397 : 		for ( count = 0; count < 256; count++ )

  00384	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  0038b	eb 09		 jmp	 SHORT $LN12@applicatio
$LN10@applicatio:
  0038d	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  00390	83 c0 01	 add	 eax, 1
  00393	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN12@applicatio:
  00396	81 7d f0 00 01
	00 00		 cmp	 DWORD PTR _count$[ebp], 256 ; 00000100H
  0039d	7d 77		 jge	 SHORT $LN11@applicatio

; 1398 : 		{
; 1399 : 
; 1400 : 			if ( !IsBadReadPtr ( memory, 4 ) )

  0039f	6a 04		 push	 4
  003a1	8b 45 ec	 mov	 eax, DWORD PTR _memory$[ebp]
  003a4	50		 push	 eax
  003a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadReadPtr@8
  003ab	85 c0		 test	 eax, eax
  003ad	75 48		 jne	 SHORT $LN20@applicatio

; 1401 : 			{
; 1402 : 				if (*memory > 0x00400000 && *memory < 0x0100000)  // likely return address, useful for recreating call stack

  003af	8b 45 ec	 mov	 eax, DWORD PTR _memory$[ebp]
  003b2	81 38 00 00 40
	00		 cmp	 DWORD PTR [eax], 4194304 ; 00400000H
  003b8	76 24		 jbe	 SHORT $LN22@applicatio
  003ba	8b 45 ec	 mov	 eax, DWORD PTR _memory$[ebp]
  003bd	81 38 00 00 10
	00		 cmp	 DWORD PTR [eax], 1048576 ; 00100000H
  003c3	73 19		 jae	 SHORT $LN22@applicatio

; 1403 : 					fprintf ( fp, "%08x *\n", *memory );

  003c5	8b 45 ec	 mov	 eax, DWORD PTR _memory$[ebp]
  003c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ca	51		 push	 ecx
  003cb	68 00 00 00 00	 push	 OFFSET ??_C@_07MNKEEDLK@?$CF08x?5?$CK?6@
  003d0	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  003d3	52		 push	 edx
  003d4	e8 00 00 00 00	 call	 _fprintf
  003d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1404 : 				else

  003dc	eb 17		 jmp	 SHORT $LN23@applicatio
$LN22@applicatio:

; 1405 : 					fprintf ( fp, "%08x\n", *memory );

  003de	8b 45 ec	 mov	 eax, DWORD PTR _memory$[ebp]
  003e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e3	51		 push	 ecx
  003e4	68 00 00 00 00	 push	 OFFSET ??_C@_05CNOPHDHD@?$CF08x?6@
  003e9	8b 55 f4	 mov	 edx, DWORD PTR _fp$[ebp]
  003ec	52		 push	 edx
  003ed	e8 00 00 00 00	 call	 _fprintf
  003f2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN23@applicatio:

; 1406 : 			}
; 1407 : 			else

  003f5	eb 11		 jmp	 SHORT $LN21@applicatio
$LN20@applicatio:

; 1408 : 			{
; 1409 : 
; 1410 : 				fprintf ( fp, "Invalid\n" );

  003f7	68 00 00 00 00	 push	 OFFSET ??_C@_08ENGLHMNJ@Invalid?6@
  003fc	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  003ff	50		 push	 eax
  00400	e8 00 00 00 00	 call	 _fprintf
  00405	83 c4 08	 add	 esp, 8
$LN21@applicatio:

; 1411 : 			}
; 1412 : 
; 1413 : 			memory++;

  00408	8b 45 ec	 mov	 eax, DWORD PTR _memory$[ebp]
  0040b	83 c0 04	 add	 eax, 4
  0040e	89 45 ec	 mov	 DWORD PTR _memory$[ebp], eax

; 1414 : 		}

  00411	e9 77 ff ff ff	 jmp	 $LN10@applicatio
$LN11@applicatio:

; 1415 : 
; 1416 : 		fflush ( fp );

  00416	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  00419	50		 push	 eax
  0041a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  00420	83 c4 04	 add	 esp, 4

; 1417 : 
; 1418 : 		fclose ( fp );

  00423	8b 45 f4	 mov	 eax, DWORD PTR _fp$[ebp]
  00426	50		 push	 eax
  00427	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0042d	83 c4 04	 add	 esp, 4
$LN13@applicatio:

; 1419 : 	}
; 1420 : 
; 1421 : 	//
; 1422 : 	// Let the system clean itself up!
; 1423 : 	//
; 1424 : 
; 1425 : 	return ( EXCEPTION_CONTINUE_SEARCH );

  00430	33 c0		 xor	 eax, eax

; 1426 : }

  00432	5f		 pop	 edi
  00433	5e		 pop	 esi
  00434	5b		 pop	 ebx
  00435	8b e5		 mov	 esp, ebp
  00437	5d		 pop	 ebp
  00438	c2 04 00	 ret	 4
?application_exception_handler@@YGJPAU_EXCEPTION_POINTERS@@@Z ENDP ; application_exception_handler
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?do_registered_exits@@YGXXZ
_TEXT	SEGMENT
_count$ = -4						; size = 4
?do_registered_exits@@YGXXZ PROC			; do_registered_exits, COMDAT

; 1185 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1186 : 
; 1187 : 	int
; 1188 : 		count;
; 1189 : 
; 1190 : 	bExiting = TRUE;

  00009	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bExiting@@3HA, 1 ; bExiting

; 1191 : 
; 1192 : 	//
; 1193 : 	// In System thread - so disable the user thread.
; 1194 : 	//
; 1195 : 
; 1196 : 	SetThreadPriority ( application_thread_handle, THREAD_PRIORITY_IDLE );

  00013	6a f1		 push	 -15			; fffffff1H
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_thread_handle@@3PAXA ; application_thread_handle
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadPriority@8

; 1197 : 
; 1198 : 	//
; 1199 : 	// Do the registered exit routines
; 1200 : 	//
; 1201 : 
; 1202 : 	for ( count = ( number_exit_functions - 1 ); count >= 0; count-- )

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_exit_functions@@3HA ; number_exit_functions
  00026	83 e8 01	 sub	 eax, 1
  00029	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  0002c	eb 09		 jmp	 SHORT $LN4@do_registe
$LN2@do_registe:
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00031	83 e8 01	 sub	 eax, 1
  00034	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@do_registe:
  00037	83 7d fc 00	 cmp	 DWORD PTR _count$[ebp], 0
  0003b	7c 29		 jl	 SHORT $LN1@do_registe

; 1203 : 	{
; 1204 : 
; 1205 : 		if ( ! exit_functions[count].called )

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00040	83 3c c5 00 00
	00 00 00	 cmp	 DWORD PTR ?exit_functions@@3PAUexit_struct@@A[eax*8], 0
  00048	75 1a		 jne	 SHORT $LN5@do_registe

; 1206 : 		{
; 1207 : 
; 1208 : 			//
; 1209 : 			// call the exit function
; 1210 : 			//
; 1211 : 
; 1212 : 			exit_functions[count].function ();

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0004d	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR ?exit_functions@@3PAUexit_struct@@A[eax*8+4]
  00054	ff d1		 call	 ecx

; 1213 : 
; 1214 : 			exit_functions[count].called = TRUE;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00059	c7 04 c5 00 00
	00 00 01 00 00
	00		 mov	 DWORD PTR ?exit_functions@@3PAUexit_struct@@A[eax*8], 1
$LN5@do_registe:

; 1215 : 		}
; 1216 : 	}

  00064	eb c8		 jmp	 SHORT $LN2@do_registe
$LN1@do_registe:

; 1217 : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?do_registered_exits@@YGXXZ ENDP			; do_registered_exits
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?windows_exit_routine@@YGJPAX@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?windows_exit_routine@@YGJPAX@Z PROC			; windows_exit_routine, COMDAT

; 1151 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1152 : 
; 1153 : 	do_registered_exits ();

  00009	e8 00 00 00 00	 call	 ?do_registered_exits@@YGXXZ ; do_registered_exits

; 1154 : 
; 1155 : 	//
; 1156 : 	// If we debug_fatal'd we need to display a message box. Now is the time for that
; 1157 : 	//
; 1158 : 
; 1159 : 	if ( application_debug_fatal )

  0000e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?application_debug_fatal@@3HA, 0 ; application_debug_fatal
  00015	74 18		 je	 SHORT $LN2@windows_ex

; 1160 : 	{
; 1161 : 
; 1162 : 		#ifdef COMMERCIAL
; 1163 : 
; 1164 : 		MessageBox ( application_window, application_debug_fatal_string, "ERROR", MB_OK );
; 1165 : 
; 1166 : 		#else
; 1167 : 
; 1168 : 		MessageBox ( application_window, application_debug_fatal_string, "DEBUG FATAL", MB_OK );

  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0M@ILFGMGPN@DEBUG?5FATAL@
  0001e	68 00 00 00 00	 push	 OFFSET ?application_debug_fatal_string@@3PADA ; application_debug_fatal_string
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN2@windows_ex:

; 1169 : 
; 1170 : 		#endif
; 1171 : 	}
; 1172 : 
; 1173 : 	PostMessage ( application_window, WM_QUIT, 0, 0 );

  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	6a 12		 push	 18			; 00000012H
  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 1174 : 
; 1175 : 	PostQuitMessage ( 0 );

  00041	6a 00		 push	 0
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4

; 1176 : 
; 1177 : 	return ( 0 );

  00049	33 c0		 xor	 eax, eax

; 1178 : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?windows_exit_routine@@YGJPAX@Z ENDP			; windows_exit_routine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?windows_systemcommand_routine@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
tv67 = -72						; size = 4
_lRc$ = -4						; size = 4
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?windows_systemcommand_routine@@YGJPAUHWND__@@IIJ@Z PROC ; windows_systemcommand_routine, COMDAT

; 1118 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1119 : 
; 1120 : 	LRESULT
; 1121 : 		lRc;
; 1122 : 
; 1123 : 	switch ( GET_WM_COMMAND_ID ( wParam, lParam ) )

  00009	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0000c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00011	0f b7 c8	 movzx	 ecx, ax
  00014	89 4d b8	 mov	 DWORD PTR tv67[ebp], ecx
  00017	81 7d b8 40 f1
	00 00		 cmp	 DWORD PTR tv67[ebp], 61760 ; 0000f140H
  0001e	74 02		 je	 SHORT $LN4@windows_sy
  00020	eb 06		 jmp	 SHORT $LN5@windows_sy
$LN4@windows_sy:

; 1124 : 	{
; 1125 : 
; 1126 : 		case SC_SCREENSAVE:
; 1127 : 		{
; 1128 : 
; 1129 : 			return ( 0 );

  00022	33 c0		 xor	 eax, eax
  00024	eb 20		 jmp	 SHORT $LN1@windows_sy

; 1130 : 
; 1131 : 			break;

  00026	eb 1b		 jmp	 SHORT $LN2@windows_sy
$LN5@windows_sy:

; 1132 : 		}
; 1133 : 
; 1134 : 		default:
; 1135 : 		{
; 1136 : 
; 1137 : 			lRc = DefWindowProc ( application_window, message, wParam, lParam );

  00028	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 0c	 mov	 edx, DWORD PTR _message$[ebp]
  00033	52		 push	 edx
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  00039	50		 push	 eax
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  00040	89 45 fc	 mov	 DWORD PTR _lRc$[ebp], eax
$LN2@windows_sy:

; 1138 : 
; 1139 : 			break;
; 1140 : 		}
; 1141 : 	}
; 1142 : 
; 1143 : 	return ( lRc );

  00043	8b 45 fc	 mov	 eax, DWORD PTR _lRc$[ebp]
$LN1@windows_sy:

; 1144 : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 10 00	 ret	 16			; 00000010H
?windows_systemcommand_routine@@YGJPAUHWND__@@IIJ@Z ENDP ; windows_systemcommand_routine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?windows_paint_routine@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_ps$ = -64						; size = 64
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?windows_paint_routine@@YGJPAUHWND__@@IIJ@Z PROC	; windows_paint_routine, COMDAT

; 1101 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1102 : 
; 1103 : 	PAINTSTRUCT
; 1104 : 		ps;
; 1105 : 
; 1106 : 	BeginPaint ( hWnd, &ps );

  0000c	8d 45 c0	 lea	 eax, DWORD PTR _ps$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  00013	51		 push	 ecx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BeginPaint@8

; 1107 : 
; 1108 : 	EndPaint ( hWnd, &ps );

  0001a	8d 45 c0	 lea	 eax, DWORD PTR _ps$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  00021	51		 push	 ecx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndPaint@8

; 1109 : 
; 1110 : 	return ( TRUE );

  00028	b8 01 00 00 00	 mov	 eax, 1

; 1111 : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 10 00	 ret	 16			; 00000010H
?windows_paint_routine@@YGJPAUHWND__@@IIJ@Z ENDP	; windows_paint_routine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?windows_close_request_routine@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?windows_close_request_routine@@YGJPAUHWND__@@IIJ@Z PROC ; windows_close_request_routine, COMDAT

; 967  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 968  : 
; 969  : 	//
; 970  : 	// We do not want to let the user ALT-F4 out of the application - so return 0
; 971  : 	//
; 972  : 
; 973  : 	return ( 0 );

  00009	33 c0		 xor	 eax, eax

; 974  : }

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c2 10 00	 ret	 16			; 00000010H
?windows_close_request_routine@@YGJPAUHWND__@@IIJ@Z ENDP ; windows_close_request_routine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?windows_cursor_routine@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?windows_cursor_routine@@YGJPAUHWND__@@IIJ@Z PROC	; windows_cursor_routine, COMDAT

; 955  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 956  : 
; 957  :     SetCursor ( NULL );

  00009	6a 00		 push	 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4

; 958  : 
; 959  :     return ( TRUE );

  00011	b8 01 00 00 00	 mov	 eax, 1

; 960  : }

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?windows_cursor_routine@@YGJPAUHWND__@@IIJ@Z ENDP	; windows_cursor_routine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?windows_sizemove_routine@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?windows_sizemove_routine@@YGJPAUHWND__@@IIJ@Z PROC	; windows_sizemove_routine, COMDAT

; 939  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 940  : 
; 941  : 	GetClientRect ( application_window, &application_window_position );

  00009	68 00 00 00 00	 push	 OFFSET ?application_window_position@@3UtagRECT@@A
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 942  : 
; 943  : 	ClientToScreen ( application_window, (LPPOINT)&application_window_position );

  0001a	68 00 00 00 00	 push	 OFFSET ?application_window_position@@3UtagRECT@@A
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClientToScreen@8

; 944  : 
; 945  : 	ClientToScreen ( application_window, (LPPOINT)&application_window_position+1 );

  0002b	68 08 00 00 00	 push	 OFFSET ?application_window_position@@3UtagRECT@@A+8
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  00035	50		 push	 eax
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClientToScreen@8

; 946  : 
; 947  : 	return ( FALSE );

  0003c	33 c0		 xor	 eax, eax

; 948  : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 10 00	 ret	 16			; 00000010H
?windows_sizemove_routine@@YGJPAUHWND__@@IIJ@Z ENDP	; windows_sizemove_routine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?application_window_proc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?application_window_proc@@YGJPAUHWND__@@IIJ@Z PROC	; application_window_proc, COMDAT

; 508  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 509  : 
; 510  : 	int
; 511  : 		count;
; 512  : 
; 513  : 
; 514  : 	if ( !bExiting )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bExiting@@3HA, 0 ; bExiting
  00010	75 5b		 jne	 SHORT $LN5@applicatio

; 515  : 	{
; 516  : 
; 517  : 		for ( count = 0; count < number_system_message_functions; count++ )

  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00019	eb 09		 jmp	 SHORT $LN4@applicatio
$LN2@applicatio:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0001e	83 c0 01	 add	 eax, 1
  00021	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@applicatio:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00027	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_system_message_functions@@3HA ; number_system_message_functions
  0002d	7d 3e		 jge	 SHORT $LN5@applicatio

; 518  : 		{
; 519  : 
; 520  : 			if ( system_message_functions[count].parameter == message )

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00032	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR ?system_message_functions@@3PAUsystem_message_struct@@A[eax*8]
  00039	3b 4d 0c	 cmp	 ecx, DWORD PTR _message$[ebp]
  0003c	75 2d		 jne	 SHORT $LN6@applicatio

; 521  : 			{
; 522  : 
; 523  : 				if ( !bExiting )

  0003e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bExiting@@3HA, 0 ; bExiting
  00045	75 20		 jne	 SHORT $LN7@applicatio

; 524  : 				{
; 525  : 
; 526  : 					return ( system_message_functions[count].function ( hWnd, message, wParam, lParam ) );

  00047	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 0c	 mov	 edx, DWORD PTR _message$[ebp]
  00052	52		 push	 edx
  00053	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  00056	50		 push	 eax
  00057	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0005a	8b 14 cd 04 00
	00 00		 mov	 edx, DWORD PTR ?system_message_functions@@3PAUsystem_message_struct@@A[ecx*8+4]
  00061	ff d2		 call	 edx
  00063	eb 1e		 jmp	 SHORT $LN1@applicatio

; 527  : 				}
; 528  : 				else

  00065	eb 04		 jmp	 SHORT $LN6@applicatio
$LN7@applicatio:

; 529  : 				{
; 530  : 
; 531  : 					return ( FALSE );

  00067	33 c0		 xor	 eax, eax
  00069	eb 18		 jmp	 SHORT $LN1@applicatio
$LN6@applicatio:

; 532  : 
; 533  : //					return DefWindowProc(hWnd, message, wParam, lParam);
; 534  : 				}
; 535  : 			}
; 536  : 		}

  0006b	eb ae		 jmp	 SHORT $LN2@applicatio
$LN5@applicatio:

; 537  : 	}
; 538  : 
; 539  : //	return ( FALSE );
; 540  : 	return DefWindowProc(hWnd, message, wParam, lParam);

  0006d	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 0c	 mov	 edx, DWORD PTR _message$[ebp]
  00078	52		 push	 edx
  00079	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0007c	50		 push	 eax
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
$LN1@applicatio:

; 541  : }

  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 10 00	 ret	 16			; 00000010H
?application_window_proc@@YGJPAUHWND__@@IIJ@Z ENDP	; application_window_proc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?create_application_window@@YGHPAUHINSTANCE__@@H@Z
_TEXT	SEGMENT
_application_title$ = -1064				; size = 1024
_wc$ = -40						; size = 40
_hInstance$ = 8						; size = 4
_nCmdShow$ = 12						; size = 4
?create_application_window@@YGHPAUHINSTANCE__@@H@Z PROC	; create_application_window, COMDAT

; 601  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 04 00
	00		 sub	 esp, 1256		; 000004e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 602  : 
; 603  : 	WNDCLASS
; 604  : 		wc;
; 605  : 
; 606  : 	char
; 607  : 		application_title[1024];
; 608  : 
; 609  : 	//
; 610  : 	// set up and register window class
; 611  : 	//
; 612  : 
; 613  : 	wc.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;	// | CCS_NORESIZE;

  0000c	c7 45 d8 23 00
	00 00		 mov	 DWORD PTR _wc$[ebp], 35	; 00000023H

; 614  : 	wc.lpfnWndProc = application_window_proc;

  00013	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _wc$[ebp+4], OFFSET ?application_window_proc@@YGJPAUHWND__@@IIJ@Z ; application_window_proc

; 615  : 	wc.cbClsExtra = 0;

  0001a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _wc$[ebp+8], 0

; 616  : 	wc.cbWndExtra = 0;

  00021	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _wc$[ebp+12], 0

; 617  : 	wc.hInstance = hInstance;

  00028	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  0002b	89 45 e8	 mov	 DWORD PTR _wc$[ebp+16], eax

; 618  : 	wc.hIcon = LoadIcon ( hInstance, IDI_APPLICATION );

  0002e	68 00 7f 00 00	 push	 32512			; 00007f00H
  00033	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8
  0003d	89 45 ec	 mov	 DWORD PTR _wc$[ebp+20], eax

; 619  : 	wc.hCursor = LoadCursor ( NULL, IDC_ARROW );

  00040	68 00 7f 00 00	 push	 32512			; 00007f00H
  00045	6a 00		 push	 0
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  0004d	89 45 f0	 mov	 DWORD PTR _wc$[ebp+24], eax

; 620  : 	wc.hbrBackground = ( HBRUSH ) GetStockObject ( BLACK_BRUSH );

  00050	6a 04		 push	 4
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStockObject@4
  00058	89 45 f4	 mov	 DWORD PTR _wc$[ebp+28], eax

; 621  : 	wc.lpszMenuName = NULL;

  0005b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _wc$[ebp+32], 0

; 622  : 	wc.lpszClassName = "HELLO";	//NAME;

  00062	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _wc$[ebp+36], OFFSET ??_C@_05OCIGMBIP@HELLO@

; 623  : 
; 624  : 	RegisterClass ( &wc );

  00069	8d 45 d8	 lea	 eax, DWORD PTR _wc$[ebp]
  0006c	50		 push	 eax
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassA@4

; 625  : 
; 626  : 	//
; 627  : 	// create a window
; 628  : 	//
; 629  : 
; 630  : 	sprintf ( application_title, "%s %s", TITLE, __DATE__ );

  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JPMDFFII@Jan?513?52021@
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@BNGILHFC@Enemy?5Engaged?5RAH66?5Comanche?5Vs@
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs@
  00082	8d 85 d8 fb ff
	ff		 lea	 eax, DWORD PTR _application_title$[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _sprintf
  0008e	83 c4 10	 add	 esp, 16			; 00000010H

; 631  : 
; 632  : 	application_window = CreateWindowEx

  00091	6a 00		 push	 0
  00093	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  00096	50		 push	 eax
  00097	6a 00		 push	 0
  00099	6a 00		 push	 0
  0009b	6a 14		 push	 20			; 00000014H
  0009d	68 c8 00 00 00	 push	 200			; 000000c8H
  000a2	6a 00		 push	 0
  000a4	6a 00		 push	 0
  000a6	68 00 00 c6 10	 push	 281411584		; 10c60000H
  000ab	8d 8d d8 fb ff
	ff		 lea	 ecx, DWORD PTR _application_title$[ebp]
  000b1	51		 push	 ecx
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_05OCIGMBIP@HELLO@
  000b7	6a 00		 push	 0
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  000bf	a3 00 00 00 00	 mov	 DWORD PTR ?application_window@@3PAUHWND__@@A, eax ; application_window

; 633  : 	(
; 634  : 
; 635  : 		0,
; 636  : 		"HELLO",	//NAME,
; 637  : 		application_title,	//TITLE,
; 638  : 		WS_OVERLAPPED | WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX | WS_VISIBLE,
; 639  : 		0,
; 640  : 		0,
; 641  : 		200,
; 642  : 		20,
; 643  : 		NULL,
; 644  : 		NULL,
; 645  : 		hInstance,
; 646  : 		NULL
; 647  : 	);
; 648  : 
; 649  : 	if ( !application_window )

  000c4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?application_window@@3PAUHWND__@@A, 0 ; application_window
  000cb	75 04		 jne	 SHORT $LN2@create_app

; 650  : 	{
; 651  : 
; 652  : 		return ( FALSE );

  000cd	33 c0		 xor	 eax, eax
  000cf	eb 22		 jmp	 SHORT $LN1@create_app
$LN2@create_app:

; 653  : 	}
; 654  : 
; 655  : 	ShowWindow ( application_window, nCmdShow );

  000d1	8b 45 0c	 mov	 eax, DWORD PTR _nCmdShow$[ebp]
  000d4	50		 push	 eax
  000d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  000db	51		 push	 ecx
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 656  : 
; 657  : 	UpdateWindow ( application_window );

  000e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  000e7	50		 push	 eax
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UpdateWindow@4

; 658  : 
; 659  : 	return ( TRUE );

  000ee	b8 01 00 00 00	 mov	 eax, 1
$LN1@create_app:

; 660  : }

  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c2 08 00	 ret	 8
?create_application_window@@YGHPAUHINSTANCE__@@H@Z ENDP	; create_application_window
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?call_user_function_routine@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?call_user_function_routine@@YGJPAUHWND__@@IIJ@Z PROC	; call_user_function_routine, COMDAT

; 914  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 915  : 
; 916  :     int
; 917  :         count;
; 918  : 
; 919  :     for ( count=0; count<number_user_message_functions; count++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@call_user_
$LN2@call_user_:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@call_user_:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_user_message_functions@@3HA ; number_user_message_functions
  00024	7d 23		 jge	 SHORT $LN3@call_user_

; 920  :     {
; 921  : 
; 922  :         if ( user_message_functions[count].parameter == wParam )

  00026	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00029	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR ?user_message_functions@@3PAUuser_message_struct@@A[eax*8]
  00030	3b 4d 10	 cmp	 ecx, DWORD PTR _wParam$[ebp]
  00033	75 12		 jne	 SHORT $LN5@call_user_

; 923  :         {
; 924  : 
; 925  :             return ( user_message_functions[count].function ( ( void * ) lParam ) );

  00035	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00038	50		 push	 eax
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0003c	8b 14 cd 04 00
	00 00		 mov	 edx, DWORD PTR ?user_message_functions@@3PAUuser_message_struct@@A[ecx*8+4]
  00043	ff d2		 call	 edx
  00045	eb 04		 jmp	 SHORT $LN1@call_user_
$LN5@call_user_:

; 926  :         }
; 927  :     }

  00047	eb c9		 jmp	 SHORT $LN2@call_user_
$LN3@call_user_:

; 928  : 
; 929  : 
; 930  : 
; 931  :     return ( FALSE );

  00049	33 c0		 xor	 eax, eax
$LN1@call_user_:

; 932  : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 10 00	 ret	 16			; 00000010H
?call_user_function_routine@@YGJPAUHWND__@@IIJ@Z ENDP	; call_user_function_routine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?call_post_activate_function_routine@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_active$ = -8						; size = 4
_count$ = -4						; size = 4
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?call_post_activate_function_routine@@YGJPAUHWND__@@IIJ@Z PROC ; call_post_activate_function_routine, COMDAT

; 1042 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1043 : 
; 1044 : 	int
; 1045 : 		count,
; 1046 : 		active;
; 1047 : 
; 1048 : 	active = LOWORD ( wParam );

  00009	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0000c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00011	0f b7 c8	 movzx	 ecx, ax
  00014	89 4d f8	 mov	 DWORD PTR _active$[ebp], ecx

; 1049 : 
; 1050 : 	if ( active == WA_INACTIVE )

  00017	83 7d f8 00	 cmp	 DWORD PTR _active$[ebp], 0
  0001b	75 09		 jne	 SHORT $LN5@call_post_

; 1051 : 	{
; 1052 : 
; 1053 : 		//
; 1054 : 		// Application becoming inactive
; 1055 : 		//
; 1056 : 
; 1057 : 		active = FALSE;

  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _active$[ebp], 0

; 1058 : 	}
; 1059 : 	else

  00024	eb 07		 jmp	 SHORT $LN6@call_post_
$LN5@call_post_:

; 1060 : 	{
; 1061 : 
; 1062 : 		//
; 1063 : 		// Application becoming active
; 1064 : 		//
; 1065 : 
; 1066 : 		active = TRUE;

  00026	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _active$[ebp], 1
$LN6@call_post_:

; 1067 : 	}
; 1068 : 
; 1069 : 	//
; 1070 : 	// Call any routine thats interested in the program becoming active
; 1071 : 	//
; 1072 : 
; 1073 : 	for ( count = 0; count < number_post_activate_message_functions; count++ )

  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00034	eb 09		 jmp	 SHORT $LN4@call_post_
$LN2@call_post_:
  00036	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00039	83 c0 01	 add	 eax, 1
  0003c	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@call_post_:
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00042	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_post_activate_message_functions@@3HA ; number_post_activate_message_functions
  00048	7d 1f		 jge	 SHORT $LN3@call_post_

; 1074 : 	{
; 1075 : 
; 1076 : 		if ( post_activate_message_functions[count] )

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0004d	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR ?post_activate_message_functions@@3PAP6GXH@ZA[eax*4], 0
  00055	74 10		 je	 SHORT $LN7@call_post_

; 1077 : 		{
; 1078 : 
; 1079 : 			post_activate_message_functions[count] ( active );

  00057	8b 45 f8	 mov	 eax, DWORD PTR _active$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0005e	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?post_activate_message_functions@@3PAP6GXH@ZA[ecx*4]
  00065	ff d2		 call	 edx
$LN7@call_post_:

; 1080 : 		}
; 1081 : 	}

  00067	eb cd		 jmp	 SHORT $LN2@call_post_
$LN3@call_post_:

; 1082 : 
; 1083 : 	if ( active )

  00069	83 7d f8 00	 cmp	 DWORD PTR _active$[ebp], 0
  0006d	74 0a		 je	 SHORT $LN8@call_post_

; 1084 : 	{
; 1085 : 
; 1086 : 		//
; 1087 : 		// If we're becoming active, do that NOW
; 1088 : 		//
; 1089 : 
; 1090 : 		application_active = TRUE;

  0006f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?application_active@@3HA, 1 ; application_active
$LN8@call_post_:

; 1091 : 	}
; 1092 : 
; 1093 : 	return ( 0 );

  00079	33 c0		 xor	 eax, eax

; 1094 : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 10 00	 ret	 16			; 00000010H
?call_post_activate_function_routine@@YGJPAUHWND__@@IIJ@Z ENDP ; call_post_activate_function_routine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?call_pre_activate_function_routine@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_active$ = -8						; size = 4
_count$ = -4						; size = 4
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?call_pre_activate_function_routine@@YGJPAUHWND__@@IIJ@Z PROC ; call_pre_activate_function_routine, COMDAT

; 981  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 982  : 
; 983  : 	int
; 984  : 		count,
; 985  : 		active;
; 986  : 
; 987  : 	active = LOWORD ( wParam );

  00009	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0000c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00011	0f b7 c8	 movzx	 ecx, ax
  00014	89 4d f8	 mov	 DWORD PTR _active$[ebp], ecx

; 988  : 
; 989  : 	if ( active == WA_INACTIVE )

  00017	83 7d f8 00	 cmp	 DWORD PTR _active$[ebp], 0
  0001b	75 09		 jne	 SHORT $LN5@call_pre_a

; 990  : 	{
; 991  : 
; 992  : 		//
; 993  : 		// Application becoming inactive
; 994  : 		//
; 995  : 
; 996  : 		active = FALSE;

  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _active$[ebp], 0

; 997  : 	}
; 998  : 	else

  00024	eb 07		 jmp	 SHORT $LN6@call_pre_a
$LN5@call_pre_a:

; 999  : 	{
; 1000 : 
; 1001 : 		//
; 1002 : 		// Application becoming active
; 1003 : 		//
; 1004 : 
; 1005 : 		active = TRUE;

  00026	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _active$[ebp], 1
$LN6@call_pre_a:

; 1006 : 	}
; 1007 : 
; 1008 : 	//
; 1009 : 	// Call any routine thats interested in the program becoming active
; 1010 : 	//
; 1011 : 
; 1012 : 	for ( count = 0; count < number_pre_activate_message_functions; count++ )

  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00034	eb 09		 jmp	 SHORT $LN4@call_pre_a
$LN2@call_pre_a:
  00036	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00039	83 c0 01	 add	 eax, 1
  0003c	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@call_pre_a:
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00042	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_pre_activate_message_functions@@3HA ; number_pre_activate_message_functions
  00048	7d 1f		 jge	 SHORT $LN3@call_pre_a

; 1013 : 	{
; 1014 : 
; 1015 : 		if ( pre_activate_message_functions[count] )

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0004d	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR ?pre_activate_message_functions@@3PAP6GXH@ZA[eax*4], 0
  00055	74 10		 je	 SHORT $LN7@call_pre_a

; 1016 : 		{
; 1017 : 
; 1018 : 			pre_activate_message_functions[count] ( active );

  00057	8b 45 f8	 mov	 eax, DWORD PTR _active$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0005e	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?pre_activate_message_functions@@3PAP6GXH@ZA[ecx*4]
  00065	ff d2		 call	 edx
$LN7@call_pre_a:

; 1019 : 		}
; 1020 : 	}

  00067	eb cd		 jmp	 SHORT $LN2@call_pre_a
$LN3@call_pre_a:

; 1021 : 
; 1022 : 	application_active = active;

  00069	8b 45 f8	 mov	 eax, DWORD PTR _active$[ebp]
  0006c	a3 00 00 00 00	 mov	 DWORD PTR ?application_active@@3HA, eax ; application_active

; 1023 : 
; 1024 : 	//
; 1025 : 	// Set the window to be the top window if we're becoming active
; 1026 : 	//
; 1027 : 
; 1028 : 	if ( active )

  00071	83 7d f8 00	 cmp	 DWORD PTR _active$[ebp], 0
  00075	74 0c		 je	 SHORT $LN8@call_pre_a

; 1029 : 	{
; 1030 : 
; 1031 : 		SetActiveWindow ( application_window );

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  0007c	50		 push	 eax
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetActiveWindow@4
$LN8@call_pre_a:

; 1032 : 	}
; 1033 : 
; 1034 : 	return ( 0 );

  00083	33 c0		 xor	 eax, eax

; 1035 : }

  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 10 00	 ret	 16			; 00000010H
?call_pre_activate_function_routine@@YGJPAUHWND__@@IIJ@Z ENDP ; call_pre_activate_function_routine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?set_application_current_directory@@YGXXZ
_TEXT	SEGMENT
_string_length$1 = -1040				; size = 4
_type$2 = -1036						; size = 4
_root$3 = -1032						; size = 1024
_key$ = -8						; size = 4
_ptr$ = -4						; size = 4
?set_application_current_directory@@YGXXZ PROC		; set_application_current_directory, COMDAT

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 04 00
	00		 sub	 esp, 1232		; 000004d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 454  : 	char
; 455  : 		*ptr;
; 456  : 
; 457  : 	// Casm 17JUN05 Using directory from Registry while debugging.
; 458  : #ifdef DEBUG
; 459  : 
; 460  : 	HKEY key;
; 461  : 
; 462  : 	if ( RegOpenKey ( HKEY_LOCAL_MACHINE, "Software\\Razorworks\\Comanche Hokum", &key ) == ERROR_SUCCESS )

  0000c	8d 45 f8	 lea	 eax, DWORD PTR _key$[ebp]
  0000f	50		 push	 eax
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LLJBMCPC@Software?2Razorworks?2Comanche?5Ho@
  00015	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyA@12
  00020	85 c0		 test	 eax, eax
  00022	75 77		 jne	 SHORT $LN4@set_applic

; 463  : 	{
; 464  : 		char root[1024];
; 465  : 		DWORD type;
; 466  : 		DWORD string_length;
; 467  : 
; 468  : 		string_length = sizeof ( root );

  00024	c7 85 f0 fb ff
	ff 00 04 00 00	 mov	 DWORD PTR _string_length$1[ebp], 1024 ; 00000400H

; 469  : 		type = REG_SZ;

  0002e	c7 85 f4 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _type$2[ebp], 1

; 470  : 		RegQueryValueEx ( key, "Installation Path", NULL, &type, ( LPBYTE ) root, ( LPDWORD ) &string_length );

  00038	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _string_length$1[ebp]
  0003e	50		 push	 eax
  0003f	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _root$3[ebp]
  00045	51		 push	 ecx
  00046	8d 95 f4 fb ff
	ff		 lea	 edx, DWORD PTR _type$2[ebp]
  0004c	52		 push	 edx
  0004d	6a 00		 push	 0
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DEGFMGAC@Installation?5Path@
  00054	8b 45 f8	 mov	 eax, DWORD PTR _key$[ebp]
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24

; 471  : 		strcat ( root, "\\COHOKUM" );

  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_08MCNMNMBL@?2COHOKUM@
  00063	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _root$3[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _strcat
  0006f	83 c4 08	 add	 esp, 8

; 472  :    		SetCurrentDirectory ( root );

  00072	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _root$3[ebp]
  00078	50		 push	 eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCurrentDirectoryA@4

; 473  : 		GetCurrentDirectory ( sizeof ( application_current_directory ), application_current_directory );

  0007f	68 00 00 00 00	 push	 OFFSET ?application_current_directory@@3PADA ; application_current_directory
  00084	68 00 04 00 00	 push	 1024			; 00000400H
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentDirectoryA@8

; 474  : 		RegCloseKey ( key );

  0008f	8b 45 f8	 mov	 eax, DWORD PTR _key$[ebp]
  00092	50		 push	 eax
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 475  : 		return;

  00099	eb 67		 jmp	 SHORT $LN1@set_applic
$LN4@set_applic:

; 476  : 	}
; 477  : 
; 478  : #endif
; 479  : 	// Casm 17JUN05 Using directory from Registry while debugging.
; 480  : 
; 481  : 	GetModuleFileName ( NULL, application_current_directory, sizeof ( application_current_directory ) );

  0009b	68 00 04 00 00	 push	 1024			; 00000400H
  000a0	68 00 00 00 00	 push	 OFFSET ?application_current_directory@@3PADA ; application_current_directory
  000a5	6a 00		 push	 0
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 482  : 
; 483  : 	ptr = application_current_directory;

  000ad	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ptr$[ebp], OFFSET ?application_current_directory@@3PADA ; application_current_directory

; 484  : 
; 485  : 	ptr += strlen ( application_current_directory );

  000b4	68 00 00 00 00	 push	 OFFSET ?application_current_directory@@3PADA ; application_current_directory
  000b9	e8 00 00 00 00	 call	 _strlen
  000be	83 c4 04	 add	 esp, 4
  000c1	03 45 fc	 add	 eax, DWORD PTR _ptr$[ebp]
  000c4	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax
$LN2@set_applic:

; 486  : 
; 487  : 	while ( ( *ptr != '\\' ) && ( ptr > application_current_directory ) )

  000c7	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  000ca	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000cd	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  000d0	74 14		 je	 SHORT $LN3@set_applic
  000d2	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _ptr$[ebp], OFFSET ?application_current_directory@@3PADA ; application_current_directory
  000d9	76 0b		 jbe	 SHORT $LN3@set_applic

; 488  : 	{
; 489  : 
; 490  : 		ptr--;

  000db	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  000de	83 e8 01	 sub	 eax, 1
  000e1	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 491  : 	}

  000e4	eb e1		 jmp	 SHORT $LN2@set_applic
$LN3@set_applic:

; 492  : 
; 493  : 	if ( *ptr == '\\' )

  000e6	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  000e9	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000ec	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  000ef	75 11		 jne	 SHORT $LN1@set_applic

; 494  : 	{
; 495  : 
; 496  : 		*ptr = '\0';

  000f1	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  000f4	c6 00 00	 mov	 BYTE PTR [eax], 0

; 497  : 
; 498  : 		SetCurrentDirectory ( application_current_directory );

  000f7	68 00 00 00 00	 push	 OFFSET ?application_current_directory@@3PADA ; application_current_directory
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCurrentDirectoryA@4
$LN1@set_applic:

; 499  : 	}
; 500  : 
; 501  : }

  00102	5f		 pop	 edi
  00103	5e		 pop	 esi
  00104	5b		 pop	 ebx
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c3		 ret	 0
?set_application_current_directory@@YGXXZ ENDP		; set_application_current_directory
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?initialise_application_exception_handler@@YGXXZ
_TEXT	SEGMENT
?initialise_application_exception_handler@@YGXXZ PROC	; initialise_application_exception_handler, COMDAT

; 1224 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1225 : 
; 1226 : 	SetUnhandledExceptionFilter ( application_exception_handler );

  00009	68 00 00 00 00	 push	 OFFSET ?application_exception_handler@@YGJPAU_EXCEPTION_POINTERS@@@Z ; application_exception_handler
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetUnhandledExceptionFilter@4

; 1227 : }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?initialise_application_exception_handler@@YGXXZ ENDP	; initialise_application_exception_handler
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?start_application@@YGXXZ
_TEXT	SEGMENT
_ptr$ = -2192						; size = 4
_argv$ = -2188						; size = 128
_strings$ = -2060					; size = 2048
_argc$ = -12						; size = 4
_count$ = -8						; size = 4
_string$ = -4						; size = 4
?start_application@@YGXXZ PROC				; start_application, COMDAT

; 667  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 09 00
	00		 sub	 esp, 2512		; 000009d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 668  : 
; 669  : 	int
; 670  : 		string,
; 671  : 		count,
; 672  : 		argc;
; 673  : 
; 674  : 	char
; 675  : 		strings[32][64],
; 676  : 		*argv[32],
; 677  : 		*ptr;
; 678  : 
; 679  : 
; 680  : 	SetThreadPriority ( GetCurrentThread (), THREAD_PRIORITY_NORMAL );

  0000c	6a 00		 push	 0
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  00014	50		 push	 eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadPriority@8

; 681  : 
; 682  : 	strcpy ( &strings[0][0], "APPLICATION" );

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GPGGNAFB@APPLICATION@
  00020	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8d 94 0d f4 f7
	ff ff		 lea	 edx, DWORD PTR _strings$[ebp+ecx]
  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	6b c8 00	 imul	 ecx, eax, 0
  00037	03 d1		 add	 edx, ecx
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 _strcpy
  0003f	83 c4 08	 add	 esp, 8

; 683  : 
; 684  : 	argv[0] = &strings[0][0];

  00042	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00047	6b c8 00	 imul	 ecx, eax, 0
  0004a	8d 94 0d f4 f7
	ff ff		 lea	 edx, DWORD PTR _strings$[ebp+ecx]
  00051	b8 01 00 00 00	 mov	 eax, 1
  00056	6b c8 00	 imul	 ecx, eax, 0
  00059	03 d1		 add	 edx, ecx
  0005b	b8 04 00 00 00	 mov	 eax, 4
  00060	6b c8 00	 imul	 ecx, eax, 0
  00063	89 94 0d 74 f7
	ff ff		 mov	 DWORD PTR _argv$[ebp+ecx], edx

; 685  : 
; 686  : 	ptr = main_command_line;

  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?main_command_line@@3PADA ; main_command_line
  0006f	89 85 70 f7 ff
	ff		 mov	 DWORD PTR _ptr$[ebp], eax

; 687  : 
; 688  : 	count = 0;

  00075	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 689  : 
; 690  : 	string = 1;

  0007c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _string$[ebp], 1
$LN2@start_appl:

; 691  : 
; 692  : 	while ( *ptr != '\0' )

  00083	8b 85 70 f7 ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  00089	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0008c	85 c9		 test	 ecx, ecx
  0008e	0f 84 b7 00 00
	00		 je	 $LN3@start_appl
$LN4@start_appl:

; 693  : 	{
; 694  : 
; 695  : 		while ( ( *ptr != ' ' ) && ( *ptr != '\0' ) )

  00094	8b 85 70 f7 ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  0009a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0009d	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000a0	74 42		 je	 SHORT $LN5@start_appl
  000a2	8b 85 70 f7 ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  000a8	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000ab	85 c9		 test	 ecx, ecx
  000ad	74 35		 je	 SHORT $LN5@start_appl

; 696  : 		{
; 697  : 
; 698  : 			strings[string][count] = *ptr;

  000af	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  000b2	c1 e0 06	 shl	 eax, 6
  000b5	8d 8c 05 f4 f7
	ff ff		 lea	 ecx, DWORD PTR _strings$[ebp+eax]
  000bc	8b 55 f8	 mov	 edx, DWORD PTR _count$[ebp]
  000bf	8b 85 70 f7 ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  000c5	8a 00		 mov	 al, BYTE PTR [eax]
  000c7	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 699  : 
; 700  : 			count++;

  000ca	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  000cd	83 c0 01	 add	 eax, 1
  000d0	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 701  : 			ptr++;

  000d3	8b 85 70 f7 ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  000d9	83 c0 01	 add	 eax, 1
  000dc	89 85 70 f7 ff
	ff		 mov	 DWORD PTR _ptr$[ebp], eax

; 702  : 		}

  000e2	eb b0		 jmp	 SHORT $LN4@start_appl
$LN5@start_appl:

; 703  : 
; 704  : 		if ( *ptr == ' ' )

  000e4	8b 85 70 f7 ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  000ea	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000ed	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000f0	75 0f		 jne	 SHORT $LN6@start_appl

; 705  : 		{
; 706  : 
; 707  : 			ptr++;

  000f2	8b 85 70 f7 ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  000f8	83 c0 01	 add	 eax, 1
  000fb	89 85 70 f7 ff
	ff		 mov	 DWORD PTR _ptr$[ebp], eax
$LN6@start_appl:

; 708  : 		}
; 709  : 
; 710  : 		strings[string][count] = '\0';

  00101	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00104	c1 e0 06	 shl	 eax, 6
  00107	8d 8c 05 f4 f7
	ff ff		 lea	 ecx, DWORD PTR _strings$[ebp+eax]
  0010e	8b 55 f8	 mov	 edx, DWORD PTR _count$[ebp]
  00111	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0

; 711  : 		argv[string] = &strings[string][0];

  00115	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00118	c1 e0 06	 shl	 eax, 6
  0011b	8d 8c 05 f4 f7
	ff ff		 lea	 ecx, DWORD PTR _strings$[ebp+eax]
  00122	ba 01 00 00 00	 mov	 edx, 1
  00127	6b c2 00	 imul	 eax, edx, 0
  0012a	03 c8		 add	 ecx, eax
  0012c	8b 55 fc	 mov	 edx, DWORD PTR _string$[ebp]
  0012f	89 8c 95 74 f7
	ff ff		 mov	 DWORD PTR _argv$[ebp+edx*4], ecx

; 712  : 
; 713  : 		count = 0;

  00136	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 714  : 		string++;

  0013d	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00140	83 c0 01	 add	 eax, 1
  00143	89 45 fc	 mov	 DWORD PTR _string$[ebp], eax

; 715  : 	}

  00146	e9 38 ff ff ff	 jmp	 $LN2@start_appl
$LN3@start_appl:

; 716  : 
; 717  : 	argc = string;

  0014b	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  0014e	89 45 f4	 mov	 DWORD PTR _argc$[ebp], eax

; 718  : 
; 719  : 	//
; 720  : 	// The graphics / 3d / 2d systems need the maths fpu to round to zero
; 721  : 	//
; 722  : 
; 723  : 	set_fpu_rounding_mode_zero ();

  00151	e8 00 00 00 00	 call	 ?set_fpu_rounding_mode_zero@@YGXXZ ; set_fpu_rounding_mode_zero

; 724  : 
; 725  : 	set_fpu_exceptions ();

  00156	e8 00 00 00 00	 call	 ?set_fpu_exceptions@@YGXXZ ; set_fpu_exceptions

; 726  : 
; 727  : 	application_main ( argc, argv );

  0015b	8d 85 74 f7 ff
	ff		 lea	 eax, DWORD PTR _argv$[ebp]
  00161	50		 push	 eax
  00162	8b 4d f4	 mov	 ecx, DWORD PTR _argc$[ebp]
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 ?application_main@@YGXHPAPAD@Z ; application_main

; 728  : }

  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c3		 ret	 0
?start_application@@YGXXZ ENDP				; start_application
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?end_application@@YGXXZ
_TEXT	SEGMENT
?end_application@@YGXXZ PROC				; end_application, COMDAT

; 588  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 589  : 	f3d_context_leave ();

  00009	e8 00 00 00 00	 call	 ?f3d_context_leave@@YGXXZ ; f3d_context_leave

; 590  : 
; 591  : 	SendMessage ( application_window, WM_USER, exit_message_id, 0 );

  0000e	6a 00		 push	 0
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?exit_message_id@@3HA ; exit_message_id
  00015	50		 push	 eax
  00016	68 00 04 00 00	 push	 1024			; 00000400H
  0001b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  00021	51		 push	 ecx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 592  : 
; 593  : 	Sleep ( INFINITE );

  00028	6a ff		 push	 -1
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 594  : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?end_application@@YGXXZ ENDP				; end_application
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?register_post_activate_message_function@@YGHP6GXH@Z@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_fn$ = 8						; size = 4
?register_post_activate_message_function@@YGHP6GXH@Z@Z PROC ; register_post_activate_message_function, COMDAT

; 844  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 845  : 
; 846  : 	int
; 847  : 		count;
; 848  : 
; 849  : 	//
; 850  : 	// Check to see if we already have registered this message.
; 851  : 	//
; 852  : 
; 853  : 	for ( count = 0; count < number_post_activate_message_functions; count++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@register_p
$LN2@register_p:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@register_p:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_post_activate_message_functions@@3HA ; number_post_activate_message_functions
  00024	7d 15		 jge	 SHORT $LN3@register_p

; 854  : 	{
; 855  : 
; 856  : 		if ( post_activate_message_functions[count] == fn )

  00026	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00029	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?post_activate_message_functions@@3PAP6GXH@ZA[eax*4]
  00030	3b 4d 08	 cmp	 ecx, DWORD PTR _fn$[ebp]
  00033	75 04		 jne	 SHORT $LN5@register_p

; 857  : 		{
; 858  : 
; 859  : 			return ( FALSE );

  00035	33 c0		 xor	 eax, eax
  00037	eb 23		 jmp	 SHORT $LN1@register_p
$LN5@register_p:

; 860  : 		}
; 861  : 	}

  00039	eb d7		 jmp	 SHORT $LN2@register_p
$LN3@register_p:

; 862  : 
; 863  : 	//
; 864  : 	// Insert the function into the table
; 865  : 	//
; 866  : 
; 867  : 	post_activate_message_functions[number_post_activate_message_functions] = fn;

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_post_activate_message_functions@@3HA ; number_post_activate_message_functions
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _fn$[ebp]
  00043	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?post_activate_message_functions@@3PAP6GXH@ZA[eax*4], ecx

; 868  : 
; 869  : 	number_post_activate_message_functions ++;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_post_activate_message_functions@@3HA ; number_post_activate_message_functions
  0004f	83 c0 01	 add	 eax, 1
  00052	a3 00 00 00 00	 mov	 DWORD PTR ?number_post_activate_message_functions@@3HA, eax ; number_post_activate_message_functions

; 870  : 
; 871  : 	return ( TRUE );

  00057	b8 01 00 00 00	 mov	 eax, 1
$LN1@register_p:

; 872  : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?register_post_activate_message_function@@YGHP6GXH@Z@Z ENDP ; register_post_activate_message_function
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?register_pre_activate_message_function@@YGHP6GXH@Z@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_fn$ = 8						; size = 4
?register_pre_activate_message_function@@YGHP6GXH@Z@Z PROC ; register_pre_activate_message_function, COMDAT

; 809  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 810  : 
; 811  : 	int
; 812  : 		count;
; 813  : 
; 814  : 	//
; 815  : 	// Check to see if we already have registered this message.
; 816  : 	//
; 817  : 
; 818  : 	for ( count = 0; count < number_pre_activate_message_functions; count++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@register_p
$LN2@register_p:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@register_p:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_pre_activate_message_functions@@3HA ; number_pre_activate_message_functions
  00024	7d 15		 jge	 SHORT $LN3@register_p

; 819  : 	{
; 820  : 
; 821  : 		if ( pre_activate_message_functions[count] == fn )

  00026	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00029	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?pre_activate_message_functions@@3PAP6GXH@ZA[eax*4]
  00030	3b 4d 08	 cmp	 ecx, DWORD PTR _fn$[ebp]
  00033	75 04		 jne	 SHORT $LN5@register_p

; 822  : 		{
; 823  : 
; 824  : 			return ( FALSE );

  00035	33 c0		 xor	 eax, eax
  00037	eb 23		 jmp	 SHORT $LN1@register_p
$LN5@register_p:

; 825  : 		}
; 826  : 	}

  00039	eb d7		 jmp	 SHORT $LN2@register_p
$LN3@register_p:

; 827  : 
; 828  : 	//
; 829  : 	// Insert the function into the table
; 830  : 	//
; 831  : 
; 832  : 	pre_activate_message_functions[number_pre_activate_message_functions] = fn;

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_pre_activate_message_functions@@3HA ; number_pre_activate_message_functions
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _fn$[ebp]
  00043	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?pre_activate_message_functions@@3PAP6GXH@ZA[eax*4], ecx

; 833  : 
; 834  : 	number_pre_activate_message_functions ++;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_pre_activate_message_functions@@3HA ; number_pre_activate_message_functions
  0004f	83 c0 01	 add	 eax, 1
  00052	a3 00 00 00 00	 mov	 DWORD PTR ?number_pre_activate_message_functions@@3HA, eax ; number_pre_activate_message_functions

; 835  : 
; 836  : 	return ( TRUE );

  00057	b8 01 00 00 00	 mov	 eax, 1
$LN1@register_p:

; 837  : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?register_pre_activate_message_function@@YGHP6GXH@Z@Z ENDP ; register_pre_activate_message_function
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_parm$ = 8						; size = 4
_fn$ = 12						; size = 4
?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z PROC ; register_system_message_function, COMDAT

; 735  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 736  : 
; 737  :     int
; 738  :         count;
; 739  : 
; 740  :     //
; 741  :     // Check to see if we already have registered this message.
; 742  :     //
; 743  : 
; 744  :     for ( count=0; count<number_system_message_functions; count++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@register_s
$LN2@register_s:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@register_s:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_system_message_functions@@3HA ; number_system_message_functions
  00024	7d 15		 jge	 SHORT $LN3@register_s

; 745  :     {
; 746  : 
; 747  :         if ( system_message_functions[count].parameter == parm )

  00026	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00029	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR ?system_message_functions@@3PAUsystem_message_struct@@A[eax*8]
  00030	3b 4d 08	 cmp	 ecx, DWORD PTR _parm$[ebp]
  00033	75 04		 jne	 SHORT $LN5@register_s

; 748  :         {
; 749  : 
; 750  :             return ( FALSE );

  00035	33 c0		 xor	 eax, eax
  00037	eb 32		 jmp	 SHORT $LN1@register_s
$LN5@register_s:

; 751  :         }
; 752  :     }

  00039	eb d7		 jmp	 SHORT $LN2@register_s
$LN3@register_s:

; 753  : 
; 754  :     //
; 755  :     // Insert the function into the table
; 756  :     //
; 757  : 
; 758  :     system_message_functions[number_system_message_functions].parameter = parm;

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_system_message_functions@@3HA ; number_system_message_functions
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _parm$[ebp]
  00043	89 0c c5 00 00
	00 00		 mov	 DWORD PTR ?system_message_functions@@3PAUsystem_message_struct@@A[eax*8], ecx

; 759  : 
; 760  :     system_message_functions[number_system_message_functions].function = fn;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_system_message_functions@@3HA ; number_system_message_functions
  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _fn$[ebp]
  00052	89 0c c5 04 00
	00 00		 mov	 DWORD PTR ?system_message_functions@@3PAUsystem_message_struct@@A[eax*8+4], ecx

; 761  : 
; 762  :     number_system_message_functions ++;

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_system_message_functions@@3HA ; number_system_message_functions
  0005e	83 c0 01	 add	 eax, 1
  00061	a3 00 00 00 00	 mov	 DWORD PTR ?number_system_message_functions@@3HA, eax ; number_system_message_functions

; 763  : 
; 764  :     return ( TRUE );

  00066	b8 01 00 00 00	 mov	 eax, 1
$LN1@register_s:

; 765  : }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z ENDP ; register_system_message_function
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?register_user_message_function@@YGHHP6GJPAX@Z@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_parm$ = 8						; size = 4
_fn$ = 12						; size = 4
?register_user_message_function@@YGHHP6GJPAX@Z@Z PROC	; register_user_message_function, COMDAT

; 772  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 773  : 
; 774  :     int
; 775  :         count;
; 776  : 
; 777  :     //
; 778  :     // Check to see if we already have registered this message.
; 779  :     //
; 780  : 
; 781  :     for ( count=0; count<number_user_message_functions; count++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@register_u
$LN2@register_u:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@register_u:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_user_message_functions@@3HA ; number_user_message_functions
  00024	7d 15		 jge	 SHORT $LN3@register_u

; 782  :     {
; 783  : 
; 784  :         if ( user_message_functions[count].parameter == parm )

  00026	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00029	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR ?user_message_functions@@3PAUuser_message_struct@@A[eax*8]
  00030	3b 4d 08	 cmp	 ecx, DWORD PTR _parm$[ebp]
  00033	75 04		 jne	 SHORT $LN5@register_u

; 785  :         {
; 786  : 
; 787  :             return ( FALSE );

  00035	33 c0		 xor	 eax, eax
  00037	eb 32		 jmp	 SHORT $LN1@register_u
$LN5@register_u:

; 788  :         }
; 789  :     }

  00039	eb d7		 jmp	 SHORT $LN2@register_u
$LN3@register_u:

; 790  : 
; 791  :     //
; 792  :    // Insert the function into the table
; 793  :     //
; 794  : 
; 795  :     user_message_functions[number_user_message_functions].parameter = parm;

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_user_message_functions@@3HA ; number_user_message_functions
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _parm$[ebp]
  00043	89 0c c5 00 00
	00 00		 mov	 DWORD PTR ?user_message_functions@@3PAUuser_message_struct@@A[eax*8], ecx

; 796  : 
; 797  :     user_message_functions[number_user_message_functions].function = fn;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_user_message_functions@@3HA ; number_user_message_functions
  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _fn$[ebp]
  00052	89 0c c5 04 00
	00 00		 mov	 DWORD PTR ?user_message_functions@@3PAUuser_message_struct@@A[eax*8+4], ecx

; 798  : 
; 799  :     number_user_message_functions ++;

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_user_message_functions@@3HA ; number_user_message_functions
  0005e	83 c0 01	 add	 eax, 1
  00061	a3 00 00 00 00	 mov	 DWORD PTR ?number_user_message_functions@@3HA, eax ; number_user_message_functions

; 800  : 
; 801  :     return ( TRUE );

  00066	b8 01 00 00 00	 mov	 eax, 1
$LN1@register_u:

; 802  : }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
?register_user_message_function@@YGHHP6GJPAX@Z@Z ENDP	; register_user_message_function
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?register_exit_function@@YGXP6GXXZ@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_fn$ = 8						; size = 4
?register_exit_function@@YGXP6GXXZ@Z PROC		; register_exit_function, COMDAT

; 879  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 880  : 
; 881  :     int
; 882  :         count;
; 883  : 
; 884  :     //
; 885  :     // Check to see if we already have registered this message.
; 886  :     //
; 887  : 
; 888  :     for ( count=0; count<number_exit_functions; count++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@register_e
$LN2@register_e:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@register_e:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_exit_functions@@3HA ; number_exit_functions
  00024	7d 13		 jge	 SHORT $LN3@register_e

; 889  :     {
; 890  : 
; 891  :         if ( exit_functions[count].function == fn )

  00026	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00029	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR ?exit_functions@@3PAUexit_struct@@A[eax*8+4]
  00030	3b 4d 08	 cmp	 ecx, DWORD PTR _fn$[ebp]
  00033	75 02		 jne	 SHORT $LN5@register_e

; 892  :         {
; 893  : 
; 894  :             return;

  00035	eb 2e		 jmp	 SHORT $LN1@register_e
$LN5@register_e:

; 895  :         }
; 896  :     }

  00037	eb d9		 jmp	 SHORT $LN2@register_e
$LN3@register_e:

; 897  : 
; 898  :     //
; 899  :     // Insert the function into the table
; 900  :     //
; 901  : 
; 902  :     exit_functions[number_exit_functions].function = fn;

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_exit_functions@@3HA ; number_exit_functions
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _fn$[ebp]
  00041	89 0c c5 04 00
	00 00		 mov	 DWORD PTR ?exit_functions@@3PAUexit_struct@@A[eax*8+4], ecx

; 903  : 
; 904  :     exit_functions[number_exit_functions].called = FALSE;

  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_exit_functions@@3HA ; number_exit_functions
  0004d	c7 04 c5 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?exit_functions@@3PAUexit_struct@@A[eax*8], 0

; 905  : 
; 906  :     number_exit_functions ++;

  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_exit_functions@@3HA ; number_exit_functions
  0005d	83 c0 01	 add	 eax, 1
  00060	a3 00 00 00 00	 mov	 DWORD PTR ?number_exit_functions@@3HA, eax ; number_exit_functions
$LN1@register_e:

; 907  : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
?register_exit_function@@YGXP6GXXZ@Z ENDP		; register_exit_function
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?initialise_windows@@YGHPAUHINSTANCE__@@H@Z
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
_nCmdShow$ = 12						; size = 4
?initialise_windows@@YGHPAUHINSTANCE__@@H@Z PROC	; initialise_windows, COMDAT

; 572  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 573  : 
; 574  :     if ( !create_application_window ( hInstance, nCmdShow ) )

  00009	8b 45 0c	 mov	 eax, DWORD PTR _nCmdShow$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _hInstance$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ?create_application_window@@YGHPAUHINSTANCE__@@H@Z ; create_application_window
  00016	85 c0		 test	 eax, eax
  00018	75 04		 jne	 SHORT $LN2@initialise

; 575  :     {
; 576  : 
; 577  :         return ( FALSE );

  0001a	33 c0		 xor	 eax, eax
  0001c	eb 05		 jmp	 SHORT $LN1@initialise
$LN2@initialise:

; 578  :     }
; 579  : 
; 580  :     return ( TRUE );

  0001e	b8 01 00 00 00	 mov	 eax, 1
$LN1@initialise:

; 581  : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?initialise_windows@@YGHPAUHINSTANCE__@@H@Z ENDP	; initialise_windows
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT ?deinitialise_windows@@YGXXZ
_TEXT	SEGMENT
?deinitialise_windows@@YGXXZ PROC			; deinitialise_windows, COMDAT

; 549  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 550  : 
; 551  : 	if ( application_debug_fatal )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?application_debug_fatal@@3HA, 0 ; application_debug_fatal
  00010	74 18		 je	 SHORT $LN1@deinitiali

; 552  : 	{
; 553  : 
; 554  : 		#ifdef COMMERCIAL
; 555  : 
; 556  : 		MessageBox ( application_window, application_debug_fatal_string, "ERROR", MB_OK );
; 557  : 
; 558  : 		#else
; 559  : 
; 560  : 		MessageBox ( application_window, application_debug_fatal_string, "DEBUG FATAL", MB_OK );

  00012	6a 00		 push	 0
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0M@ILFGMGPN@DEBUG?5FATAL@
  00019	68 00 00 00 00	 push	 OFFSET ?application_debug_fatal_string@@3PADA ; application_debug_fatal_string
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?application_window@@3PAUHWND__@@A ; application_window
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN1@deinitiali:

; 561  : 
; 562  : 		#endif
; 563  : 	}
; 564  : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?deinitialise_windows@@YGXXZ ENDP			; deinitialise_windows
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\startup.c
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_handle_array$1 = -48					; size = 8
_object_count$2 = -40					; size = 4
_message_index$3 = -36					; size = 4
_terminated$ = -32					; size = 4
_msg$ = -28						; size = 28
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC					; COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 257  : 
; 258  : 	MSG
; 259  : 		msg;
; 260  : 
; 261  : 	int
; 262  : 		terminated;
; 263  : 
; 264  : 	//
; 265  : 	// Initialise DCOM
; 266  : 	//
; 267  : 
; 268  : 	CoInitializeEx ( NULL, COINIT_MULTITHREADED );

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoInitializeEx@8

; 269  : 
; 270  : 	//
; 271  : 	// Install our own exception handler!
; 272  : 	//
; 273  : 
; 274  : 	initialise_application_exception_handler ();

  00013	e8 00 00 00 00	 call	 ?initialise_application_exception_handler@@YGXXZ ; initialise_application_exception_handler

; 275  : 
; 276  : 	//
; 277  : 	// Set the current directory to where the executable is located
; 278  : 	//
; 279  : 
; 280  : 	set_application_current_directory ();

  00018	e8 00 00 00 00	 call	 ?set_application_current_directory@@YGXXZ ; set_application_current_directory

; 281  : 
; 282  : 	//
; 283  : 	// Unlink the debug.log file here.
; 284  : 	//
; 285  : 
; 286  : 	unlink ( "debug.log" );

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_09INNEDIGD@debug?4log@
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___unlink
  00028	83 c4 04	 add	 esp, 4

; 287  : 
; 288  : 	system_thread_id = GetCurrentThreadId ();

  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  00031	a3 00 00 00 00	 mov	 DWORD PTR ?system_thread_id@@3KA, eax ; system_thread_id

; 289  : 
; 290  : 	application_debug_fatal = FALSE;

  00036	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?application_debug_fatal@@3HA, 0 ; application_debug_fatal

; 291  : 
; 292  : 	application_active = TRUE;

  00040	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?application_active@@3HA, 1 ; application_active

; 293  : 
; 294  : 	//
; 295  : 	// Initialise the memory statistics
; 296  : 	//
; 297  : 
; 298  : 	initialise_memory_totals ();

  0004a	e8 00 00 00 00	 call	 ?initialise_memory_totals@@YGXXZ ; initialise_memory_totals

; 299  : 
; 300  : 	if ( !initialise_windows ( hInstance, nCmdShow ) )

  0004f	8b 45 14	 mov	 eax, DWORD PTR _nCmdShow$[ebp]
  00052	50		 push	 eax
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _hInstance$[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ?initialise_windows@@YGHPAUHINSTANCE__@@H@Z ; initialise_windows
  0005c	85 c0		 test	 eax, eax
  0005e	75 0c		 jne	 SHORT $LN6@WinMain

; 301  : 	{
; 302  : 
; 303  : 		deinitialise_windows ();

  00060	e8 00 00 00 00	 call	 ?deinitialise_windows@@YGXXZ ; deinitialise_windows

; 304  : 
; 305  : 		return ( FALSE );

  00065	33 c0		 xor	 eax, eax
  00067	e9 fd 01 00 00	 jmp	 $LN1@WinMain
$LN6@WinMain:

; 306  : 	}
; 307  : 
; 308  : 	application_instance = hInstance;

  0006c	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  0006f	a3 00 00 00 00	 mov	 DWORD PTR ?application_instance@@3PAUHINSTANCE__@@A, eax ; application_instance

; 309  : 
; 310  :    number_user_message_functions = 0;

  00074	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?number_user_message_functions@@3HA, 0 ; number_user_message_functions

; 311  : 
; 312  : 	number_system_message_functions = 0;

  0007e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?number_system_message_functions@@3HA, 0 ; number_system_message_functions

; 313  : 
; 314  : 	number_pre_activate_message_functions = 0;

  00088	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?number_pre_activate_message_functions@@3HA, 0 ; number_pre_activate_message_functions

; 315  : 
; 316  : 	number_post_activate_message_functions = 0;

  00092	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?number_post_activate_message_functions@@3HA, 0 ; number_post_activate_message_functions

; 317  : 
; 318  : 	register_system_message_function ( WM_USER, call_user_function_routine );

  0009c	68 00 00 00 00	 push	 OFFSET ?call_user_function_routine@@YGJPAUHWND__@@IIJ@Z ; call_user_function_routine
  000a1	68 00 04 00 00	 push	 1024			; 00000400H
  000a6	e8 00 00 00 00	 call	 ?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z ; register_system_message_function

; 319  : 
; 320  : 	register_system_message_function ( WM_SETCURSOR, windows_cursor_routine );

  000ab	68 00 00 00 00	 push	 OFFSET ?windows_cursor_routine@@YGJPAUHWND__@@IIJ@Z ; windows_cursor_routine
  000b0	6a 20		 push	 32			; 00000020H
  000b2	e8 00 00 00 00	 call	 ?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z ; register_system_message_function

; 321  : 
; 322  : 	register_system_message_function ( WM_ACTIVATE, call_pre_activate_function_routine );

  000b7	68 00 00 00 00	 push	 OFFSET ?call_pre_activate_function_routine@@YGJPAUHWND__@@IIJ@Z ; call_pre_activate_function_routine
  000bc	6a 06		 push	 6
  000be	e8 00 00 00 00	 call	 ?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z ; register_system_message_function

; 323  : 
; 324  : 	register_system_message_function ( WM_ACTIVATEAPP, call_post_activate_function_routine );

  000c3	68 00 00 00 00	 push	 OFFSET ?call_post_activate_function_routine@@YGJPAUHWND__@@IIJ@Z ; call_post_activate_function_routine
  000c8	6a 1c		 push	 28			; 0000001cH
  000ca	e8 00 00 00 00	 call	 ?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z ; register_system_message_function

; 325  : 
; 326  : 	register_system_message_function ( WM_PAINT, windows_paint_routine  );

  000cf	68 00 00 00 00	 push	 OFFSET ?windows_paint_routine@@YGJPAUHWND__@@IIJ@Z ; windows_paint_routine
  000d4	6a 0f		 push	 15			; 0000000fH
  000d6	e8 00 00 00 00	 call	 ?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z ; register_system_message_function

; 327  : 
; 328  : 	register_system_message_function ( WM_MOVE, windows_sizemove_routine );

  000db	68 00 00 00 00	 push	 OFFSET ?windows_sizemove_routine@@YGJPAUHWND__@@IIJ@Z ; windows_sizemove_routine
  000e0	6a 03		 push	 3
  000e2	e8 00 00 00 00	 call	 ?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z ; register_system_message_function

; 329  : 
; 330  : 	register_system_message_function ( WM_SYSCOMMAND, windows_systemcommand_routine );

  000e7	68 00 00 00 00	 push	 OFFSET ?windows_systemcommand_routine@@YGJPAUHWND__@@IIJ@Z ; windows_systemcommand_routine
  000ec	68 12 01 00 00	 push	 274			; 00000112H
  000f1	e8 00 00 00 00	 call	 ?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z ; register_system_message_function

; 331  : 
; 332  : 	register_system_message_function ( WM_CLOSE, windows_close_request_routine );

  000f6	68 00 00 00 00	 push	 OFFSET ?windows_close_request_routine@@YGJPAUHWND__@@IIJ@Z ; windows_close_request_routine
  000fb	6a 10		 push	 16			; 00000010H
  000fd	e8 00 00 00 00	 call	 ?register_system_message_function@@YGHHP6GJPAUHWND__@@IIJ@Z@Z ; register_system_message_function

; 333  : 
; 334  : 	initialise_cdrom_system ();

  00102	e8 00 00 00 00	 call	 ?initialise_cdrom_system@@YGXXZ ; initialise_cdrom_system

; 335  : 
; 336  : 	initialise_system_thread_calling_function ();

  00107	e8 00 00 00 00	 call	 ?initialise_system_thread_calling_function@@YGXXZ ; initialise_system_thread_calling_function

; 337  : 
; 338  : 	exit_message_id = get_unique_message_id ();

  0010c	e8 00 00 00 00	 call	 ?get_unique_message_id@@YGHXZ ; get_unique_message_id
  00111	a3 00 00 00 00	 mov	 DWORD PTR ?exit_message_id@@3HA, eax ; exit_message_id

; 339  : 
; 340  : 	register_user_message_function ( exit_message_id, windows_exit_routine );

  00116	68 00 00 00 00	 push	 OFFSET ?windows_exit_routine@@YGJPAX@Z ; windows_exit_routine
  0011b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?exit_message_id@@3HA ; exit_message_id
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 ?register_user_message_function@@YGHHP6GJPAX@Z@Z ; register_user_message_function

; 341  : 
; 342  : 	//
; 343  : 	// The graphics / 3d / 2d systems need the maths fpu to round to zero
; 344  : 	//
; 345  : 
; 346  : 	set_fpu_rounding_mode_zero ();

  00126	e8 00 00 00 00	 call	 ?set_fpu_rounding_mode_zero@@YGXXZ ; set_fpu_rounding_mode_zero

; 347  : 
; 348  : 	set_fpu_exceptions ();

  0012b	e8 00 00 00 00	 call	 ?set_fpu_exceptions@@YGXXZ ; set_fpu_exceptions

; 349  : 
; 350  : 	initialise_event_system ();

  00130	e8 00 00 00 00	 call	 ?initialise_event_system@@YGHXZ ; initialise_event_system

; 351  : 
; 352  : 	initialise_timers_system ();

  00135	e8 00 00 00 00	 call	 ?initialise_timers_system@@YGHXZ ; initialise_timers_system

; 353  : 
; 354  : 	initialise_file_system ();

  0013a	e8 00 00 00 00	 call	 ?initialise_file_system@@YGHXZ ; initialise_file_system

; 355  : 
; 356  : 	main_command_line = lpCmdLine;

  0013f	8b 45 10	 mov	 eax, DWORD PTR _lpCmdLine$[ebp]
  00142	a3 00 00 00 00	 mov	 DWORD PTR ?main_command_line@@3PADA, eax ; main_command_line

; 357  : 
; 358  : 	terminated = FALSE;

  00147	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _terminated$[ebp], 0

; 359  : 
; 360  : 	application_thread_handle = CreateThread

  0014e	68 00 00 00 00	 push	 OFFSET ?application_thread_id@@3KA ; application_thread_id
  00153	6a 00		 push	 0
  00155	6a 00		 push	 0
  00157	68 00 00 00 00	 push	 OFFSET ?start_application@@YGXXZ ; start_application
  0015c	6a 00		 push	 0
  0015e	6a 00		 push	 0
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  00166	a3 00 00 00 00	 mov	 DWORD PTR ?application_thread_handle@@3PAXA, eax ; application_thread_handle

; 361  : 	(
; 362  : 		(LPSECURITY_ATTRIBUTES) NULL,
; 363  : 		0,
; 364  : 		(LPTHREAD_START_ROUTINE) start_application,
; 365  : 		0,
; 366  : 		0,
; 367  : 		&application_thread_id
; 368  : 	);
; 369  : 
; 370  : 	SetThreadPriority ( GetCurrentThread (), THREAD_PRIORITY_ABOVE_NORMAL );

  0016b	6a 01		 push	 1
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  00173	50		 push	 eax
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadPriority@8
$LN2@WinMain:

; 371  : 
; 372  : 	while ( !terminated )

  0017a	83 7d e0 00	 cmp	 DWORD PTR _terminated$[ebp], 0
  0017e	0f 85 dc 00 00
	00		 jne	 $LN3@WinMain

; 373  : 	{
; 374  : 
; 375  : 		DWORD
; 376  : 			message_index,
; 377  : 			object_count;
; 378  : 
; 379  : 		HANDLE
; 380  : 			handle_array[2];
; 381  : 
; 382  : 		object_count = 0;

  00184	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _object_count$2[ebp], 0

; 383  : 
; 384  : 		if ( keyboard_handle )

  0018b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?keyboard_handle@@3PAXA, 0 ; keyboard_handle
  00192	74 16		 je	 SHORT $LN7@WinMain

; 385  : 		{
; 386  : 
; 387  : 			handle_array[object_count] = keyboard_handle;

  00194	8b 45 d8	 mov	 eax, DWORD PTR _object_count$2[ebp]
  00197	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?keyboard_handle@@3PAXA ; keyboard_handle
  0019d	89 4c 85 d0	 mov	 DWORD PTR _handle_array$1[ebp+eax*4], ecx

; 388  : 
; 389  : 			object_count++;

  001a1	8b 45 d8	 mov	 eax, DWORD PTR _object_count$2[ebp]
  001a4	83 c0 01	 add	 eax, 1
  001a7	89 45 d8	 mov	 DWORD PTR _object_count$2[ebp], eax
$LN7@WinMain:

; 390  : 		}
; 391  : 
; 392  : 		if ( mouse_handle )

  001aa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?mouse_handle@@3PAXA, 0 ; mouse_handle
  001b1	74 16		 je	 SHORT $LN8@WinMain

; 393  : 		{
; 394  : 
; 395  : 			handle_array[object_count] = mouse_handle;

  001b3	8b 45 d8	 mov	 eax, DWORD PTR _object_count$2[ebp]
  001b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?mouse_handle@@3PAXA ; mouse_handle
  001bc	89 4c 85 d0	 mov	 DWORD PTR _handle_array$1[ebp+eax*4], ecx

; 396  : 
; 397  : 			object_count++;

  001c0	8b 45 d8	 mov	 eax, DWORD PTR _object_count$2[ebp]
  001c3	83 c0 01	 add	 eax, 1
  001c6	89 45 d8	 mov	 DWORD PTR _object_count$2[ebp], eax
$LN8@WinMain:

; 398  : 		}
; 399  : 
; 400  : 		message_index = MsgWaitForMultipleObjects( object_count, handle_array, 0, INFINITE, QS_ALLINPUT);

  001c9	68 ff 1c 00 00	 push	 7423			; 00001cffH
  001ce	6a ff		 push	 -1
  001d0	6a 00		 push	 0
  001d2	8d 45 d0	 lea	 eax, DWORD PTR _handle_array$1[ebp]
  001d5	50		 push	 eax
  001d6	8b 4d d8	 mov	 ecx, DWORD PTR _object_count$2[ebp]
  001d9	51		 push	 ecx
  001da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MsgWaitForMultipleObjects@20
  001e0	89 45 dc	 mov	 DWORD PTR _message_index$3[ebp], eax

; 401  : //		message_index = MsgWaitForMultipleObjects( object_count, handle_array, 0, 100, QS_ALLINPUT);
; 402  : 
; 403  : 		if ( ( message_index >= object_count ) || ( message_index == WAIT_TIMEOUT ) )

  001e3	8b 45 dc	 mov	 eax, DWORD PTR _message_index$3[ebp]
  001e6	3b 45 d8	 cmp	 eax, DWORD PTR _object_count$2[ebp]
  001e9	73 09		 jae	 SHORT $LN4@WinMain
  001eb	81 7d dc 02 01
	00 00		 cmp	 DWORD PTR _message_index$3[ebp], 258 ; 00000102H
  001f2	75 3d		 jne	 SHORT $LN9@WinMain
$LN4@WinMain:

; 404  : 		{
; 405  : 
; 406  : 			//
; 407  : 			// Default windows messaging
; 408  : 			//
; 409  : 
; 410  : 			while ( PeekMessage ( &msg, NULL, 0, 0, PM_REMOVE ) )

  001f4	6a 01		 push	 1
  001f6	6a 00		 push	 0
  001f8	6a 00		 push	 0
  001fa	6a 00		 push	 0
  001fc	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  001ff	50		 push	 eax
  00200	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  00206	85 c0		 test	 eax, eax
  00208	74 25		 je	 SHORT $LN5@WinMain

; 411  : 			{
; 412  : 
; 413  : 				if ( msg.message == WM_QUIT )

  0020a	83 7d e8 12	 cmp	 DWORD PTR _msg$[ebp+4], 18 ; 00000012H
  0020e	75 09		 jne	 SHORT $LN12@WinMain

; 414  : 				{
; 415  : 
; 416  : 					terminated = TRUE;

  00210	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _terminated$[ebp], 1

; 417  : 				}
; 418  : 				else

  00217	eb 14		 jmp	 SHORT $LN13@WinMain
$LN12@WinMain:

; 419  : 				{
; 420  : 
; 421  : 					TranslateMessage(&msg);

  00219	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  0021c	50		 push	 eax
  0021d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TranslateMessage@4

; 422  : 
; 423  : 					DispatchMessage(&msg);

  00223	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  00226	50		 push	 eax
  00227	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DispatchMessageA@4
$LN13@WinMain:

; 424  : 				}
; 425  : 			}

  0022d	eb c5		 jmp	 SHORT $LN4@WinMain
$LN5@WinMain:

; 426  : 		}
; 427  : 		else

  0022f	eb 2a		 jmp	 SHORT $LN10@WinMain
$LN9@WinMain:

; 428  : 		{
; 429  : 
; 430  : 			if ( handle_array[message_index] == keyboard_handle )

  00231	8b 45 dc	 mov	 eax, DWORD PTR _message_index$3[ebp]
  00234	8b 4c 85 d0	 mov	 ecx, DWORD PTR _handle_array$1[ebp+eax*4]
  00238	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?keyboard_handle@@3PAXA ; keyboard_handle
  0023e	75 07		 jne	 SHORT $LN14@WinMain

; 431  : 			{
; 432  : 
; 433  : 				generate_keyboard_events ();

  00240	e8 00 00 00 00	 call	 ?generate_keyboard_events@@YGXXZ ; generate_keyboard_events
  00245	eb 14		 jmp	 SHORT $LN10@WinMain
$LN14@WinMain:

; 434  : 			}
; 435  : 			else if ( handle_array[message_index] == mouse_handle )

  00247	8b 45 dc	 mov	 eax, DWORD PTR _message_index$3[ebp]
  0024a	8b 4c 85 d0	 mov	 ecx, DWORD PTR _handle_array$1[ebp+eax*4]
  0024e	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?mouse_handle@@3PAXA ; mouse_handle
  00254	75 05		 jne	 SHORT $LN10@WinMain

; 436  : 			{
; 437  : 
; 438  : 				generate_mouse_events ();

  00256	e8 00 00 00 00	 call	 ?generate_mouse_events@@YGXXZ ; generate_mouse_events
$LN10@WinMain:

; 439  : 			}
; 440  : 		}
; 441  : 	}

  0025b	e9 1a ff ff ff	 jmp	 $LN2@WinMain
$LN3@WinMain:

; 442  : 
; 443  : 	CoUninitialize ();

  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0

; 444  : 
; 445  : 	return ( msg.wParam );

  00266	8b 45 ec	 mov	 eax, DWORD PTR _msg$[ebp+8]
$LN1@WinMain:

; 446  : }

  00269	5f		 pop	 edi
  0026a	5e		 pop	 esi
  0026b	5b		 pop	 ebx
  0026c	8b e5		 mov	 esp, ebp
  0026e	5d		 pop	 ebp
  0026f	c2 10 00	 ret	 16			; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1459 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1460 :         #pragma warning(push)
; 1461 :         #pragma warning(disable: 4996) // Deprecation
; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1463 :         #pragma warning(pop)
; 1464 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH
  00035	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00038	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003c	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003e	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00045	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00047	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  0004a	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004d	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1395 :     }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Stream$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vfprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 842  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	51		 push	 ecx
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	52		 push	 edx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  0002b	83 c4 18	 add	 esp, 24			; 00000018H

; 644  :     }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
