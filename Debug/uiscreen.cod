; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\userint2\ui_draw\uiscreen.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?ui_pop_screen@@YGXXZ				; ui_pop_screen
PUBLIC	?ui_push_screen@@YGXPAX@Z			; ui_push_screen
PUBLIC	?ui_list_screen_stack@@YGXXZ			; ui_list_screen_stack
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_09PNFNDAFP@Screen?5?$CFd@			; `string'
PUBLIC	__real@41200000
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__free:PROC
EXTRN	?safe_malloc_memory@@YGPAXI@Z:PROC		; safe_malloc_memory
EXTRN	?ui_display_text@@YGMPBDMM@Z:PROC		; ui_display_text
EXTRN	?current_font@@3PAUUI_FONT_TYPE@@A:DWORD	; current_font
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?screen_stack_head@@3PAUUI_SCREEN_STACK@@A DD 01H DUP (?) ; screen_stack_head
?screen_stack_tail@@3PAUUI_SCREEN_STACK@@A DD 01H DUP (?) ; screen_stack_tail
?screen_id@@3HA DD 01H DUP (?)				; screen_id
_BSS	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT ??_C@_09PNFNDAFP@Screen?5?$CFd@
CONST	SEGMENT
??_C@_09PNFNDAFP@Screen?5?$CFd@ DB 'Screen %d', 00H	; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\userint2\ui_draw\uiscreen.c
;	COMDAT ?ui_list_screen_stack@@YGXXZ
_TEXT	SEGMENT
_buffer$ = -32						; size = 20
_y$ = -12						; size = 4
_counter$ = -8						; size = 4
_this_screen$ = -4					; size = 4
?ui_list_screen_stack@@YGXXZ PROC			; ui_list_screen_stack, COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 237  : 
; 238  : 	ui_screen_stack
; 239  : 		*this_screen;
; 240  : 
; 241  : 	int
; 242  : 		counter = 0,

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _counter$[ebp], 0

; 243  : 		y = 50;

  00010	c7 45 f4 32 00
	00 00		 mov	 DWORD PTR _y$[ebp], 50	; 00000032H

; 244  : 
; 245  : 	char
; 246  : 		buffer [20];
; 247  : 
; 248  : 	this_screen = screen_stack_head;

  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A
  0001c	89 45 fc	 mov	 DWORD PTR _this_screen$[ebp], eax
$LN2@ui_list_sc:

; 249  : 
; 250  : 	while (this_screen)

  0001f	83 7d fc 00	 cmp	 DWORD PTR _this_screen$[ebp], 0
  00023	74 5d		 je	 SHORT $LN3@ui_list_sc

; 251  : 	{
; 252  : 
; 253  : 		sprintf (buffer, "Screen %d", this_screen->screen_id);

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this_screen$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	51		 push	 ecx
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_09PNFNDAFP@Screen?5?$CFd@
  00030	8d 55 e0	 lea	 edx, DWORD PTR _buffer$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _sprintf
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 254  : 
; 255  : 		ui_display_text (buffer, 10, y);

  0003c	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _y$[ebp]
  00041	51		 push	 ecx
  00042	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00047	51		 push	 ecx
  00048	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  00050	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00055	8d 45 e0	 lea	 eax, DWORD PTR _buffer$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?ui_display_text@@YGMPBDMM@Z ; ui_display_text
  0005e	dd d8		 fstp	 ST(0)

; 256  : 
; 257  : 		y += ui_get_font_height ();

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR ?current_font@@3PAUUI_FONT_TYPE@@A ; current_font
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _y$[ebp]
  00068	03 48 10	 add	 ecx, DWORD PTR [eax+16]
  0006b	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx

; 258  : 
; 259  : 		counter ++;

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _counter$[ebp]
  00071	83 c0 01	 add	 eax, 1
  00074	89 45 f8	 mov	 DWORD PTR _counter$[ebp], eax

; 260  : 
; 261  : 		this_screen = this_screen->prev;

  00077	8b 45 fc	 mov	 eax, DWORD PTR _this_screen$[ebp]
  0007a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007d	89 4d fc	 mov	 DWORD PTR _this_screen$[ebp], ecx

; 262  : 	}

  00080	eb 9d		 jmp	 SHORT $LN2@ui_list_sc
$LN3@ui_list_sc:

; 263  : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?ui_list_screen_stack@@YGXXZ ENDP			; ui_list_screen_stack
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\userint2\ui_draw\uiscreen.c
;	COMDAT ?ui_push_screen@@YGXPAX@Z
_TEXT	SEGMENT
_new_stack_item$ = -8					; size = 4
_stack_search$ = -4					; size = 4
_this_screen$ = 8					; size = 4
?ui_push_screen@@YGXPAX@Z PROC				; ui_push_screen, COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 117  : 
; 118  : 	ui_screen_stack
; 119  : 		*stack_search,
; 120  : 		*new_stack_item;
; 121  : 
; 122  : 	// check if already on stack
; 123  : 
; 124  : 	stack_search = screen_stack_head;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A
  0000e	89 45 fc	 mov	 DWORD PTR _stack_search$[ebp], eax
$LN2@ui_push_sc:

; 125  : 
; 126  : 	while (stack_search)

  00011	83 7d fc 00	 cmp	 DWORD PTR _stack_search$[ebp], 0
  00015	74 3e		 je	 SHORT $LN3@ui_push_sc

; 127  : 	{
; 128  : 
; 129  : 		// screen found on stack
; 130  : 
; 131  : 		if (stack_search->screen == this_screen)

  00017	8b 45 fc	 mov	 eax, DWORD PTR _stack_search$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	3b 4d 08	 cmp	 ecx, DWORD PTR _this_screen$[ebp]
  00020	75 28		 jne	 SHORT $LN6@ui_push_sc

; 132  : 		{
; 133  : 
; 134  : 			// pop all down to this screen
; 135  : 
; 136  : 			stack_search = screen_stack_head;

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A
  00027	89 45 fc	 mov	 DWORD PTR _stack_search$[ebp], eax
$LN4@ui_push_sc:

; 137  : 
; 138  : 			while (stack_search->screen != this_screen)

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _stack_search$[ebp]
  0002d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00030	3b 4d 08	 cmp	 ecx, DWORD PTR _this_screen$[ebp]
  00033	74 10		 je	 SHORT $LN5@ui_push_sc

; 139  : 			{
; 140  : 
; 141  : 				ui_pop_screen ();

  00035	e8 00 00 00 00	 call	 ?ui_pop_screen@@YGXXZ	; ui_pop_screen

; 142  : 
; 143  : 				stack_search = stack_search->prev;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _stack_search$[ebp]
  0003d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00040	89 4d fc	 mov	 DWORD PTR _stack_search$[ebp], ecx

; 144  : 			}

  00043	eb e5		 jmp	 SHORT $LN4@ui_push_sc
$LN5@ui_push_sc:

; 145  : 
; 146  : 			return;

  00045	e9 b2 00 00 00	 jmp	 $LN1@ui_push_sc
$LN6@ui_push_sc:

; 147  : 		}
; 148  : 
; 149  : 		stack_search = stack_search->prev;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _stack_search$[ebp]
  0004d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00050	89 4d fc	 mov	 DWORD PTR _stack_search$[ebp], ecx

; 150  : 	}

  00053	eb bc		 jmp	 SHORT $LN2@ui_push_sc
$LN3@ui_push_sc:

; 151  : 
; 152  : 	// malloc new screen
; 153  : 
; 154  : 	new_stack_item = (ui_screen_stack *) safe_malloc (sizeof (ui_screen_stack));

  00055	6a 14		 push	 20			; 00000014H
  00057	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  0005c	89 45 f8	 mov	 DWORD PTR _new_stack_item$[ebp], eax

; 155  : 
; 156  : 	new_stack_item->screen = this_screen;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _new_stack_item$[ebp]
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _this_screen$[ebp]
  00065	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 157  : 
; 158  : 	new_stack_item->screen_id = screen_id ++;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _new_stack_item$[ebp]
  0006b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?screen_id@@3HA
  00071	89 08		 mov	 DWORD PTR [eax], ecx
  00073	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?screen_id@@3HA
  00079	83 c2 01	 add	 edx, 1
  0007c	89 15 00 00 00
	00		 mov	 DWORD PTR ?screen_id@@3HA, edx

; 159  : 
; 160  : 	new_stack_item->displayable = TRUE;

  00082	8b 45 f8	 mov	 eax, DWORD PTR _new_stack_item$[ebp]
  00085	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 161  : 
; 162  : 	// first screen on stack
; 163  : 
; 164  : 	if (!screen_stack_head)

  0008c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A, 0
  00093	75 26		 jne	 SHORT $LN7@ui_push_sc

; 165  : 	{
; 166  : 
; 167  : 		screen_stack_head = new_stack_item;

  00095	8b 45 f8	 mov	 eax, DWORD PTR _new_stack_item$[ebp]
  00098	a3 00 00 00 00	 mov	 DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A, eax

; 168  : 
; 169  : 		screen_stack_tail = new_stack_item;

  0009d	8b 45 f8	 mov	 eax, DWORD PTR _new_stack_item$[ebp]
  000a0	a3 00 00 00 00	 mov	 DWORD PTR ?screen_stack_tail@@3PAUUI_SCREEN_STACK@@A, eax

; 170  : 
; 171  : 		new_stack_item->prev = NULL;

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _new_stack_item$[ebp]
  000a8	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 172  : 
; 173  : 		new_stack_item->next = NULL;

  000af	8b 45 f8	 mov	 eax, DWORD PTR _new_stack_item$[ebp]
  000b2	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 174  : 
; 175  : 		return;

  000b9	eb 41		 jmp	 SHORT $LN1@ui_push_sc
$LN7@ui_push_sc:

; 176  : 	}
; 177  : 
; 178  : 	// add screen to head of stack
; 179  : 
; 180  : 	screen_stack_head->displayable = FALSE;

  000bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A
  000c0	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 181  : 
; 182  : 	new_stack_item->prev = screen_stack_head;

  000c7	8b 45 f8	 mov	 eax, DWORD PTR _new_stack_item$[ebp]
  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A
  000d0	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 183  : 
; 184  : 	screen_stack_head->next = new_stack_item;

  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A
  000d8	8b 4d f8	 mov	 ecx, DWORD PTR _new_stack_item$[ebp]
  000db	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 185  : 
; 186  : 	screen_stack_head = new_stack_item;

  000de	8b 45 f8	 mov	 eax, DWORD PTR _new_stack_item$[ebp]
  000e1	a3 00 00 00 00	 mov	 DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A, eax

; 187  : 
; 188  : 	screen_stack_head->displayable = TRUE;

  000e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A
  000eb	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 189  : 
; 190  : 	new_stack_item->next = NULL;

  000f2	8b 45 f8	 mov	 eax, DWORD PTR _new_stack_item$[ebp]
  000f5	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
$LN1@ui_push_sc:

; 191  : }

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?ui_push_screen@@YGXPAX@Z ENDP				; ui_push_screen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\userint2\ui_draw\uiscreen.c
;	COMDAT ?ui_pop_screen@@YGXXZ
_TEXT	SEGMENT
_popped_screen$ = -4					; size = 4
?ui_pop_screen@@YGXXZ PROC				; ui_pop_screen, COMDAT

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 199  : 
; 200  : 	ui_screen_stack
; 201  : 		*popped_screen;
; 202  : 
; 203  : 	// store screen to pop and unlink it and destroy it.
; 204  : 
; 205  : 	if (screen_stack_head)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A, 0
  00010	74 50		 je	 SHORT $LN1@ui_pop_scr

; 206  : 	{
; 207  : 	
; 208  : 		popped_screen = screen_stack_head;

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A
  00017	89 45 fc	 mov	 DWORD PTR _popped_screen$[ebp], eax

; 209  : 	
; 210  : 		screen_stack_head = screen_stack_head->prev;

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A
  0001f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00022	89 0d 00 00 00
	00		 mov	 DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A, ecx

; 211  : 	
; 212  : 		if (screen_stack_head)

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A, 0
  0002f	74 1a		 je	 SHORT $LN3@ui_pop_scr

; 213  : 		{
; 214  : 
; 215  : 			screen_stack_head->next = NULL;

  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A
  00036	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 216  : 	
; 217  : 			screen_stack_head->displayable = TRUE;

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?screen_stack_head@@3PAUUI_SCREEN_STACK@@A
  00042	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 218  : 		}
; 219  : 		else

  00049	eb 0a		 jmp	 SHORT $LN4@ui_pop_scr
$LN3@ui_pop_scr:

; 220  : 		{
; 221  : 
; 222  : 			// empty stack
; 223  : 
; 224  : 			screen_stack_tail = NULL;

  0004b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?screen_stack_tail@@3PAUUI_SCREEN_STACK@@A, 0
$LN4@ui_pop_scr:

; 225  : 		}
; 226  : 	
; 227  : 		free (popped_screen);

  00055	8b 45 fc	 mov	 eax, DWORD PTR _popped_screen$[ebp]
  00058	50		 push	 eax
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0005f	83 c4 04	 add	 esp, 4
$LN1@ui_pop_scr:

; 228  : 	}
; 229  : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?ui_pop_screen@@YGXXZ ENDP				; ui_pop_screen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1459 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1460 :         #pragma warning(push)
; 1461 :         #pragma warning(disable: 4996) // Deprecation
; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1463 :         #pragma warning(pop)
; 1464 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH
  00035	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00038	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003c	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003e	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00045	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00047	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  0004a	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004d	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1395 :     }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
