; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\modules\system\memory.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?mem_total_value@@3DA				; mem_total_value
_BSS	SEGMENT
?mem_total_value@@3DA DB 01H DUP (?)			; mem_total_value
_BSS	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	?pretouch_memory@@YGXPADH@Z			; pretouch_memory
PUBLIC	?initialise_memory_totals@@YGXXZ		; initialise_memory_totals
PUBLIC	?report_memory_totals@@YGXPAD@Z			; report_memory_totals
PUBLIC	?walk_memory_heap@@YGXXZ			; walk_memory_heap
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0BE@IIKEHNKI@MEMORY?5USED?5?$CFs?5?9?5?$CFd@ ; `string'
PUBLIC	??_C@_0BK@CPBFPNDD@Total?5Physical?5memory?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0BO@GONFPPEO@Physical?5memory?5available?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0BJ@MMHJLNJA@Total?5Virtual?5memory?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0BN@BGNAINDH@Virtual?5memory?5available?3?5?$CFd@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_08CGJDIEAB@heap?4log@			; `string'
PUBLIC	??_C@_04PCNCCNDP@USED@				; `string'
PUBLIC	??_C@_04HEDFJGEJ@FREE@				; `string'
PUBLIC	??_C@_0BM@DDMAEFOG@?$CFs?5block?5at?5?$CFFp?5of?5size?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BC@CNLHFBDB@OK?5?9?5end?5of?5heap?6@	; `string'
PUBLIC	??_C@_0BE@BAKCFFFH@OK?5?9?5heap?5is?5empty?6@	; `string'
PUBLIC	??_C@_0BJ@MOAKDHNF@ERROR?5?9?5heap?5is?5damaged?6@ ; `string'
PUBLIC	??_C@_0BN@FFPPJOKG@ERROR?5?9?5bad?5pointer?5to?5heap?6@ ; `string'
PUBLIC	??_C@_0BK@LDBJAAHN@ERROR?5?9?5bad?5node?5in?5heap?6@ ; `string'
PUBLIC	??_C@_0BM@IKGODKJK@Total?5memory_allocated?5?$DN?5?$CFd@ ; `string'
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp___heapwalk:PROC
EXTRN	__imp__GlobalMemoryStatus@4:PROC
EXTRN	?debug_log@@YAXPBDZZ:PROC			; debug_log
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

?initial_total_memory_available@@3KA DD 01H DUP (?)	; initial_total_memory_available
_BSS	ENDS
;	COMDAT ??_C@_0BM@IKGODKJK@Total?5memory_allocated?5?$DN?5?$CFd@
CONST	SEGMENT
??_C@_0BM@IKGODKJK@Total?5memory_allocated?5?$DN?5?$CFd@ DB 'Total memory'
	DB	'_allocated = %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LDBJAAHN@ERROR?5?9?5bad?5node?5in?5heap?6@
CONST	SEGMENT
??_C@_0BK@LDBJAAHN@ERROR?5?9?5bad?5node?5in?5heap?6@ DB 'ERROR - bad node'
	DB	' in heap', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FFPPJOKG@ERROR?5?9?5bad?5pointer?5to?5heap?6@
CONST	SEGMENT
??_C@_0BN@FFPPJOKG@ERROR?5?9?5bad?5pointer?5to?5heap?6@ DB 'ERROR - bad p'
	DB	'ointer to heap', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MOAKDHNF@ERROR?5?9?5heap?5is?5damaged?6@
CONST	SEGMENT
??_C@_0BJ@MOAKDHNF@ERROR?5?9?5heap?5is?5damaged?6@ DB 'ERROR - heap is da'
	DB	'maged', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BAKCFFFH@OK?5?9?5heap?5is?5empty?6@
CONST	SEGMENT
??_C@_0BE@BAKCFFFH@OK?5?9?5heap?5is?5empty?6@ DB 'OK - heap is empty', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CNLHFBDB@OK?5?9?5end?5of?5heap?6@
CONST	SEGMENT
??_C@_0BC@CNLHFBDB@OK?5?9?5end?5of?5heap?6@ DB 'OK - end of heap', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DDMAEFOG@?$CFs?5block?5at?5?$CFFp?5of?5size?5?$CFd?6@
CONST	SEGMENT
??_C@_0BM@DDMAEFOG@?$CFs?5block?5at?5?$CFFp?5of?5size?5?$CFd?6@ DB '%s bl'
	DB	'ock at %Fp of size %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HEDFJGEJ@FREE@
CONST	SEGMENT
??_C@_04HEDFJGEJ@FREE@ DB 'FREE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCNCCNDP@USED@
CONST	SEGMENT
??_C@_04PCNCCNDP@USED@ DB 'USED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08CGJDIEAB@heap?4log@
CONST	SEGMENT
??_C@_08CGJDIEAB@heap?4log@ DB 'heap.log', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BGNAINDH@Virtual?5memory?5available?3?5?$CFd@
CONST	SEGMENT
??_C@_0BN@BGNAINDH@Virtual?5memory?5available?3?5?$CFd@ DB 'Virtual memor'
	DB	'y available: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MMHJLNJA@Total?5Virtual?5memory?3?5?$CFd@
CONST	SEGMENT
??_C@_0BJ@MMHJLNJA@Total?5Virtual?5memory?3?5?$CFd@ DB 'Total Virtual mem'
	DB	'ory: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GONFPPEO@Physical?5memory?5available?3?5?$CFd@
CONST	SEGMENT
??_C@_0BO@GONFPPEO@Physical?5memory?5available?3?5?$CFd@ DB 'Physical mem'
	DB	'ory available: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CPBFPNDD@Total?5Physical?5memory?3?5?$CFd@
CONST	SEGMENT
??_C@_0BK@CPBFPNDD@Total?5Physical?5memory?3?5?$CFd@ DB 'Total Physical m'
	DB	'emory: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IIKEHNKI@MEMORY?5USED?5?$CFs?5?9?5?$CFd@
CONST	SEGMENT
??_C@_0BE@IIKEHNKI@MEMORY?5USED?5?$CFs?5?9?5?$CFd@ DB 'MEMORY USED %s - %'
	DB	'd', 00H					; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memory.c
;	COMDAT ?walk_memory_heap@@YGXXZ
_TEXT	SEGMENT
tv80 = -92						; size = 4
tv75 = -92						; size = 4
_fp$ = -24						; size = 4
_memory_allocated$ = -20				; size = 4
_heap_status$ = -16					; size = 4
_heap$ = -12						; size = 12
?walk_memory_heap@@YGXXZ PROC				; walk_memory_heap, COMDAT

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 208  : 
; 209  : #ifdef WIN32
; 210  : 	struct _heapinfo
; 211  : 		heap;
; 212  : #endif
; 213  : 
; 214  : 	int
; 215  : 		heap_status;
; 216  : 
; 217  : 	long
; 218  : 		memory_allocated;
; 219  : 
; 220  : 	FILE
; 221  : 		*fp;
; 222  : 
; 223  : 	fp = fopen ( "heap.log", "w" );

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w@
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_08CGJDIEAB@heap?4log@
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00019	83 c4 08	 add	 esp, 8
  0001c	89 45 e8	 mov	 DWORD PTR _fp$[ebp], eax

; 224  : 
; 225  : 	memory_allocated = 0;;

  0001f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _memory_allocated$[ebp], 0

; 226  : 
; 227  : 	if ( fp )

  00026	83 7d e8 00	 cmp	 DWORD PTR _fp$[ebp], 0
  0002a	0f 84 01 01 00
	00		 je	 $LN1@walk_memor

; 228  : 	{
; 229  : 	
; 230  : #ifdef WIN32
; 231  : 		heap._pentry = NULL;

  00030	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _heap$[ebp], 0
$LN4@walk_memor:

; 232  : 	
; 233  : 		for(;;)
; 234  : 		{
; 235  : 	
; 236  : 			heap_status = _heapwalk( &heap );

  00037	8d 45 f4	 lea	 eax, DWORD PTR _heap$[ebp]
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___heapwalk
  00041	83 c4 04	 add	 esp, 4
  00044	89 45 f0	 mov	 DWORD PTR _heap_status$[ebp], eax

; 237  : 
; 238  : #ifdef _HEAPOK
; 239  : 
; 240  : 			if ( heap_status != _HEAPOK )

  00047	83 7d f0 fe	 cmp	 DWORD PTR _heap_status$[ebp], -2 ; fffffffeH
  0004b	74 02		 je	 SHORT $LN8@walk_memor

; 241  : 
; 242  : #else
; 243  : 
; 244  : 			if ( !heap_status )
; 245  : 
; 246  : #endif
; 247  : 
; 248  : 				break;

  0004d	eb 44		 jmp	 SHORT $LN3@walk_memor
$LN8@walk_memor:

; 249  : 	
; 250  : 			fprintf ( fp, "%s block at %Fp of size %d\n", ( heap._useflag == _USEDENTRY ? "USED" : "FREE" ), heap._pentry, heap._size );

  0004f	83 7d fc 01	 cmp	 DWORD PTR _heap$[ebp+8], 1
  00053	75 09		 jne	 SHORT $LN16@walk_memor
  00055	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], OFFSET ??_C@_04PCNCCNDP@USED@
  0005c	eb 07		 jmp	 SHORT $LN17@walk_memor
$LN16@walk_memor:
  0005e	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], OFFSET ??_C@_04HEDFJGEJ@FREE@
$LN17@walk_memor:
  00065	8b 45 f8	 mov	 eax, DWORD PTR _heap$[ebp+4]
  00068	50		 push	 eax
  00069	8b 4d f4	 mov	 ecx, DWORD PTR _heap$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 55 a4	 mov	 edx, DWORD PTR tv75[ebp]
  00070	52		 push	 edx
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DDMAEFOG@?$CFs?5block?5at?5?$CFFp?5of?5size?5?$CFd?6@
  00076	8b 45 e8	 mov	 eax, DWORD PTR _fp$[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 _fprintf
  0007f	83 c4 14	 add	 esp, 20			; 00000014H

; 251  : 
; 252  : 			if ( heap._useflag == _USEDENTRY )

  00082	83 7d fc 01	 cmp	 DWORD PTR _heap$[ebp+8], 1
  00086	75 09		 jne	 SHORT $LN9@walk_memor

; 253  : 			{
; 254  : 
; 255  : 				memory_allocated += heap._size;

  00088	8b 45 ec	 mov	 eax, DWORD PTR _memory_allocated$[ebp]
  0008b	03 45 f8	 add	 eax, DWORD PTR _heap$[ebp+4]
  0008e	89 45 ec	 mov	 DWORD PTR _memory_allocated$[ebp], eax
$LN9@walk_memor:

; 256  : 			}
; 257  : 		}

  00091	eb a4		 jmp	 SHORT $LN4@walk_memor
$LN3@walk_memor:

; 258  : 		
; 259  : #ifdef _HEAPOK
; 260  : 
; 261  : 		switch ( heap_status )

  00093	8b 45 f0	 mov	 eax, DWORD PTR _heap_status$[ebp]
  00096	89 45 a4	 mov	 DWORD PTR tv80[ebp], eax
  00099	8b 4d a4	 mov	 ecx, DWORD PTR tv80[ebp]
  0009c	83 c1 06	 add	 ecx, 6
  0009f	89 4d a4	 mov	 DWORD PTR tv80[ebp], ecx
  000a2	83 7d a4 05	 cmp	 DWORD PTR tv80[ebp], 5
  000a6	77 67		 ja	 SHORT $LN5@walk_memor
  000a8	8b 55 a4	 mov	 edx, DWORD PTR tv80[ebp]
  000ab	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN18@walk_memor[edx*4]
$LN10@walk_memor:

; 262  : 		{
; 263  : 	
; 264  : 			case _HEAPEND:
; 265  : 			{
; 266  : 		
; 267  : 				fprintf ( fp, "OK - end of heap\n" );

  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CNLHFBDB@OK?5?9?5end?5of?5heap?6@
  000b7	8b 45 e8	 mov	 eax, DWORD PTR _fp$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _fprintf
  000c0	83 c4 08	 add	 esp, 8

; 268  : 	
; 269  : 				break;

  000c3	eb 4a		 jmp	 SHORT $LN5@walk_memor
$LN11@walk_memor:

; 270  : 			}
; 271  : 			case _HEAPEMPTY:
; 272  : 			{
; 273  : 	
; 274  : 				fprintf ( fp, "OK - heap is empty\n" );

  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BAKCFFFH@OK?5?9?5heap?5is?5empty?6@
  000ca	8b 45 e8	 mov	 eax, DWORD PTR _fp$[ebp]
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 _fprintf
  000d3	83 c4 08	 add	 esp, 8

; 275  : 	
; 276  : 				break;

  000d6	eb 37		 jmp	 SHORT $LN5@walk_memor
$LN12@walk_memor:

; 277  : 			}
; 278  : 			case _HEAPBADBEGIN:
; 279  : 			{
; 280  : 	
; 281  : 				fprintf ( fp, "ERROR - heap is damaged\n" );

  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@MOAKDHNF@ERROR?5?9?5heap?5is?5damaged?6@
  000dd	8b 45 e8	 mov	 eax, DWORD PTR _fp$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _fprintf
  000e6	83 c4 08	 add	 esp, 8

; 282  : 	
; 283  : 				break;

  000e9	eb 24		 jmp	 SHORT $LN5@walk_memor
$LN13@walk_memor:

; 284  : 			}
; 285  : 			case _HEAPBADPTR:
; 286  : 			{
; 287  : 	
; 288  : 				fprintf ( fp, "ERROR - bad pointer to heap\n" );

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@FFPPJOKG@ERROR?5?9?5bad?5pointer?5to?5heap?6@
  000f0	8b 45 e8	 mov	 eax, DWORD PTR _fp$[ebp]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 _fprintf
  000f9	83 c4 08	 add	 esp, 8

; 289  : 	
; 290  : 				break;

  000fc	eb 11		 jmp	 SHORT $LN5@walk_memor
$LN14@walk_memor:

; 291  : 			}
; 292  : 			case _HEAPBADNODE:
; 293  : 			{
; 294  : 	
; 295  : 				fprintf ( fp, "ERROR - bad node in heap\n" );

  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@LDBJAAHN@ERROR?5?9?5bad?5node?5in?5heap?6@
  00103	8b 45 e8	 mov	 eax, DWORD PTR _fp$[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 _fprintf
  0010c	83 c4 08	 add	 esp, 8
$LN5@walk_memor:

; 296  : 	
; 297  : 				break;
; 298  : 			}
; 299  : 		}
; 300  : 
; 301  : #endif
; 302  : 
; 303  : 		fprintf ( fp, "Total memory_allocated = %d", memory_allocated );

  0010f	8b 45 ec	 mov	 eax, DWORD PTR _memory_allocated$[ebp]
  00112	50		 push	 eax
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IKGODKJK@Total?5memory_allocated?5?$DN?5?$CFd@
  00118	8b 4d e8	 mov	 ecx, DWORD PTR _fp$[ebp]
  0011b	51		 push	 ecx
  0011c	e8 00 00 00 00	 call	 _fprintf
  00121	83 c4 0c	 add	 esp, 12			; 0000000cH

; 304  : #else
; 305  : 		// TODO: implement on non-win32
; 306  : 		fprintf ( fp, "TODO: implement walk_memory_heap() on non-win32.\n" );
; 307  : #endif
; 308  : 
; 309  : 		fclose ( fp );

  00124	8b 45 e8	 mov	 eax, DWORD PTR _fp$[ebp]
  00127	50		 push	 eax
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0012e	83 c4 04	 add	 esp, 4
$LN1@walk_memor:

; 310  : 	}
; 311  : 	
; 312  : }

  00131	5f		 pop	 edi
  00132	5e		 pop	 esi
  00133	5b		 pop	 ebx
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c3		 ret	 0
$LN18@walk_memor:
  00138	00 00 00 00	 DD	 $LN13@walk_memor
  0013c	00 00 00 00	 DD	 $LN10@walk_memor
  00140	00 00 00 00	 DD	 $LN14@walk_memor
  00144	00 00 00 00	 DD	 $LN12@walk_memor
  00148	00 00 00 00	 DD	 $LN5@walk_memor
  0014c	00 00 00 00	 DD	 $LN11@walk_memor
?walk_memory_heap@@YGXXZ ENDP				; walk_memory_heap
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memory.c
;	COMDAT ?report_memory_totals@@YGXPAD@Z
_TEXT	SEGMENT
_total_memory_available$ = -44				; size = 4
_virtual_memory_available$ = -40			; size = 4
_physical_memory_available$ = -36			; size = 4
_status$ = -32						; size = 32
_string$ = 8						; size = 4
?report_memory_totals@@YGXPAD@Z PROC			; report_memory_totals, COMDAT

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 150  : 
; 151  : #ifdef WIN32
; 152  : 	MEMORYSTATUS
; 153  : 		status;
; 154  : 
; 155  : 	int
; 156  : 		physical_memory_available,
; 157  : 		virtual_memory_available,
; 158  : 		total_memory_available;
; 159  : 
; 160  : 	status.dwLength = sizeof ( status );

  00009	c7 45 e0 20 00
	00 00		 mov	 DWORD PTR _status$[ebp], 32 ; 00000020H

; 161  : 
; 162  : 	GlobalMemoryStatus ( &status );

  00010	8d 45 e0	 lea	 eax, DWORD PTR _status$[ebp]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalMemoryStatus@4

; 163  : 
; 164  : 	physical_memory_available = status.dwTotalPhys - status.dwAvailPhys;

  0001a	8b 45 e8	 mov	 eax, DWORD PTR _status$[ebp+8]
  0001d	2b 45 ec	 sub	 eax, DWORD PTR _status$[ebp+12]
  00020	89 45 dc	 mov	 DWORD PTR _physical_memory_available$[ebp], eax

; 165  : 
; 166  : 	virtual_memory_available = status.dwTotalPageFile - status.dwAvailPageFile;

  00023	8b 45 f0	 mov	 eax, DWORD PTR _status$[ebp+16]
  00026	2b 45 f4	 sub	 eax, DWORD PTR _status$[ebp+20]
  00029	89 45 d8	 mov	 DWORD PTR _virtual_memory_available$[ebp], eax

; 167  : 
; 168  : 	total_memory_available = physical_memory_available + virtual_memory_available;

  0002c	8b 45 dc	 mov	 eax, DWORD PTR _physical_memory_available$[ebp]
  0002f	03 45 d8	 add	 eax, DWORD PTR _virtual_memory_available$[ebp]
  00032	89 45 d4	 mov	 DWORD PTR _total_memory_available$[ebp], eax

; 169  : 
; 170  : 	debug_log ( "MEMORY USED %s - %d", string, total_memory_available - initial_total_memory_available );

  00035	8b 45 d4	 mov	 eax, DWORD PTR _total_memory_available$[ebp]
  00038	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?initial_total_memory_available@@3KA
  0003e	50		 push	 eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00042	51		 push	 ecx
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@IIKEHNKI@MEMORY?5USED?5?$CFs?5?9?5?$CFd@
  00048	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 171  : 	debug_log ( "Total Physical memory: %d", status.dwTotalPhys );

  00050	8b 45 e8	 mov	 eax, DWORD PTR _status$[ebp+8]
  00053	50		 push	 eax
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CPBFPNDD@Total?5Physical?5memory?3?5?$CFd@
  00059	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0005e	83 c4 08	 add	 esp, 8

; 172  : 	debug_log ( "Physical memory available: %d", status.dwAvailPhys );

  00061	8b 45 ec	 mov	 eax, DWORD PTR _status$[ebp+12]
  00064	50		 push	 eax
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GONFPPEO@Physical?5memory?5available?3?5?$CFd@
  0006a	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  0006f	83 c4 08	 add	 esp, 8

; 173  : 
; 174  : 	debug_log ( "Total Virtual memory: %d", status.dwTotalPageFile );

  00072	8b 45 f0	 mov	 eax, DWORD PTR _status$[ebp+16]
  00075	50		 push	 eax
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@MMHJLNJA@Total?5Virtual?5memory?3?5?$CFd@
  0007b	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00080	83 c4 08	 add	 esp, 8

; 175  : 	debug_log ( "Virtual memory available: %d", status.dwAvailPageFile );

  00083	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp+20]
  00086	50		 push	 eax
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@BGNAINDH@Virtual?5memory?5available?3?5?$CFd@
  0008c	e8 00 00 00 00	 call	 ?debug_log@@YAXPBDZZ	; debug_log
  00091	83 c4 08	 add	 esp, 8

; 176  : 
; 177  : #elif LINUX
; 178  : 
; 179  : 	// NOTE: This requires the new sysinfo structure only available in Linux 2.3.23 (i386), 2.3.48 (all architectures)
; 180  : 
; 181  : 	struct sysinfo sinfo;
; 182  : 
; 183  : 	if( sysinfo( &sinfo ) == 0 ) {
; 184  : 		debug_log ( "MEMORY USED %s - %d", string, sinfo.freeram - initial_total_memory_available );
; 185  : 
; 186  : 		debug_log ( "Total Physical memory: %d", sinfo.totalhigh );
; 187  : 		debug_log ( "Physical memory available: %d", sinfo.freehigh );
; 188  : 		
; 189  : 		debug_log ( "Total Virtual memory: %d", sinfo.totalswap );
; 190  : 		debug_log ( "Virtual memory available: %d", sinfo.freeswap );
; 191  : 	}
; 192  : 	else {
; 193  : 		debug_log("sysinfo(2) call failed: %s\n", strerror(errno));
; 194  : 	}
; 195  : 
; 196  : #else
; 197  : 	// TODO: implement on non-win32
; 198  : 	debug_log ( "TODO: implement report_memory_totals(char *) on non-win32.") ;
; 199  : #endif
; 200  : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 04 00	 ret	 4
?report_memory_totals@@YGXPAD@Z ENDP			; report_memory_totals
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memory.c
;	COMDAT ?initialise_memory_totals@@YGXXZ
_TEXT	SEGMENT
_virtual_memory_available$ = -40			; size = 4
_physical_memory_available$ = -36			; size = 4
_status$ = -32						; size = 32
?initialise_memory_totals@@YGXXZ PROC			; initialise_memory_totals, COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 108  : 
; 109  : #ifdef WIN32
; 110  : 	MEMORYSTATUS
; 111  : 		status;
; 112  : 
; 113  : 	int
; 114  : 		physical_memory_available,
; 115  : 		virtual_memory_available;
; 116  : 
; 117  : 	status.dwLength = sizeof ( status );

  00009	c7 45 e0 20 00
	00 00		 mov	 DWORD PTR _status$[ebp], 32 ; 00000020H

; 118  : 
; 119  : 	GlobalMemoryStatus ( &status );

  00010	8d 45 e0	 lea	 eax, DWORD PTR _status$[ebp]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalMemoryStatus@4

; 120  : 
; 121  : 	physical_memory_available = status.dwTotalPhys - status.dwAvailPhys;

  0001a	8b 45 e8	 mov	 eax, DWORD PTR _status$[ebp+8]
  0001d	2b 45 ec	 sub	 eax, DWORD PTR _status$[ebp+12]
  00020	89 45 dc	 mov	 DWORD PTR _physical_memory_available$[ebp], eax

; 122  : 
; 123  : 	virtual_memory_available = status.dwTotalPageFile - status.dwAvailPageFile;

  00023	8b 45 f0	 mov	 eax, DWORD PTR _status$[ebp+16]
  00026	2b 45 f4	 sub	 eax, DWORD PTR _status$[ebp+20]
  00029	89 45 d8	 mov	 DWORD PTR _virtual_memory_available$[ebp], eax

; 124  : 
; 125  : 	initial_total_memory_available = physical_memory_available + virtual_memory_available;

  0002c	8b 45 dc	 mov	 eax, DWORD PTR _physical_memory_available$[ebp]
  0002f	03 45 d8	 add	 eax, DWORD PTR _virtual_memory_available$[ebp]
  00032	a3 00 00 00 00	 mov	 DWORD PTR ?initial_total_memory_available@@3KA, eax

; 126  : 
; 127  : #elif LINUX
; 128  : 
; 129  : 	struct sysinfo sinfo;
; 130  : 
; 131  : 	if( sysinfo( &sinfo ) == 0 ) {
; 132  : 		initial_total_memory_available = sinfo.freeram;
; 133  : 	}
; 134  : 	else {
; 135  : 		debug_log("sysinfo(2) call failed: %s\n", strerror(errno));
; 136  : 	}
; 137  : 
; 138  : #else
; 139  : 	// TODO: Implement for operating systems that aren't Linux or Windows
; 140  : 	debug_log ( "TODO: implement initialise_memory_totals() on this platform.") ;
; 141  : #endif
; 142  : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?initialise_memory_totals@@YGXXZ ENDP			; initialise_memory_totals
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\modules\system\memory.c
;	COMDAT ?pretouch_memory@@YGXPADH@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_memory$ = 8						; size = 4
_size$ = 12						; size = 4
?pretouch_memory@@YGXPADH@Z PROC			; pretouch_memory, COMDAT

; 86   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 
; 88   : 	int
; 89   : 		count;
; 90   : 
; 91   : 	mem_total_value = 0;

  00009	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?mem_total_value@@3DA, 0 ; mem_total_value

; 92   : 
; 93   : 	for ( count = 0; count < size; count += 2048 )

  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00017	eb 0b		 jmp	 SHORT $LN4@pretouch_m
$LN2@pretouch_m:
  00019	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0001c	05 00 08 00 00	 add	 eax, 2048		; 00000800H
  00021	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@pretouch_m:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00027	3b 45 0c	 cmp	 eax, DWORD PTR _size$[ebp]
  0002a	7d 22		 jge	 SHORT $LN1@pretouch_m

; 94   : 	{
; 95   : 
; 96   : 		mem_total_value += *memory;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _memory$[ebp]
  0002f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00032	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?mem_total_value@@3DA ; mem_total_value
  00039	03 d1		 add	 edx, ecx
  0003b	88 15 00 00 00
	00		 mov	 BYTE PTR ?mem_total_value@@3DA, dl ; mem_total_value

; 97   : 
; 98   : 		memory += 2048;

  00041	8b 45 08	 mov	 eax, DWORD PTR _memory$[ebp]
  00044	05 00 08 00 00	 add	 eax, 2048		; 00000800H
  00049	89 45 08	 mov	 DWORD PTR _memory$[ebp], eax

; 99   : 	}

  0004c	eb cb		 jmp	 SHORT $LN2@pretouch_m
$LN1@pretouch_m:

; 100  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
?pretouch_memory@@YGXPADH@Z ENDP			; pretouch_memory
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Stream$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vfprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 842  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	51		 push	 ecx
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	52		 push	 edx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  0002b	83 c4 18	 add	 esp, 24			; 00000018H

; 644  :     }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
