; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\nhv90\Projects\eech\aphavoc\source\ai\faction\routegen.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?number_of_route_waypoint_positions@@3HA	; number_of_route_waypoint_positions
PUBLIC	?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
PUBLIC	?waypoint_nodes@@3PAUWAYPOINT_NODE@@A		; waypoint_nodes
PUBLIC	?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A ; waypoint_starting_nodes
PUBLIC	?number_of_waypoint_nodes@@3HA			; number_of_waypoint_nodes
PUBLIC	?number_of_waypoint_starting_nodes@@3HA		; number_of_waypoint_starting_nodes
_BSS	SEGMENT
?number_of_route_waypoint_positions@@3HA DD 01H DUP (?)	; number_of_route_waypoint_positions
?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A DD 01H DUP (?) ; route_waypoint_positions
?waypoint_nodes@@3PAUWAYPOINT_NODE@@A DB 02e800H DUP (?) ; waypoint_nodes
?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A DD 018H DUP (?) ; waypoint_starting_nodes
?number_of_waypoint_nodes@@3HA DD 01H DUP (?)		; number_of_waypoint_nodes
?number_of_waypoint_starting_nodes@@3HA DD 01H DUP (?)	; number_of_waypoint_starting_nodes
_BSS	ENDS
PUBLIC	_fabsf
PUBLIC	_sqrtf
PUBLIC	?fabs@@YGMM@Z					; fabs
PUBLIC	?sqrt@@YGMM@Z					; sqrt
PUBLIC	?destroy_routegen_waypoint_routes@@YGXXZ	; destroy_routegen_waypoint_routes
PUBLIC	?parse_waypoint_routes_from_object@@YGXHHPAUVEC3D@@@Z ; parse_waypoint_routes_from_object
PUBLIC	?get_number_of_nodes_at_depth@@YGHH@Z		; get_number_of_nodes_at_depth
PUBLIC	?get_waypoint_node_child_index@@YGHPAUWAYPOINT_NODE@@0@Z ; get_waypoint_node_child_index
PUBLIC	??$max@M@std@@YGABMABM0@Z			; std::max<float>
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	?__LINE__Var@?0??parse_waypoint_routes_from_object@@YGXHHPAUVEC3D@@@Z@4JA ; `parse_waypoint_routes_from_object'::`1'::__LINE__Var
PUBLIC	??_C@_0EC@BMNFJBIG@c?3?2users?2nhv90?2projects?2eech?2ap@ ; `string'
PUBLIC	??_C@_0CO@EHFGCHFB@number_of_waypoint_nodes?5?$DM?5MAX_@ ; `string'
PUBLIC	??_C@_0DK@EFLHHJMA@?$CBobjects_3d_data?$FLobject_index?$FN?4@ ; `string'
PUBLIC	??_C@_0DI@JHDKHNDO@number_of_waypoint_starting_nod@ ; `string'
PUBLIC	??_C@_0DC@DIGGGCM@Unable?5to?5find?5child?5pointer?5on@ ; `string'
PUBLIC	?__LINE__Var@?0??swap_waypoint_nodes@@YGXHH@Z@4JA ; `swap_waypoint_nodes'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@HMNIMLNH@Run?5out?5of?5tree?$CB@	; `string'
PUBLIC	??_C@_0DA@OOFCHPBB@child_index?5?$DM?5number_of_waypoin@ ; `string'
PUBLIC	??_C@_0DG@HCOBEKGM@other_child_index?5?$DM?5number_of_w@ ; `string'
PUBLIC	??_C@_0BD@FEEMDEPI@invalid?5comparator@		; `string'
PUBLIC	??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@ ; `string'
PUBLIC	??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ ; `string'
PUBLIC	__real@4008000000000000
PUBLIC	__real@46fffe00
EXTRN	__imp___invalid_parameter:PROC
EXTRN	_memset:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	_fabs:PROC
EXTRN	_sqrt:PROC
EXTRN	?process_assert@@YGXPBD0H@Z:PROC		; process_assert
EXTRN	?debug_fatal@@YAXPBDZZ:PROC			; debug_fatal
EXTRN	?safe_malloc_memory@@YGPAXI@Z:PROC		; safe_malloc_memory
EXTRN	?safe_free@@YGXPAX@Z:PROC			; safe_free
EXTRN	?objects_3d_data@@3PAUOBJECT_3D@@A:DWORD	; objects_3d_data
EXTRN	__fltused:DWORD
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
CONST	SEGMENT
??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@
CONST	SEGMENT
??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@ DB 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'm', 00H, 'a', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 'l', 00H
	DB	'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\algorithm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FEEMDEPI@invalid?5comparator@
CONST	SEGMENT
??_C@_0BD@FEEMDEPI@invalid?5comparator@ DB 'invalid comparator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HCOBEKGM@other_child_index?5?$DM?5number_of_w@
CONST	SEGMENT
??_C@_0DG@HCOBEKGM@other_child_index?5?$DM?5number_of_w@ DB 'other_child_'
	DB	'index < number_of_waypoint_starting_nodes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OOFCHPBB@child_index?5?$DM?5number_of_waypoin@
CONST	SEGMENT
??_C@_0DA@OOFCHPBB@child_index?5?$DM?5number_of_waypoin@ DB 'child_index '
	DB	'< number_of_waypoint_starting_nodes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HMNIMLNH@Run?5out?5of?5tree?$CB@
CONST	SEGMENT
??_C@_0BB@HMNIMLNH@Run?5out?5of?5tree?$CB@ DB 'Run out of tree!', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??swap_waypoint_nodes@@YGXHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??swap_waypoint_nodes@@YGXHH@Z@4JA DD 0420H ; `swap_waypoint_nodes'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DC@DIGGGCM@Unable?5to?5find?5child?5pointer?5on@
CONST	SEGMENT
??_C@_0DC@DIGGGCM@Unable?5to?5find?5child?5pointer?5on@ DB 'Unable to fin'
	DB	'd child pointer on parent route node', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@JHDKHNDO@number_of_waypoint_starting_nod@
CONST	SEGMENT
??_C@_0DI@JHDKHNDO@number_of_waypoint_starting_nod@ DB 'number_of_waypoin'
	DB	't_starting_nodes < MAX_WAYPOINT_STARTS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EFLHHJMA@?$CBobjects_3d_data?$FLobject_index?$FN?4@
CONST	SEGMENT
??_C@_0DK@EFLHHJMA@?$CBobjects_3d_data?$FLobject_index?$FN?4@ DB '!object'
	DB	's_3d_data[object_index].surfaces[surface].polygons', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@EHFGCHFB@number_of_waypoint_nodes?5?$DM?5MAX_@
CONST	SEGMENT
??_C@_0CO@EHFGCHFB@number_of_waypoint_nodes?5?$DM?5MAX_@ DB 'number_of_wa'
	DB	'ypoint_nodes < MAX_WAYPOINT_NODES', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@BMNFJBIG@c?3?2users?2nhv90?2projects?2eech?2ap@
CONST	SEGMENT
??_C@_0EC@BMNFJBIG@c?3?2users?2nhv90?2projects?2eech?2ap@ DB 'c:\users\nh'
	DB	'v90\projects\eech\aphavoc\source\ai\faction\routegen.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??parse_waypoint_routes_from_object@@YGXHHPAUVEC3D@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??parse_waypoint_routes_from_object@@YGXHHPAUVEC3D@@@Z@4JA DD 0bfH ; `parse_waypoint_routes_from_object'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
;	COMDAT ??$max@M@std@@YGABMABM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@M@std@@YGABMABM0@Z PROC				; std::max<float>, COMDAT

; 5387 : 	{	// return larger of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5388 : 	if (_Left < _Right)

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00013	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00016	76 64		 jbe	 SHORT $LN8@max
$LN4@max:

; 5389 : 		{
; 5390 : 		_STL_ASSERT(!(_Right < _Left), "invalid comparator");

  00018	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00022	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00025	77 02		 ja	 SHORT $LN9@max
  00027	eb 4a		 jmp	 SHORT $LN6@max
$LN9@max:
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FEEMDEPI@invalid?5comparator@
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00033	6a 00		 push	 0
  00035	68 0e 15 00 00	 push	 5390			; 0000150eH
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  0003f	6a 02		 push	 2
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00047	83 c4 18	 add	 esp, 24			; 00000018H
  0004a	83 f8 01	 cmp	 eax, 1
  0004d	75 01		 jne	 SHORT $LN12@max
  0004f	cc		 int	 3
$LN12@max:
  00050	6a 00		 push	 0
  00052	68 0e 15 00 00	 push	 5390			; 0000150eH
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0006c	83 c4 14	 add	 esp, 20			; 00000014H
  0006f	33 c0		 xor	 eax, eax
  00071	75 b6		 jne	 SHORT $LN9@max
$LN6@max:
  00073	33 c0		 xor	 eax, eax
  00075	75 a1		 jne	 SHORT $LN4@max

; 5391 : 		return (_Right);

  00077	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0007a	eb 03		 jmp	 SHORT $LN1@max
$LN8@max:

; 5392 : 		}
; 5393 : 
; 5394 : 	return (_Left);

  0007c	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
$LN1@max:

; 5395 : 	}

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
??$max@M@std@@YGABMABM0@Z ENDP				; std::max<float>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\ai\faction\routegen.c
;	COMDAT ?swap_waypoint_nodes@@YGXHH@Z
_TEXT	SEGMENT
_this_node$1 = -32					; size = 4
_common_parent$ = -28					; size = 4
_other_child$ = -24					; size = 4
_child$ = -20						; size = 4
_other_child_index$ = -16				; size = 4
_child_index$ = -12					; size = 4
_count$ = -8						; size = 4
_found$ = -4						; size = 4
_node$ = 8						; size = 4
_other_node$ = 12					; size = 4
?swap_waypoint_nodes@@YGXHH@Z PROC			; swap_waypoint_nodes, COMDAT

; 1056 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1057 : 
; 1058 : 	int
; 1059 : 		found,
; 1060 : 		count,
; 1061 : 		child_index,
; 1062 : 		other_child_index;
; 1063 : 
; 1064 : 	waypoint_node
; 1065 : 		*child,
; 1066 : 		*other_child,
; 1067 : 		*common_parent;
; 1068 : 
; 1069 : 	//
; 1070 : 	// Find the common parent of these two nodes.
; 1071 : 	//
; 1072 : 
; 1073 : 	found = FALSE;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _found$[ebp], 0

; 1074 : 
; 1075 : 	child = &waypoint_nodes[node];

  00010	69 45 08 f8 00
	00 00		 imul	 eax, DWORD PTR _node$[ebp], 248
  00017	05 00 00 00 00	 add	 eax, OFFSET ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A ; waypoint_nodes
  0001c	89 45 ec	 mov	 DWORD PTR _child$[ebp], eax

; 1076 : 
; 1077 : 	other_child = &waypoint_nodes[other_node];

  0001f	69 45 0c f8 00
	00 00		 imul	 eax, DWORD PTR _other_node$[ebp], 248
  00026	05 00 00 00 00	 add	 eax, OFFSET ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A ; waypoint_nodes
  0002b	89 45 e8	 mov	 DWORD PTR _other_child$[ebp], eax

; 1078 : 
; 1079 : 	common_parent = NULL;

  0002e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _common_parent$[ebp], 0
$LN2@swap_waypo:

; 1080 : 
; 1081 : 	while ( !found )

  00035	83 7d fc 00	 cmp	 DWORD PTR _found$[ebp], 0
  00039	75 7a		 jne	 SHORT $LN3@swap_waypo

; 1082 : 	{
; 1083 : 
; 1084 : 		if ( ( !child ) || ( !other_child ) )

  0003b	83 7d ec 00	 cmp	 DWORD PTR _child$[ebp], 0
  0003f	74 06		 je	 SHORT $LN25@swap_waypo
  00041	83 7d e8 00	 cmp	 DWORD PTR _other_child$[ebp], 0
  00045	75 0d		 jne	 SHORT $LN24@swap_waypo
$LN25@swap_waypo:

; 1085 : 		{
; 1086 : 
; 1087 : 			debug_fatal ( "Run out of tree!" );

  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HMNIMLNH@Run?5out?5of?5tree?$CB@
  0004c	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  00051	83 c4 04	 add	 esp, 4
$LN24@swap_waypo:

; 1088 : 		}
; 1089 : 
; 1090 : 		if ( child->parents[0] == other_child->parents[0] )

  00054	b8 04 00 00 00	 mov	 eax, 4
  00059	6b c8 00	 imul	 ecx, eax, 0
  0005c	ba 04 00 00 00	 mov	 edx, 4
  00061	6b c2 00	 imul	 eax, edx, 0
  00064	8b 55 ec	 mov	 edx, DWORD PTR _child$[ebp]
  00067	8b 75 e8	 mov	 esi, DWORD PTR _other_child$[ebp]
  0006a	8b 4c 0a 38	 mov	 ecx, DWORD PTR [edx+ecx+56]
  0006e	3b 4c 06 38	 cmp	 ecx, DWORD PTR [esi+eax+56]
  00072	75 1b		 jne	 SHORT $LN26@swap_waypo

; 1091 : 		{
; 1092 : 
; 1093 : 			found = TRUE;

  00074	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _found$[ebp], 1

; 1094 : 
; 1095 : 			common_parent = child->parents[0];

  0007b	b8 04 00 00 00	 mov	 eax, 4
  00080	6b c8 00	 imul	 ecx, eax, 0
  00083	8b 55 ec	 mov	 edx, DWORD PTR _child$[ebp]
  00086	8b 44 0a 38	 mov	 eax, DWORD PTR [edx+ecx+56]
  0008a	89 45 e4	 mov	 DWORD PTR _common_parent$[ebp], eax

; 1096 : 		}
; 1097 : 		else

  0008d	eb 24		 jmp	 SHORT $LN27@swap_waypo
$LN26@swap_waypo:

; 1098 : 		{
; 1099 : 
; 1100 : 			child = child->parents[0];

  0008f	b8 04 00 00 00	 mov	 eax, 4
  00094	6b c8 00	 imul	 ecx, eax, 0
  00097	8b 55 ec	 mov	 edx, DWORD PTR _child$[ebp]
  0009a	8b 44 0a 38	 mov	 eax, DWORD PTR [edx+ecx+56]
  0009e	89 45 ec	 mov	 DWORD PTR _child$[ebp], eax

; 1101 : 
; 1102 : 			other_child = other_child->parents[0];

  000a1	b8 04 00 00 00	 mov	 eax, 4
  000a6	6b c8 00	 imul	 ecx, eax, 0
  000a9	8b 55 e8	 mov	 edx, DWORD PTR _other_child$[ebp]
  000ac	8b 44 0a 38	 mov	 eax, DWORD PTR [edx+ecx+56]
  000b0	89 45 e8	 mov	 DWORD PTR _other_child$[ebp], eax
$LN27@swap_waypo:

; 1103 : 		}
; 1104 : 	}

  000b3	eb 80		 jmp	 SHORT $LN2@swap_waypo
$LN3@swap_waypo:

; 1105 : 
; 1106 : 	if ( common_parent )

  000b5	83 7d e4 00	 cmp	 DWORD PTR _common_parent$[ebp], 0
  000b9	0f 84 c8 00 00
	00		 je	 $LN28@swap_waypo

; 1107 : 	{
; 1108 : 	
; 1109 : 		//
; 1110 : 		// Swap the two child pointers around
; 1111 : 		//
; 1112 : 	
; 1113 : 		for ( count = 0; count < common_parent->number_of_children; count++ )

  000bf	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  000c6	eb 09		 jmp	 SHORT $LN6@swap_waypo
$LN4@swap_waypo:
  000c8	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  000cb	83 c0 01	 add	 eax, 1
  000ce	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN6@swap_waypo:
  000d1	8b 45 e4	 mov	 eax, DWORD PTR _common_parent$[ebp]
  000d4	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  000d7	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000da	7d 32		 jge	 SHORT $LN5@swap_waypo

; 1114 : 		{
; 1115 : 	
; 1116 : 			if ( common_parent->children[count] == child )

  000dc	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  000df	8b 4d e4	 mov	 ecx, DWORD PTR _common_parent$[ebp]
  000e2	8b 94 81 98 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+152]
  000e9	3b 55 ec	 cmp	 edx, DWORD PTR _child$[ebp]
  000ec	75 06		 jne	 SHORT $LN30@swap_waypo

; 1117 : 			{
; 1118 : 	
; 1119 : 				child_index = count;

  000ee	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  000f1	89 45 f4	 mov	 DWORD PTR _child_index$[ebp], eax
$LN30@swap_waypo:

; 1120 : 			}
; 1121 : 	
; 1122 : 			if ( common_parent->children[count] == other_child )

  000f4	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  000f7	8b 4d e4	 mov	 ecx, DWORD PTR _common_parent$[ebp]
  000fa	8b 94 81 98 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+152]
  00101	3b 55 e8	 cmp	 edx, DWORD PTR _other_child$[ebp]
  00104	75 06		 jne	 SHORT $LN31@swap_waypo

; 1123 : 			{
; 1124 : 	
; 1125 : 				other_child_index = count;

  00106	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00109	89 45 f0	 mov	 DWORD PTR _other_child_index$[ebp], eax
$LN31@swap_waypo:

; 1126 : 			}
; 1127 : 		}

  0010c	eb ba		 jmp	 SHORT $LN4@swap_waypo
$LN5@swap_waypo:

; 1128 : 	
; 1129 : 		common_parent->children[child_index] = other_child;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR _child_index$[ebp]
  00111	8b 4d e4	 mov	 ecx, DWORD PTR _common_parent$[ebp]
  00114	8b 55 e8	 mov	 edx, DWORD PTR _other_child$[ebp]
  00117	89 94 81 98 00
	00 00		 mov	 DWORD PTR [ecx+eax*4+152], edx

; 1130 : 	
; 1131 : 		common_parent->children[other_child_index] = child;

  0011e	8b 45 f0	 mov	 eax, DWORD PTR _other_child_index$[ebp]
  00121	8b 4d e4	 mov	 ecx, DWORD PTR _common_parent$[ebp]
  00124	8b 55 ec	 mov	 edx, DWORD PTR _child$[ebp]
  00127	89 94 81 98 00
	00 00		 mov	 DWORD PTR [ecx+eax*4+152], edx

; 1132 : 	
; 1133 : 		//
; 1134 : 		// Now invalidate the node indices of every child below the parents level
; 1135 : 		//
; 1136 : 	
; 1137 : 		for ( count = 0; count < number_of_waypoint_nodes; count++ )

  0012e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00135	eb 09		 jmp	 SHORT $LN9@swap_waypo
$LN7@swap_waypo:
  00137	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0013a	83 c0 01	 add	 eax, 1
  0013d	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN9@swap_waypo:
  00140	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00143	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  00149	7d 37		 jge	 SHORT $LN8@swap_waypo

; 1138 : 		{
; 1139 : 	
; 1140 : 			if ( waypoint_nodes[count].tree_depth > common_parent->tree_depth )

  0014b	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00152	8b 4d e4	 mov	 ecx, DWORD PTR _common_parent$[ebp]
  00155	8b 90 00 00 00
	00		 mov	 edx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax]
  0015b	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0015d	7e 21		 jle	 SHORT $LN32@swap_waypo

; 1141 : 			{
; 1142 : 	
; 1143 : 				if ( waypoint_nodes[count].node_index )

  0015f	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00166	83 b8 08 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+8], 0
  0016d	74 11		 je	 SHORT $LN32@swap_waypo

; 1144 : 				{
; 1145 : 	
; 1146 : 					waypoint_nodes[count].node_index = -1;

  0016f	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00176	c7 80 08 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+8], -1
$LN32@swap_waypo:

; 1147 : 				}
; 1148 : 			}
; 1149 : 		}

  00180	eb b5		 jmp	 SHORT $LN7@swap_waypo
$LN8@swap_waypo:

; 1150 : 	}
; 1151 : 	else

  00182	e9 52 01 00 00	 jmp	 $LN29@swap_waypo
$LN28@swap_waypo:

; 1152 : 	{
; 1153 : 
; 1154 : 		//
; 1155 : 		// Swap the waypoint starting nodes around!
; 1156 : 		//
; 1157 : 
; 1158 : 		for ( child_index = 1; child_index < number_of_waypoint_starting_nodes; child_index++ )

  00187	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _child_index$[ebp], 1
  0018e	eb 09		 jmp	 SHORT $LN12@swap_waypo
$LN10@swap_waypo:
  00190	8b 45 f4	 mov	 eax, DWORD PTR _child_index$[ebp]
  00193	83 c0 01	 add	 eax, 1
  00196	89 45 f4	 mov	 DWORD PTR _child_index$[ebp], eax
$LN12@swap_waypo:
  00199	8b 45 f4	 mov	 eax, DWORD PTR _child_index$[ebp]
  0019c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_starting_nodes@@3HA ; number_of_waypoint_starting_nodes
  001a2	7d 13		 jge	 SHORT $LN11@swap_waypo

; 1159 : 		{
; 1160 : 
; 1161 : 			if ( waypoint_starting_nodes[child_index] == child )

  001a4	8b 45 f4	 mov	 eax, DWORD PTR _child_index$[ebp]
  001a7	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[eax*4]
  001ae	3b 4d ec	 cmp	 ecx, DWORD PTR _child$[ebp]
  001b1	75 02		 jne	 SHORT $LN34@swap_waypo

; 1162 : 			{
; 1163 : 
; 1164 : 				break;

  001b3	eb 02		 jmp	 SHORT $LN11@swap_waypo
$LN34@swap_waypo:

; 1165 : 			}
; 1166 : 		}

  001b5	eb d9		 jmp	 SHORT $LN10@swap_waypo
$LN11@swap_waypo:

; 1167 : 
; 1168 : 		for ( other_child_index = 1; other_child_index < number_of_waypoint_starting_nodes; other_child_index++ )

  001b7	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _other_child_index$[ebp], 1
  001be	eb 09		 jmp	 SHORT $LN15@swap_waypo
$LN13@swap_waypo:
  001c0	8b 45 f0	 mov	 eax, DWORD PTR _other_child_index$[ebp]
  001c3	83 c0 01	 add	 eax, 1
  001c6	89 45 f0	 mov	 DWORD PTR _other_child_index$[ebp], eax
$LN15@swap_waypo:
  001c9	8b 45 f0	 mov	 eax, DWORD PTR _other_child_index$[ebp]
  001cc	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_starting_nodes@@3HA ; number_of_waypoint_starting_nodes
  001d2	7d 13		 jge	 SHORT $LN14@swap_waypo

; 1169 : 		{
; 1170 : 
; 1171 : 			if ( waypoint_starting_nodes[other_child_index] == other_child )

  001d4	8b 45 f0	 mov	 eax, DWORD PTR _other_child_index$[ebp]
  001d7	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[eax*4]
  001de	3b 4d e8	 cmp	 ecx, DWORD PTR _other_child$[ebp]
  001e1	75 02		 jne	 SHORT $LN35@swap_waypo

; 1172 : 			{
; 1173 : 
; 1174 : 				break;

  001e3	eb 02		 jmp	 SHORT $LN14@swap_waypo
$LN35@swap_waypo:

; 1175 : 			}
; 1176 : 		}

  001e5	eb d9		 jmp	 SHORT $LN13@swap_waypo
$LN14@swap_waypo:

; 1177 : 
; 1178 : 		ASSERT ( child_index < number_of_waypoint_starting_nodes );

  001e7	8b 45 f4	 mov	 eax, DWORD PTR _child_index$[ebp]
  001ea	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_starting_nodes@@3HA ; number_of_waypoint_starting_nodes
  001f0	7c 18		 jl	 SHORT $LN36@swap_waypo
  001f2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??swap_waypoint_nodes@@YGXHH@Z@4JA
  001f7	83 c0 7a	 add	 eax, 122		; 0000007aH
  001fa	50		 push	 eax
  001fb	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@BMNFJBIG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00200	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@OOFCHPBB@child_index?5?$DM?5number_of_waypoin@
  00205	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN36@swap_waypo:

; 1179 : 
; 1180 : 		ASSERT ( other_child_index < number_of_waypoint_starting_nodes );

  0020a	8b 45 f0	 mov	 eax, DWORD PTR _other_child_index$[ebp]
  0020d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_starting_nodes@@3HA ; number_of_waypoint_starting_nodes
  00213	7c 18		 jl	 SHORT $LN37@swap_waypo
  00215	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??swap_waypoint_nodes@@YGXHH@Z@4JA
  0021a	83 c0 7c	 add	 eax, 124		; 0000007cH
  0021d	50		 push	 eax
  0021e	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@BMNFJBIG@c?3?2users?2nhv90?2projects?2eech?2ap@
  00223	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@HCOBEKGM@other_child_index?5?$DM?5number_of_w@
  00228	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN37@swap_waypo:

; 1181 : 
; 1182 : 		waypoint_starting_nodes[child_index] = other_child;

  0022d	8b 45 f4	 mov	 eax, DWORD PTR _child_index$[ebp]
  00230	8b 4d e8	 mov	 ecx, DWORD PTR _other_child$[ebp]
  00233	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[eax*4], ecx

; 1183 : 
; 1184 : 		waypoint_starting_nodes[other_child_index] = child;

  0023a	8b 45 f0	 mov	 eax, DWORD PTR _other_child_index$[ebp]
  0023d	8b 4d ec	 mov	 ecx, DWORD PTR _child$[ebp]
  00240	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[eax*4], ecx

; 1185 : 
; 1186 : 		//
; 1187 : 		// Now invalidate all the node indices apart from the primary
; 1188 : 		//
; 1189 : 	
; 1190 : 		for ( count = 0; count < number_of_waypoint_nodes; count++ )

  00247	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  0024e	eb 09		 jmp	 SHORT $LN18@swap_waypo
$LN16@swap_waypo:
  00250	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00253	83 c0 01	 add	 eax, 1
  00256	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN18@swap_waypo:
  00259	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0025c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  00262	7d 23		 jge	 SHORT $LN17@swap_waypo

; 1191 : 		{
; 1192 : 	
; 1193 : 			if ( waypoint_nodes[count].node_index )

  00264	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0026b	83 b8 08 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+8], 0
  00272	74 11		 je	 SHORT $LN38@swap_waypo

; 1194 : 			{
; 1195 : 
; 1196 : 				waypoint_nodes[count].node_index = -1;

  00274	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0027b	c7 80 08 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+8], -1
$LN38@swap_waypo:

; 1197 : 			}
; 1198 : 		}

  00285	eb c9		 jmp	 SHORT $LN16@swap_waypo
$LN17@swap_waypo:

; 1199 : 
; 1200 : 		//
; 1201 : 		// Go through each tree setting the main route node index
; 1202 : 		//
; 1203 : 	
; 1204 : 		for ( count = 0; count < number_of_waypoint_starting_nodes; count++ )

  00287	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  0028e	eb 09		 jmp	 SHORT $LN21@swap_waypo
$LN19@swap_waypo:
  00290	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00293	83 c0 01	 add	 eax, 1
  00296	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN21@swap_waypo:
  00299	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0029c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_starting_nodes@@3HA ; number_of_waypoint_starting_nodes
  002a2	7d 35		 jge	 SHORT $LN29@swap_waypo

; 1205 : 		{
; 1206 : 	
; 1207 : 			waypoint_node
; 1208 : 				*this_node;
; 1209 : 	
; 1210 : 			this_node = waypoint_starting_nodes[count];

  002a4	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  002a7	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[eax*4]
  002ae	89 4d e0	 mov	 DWORD PTR _this_node$1[ebp], ecx
$LN22@swap_waypo:

; 1211 : 	
; 1212 : 			while ( this_node )

  002b1	83 7d e0 00	 cmp	 DWORD PTR _this_node$1[ebp], 0
  002b5	74 20		 je	 SHORT $LN23@swap_waypo

; 1213 : 			{
; 1214 : 	
; 1215 : 				this_node->node_index = count;

  002b7	8b 45 e0	 mov	 eax, DWORD PTR _this_node$1[ebp]
  002ba	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  002bd	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1216 : 	
; 1217 : 				this_node = this_node->children[0];

  002c0	b8 04 00 00 00	 mov	 eax, 4
  002c5	6b c8 00	 imul	 ecx, eax, 0
  002c8	8b 55 e0	 mov	 edx, DWORD PTR _this_node$1[ebp]
  002cb	8b 84 0a 98 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+152]
  002d2	89 45 e0	 mov	 DWORD PTR _this_node$1[ebp], eax

; 1218 : 			}

  002d5	eb da		 jmp	 SHORT $LN22@swap_waypo
$LN23@swap_waypo:

; 1219 : 		}

  002d7	eb b7		 jmp	 SHORT $LN19@swap_waypo
$LN29@swap_waypo:

; 1220 : 	}
; 1221 : 
; 1222 : 	//
; 1223 : 	// Now renumber the indices ( again )
; 1224 : 	//
; 1225 : 
; 1226 : 	set_node_indices ();

  002d9	e8 00 00 00 00	 call	 ?set_node_indices@@YGXXZ ; set_node_indices

; 1227 : }

  002de	5f		 pop	 edi
  002df	5e		 pop	 esi
  002e0	5b		 pop	 ebx
  002e1	8b e5		 mov	 esp, ebp
  002e3	5d		 pop	 ebp
  002e4	c2 08 00	 ret	 8
?swap_waypoint_nodes@@YGXHH@Z ENDP			; swap_waypoint_nodes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\ai\faction\routegen.c
;	COMDAT ?node_within_range@@YGHPAUVEC3D@@0@Z
_TEXT	SEGMENT
_range$ = -16						; size = 4
_dz$ = -12						; size = 4
_dy$ = -8						; size = 4
_dx$ = -4						; size = 4
_pos1$ = 8						; size = 4
_pos2$ = 12						; size = 4
?node_within_range@@YGHPAUVEC3D@@0@Z PROC		; node_within_range, COMDAT

; 1023 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1024 : 
; 1025 : 	float
; 1026 : 		dx,
; 1027 : 		dy,
; 1028 : 		dz;
; 1029 : 
; 1030 : 	float
; 1031 : 		range;
; 1032 : 
; 1033 : 	dx = pos1->x - pos2->x;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pos1$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _pos2$[ebp]
  0000f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00013	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00017	f3 0f 11 45 fc	 movss	 DWORD PTR _dx$[ebp], xmm0

; 1034 : 	dy = pos1->y - pos2->y;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _pos1$[ebp]
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _pos2$[ebp]
  00022	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00027	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0002c	f3 0f 11 45 f8	 movss	 DWORD PTR _dy$[ebp], xmm0

; 1035 : 	dz = pos1->z - pos2->z;

  00031	8b 45 08	 mov	 eax, DWORD PTR _pos1$[ebp]
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _pos2$[ebp]
  00037	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0003c	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00041	f3 0f 11 45 f4	 movss	 DWORD PTR _dz$[ebp], xmm0

; 1036 : 
; 1037 : 	range = sqrt ( ( dx * dx ) + ( dy * dy ) + ( dz * dz ) );

  00046	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _dx$[ebp]
  0004b	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR _dx$[ebp]
  00050	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _dy$[ebp]
  00055	f3 0f 59 4d f8	 mulss	 xmm1, DWORD PTR _dy$[ebp]
  0005a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0005e	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _dz$[ebp]
  00063	f3 0f 59 4d f4	 mulss	 xmm1, DWORD PTR _dz$[ebp]
  00068	f3 0f 58 c1	 addss	 xmm0, xmm1
  0006c	51		 push	 ecx
  0006d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00072	e8 00 00 00 00	 call	 ?sqrt@@YGMM@Z		; sqrt
  00077	d9 5d f0	 fstp	 DWORD PTR _range$[ebp]

; 1038 : 
; 1039 : 	if ( range < 3.0 )

  0007a	f3 0f 5a 45 f0	 cvtss2sd xmm0, DWORD PTR _range$[ebp]
  0007f	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4008000000000000
  00087	66 0f 2f c8	 comisd	 xmm1, xmm0
  0008b	76 09		 jbe	 SHORT $LN2@node_withi

; 1040 : 	{
; 1041 : 
; 1042 : 		return ( TRUE );

  0008d	b8 01 00 00 00	 mov	 eax, 1
  00092	eb 04		 jmp	 SHORT $LN3@node_withi

; 1043 : 	}
; 1044 : 	else

  00094	eb 02		 jmp	 SHORT $LN3@node_withi
$LN2@node_withi:

; 1045 : 	{
; 1046 : 
; 1047 : 		return ( FALSE );

  00096	33 c0		 xor	 eax, eax
$LN3@node_withi:

; 1048 : 	}
; 1049 : }

  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8
?node_within_range@@YGHPAUVEC3D@@0@Z ENDP		; node_within_range
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\ai\faction\routegen.c
;	COMDAT ?match_end_slots@@YGXHHPAUVEC3D@@@Z
_TEXT	SEGMENT
_finished$ = -16					; size = 4
_other_node$ = -12					; size = 4
_node$ = -8						; size = 4
_count$ = -4						; size = 4
_tree_depth$ = 8					; size = 4
_number_of_matching_slots$ = 12				; size = 4
_slots$ = 16						; size = 4
?match_end_slots@@YGXHHPAUVEC3D@@@Z PROC		; match_end_slots, COMDAT

; 924  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 925  : 
; 926  : 	int
; 927  : 		count,
; 928  : 		node,
; 929  : 		other_node,
; 930  : 		finished;
; 931  : 
; 932  : 	finished = FALSE;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _finished$[ebp], 0
$LN2@match_end_:

; 933  : 
; 934  : 	while ( !finished )

  00010	83 7d f0 00	 cmp	 DWORD PTR _finished$[ebp], 0
  00014	0f 85 11 01 00
	00		 jne	 $LN1@match_end_

; 935  : 	{
; 936  : 
; 937  : 		//
; 938  : 		// Go through the routes, checking each end point matches the slots given
; 939  : 		//
; 940  : 
; 941  : 		finished = TRUE;

  0001a	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _finished$[ebp], 1

; 942  : 
; 943  : 		for ( count = 0; count < number_of_matching_slots; count++ )

  00021	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00028	eb 09		 jmp	 SHORT $LN6@match_end_
$LN4@match_end_:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0002d	83 c0 01	 add	 eax, 1
  00030	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN6@match_end_:
  00033	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00036	3b 45 0c	 cmp	 eax, DWORD PTR _number_of_matching_slots$[ebp]
  00039	0f 8d e7 00 00
	00		 jge	 $LN5@match_end_

; 944  : 		{
; 945  : 
; 946  : 			for ( node = 0; node < number_of_waypoint_nodes; node++ )

  0003f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _node$[ebp], 0
  00046	eb 09		 jmp	 SHORT $LN9@match_end_
$LN7@match_end_:
  00048	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  0004b	83 c0 01	 add	 eax, 1
  0004e	89 45 f8	 mov	 DWORD PTR _node$[ebp], eax
$LN9@match_end_:
  00051	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  00054	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  0005a	0f 8d c1 00 00
	00		 jge	 $LN8@match_end_

; 947  : 			{
; 948  : 
; 949  : 				if ( ( waypoint_nodes[node].tree_depth == tree_depth ) && ( waypoint_nodes[node].node_index == count ) )

  00060	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _node$[ebp], 248
  00067	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax]
  0006d	3b 4d 08	 cmp	 ecx, DWORD PTR _tree_depth$[ebp]
  00070	0f 85 a6 00 00
	00		 jne	 $LN13@match_end_
  00076	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _node$[ebp], 248
  0007d	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+8]
  00083	3b 4d fc	 cmp	 ecx, DWORD PTR _count$[ebp]
  00086	0f 85 90 00 00
	00		 jne	 $LN13@match_end_

; 950  : 				{
; 951  : 
; 952  : 					if ( !node_within_range ( &waypoint_nodes[node].position, &slots[count] ) )

  0008c	6b 45 fc 0c	 imul	 eax, DWORD PTR _count$[ebp], 12
  00090	03 45 10	 add	 eax, DWORD PTR _slots$[ebp]
  00093	50		 push	 eax
  00094	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _node$[ebp], 248
  0009b	81 c1 2c 00 00
	00		 add	 ecx, OFFSET ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A+44
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 ?node_within_range@@YGHPAUVEC3D@@0@Z ; node_within_range
  000a7	85 c0		 test	 eax, eax
  000a9	75 71		 jne	 SHORT $LN13@match_end_

; 953  : 					{
; 954  : 
; 955  : 						//
; 956  : 						// Find the node we need to swap with this one
; 957  : 						//
; 958  : 
; 959  : 						for ( other_node = 0; other_node < number_of_waypoint_nodes; other_node++ )

  000ab	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _other_node$[ebp], 0
  000b2	eb 09		 jmp	 SHORT $LN12@match_end_
$LN10@match_end_:
  000b4	8b 45 f4	 mov	 eax, DWORD PTR _other_node$[ebp]
  000b7	83 c0 01	 add	 eax, 1
  000ba	89 45 f4	 mov	 DWORD PTR _other_node$[ebp], eax
$LN12@match_end_:
  000bd	8b 45 f4	 mov	 eax, DWORD PTR _other_node$[ebp]
  000c0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  000c6	7d 35		 jge	 SHORT $LN11@match_end_

; 960  : 						{
; 961  : 
; 962  : 							if (	( waypoint_nodes[other_node].tree_depth == tree_depth ) &&

  000c8	69 45 f4 f8 00
	00 00		 imul	 eax, DWORD PTR _other_node$[ebp], 248
  000cf	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax]
  000d5	3b 4d 08	 cmp	 ecx, DWORD PTR _tree_depth$[ebp]
  000d8	75 21		 jne	 SHORT $LN15@match_end_
  000da	6b 45 fc 0c	 imul	 eax, DWORD PTR _count$[ebp], 12
  000de	03 45 10	 add	 eax, DWORD PTR _slots$[ebp]
  000e1	50		 push	 eax
  000e2	69 4d f4 f8 00
	00 00		 imul	 ecx, DWORD PTR _other_node$[ebp], 248
  000e9	81 c1 2c 00 00
	00		 add	 ecx, OFFSET ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A+44
  000ef	51		 push	 ecx
  000f0	e8 00 00 00 00	 call	 ?node_within_range@@YGHPAUVEC3D@@0@Z ; node_within_range
  000f5	85 c0		 test	 eax, eax
  000f7	74 02		 je	 SHORT $LN15@match_end_

; 963  : 									( node_within_range ( &waypoint_nodes[other_node].position, &slots[count] ) ) )
; 964  : 							{
; 965  : 
; 966  : 								break;

  000f9	eb 02		 jmp	 SHORT $LN11@match_end_
$LN15@match_end_:

; 967  : 							}
; 968  : 						}

  000fb	eb b7		 jmp	 SHORT $LN10@match_end_
$LN11@match_end_:

; 969  : 
; 970  : 						if ( other_node != number_of_waypoint_nodes )

  000fd	8b 45 f4	 mov	 eax, DWORD PTR _other_node$[ebp]
  00100	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  00106	74 14		 je	 SHORT $LN13@match_end_

; 971  : 						{
; 972  : 
; 973  : 							#if DEBUG_MODULE
; 974  : 
; 975  : 							debug_log ( "Swapping nodes %d and %d", node, other_node );
; 976  : 
; 977  : 							#endif
; 978  : 
; 979  : 							swap_waypoint_nodes ( node, other_node );

  00108	8b 45 f4	 mov	 eax, DWORD PTR _other_node$[ebp]
  0010b	50		 push	 eax
  0010c	8b 4d f8	 mov	 ecx, DWORD PTR _node$[ebp]
  0010f	51		 push	 ecx
  00110	e8 00 00 00 00	 call	 ?swap_waypoint_nodes@@YGXHH@Z ; swap_waypoint_nodes

; 980  : 
; 981  : 							finished = FALSE;

  00115	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _finished$[ebp], 0
$LN13@match_end_:

; 982  : 						}
; 983  : 
; 984  : 						#if DEBUG_MODULE
; 985  : 
; 986  : 						else
; 987  : 						{
; 988  : 
; 989  : 							debug_log ( "CANT FIND A NODE TO SWAP!!!!! %f, %f, %f", slots[count].x, slots[count].y, slots[count].z );
; 990  : 
; 991  : 							for ( other_node = 0; other_node < number_of_waypoint_nodes; other_node++ )
; 992  : 							{
; 993  : 
; 994  : 
; 995  : 								if ( waypoint_nodes[other_node].tree_depth == tree_depth )
; 996  : 								{
; 997  : 
; 998  : 									debug_log ( "NODE: %f, %f, %f",
; 999  : 														waypoint_nodes[other_node].position.x,
; 1000 : 														waypoint_nodes[other_node].position.y,
; 1001 : 														waypoint_nodes[other_node].position.z );
; 1002 : 
; 1003 : 
; 1004 : 								}
; 1005 : 							}
; 1006 : 
; 1007 : 							debug_fatal ( "ERROR" );
; 1008 : 						}
; 1009 : 
; 1010 : 						#endif
; 1011 : 					}
; 1012 : 				}
; 1013 : 			}

  0011c	e9 27 ff ff ff	 jmp	 $LN7@match_end_
$LN8@match_end_:

; 1014 : 		}

  00121	e9 04 ff ff ff	 jmp	 $LN4@match_end_
$LN5@match_end_:

; 1015 : 	}

  00126	e9 e5 fe ff ff	 jmp	 $LN2@match_end_
$LN1@match_end_:

; 1016 : }

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 0c 00	 ret	 12			; 0000000cH
?match_end_slots@@YGXHHPAUVEC3D@@@Z ENDP		; match_end_slots
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\ai\faction\routegen.c
;	COMDAT ?set_node_indices@@YGXXZ
_TEXT	SEGMENT
_parent$1 = -32						; size = 4
_parent_count$2 = -28					; size = 4
_lowest_parent_index$3 = -24				; size = 4
_child_index$4 = -20					; size = 4
_hierarchy_width$5 = -16				; size = 4
_parent$6 = -12						; size = 4
_count$ = -8						; size = 4
_number_of_nodes_left$ = -4				; size = 4
?set_node_indices@@YGXXZ PROC				; set_node_indices, COMDAT

; 823  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 824  : 
; 825  : 	int
; 826  : 		number_of_nodes_left,
; 827  : 		count;
; 828  : 
; 829  : 	//
; 830  : 	// Count the number of nodes that haven't been given a valid node index
; 831  : 	//
; 832  : 
; 833  : 	number_of_nodes_left = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _number_of_nodes_left$[ebp], 0

; 834  : 
; 835  : 	for ( count = 0; count < number_of_waypoint_nodes; count++ )

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@set_node_i
$LN2@set_node_i:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN4@set_node_i:
  00022	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00025	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  0002b	7d 1b		 jge	 SHORT $LN5@set_node_i

; 836  : 	{
; 837  : 
; 838  : 		if ( waypoint_nodes[count].node_index == -1 )

  0002d	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00034	83 b8 08 00 00
	00 ff		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+8], -1
  0003b	75 09		 jne	 SHORT $LN13@set_node_i

; 839  : 		{
; 840  : 
; 841  : 			number_of_nodes_left++;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _number_of_nodes_left$[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 fc	 mov	 DWORD PTR _number_of_nodes_left$[ebp], eax
$LN13@set_node_i:

; 842  : 		}
; 843  : 	}

  00046	eb d1		 jmp	 SHORT $LN2@set_node_i
$LN5@set_node_i:

; 844  : 
; 845  : 	//
; 846  : 	// Go through all the nodes left setting the node indices
; 847  : 	//
; 848  : 
; 849  : 	while ( number_of_nodes_left )

  00048	83 7d fc 00	 cmp	 DWORD PTR _number_of_nodes_left$[ebp], 0
  0004c	0f 84 49 01 00
	00		 je	 $LN1@set_node_i

; 850  : 	{
; 851  : 	
; 852  : 		for ( count = 0; count < number_of_waypoint_nodes; count++ )

  00052	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00059	eb 09		 jmp	 SHORT $LN9@set_node_i
$LN7@set_node_i:
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0005e	83 c0 01	 add	 eax, 1
  00061	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN9@set_node_i:
  00064	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00067	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  0006d	0f 8d 23 01 00
	00		 jge	 $LN8@set_node_i

; 853  : 		{
; 854  : 	
; 855  : 			if ( waypoint_nodes[count].node_index == -1 )

  00073	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0007a	83 b8 08 00 00
	00 ff		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+8], -1
  00081	0f 85 0a 01 00
	00		 jne	 $LN14@set_node_i

; 856  : 			{
; 857  : 
; 858  : 				if ( waypoint_nodes[count].number_of_parents == 1 )

  00087	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0008e	83 b8 10 00 00
	00 01		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+16], 1
  00095	75 71		 jne	 SHORT $LN15@set_node_i

; 859  : 				{
; 860  : 
; 861  : 					waypoint_node
; 862  : 						*parent;
; 863  : 
; 864  : 					parent = waypoint_nodes[count].parents[0];

  00097	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0009e	b9 04 00 00 00	 mov	 ecx, 4
  000a3	6b d1 00	 imul	 edx, ecx, 0
  000a6	8b 84 10 38 00
	00 00		 mov	 eax, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+edx+56]
  000ad	89 45 f4	 mov	 DWORD PTR _parent$6[ebp], eax

; 865  : 
; 866  : 					if ( parent->node_index != -1 )

  000b0	8b 45 f4	 mov	 eax, DWORD PTR _parent$6[ebp]
  000b3	83 78 08 ff	 cmp	 DWORD PTR [eax+8], -1
  000b7	74 4a		 je	 SHORT $LN17@set_node_i

; 867  : 					{
; 868  : 
; 869  : 						int
; 870  : 							hierarchy_width,
; 871  : 							child_index;
; 872  : 
; 873  : 						child_index = get_waypoint_node_child_index ( parent, &waypoint_nodes[count] );

  000b9	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  000c0	05 00 00 00 00	 add	 eax, OFFSET ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A ; waypoint_nodes
  000c5	50		 push	 eax
  000c6	8b 4d f4	 mov	 ecx, DWORD PTR _parent$6[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 ?get_waypoint_node_child_index@@YGHPAUWAYPOINT_NODE@@0@Z ; get_waypoint_node_child_index
  000cf	89 45 ec	 mov	 DWORD PTR _child_index$4[ebp], eax

; 874  : 
; 875  : 						hierarchy_width = get_number_of_nodes_at_depth ( parent->tree_depth );

  000d2	8b 45 f4	 mov	 eax, DWORD PTR _parent$6[ebp]
  000d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 ?get_number_of_nodes_at_depth@@YGHH@Z ; get_number_of_nodes_at_depth
  000dd	89 45 f0	 mov	 DWORD PTR _hierarchy_width$5[ebp], eax

; 876  : 
; 877  : 						waypoint_nodes[count].node_index = hierarchy_width * child_index + parent->node_index;

  000e0	8b 45 f0	 mov	 eax, DWORD PTR _hierarchy_width$5[ebp]
  000e3	0f af 45 ec	 imul	 eax, DWORD PTR _child_index$4[ebp]
  000e7	8b 4d f4	 mov	 ecx, DWORD PTR _parent$6[ebp]
  000ea	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  000ed	69 55 f8 f8 00
	00 00		 imul	 edx, DWORD PTR _count$[ebp], 248
  000f4	89 82 08 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[edx+8], eax

; 878  : 
; 879  : 						number_of_nodes_left--;

  000fa	8b 45 fc	 mov	 eax, DWORD PTR _number_of_nodes_left$[ebp]
  000fd	83 e8 01	 sub	 eax, 1
  00100	89 45 fc	 mov	 DWORD PTR _number_of_nodes_left$[ebp], eax
$LN17@set_node_i:

; 880  : 					}
; 881  : 				}
; 882  : 				else

  00103	e9 89 00 00 00	 jmp	 $LN14@set_node_i
$LN15@set_node_i:

; 883  : 				{
; 884  : 
; 885  : 					int
; 886  : 						lowest_parent_index,
; 887  : 						parent_count;
; 888  : 
; 889  : 					lowest_parent_index = waypoint_nodes[count].parents[0]->node_index;

  00108	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0010f	b9 04 00 00 00	 mov	 ecx, 4
  00114	6b d1 00	 imul	 edx, ecx, 0
  00117	8b 84 10 38 00
	00 00		 mov	 eax, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+edx+56]
  0011e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00121	89 4d e8	 mov	 DWORD PTR _lowest_parent_index$3[ebp], ecx

; 890  : 
; 891  : 					for ( parent_count = 1; parent_count < waypoint_nodes[count].number_of_parents; parent_count++ )

  00124	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _parent_count$2[ebp], 1
  0012b	eb 09		 jmp	 SHORT $LN12@set_node_i
$LN10@set_node_i:
  0012d	8b 45 e4	 mov	 eax, DWORD PTR _parent_count$2[ebp]
  00130	83 c0 01	 add	 eax, 1
  00133	89 45 e4	 mov	 DWORD PTR _parent_count$2[ebp], eax
$LN12@set_node_i:
  00136	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0013d	8b 4d e4	 mov	 ecx, DWORD PTR _parent_count$2[ebp]
  00140	3b 88 10 00 00
	00		 cmp	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+16]
  00146	7d 2a		 jge	 SHORT $LN11@set_node_i

; 892  : 					{
; 893  : 
; 894  : 						waypoint_node
; 895  : 							*parent;
; 896  : 
; 897  : 						parent = waypoint_nodes[count].parents[parent_count];

  00148	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0014f	8b 4d e4	 mov	 ecx, DWORD PTR _parent_count$2[ebp]
  00152	8b 94 88 38 00
	00 00		 mov	 edx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+ecx*4+56]
  00159	89 55 e0	 mov	 DWORD PTR _parent$1[ebp], edx

; 898  : 
; 899  : 						if ( parent->node_index < lowest_parent_index )

  0015c	8b 45 e0	 mov	 eax, DWORD PTR _parent$1[ebp]
  0015f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00162	3b 4d e8	 cmp	 ecx, DWORD PTR _lowest_parent_index$3[ebp]
  00165	7d 09		 jge	 SHORT $LN18@set_node_i

; 900  : 						{
; 901  : 
; 902  : 							lowest_parent_index = parent->node_index;

  00167	8b 45 e0	 mov	 eax, DWORD PTR _parent$1[ebp]
  0016a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0016d	89 4d e8	 mov	 DWORD PTR _lowest_parent_index$3[ebp], ecx
$LN18@set_node_i:

; 903  : 						}
; 904  : 					}

  00170	eb bb		 jmp	 SHORT $LN10@set_node_i
$LN11@set_node_i:

; 905  : 
; 906  : 					if ( lowest_parent_index != -1 )

  00172	83 7d e8 ff	 cmp	 DWORD PTR _lowest_parent_index$3[ebp], -1
  00176	74 19		 je	 SHORT $LN14@set_node_i

; 907  : 					{
; 908  : 
; 909  : 						waypoint_nodes[count].node_index = lowest_parent_index;

  00178	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0017f	8b 4d e8	 mov	 ecx, DWORD PTR _lowest_parent_index$3[ebp]
  00182	89 88 08 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+8], ecx

; 910  : 
; 911  : 						number_of_nodes_left--;

  00188	8b 45 fc	 mov	 eax, DWORD PTR _number_of_nodes_left$[ebp]
  0018b	83 e8 01	 sub	 eax, 1
  0018e	89 45 fc	 mov	 DWORD PTR _number_of_nodes_left$[ebp], eax
$LN14@set_node_i:

; 912  : 					}
; 913  : 				}
; 914  : 			}
; 915  : 		}

  00191	e9 c5 fe ff ff	 jmp	 $LN7@set_node_i
$LN8@set_node_i:

; 916  : 	}

  00196	e9 ad fe ff ff	 jmp	 $LN5@set_node_i
$LN1@set_node_i:

; 917  : }

  0019b	5f		 pop	 edi
  0019c	5e		 pop	 esi
  0019d	5b		 pop	 ebx
  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c3		 ret	 0
?set_node_indices@@YGXXZ ENDP				; set_node_indices
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\ai\faction\routegen.c
;	COMDAT ?get_waypoint_node_child_index@@YGHPAUWAYPOINT_NODE@@0@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_parent$ = 8						; size = 4
_child$ = 12						; size = 4
?get_waypoint_node_child_index@@YGHPAUWAYPOINT_NODE@@0@Z PROC ; get_waypoint_node_child_index, COMDAT

; 772  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 773  : 
; 774  : 	int
; 775  : 		count;
; 776  : 
; 777  : 	for ( count = 0; count < parent->number_of_children; count++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@get_waypoi
$LN2@get_waypoi:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@get_waypoi:
  0001b	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  00021	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00024	7d 19		 jge	 SHORT $LN3@get_waypoi

; 778  : 	{
; 779  : 
; 780  : 		if ( parent->children[count] == child )

  00026	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  0002c	8b 94 81 98 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+152]
  00033	3b 55 0c	 cmp	 edx, DWORD PTR _child$[ebp]
  00036	75 05		 jne	 SHORT $LN5@get_waypoi

; 781  : 		{
; 782  : 
; 783  : 			return ( count );

  00038	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0003b	eb 11		 jmp	 SHORT $LN1@get_waypoi
$LN5@get_waypoi:

; 784  : 		}
; 785  : 	}

  0003d	eb d3		 jmp	 SHORT $LN2@get_waypoi
$LN3@get_waypoi:

; 786  : 
; 787  : 	debug_fatal ( "Unable to find child pointer on parent route node" );

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@DIGGGCM@Unable?5to?5find?5child?5pointer?5on@
  00044	e8 00 00 00 00	 call	 ?debug_fatal@@YAXPBDZZ	; debug_fatal
  00049	83 c4 04	 add	 esp, 4

; 788  : 
; 789  : 	return ( 0 );

  0004c	33 c0		 xor	 eax, eax
$LN1@get_waypoi:

; 790  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
?get_waypoint_node_child_index@@YGHPAUWAYPOINT_NODE@@0@Z ENDP ; get_waypoint_node_child_index
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\ai\faction\routegen.c
;	COMDAT ?get_number_of_nodes_at_depth@@YGHH@Z
_TEXT	SEGMENT
_count$ = -8						; size = 4
_total$ = -4						; size = 4
_tree_depth$ = 8					; size = 4
?get_number_of_nodes_at_depth@@YGHH@Z PROC		; get_number_of_nodes_at_depth, COMDAT

; 797  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 798  : 
; 799  : 	int
; 800  : 		total,
; 801  : 		count;
; 802  : 
; 803  : 	total = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _total$[ebp], 0

; 804  : 
; 805  : 	for ( count = 0; count < number_of_waypoint_nodes; count++ )

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@get_number
$LN2@get_number:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN4@get_number:
  00022	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00025	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  0002b	7d 1d		 jge	 SHORT $LN3@get_number

; 806  : 	{
; 807  : 
; 808  : 		if ( waypoint_nodes[count].tree_depth == tree_depth )

  0002d	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00034	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax]
  0003a	3b 4d 08	 cmp	 ecx, DWORD PTR _tree_depth$[ebp]
  0003d	75 09		 jne	 SHORT $LN5@get_number

; 809  : 		{
; 810  : 
; 811  : 			total++;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _total$[ebp]
  00042	83 c0 01	 add	 eax, 1
  00045	89 45 fc	 mov	 DWORD PTR _total$[ebp], eax
$LN5@get_number:

; 812  : 		}
; 813  : 	}

  00048	eb cf		 jmp	 SHORT $LN2@get_number
$LN3@get_number:

; 814  : 
; 815  : 	return ( total );

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _total$[ebp]

; 816  : }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
?get_number_of_nodes_at_depth@@YGHH@Z ENDP		; get_number_of_nodes_at_depth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\ai\faction\routegen.c
;	COMDAT ?parse_waypoint_routes_from_object@@YGXHHPAUVEC3D@@@Z
_TEXT	SEGMENT
$T1 = -248						; size = 4
$T2 = -244						; size = 4
$T3 = -240						; size = 4
$T4 = -236						; size = 4
$T5 = -232						; size = 4
$T6 = -228						; size = 4
_node_index$7 = -160					; size = 4
_number_of_nodes$8 = -156				; size = 4
_finished$9 = -152					; size = 4
_this_node$10 = -148					; size = 4
_tmp$11 = -144						; size = 4
_primary_start_index$12 = -140				; size = 4
_this_node$13 = -136					; size = 4
_number_of_parents$14 = -132				; size = 4
_number_of_children$15 = -128				; size = 4
_child$16 = -124					; size = 4
_parent$17 = -120					; size = 4
_add_node_flag$18 = -116				; size = 4
_point1$19 = -112					; size = 4
_point0$20 = -108					; size = 4
_number_of_surface_points$21 = -104			; size = 4
_number_of_parents$22 = -100				; size = 4
_number_of_children$23 = -96				; size = 4
_child$24 = -92						; size = 4
_parent$25 = -88					; size = 4
_add_node_flag$26 = -84					; size = 4
_point1$27 = -80					; size = 4
_point0$28 = -76					; size = 4
_number_of_surface_points$29 = -72			; size = 4
_point1$30 = -68					; size = 4
_point0$31 = -64					; size = 4
_number_of_surface_points$32 = -60			; size = 4
_loop$33 = -56						; size = 4
_zmax$34 = -52						; size = 4
_ymax$35 = -48						; size = 4
_xmax$36 = -44						; size = 4
_faces$ = -40						; size = 4
_surface_point_refs$ = -36				; size = 4
_point_refs$ = -32					; size = 4
_current_depth$ = -28					; size = 4
_maximum_tree_depth$ = -24				; size = 4
_number_of_primary_nodes_left$ = -20			; size = 4
_number_of_nodes_left$ = -16				; size = 4
_number_of_primary_nodes$ = -12				; size = 4
_count$ = -8						; size = 4
_surface$ = -4						; size = 4
_object_index$ = 8					; size = 4
_number_of_matching_slots$ = 12				; size = 4
_slots$ = 16						; size = 4
?parse_waypoint_routes_from_object@@YGXHHPAUVEC3D@@@Z PROC ; parse_waypoint_routes_from_object, COMDAT

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 192  : 
; 193  : 	int
; 194  : 		surface,
; 195  : 		count,
; 196  : 		number_of_primary_nodes,
; 197  : 		number_of_nodes_left,
; 198  : 		number_of_primary_nodes_left,
; 199  : 		maximum_tree_depth,
; 200  : 		current_depth;
; 201  : 
; 202  : 	struct POINT_3D_SHORT_REFERENCE
; 203  : 		*point_refs;
; 204  : 
; 205  : 	struct POINT_3D_PLAIN_REFERENCE
; 206  : 		*surface_point_refs;
; 207  : 
; 208  : 	object_3d_face
; 209  : 		*faces;
; 210  : 
; 211  : 	//
; 212  : 	// Copy the point data into each node.
; 213  : 	//
; 214  : 
; 215  : 	number_of_waypoint_nodes = objects_3d_data[object_index].number_of_points;

  0000c	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00016	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  0001a	89 15 00 00 00
	00		 mov	 DWORD PTR ?number_of_waypoint_nodes@@3HA, edx ; number_of_waypoint_nodes

; 216  : 
; 217  : 	ASSERT ( number_of_waypoint_nodes < MAX_WAYPOINT_NODES );

  00020	81 3d 00 00 00
	00 00 03 00 00	 cmp	 DWORD PTR ?number_of_waypoint_nodes@@3HA, 768 ; number_of_waypoint_nodes, 00000300H
  0002a	7c 18		 jl	 SHORT $LN66@parse_wayp
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??parse_waypoint_routes_from_object@@YGXHHPAUVEC3D@@@Z@4JA
  00031	83 c0 1a	 add	 eax, 26			; 0000001aH
  00034	50		 push	 eax
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@BMNFJBIG@c?3?2users?2nhv90?2projects?2eech?2ap@
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@EHFGCHFB@number_of_waypoint_nodes?5?$DM?5MAX_@
  0003f	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN66@parse_wayp:

; 218  : 
; 219  : 	{
; 220  : 
; 221  : 		float
; 222  : 			xmax,
; 223  : 			ymax,
; 224  : 			zmax;
; 225  : 	
; 226  : 		xmax = max ( fabs ( objects_3d_data[object_index].bounding_box.xmin ), fabs ( objects_3d_data[object_index].bounding_box.xmax ) );

  00044	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  0004e	51		 push	 ecx
  0004f	f3 0f 10 44 01
	14		 movss	 xmm0, DWORD PTR [ecx+eax+20]
  00055	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005a	e8 00 00 00 00	 call	 ?fabs@@YGMM@Z		; fabs
  0005f	d9 9d 1c ff ff
	ff		 fstp	 DWORD PTR $T6[ebp]
  00065	6b 55 08 68	 imul	 edx, DWORD PTR _object_index$[ebp], 104
  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  0006e	51		 push	 ecx
  0006f	f3 0f 10 44 10
	10		 movss	 xmm0, DWORD PTR [eax+edx+16]
  00075	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007a	e8 00 00 00 00	 call	 ?fabs@@YGMM@Z		; fabs
  0007f	d9 9d 18 ff ff
	ff		 fstp	 DWORD PTR $T5[ebp]
  00085	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0008b	51		 push	 ecx
  0008c	8d 95 18 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 ??$max@M@std@@YGABMABM0@Z ; std::max<float>
  00098	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0009c	f3 0f 11 45 d4	 movss	 DWORD PTR _xmax$36[ebp], xmm0

; 227  : 		ymax = max ( fabs ( objects_3d_data[object_index].bounding_box.ymin ), fabs ( objects_3d_data[object_index].bounding_box.ymax ) );

  000a1	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  000a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  000ab	51		 push	 ecx
  000ac	f3 0f 10 44 01
	1c		 movss	 xmm0, DWORD PTR [ecx+eax+28]
  000b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b7	e8 00 00 00 00	 call	 ?fabs@@YGMM@Z		; fabs
  000bc	d9 9d 14 ff ff
	ff		 fstp	 DWORD PTR $T4[ebp]
  000c2	6b 55 08 68	 imul	 edx, DWORD PTR _object_index$[ebp], 104
  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  000cb	51		 push	 ecx
  000cc	f3 0f 10 44 10
	18		 movss	 xmm0, DWORD PTR [eax+edx+24]
  000d2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d7	e8 00 00 00 00	 call	 ?fabs@@YGMM@Z		; fabs
  000dc	d9 9d 10 ff ff
	ff		 fstp	 DWORD PTR $T3[ebp]
  000e2	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000e8	51		 push	 ecx
  000e9	8d 95 10 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  000ef	52		 push	 edx
  000f0	e8 00 00 00 00	 call	 ??$max@M@std@@YGABMABM0@Z ; std::max<float>
  000f5	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000f9	f3 0f 11 45 d0	 movss	 DWORD PTR _ymax$35[ebp], xmm0

; 228  : 		zmax = max ( fabs ( objects_3d_data[object_index].bounding_box.zmin ), fabs ( objects_3d_data[object_index].bounding_box.zmax ) );

  000fe	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00102	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00108	51		 push	 ecx
  00109	f3 0f 10 44 01
	24		 movss	 xmm0, DWORD PTR [ecx+eax+36]
  0010f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00114	e8 00 00 00 00	 call	 ?fabs@@YGMM@Z		; fabs
  00119	d9 9d 0c ff ff
	ff		 fstp	 DWORD PTR $T2[ebp]
  0011f	6b 55 08 68	 imul	 edx, DWORD PTR _object_index$[ebp], 104
  00123	a1 00 00 00 00	 mov	 eax, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00128	51		 push	 ecx
  00129	f3 0f 10 44 10
	20		 movss	 xmm0, DWORD PTR [eax+edx+32]
  0012f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00134	e8 00 00 00 00	 call	 ?fabs@@YGMM@Z		; fabs
  00139	d9 9d 08 ff ff
	ff		 fstp	 DWORD PTR $T1[ebp]
  0013f	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00145	51		 push	 ecx
  00146	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0014c	52		 push	 edx
  0014d	e8 00 00 00 00	 call	 ??$max@M@std@@YGABMABM0@Z ; std::max<float>
  00152	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00156	f3 0f 11 45 cc	 movss	 DWORD PTR _zmax$34[ebp], xmm0

; 229  : 
; 230  : 		for ( count = 0; count < number_of_waypoint_nodes; count++ )

  0015b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00162	eb 09		 jmp	 SHORT $LN4@parse_wayp
$LN2@parse_wayp:
  00164	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00167	83 c0 01	 add	 eax, 1
  0016a	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN4@parse_wayp:
  0016d	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00170	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  00176	0f 8d 1c 02 00
	00		 jge	 $LN3@parse_wayp

; 231  : 		{
; 232  : 	
; 233  : 			int
; 234  : 				loop;
; 235  : 	
; 236  : 			waypoint_nodes[count].tree_depth = -1;

  0017c	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00183	c7 80 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax], -1

; 237  : 			waypoint_nodes[count].tree_number = -1;

  0018d	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00194	c7 80 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+4], -1

; 238  : 			waypoint_nodes[count].node_index = -1;

  0019e	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  001a5	c7 80 08 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+8], -1

; 239  : 			waypoint_nodes[count].number_of_children = 0;

  001af	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  001b6	c7 80 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+12], 0

; 240  : 			waypoint_nodes[count].number_of_parents = 0;

  001c0	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  001c7	c7 80 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+16], 0

; 241  : 			waypoint_nodes[count].primary = FALSE;

  001d1	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  001d8	c7 80 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+20], 0

; 242  : 			waypoint_nodes[count].start = FALSE;

  001e2	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  001e9	c7 80 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+24], 0

; 243  : 			waypoint_nodes[count].possible_start = FALSE;

  001f3	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  001fa	c7 80 1c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+28], 0

; 244  : 			waypoint_nodes[count].references = 0;

  00204	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0020b	c7 80 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+32], 0

; 245  : 			waypoint_nodes[count].in_route = FALSE;

  00215	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0021c	c7 80 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+36], 0

; 246  : 			waypoint_nodes[count].processed = FALSE;

  00226	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0022d	c7 80 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+40], 0

; 247  : 			waypoint_nodes[count].position.x = objects_3d_data[object_index].points[count].x;

  00237	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  0023b	6b 4d f8 06	 imul	 ecx, DWORD PTR _count$[ebp], 6
  0023f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00245	8b 44 02 40	 mov	 eax, DWORD PTR [edx+eax+64]
  00249	0f bf 0c 08	 movsx	 ecx, WORD PTR [eax+ecx]
  0024d	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00251	69 55 f8 f8 00
	00 00		 imul	 edx, DWORD PTR _count$[ebp], 248
  00258	f3 0f 11 82 2c
	00 00 00	 movss	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[edx+44], xmm0

; 248  : 			waypoint_nodes[count].position.y = objects_3d_data[object_index].points[count].y;

  00260	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00264	6b 4d f8 06	 imul	 ecx, DWORD PTR _count$[ebp], 6
  00268	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  0026e	8b 44 02 40	 mov	 eax, DWORD PTR [edx+eax+64]
  00272	0f bf 4c 08 02	 movsx	 ecx, WORD PTR [eax+ecx+2]
  00277	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0027b	69 55 f8 f8 00
	00 00		 imul	 edx, DWORD PTR _count$[ebp], 248
  00282	f3 0f 11 82 30
	00 00 00	 movss	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[edx+48], xmm0

; 249  : 			waypoint_nodes[count].position.z = objects_3d_data[object_index].points[count].z;

  0028a	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  0028e	6b 4d f8 06	 imul	 ecx, DWORD PTR _count$[ebp], 6
  00292	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00298	8b 44 02 40	 mov	 eax, DWORD PTR [edx+eax+64]
  0029c	0f bf 4c 08 04	 movsx	 ecx, WORD PTR [eax+ecx+4]
  002a1	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  002a5	69 55 f8 f8 00
	00 00		 imul	 edx, DWORD PTR _count$[ebp], 248
  002ac	f3 0f 11 82 34
	00 00 00	 movss	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[edx+52], xmm0

; 250  : 
; 251  : 			waypoint_nodes[count].position.x *= xmax / 32767;

  002b4	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  002bb	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _xmax$36[ebp]
  002c0	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46fffe00
  002c8	f3 0f 59 80 2c
	00 00 00	 mulss	 xmm0, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+44]
  002d0	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _count$[ebp], 248
  002d7	f3 0f 11 81 2c
	00 00 00	 movss	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[ecx+44], xmm0

; 252  : 			waypoint_nodes[count].position.y *= ymax / 32767;

  002df	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  002e6	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _ymax$35[ebp]
  002eb	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46fffe00
  002f3	f3 0f 59 80 30
	00 00 00	 mulss	 xmm0, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+48]
  002fb	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _count$[ebp], 248
  00302	f3 0f 11 81 30
	00 00 00	 movss	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[ecx+48], xmm0

; 253  : 			waypoint_nodes[count].position.z *= zmax / 32767;

  0030a	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00311	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _zmax$34[ebp]
  00316	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46fffe00
  0031e	f3 0f 59 80 34
	00 00 00	 mulss	 xmm0, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+52]
  00326	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _count$[ebp], 248
  0032d	f3 0f 11 81 34
	00 00 00	 movss	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[ecx+52], xmm0

; 254  : 	
; 255  : 			for ( loop = 0; loop < MAX_WAYPOINT_LINKS; loop++ )

  00335	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _loop$33[ebp], 0
  0033c	eb 09		 jmp	 SHORT $LN7@parse_wayp
$LN5@parse_wayp:
  0033e	8b 45 c8	 mov	 eax, DWORD PTR _loop$33[ebp]
  00341	83 c0 01	 add	 eax, 1
  00344	89 45 c8	 mov	 DWORD PTR _loop$33[ebp], eax
$LN7@parse_wayp:
  00347	83 7d c8 18	 cmp	 DWORD PTR _loop$33[ebp], 24 ; 00000018H
  0034b	7d 17		 jge	 SHORT $LN6@parse_wayp

; 256  : 			{
; 257  : 	
; 258  : 				waypoint_nodes[count].parents[loop] = NULL;

  0034d	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00354	8b 4d c8	 mov	 ecx, DWORD PTR _loop$33[ebp]
  00357	c7 84 88 38 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+ecx*4+56], 0

; 259  : 			}

  00362	eb da		 jmp	 SHORT $LN5@parse_wayp
$LN6@parse_wayp:

; 260  : 	
; 261  : 			for ( loop = 0; loop < MAX_WAYPOINT_LINKS; loop++ )

  00364	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _loop$33[ebp], 0
  0036b	eb 09		 jmp	 SHORT $LN10@parse_wayp
$LN8@parse_wayp:
  0036d	8b 45 c8	 mov	 eax, DWORD PTR _loop$33[ebp]
  00370	83 c0 01	 add	 eax, 1
  00373	89 45 c8	 mov	 DWORD PTR _loop$33[ebp], eax
$LN10@parse_wayp:
  00376	83 7d c8 18	 cmp	 DWORD PTR _loop$33[ebp], 24 ; 00000018H
  0037a	7d 17		 jge	 SHORT $LN9@parse_wayp

; 262  : 			{
; 263  : 	
; 264  : 				waypoint_nodes[count].children[loop] = NULL;

  0037c	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00383	8b 4d c8	 mov	 ecx, DWORD PTR _loop$33[ebp]
  00386	c7 84 88 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+ecx*4+152], 0

; 265  : 			}

  00391	eb da		 jmp	 SHORT $LN8@parse_wayp
$LN9@parse_wayp:

; 266  : 		}

  00393	e9 cc fd ff ff	 jmp	 $LN2@parse_wayp
$LN3@parse_wayp:

; 267  : 	}
; 268  : 
; 269  : 	//
; 270  : 	// Set the attributes on each node
; 271  : 	//
; 272  : 
; 273  : 	surface_point_refs = objects_3d_data[object_index].surface_points;

  00398	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  0039c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  003a2	8b 54 01 5c	 mov	 edx, DWORD PTR [ecx+eax+92]
  003a6	89 55 dc	 mov	 DWORD PTR _surface_point_refs$[ebp], edx

; 274  : 
; 275  : 	point_refs = objects_3d_data[object_index].object_faces_point_plain_list;

  003a9	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  003ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  003b3	8b 54 01 4c	 mov	 edx, DWORD PTR [ecx+eax+76]
  003b7	89 55 e0	 mov	 DWORD PTR _point_refs$[ebp], edx

; 276  : 
; 277  : 	faces = objects_3d_data[object_index].faces;

  003ba	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  003be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  003c4	8b 54 01 44	 mov	 edx, DWORD PTR [ecx+eax+68]
  003c8	89 55 d8	 mov	 DWORD PTR _faces$[ebp], edx

; 278  : 
; 279  : 	number_of_primary_nodes = 0;

  003cb	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _number_of_primary_nodes$[ebp], 0

; 280  : 
; 281  : 	for ( surface = 0; surface < objects_3d_data[object_index].number_of_surfaces; surface++ )

  003d2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _surface$[ebp], 0
  003d9	eb 09		 jmp	 SHORT $LN13@parse_wayp
$LN11@parse_wayp:
  003db	8b 45 fc	 mov	 eax, DWORD PTR _surface$[ebp]
  003de	83 c0 01	 add	 eax, 1
  003e1	89 45 fc	 mov	 DWORD PTR _surface$[ebp], eax
$LN13@parse_wayp:
  003e4	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  003e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  003ee	0f b7 54 01 06	 movzx	 edx, WORD PTR [ecx+eax+6]
  003f3	39 55 fc	 cmp	 DWORD PTR _surface$[ebp], edx
  003f6	0f 8d 27 02 00
	00		 jge	 $LN12@parse_wayp

; 282  : 	{
; 283  : 
; 284  : 		int
; 285  : 			number_of_surface_points;
; 286  : 
; 287  : 		ASSERT ( !objects_3d_data[object_index].surfaces[surface].polygons );

  003fc	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00400	8b 4d fc	 mov	 ecx, DWORD PTR _surface$[ebp]
  00403	c1 e1 04	 shl	 ecx, 4
  00406	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  0040c	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  00410	66 8b 0c 08	 mov	 cx, WORD PTR [eax+ecx]
  00414	66 83 e1 01	 and	 cx, 1
  00418	0f b7 d1	 movzx	 edx, cx
  0041b	85 d2		 test	 edx, edx
  0041d	74 18		 je	 SHORT $LN67@parse_wayp
  0041f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??parse_waypoint_routes_from_object@@YGXHHPAUVEC3D@@@Z@4JA
  00424	83 c0 60	 add	 eax, 96			; 00000060H
  00427	50		 push	 eax
  00428	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@BMNFJBIG@c?3?2users?2nhv90?2projects?2eech?2ap@
  0042d	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@EFLHHJMA@?$CBobjects_3d_data?$FLobject_index?$FN?4@
  00432	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN67@parse_wayp:

; 288  : 
; 289  : 		number_of_surface_points = objects_3d_data[object_index].surfaces[surface].number_of_points;

  00437	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  0043b	8b 4d fc	 mov	 ecx, DWORD PTR _surface$[ebp]
  0043e	c1 e1 04	 shl	 ecx, 4
  00441	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00447	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  0044b	0f b6 4c 08 03	 movzx	 ecx, BYTE PTR [eax+ecx+3]
  00450	89 4d c4	 mov	 DWORD PTR _number_of_surface_points$32[ebp], ecx

; 290  : 
; 291  : 		if ( number_of_surface_points == 0 )

  00453	83 7d c4 00	 cmp	 DWORD PTR _number_of_surface_points$32[ebp], 0
  00457	75 07		 jne	 SHORT $LN68@parse_wayp

; 292  : 		{
; 293  : 
; 294  : 			number_of_surface_points = 256;

  00459	c7 45 c4 00 01
	00 00		 mov	 DWORD PTR _number_of_surface_points$32[ebp], 256 ; 00000100H
$LN68@parse_wayp:

; 295  : 		}
; 296  : 
; 297  : 		for ( count = 0; count < objects_3d_data[object_index].surfaces[surface].number_of_faces; count++ )

  00460	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00467	eb 09		 jmp	 SHORT $LN16@parse_wayp
$LN14@parse_wayp:
  00469	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0046c	83 c0 01	 add	 eax, 1
  0046f	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN16@parse_wayp:
  00472	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00476	8b 4d fc	 mov	 ecx, DWORD PTR _surface$[ebp]
  00479	c1 e1 04	 shl	 ecx, 4
  0047c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00482	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  00486	0f b7 4c 08 08	 movzx	 ecx, WORD PTR [eax+ecx+8]
  0048b	39 4d f8	 cmp	 DWORD PTR _count$[ebp], ecx
  0048e	0f 8d 7e 01 00
	00		 jge	 $LN15@parse_wayp

; 298  : 		{
; 299  : 
; 300  : 			int
; 301  : 				point0,
; 302  : 				point1;
; 303  : 
; 304  : 			//
; 305  : 			// Add the point reference counts
; 306  : 			//
; 307  : 
; 308  : 			point0 = surface_point_refs[ point_refs[0].point ].point;

  00494	b8 01 00 00 00	 mov	 eax, 1
  00499	6b c8 00	 imul	 ecx, eax, 0
  0049c	8b 55 e0	 mov	 edx, DWORD PTR _point_refs$[ebp]
  0049f	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  004a3	8b 4d dc	 mov	 ecx, DWORD PTR _surface_point_refs$[ebp]
  004a6	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  004aa	89 55 c0	 mov	 DWORD PTR _point0$31[ebp], edx

; 309  : 			point1 = surface_point_refs[ point_refs[1].point ].point;

  004ad	b8 01 00 00 00	 mov	 eax, 1
  004b2	c1 e0 00	 shl	 eax, 0
  004b5	8b 4d e0	 mov	 ecx, DWORD PTR _point_refs$[ebp]
  004b8	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  004bc	8b 45 dc	 mov	 eax, DWORD PTR _surface_point_refs$[ebp]
  004bf	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  004c3	89 4d bc	 mov	 DWORD PTR _point1$30[ebp], ecx

; 310  : 
; 311  : 			waypoint_nodes[point0].references++;

  004c6	69 45 c0 f8 00
	00 00		 imul	 eax, DWORD PTR _point0$31[ebp], 248
  004cd	8b 88 20 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+32]
  004d3	83 c1 01	 add	 ecx, 1
  004d6	69 55 c0 f8 00
	00 00		 imul	 edx, DWORD PTR _point0$31[ebp], 248
  004dd	89 8a 20 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[edx+32], ecx

; 312  : 			waypoint_nodes[point1].references++;

  004e3	69 45 bc f8 00
	00 00		 imul	 eax, DWORD PTR _point1$30[ebp], 248
  004ea	8b 88 20 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+32]
  004f0	83 c1 01	 add	 ecx, 1
  004f3	69 55 bc f8 00
	00 00		 imul	 edx, DWORD PTR _point1$30[ebp], 248
  004fa	89 8a 20 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[edx+32], ecx

; 313  : 
; 314  : 			//
; 315  : 			// Set attributes on the nodes
; 316  : 			//
; 317  : 
; 318  : 			if (	( objects_3d_data[object_index].surfaces[surface].green == 0 ) &&
; 319  : 					( objects_3d_data[object_index].surfaces[surface].blue == 0 ) &&

  00500	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00504	8b 4d fc	 mov	 ecx, DWORD PTR _surface$[ebp]
  00507	c1 e1 04	 shl	 ecx, 4
  0050a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00510	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  00514	0f b6 4c 08 0d	 movzx	 ecx, BYTE PTR [eax+ecx+13]
  00519	85 c9		 test	 ecx, ecx
  0051b	75 61		 jne	 SHORT $LN69@parse_wayp
  0051d	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00521	8b 4d fc	 mov	 ecx, DWORD PTR _surface$[ebp]
  00524	c1 e1 04	 shl	 ecx, 4
  00527	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  0052d	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  00531	0f b6 4c 08 0c	 movzx	 ecx, BYTE PTR [eax+ecx+12]
  00536	85 c9		 test	 ecx, ecx
  00538	75 44		 jne	 SHORT $LN69@parse_wayp
  0053a	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  0053e	8b 4d fc	 mov	 ecx, DWORD PTR _surface$[ebp]
  00541	c1 e1 04	 shl	 ecx, 4
  00544	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  0054a	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  0054e	0f b6 4c 08 0e	 movzx	 ecx, BYTE PTR [eax+ecx+14]
  00553	85 c9		 test	 ecx, ecx
  00555	75 27		 jne	 SHORT $LN69@parse_wayp

; 320  : 					( objects_3d_data[object_index].surfaces[surface].red == 0 ) )
; 321  : 			{
; 322  : 
; 323  : 				waypoint_nodes[point0].possible_start = TRUE;

  00557	69 45 c0 f8 00
	00 00		 imul	 eax, DWORD PTR _point0$31[ebp], 248
  0055e	c7 80 1c 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+28], 1

; 324  : 				waypoint_nodes[point1].possible_start = TRUE;

  00568	69 45 bc f8 00
	00 00		 imul	 eax, DWORD PTR _point1$30[ebp], 248
  0056f	c7 80 1c 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+28], 1

; 325  : 			}
; 326  : 			else if (	( objects_3d_data[object_index].surfaces[surface].green == 255 ) &&

  00579	e9 86 00 00 00	 jmp	 $LN71@parse_wayp
$LN69@parse_wayp:

; 327  : 							( objects_3d_data[object_index].surfaces[surface].blue == 0 ) &&

  0057e	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00582	8b 4d fc	 mov	 ecx, DWORD PTR _surface$[ebp]
  00585	c1 e1 04	 shl	 ecx, 4
  00588	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  0058e	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  00592	0f b6 4c 08 0d	 movzx	 ecx, BYTE PTR [eax+ecx+13]
  00597	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0059d	75 65		 jne	 SHORT $LN71@parse_wayp
  0059f	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  005a3	8b 4d fc	 mov	 ecx, DWORD PTR _surface$[ebp]
  005a6	c1 e1 04	 shl	 ecx, 4
  005a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  005af	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  005b3	0f b6 4c 08 0c	 movzx	 ecx, BYTE PTR [eax+ecx+12]
  005b8	85 c9		 test	 ecx, ecx
  005ba	75 48		 jne	 SHORT $LN71@parse_wayp
  005bc	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  005c0	8b 4d fc	 mov	 ecx, DWORD PTR _surface$[ebp]
  005c3	c1 e1 04	 shl	 ecx, 4
  005c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  005cc	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  005d0	0f b6 4c 08 0e	 movzx	 ecx, BYTE PTR [eax+ecx+14]
  005d5	85 c9		 test	 ecx, ecx
  005d7	75 2b		 jne	 SHORT $LN71@parse_wayp

; 328  : 							( objects_3d_data[object_index].surfaces[surface].red == 0 ) )
; 329  : 			{
; 330  : 
; 331  : 				number_of_primary_nodes++;

  005d9	8b 45 f4	 mov	 eax, DWORD PTR _number_of_primary_nodes$[ebp]
  005dc	83 c0 01	 add	 eax, 1
  005df	89 45 f4	 mov	 DWORD PTR _number_of_primary_nodes$[ebp], eax

; 332  : 
; 333  : 				waypoint_nodes[point0].primary = TRUE;

  005e2	69 45 c0 f8 00
	00 00		 imul	 eax, DWORD PTR _point0$31[ebp], 248
  005e9	c7 80 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+20], 1

; 334  : 				waypoint_nodes[point1].primary = TRUE;

  005f3	69 45 bc f8 00
	00 00		 imul	 eax, DWORD PTR _point1$30[ebp], 248
  005fa	c7 80 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+20], 1
$LN71@parse_wayp:

; 335  : 			}
; 336  : 
; 337  : 			point_refs += 2;

  00604	8b 45 e0	 mov	 eax, DWORD PTR _point_refs$[ebp]
  00607	83 c0 02	 add	 eax, 2
  0060a	89 45 e0	 mov	 DWORD PTR _point_refs$[ebp], eax

; 338  : 		}

  0060d	e9 57 fe ff ff	 jmp	 $LN14@parse_wayp
$LN15@parse_wayp:

; 339  : 
; 340  : 		surface_point_refs += number_of_surface_points;

  00612	8b 45 c4	 mov	 eax, DWORD PTR _number_of_surface_points$32[ebp]
  00615	8b 4d dc	 mov	 ecx, DWORD PTR _surface_point_refs$[ebp]
  00618	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0061b	89 55 dc	 mov	 DWORD PTR _surface_point_refs$[ebp], edx

; 341  : 	}

  0061e	e9 b8 fd ff ff	 jmp	 $LN11@parse_wayp
$LN12@parse_wayp:

; 342  : 
; 343  : //	ASSERT ( number_of_primary_nodes );
; 344  : 
; 345  : 	//
; 346  : 	// Now go through setting up the start nodes
; 347  : 	//
; 348  : 
; 349  : 	number_of_nodes_left = number_of_waypoint_nodes;

  00623	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  00628	89 45 f0	 mov	 DWORD PTR _number_of_nodes_left$[ebp], eax

; 350  : 
; 351  : 	number_of_waypoint_starting_nodes = 0;

  0062b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?number_of_waypoint_starting_nodes@@3HA, 0 ; number_of_waypoint_starting_nodes

; 352  : 
; 353  : 	for ( count = 0; count < number_of_waypoint_nodes; count++ )

  00635	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  0063c	eb 09		 jmp	 SHORT $LN19@parse_wayp
$LN17@parse_wayp:
  0063e	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00641	83 c0 01	 add	 eax, 1
  00644	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN19@parse_wayp:
  00647	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0064a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  00650	0f 8d c5 00 00
	00		 jge	 $LN18@parse_wayp

; 354  : 	{
; 355  : 
; 356  : 		if ( ( waypoint_nodes[count].possible_start ) && ( waypoint_nodes[count].references == 1 ) )

  00656	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0065d	83 b8 1c 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+28], 0
  00664	0f 84 ac 00 00
	00		 je	 $LN72@parse_wayp
  0066a	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00671	83 b8 20 00 00
	00 01		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+32], 1
  00678	0f 85 98 00 00
	00		 jne	 $LN72@parse_wayp

; 357  : 		{
; 358  : 
; 359  : 			waypoint_nodes[count].start = TRUE;

  0067e	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00685	c7 80 18 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+24], 1

; 360  : 			waypoint_nodes[count].in_route = TRUE;

  0068f	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00696	c7 80 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+36], 1

; 361  : 			waypoint_nodes[count].tree_depth = 0;

  006a0	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  006a7	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax], 0

; 362  : 			waypoint_nodes[count].tree_number = number_of_waypoint_starting_nodes;

  006b1	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  006b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?number_of_waypoint_starting_nodes@@3HA ; number_of_waypoint_starting_nodes
  006be	89 88 04 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+4], ecx

; 363  : 
; 364  : 			ASSERT ( number_of_waypoint_starting_nodes < MAX_WAYPOINT_STARTS );

  006c4	83 3d 00 00 00
	00 18		 cmp	 DWORD PTR ?number_of_waypoint_starting_nodes@@3HA, 24 ; number_of_waypoint_starting_nodes, 00000018H
  006cb	7c 1a		 jl	 SHORT $LN73@parse_wayp
  006cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??parse_waypoint_routes_from_object@@YGXHHPAUVEC3D@@@Z@4JA
  006d2	05 ad 00 00 00	 add	 eax, 173		; 000000adH
  006d7	50		 push	 eax
  006d8	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@BMNFJBIG@c?3?2users?2nhv90?2projects?2eech?2ap@
  006dd	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@JHDKHNDO@number_of_waypoint_starting_nod@
  006e2	e8 00 00 00 00	 call	 ?process_assert@@YGXPBD0H@Z ; process_assert
$LN73@parse_wayp:

; 365  : 
; 366  : 			waypoint_starting_nodes[number_of_waypoint_starting_nodes] = &waypoint_nodes[count];

  006e7	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  006ee	05 00 00 00 00	 add	 eax, OFFSET ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A ; waypoint_nodes
  006f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?number_of_waypoint_starting_nodes@@3HA ; number_of_waypoint_starting_nodes
  006f9	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[ecx*4], eax

; 367  : 
; 368  : 			number_of_waypoint_starting_nodes++;

  00700	a1 00 00 00 00	 mov	 eax, DWORD PTR ?number_of_waypoint_starting_nodes@@3HA ; number_of_waypoint_starting_nodes
  00705	83 c0 01	 add	 eax, 1
  00708	a3 00 00 00 00	 mov	 DWORD PTR ?number_of_waypoint_starting_nodes@@3HA, eax ; number_of_waypoint_starting_nodes

; 369  : 
; 370  : 			number_of_nodes_left--;

  0070d	8b 45 f0	 mov	 eax, DWORD PTR _number_of_nodes_left$[ebp]
  00710	83 e8 01	 sub	 eax, 1
  00713	89 45 f0	 mov	 DWORD PTR _number_of_nodes_left$[ebp], eax
$LN72@parse_wayp:

; 371  : 		}
; 372  : 	}

  00716	e9 23 ff ff ff	 jmp	 $LN17@parse_wayp
$LN18@parse_wayp:

; 373  : 
; 374  : 	//
; 375  : 	// Iteratively add in nodes until we have populated the trees with all the *primary* nodes
; 376  : 	//
; 377  : 
; 378  : 	maximum_tree_depth = 0;

  0071b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _maximum_tree_depth$[ebp], 0

; 379  : 
; 380  : 	number_of_primary_nodes_left = 0;

  00722	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _number_of_primary_nodes_left$[ebp], 0

; 381  : 
; 382  : 	for ( count = 0; count < number_of_waypoint_nodes; count++ )

  00729	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00730	eb 09		 jmp	 SHORT $LN22@parse_wayp
$LN20@parse_wayp:
  00732	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00735	83 c0 01	 add	 eax, 1
  00738	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN22@parse_wayp:
  0073b	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0073e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  00744	7d 2b		 jge	 SHORT $LN21@parse_wayp

; 383  : 	{
; 384  : 
; 385  : 		if ( ( waypoint_nodes[count].primary ) && ( !waypoint_nodes[count].in_route ) )

  00746	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0074d	83 b8 14 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+20], 0
  00754	74 19		 je	 SHORT $LN74@parse_wayp
  00756	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  0075d	83 b8 24 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+36], 0
  00764	75 09		 jne	 SHORT $LN74@parse_wayp

; 386  : 		{
; 387  : 
; 388  : 			number_of_primary_nodes_left++;

  00766	8b 45 ec	 mov	 eax, DWORD PTR _number_of_primary_nodes_left$[ebp]
  00769	83 c0 01	 add	 eax, 1
  0076c	89 45 ec	 mov	 DWORD PTR _number_of_primary_nodes_left$[ebp], eax
$LN74@parse_wayp:

; 389  : 		}
; 390  : 	}

  0076f	eb c1		 jmp	 SHORT $LN20@parse_wayp
$LN21@parse_wayp:

; 391  : 
; 392  : 	while ( number_of_primary_nodes_left )

  00771	83 7d ec 00	 cmp	 DWORD PTR _number_of_primary_nodes_left$[ebp], 0
  00775	0f 84 e8 02 00
	00		 je	 $LN24@parse_wayp

; 393  : 	{
; 394  : 
; 395  : 		surface_point_refs = objects_3d_data[object_index].surface_points;

  0077b	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  0077f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00785	8b 54 01 5c	 mov	 edx, DWORD PTR [ecx+eax+92]
  00789	89 55 dc	 mov	 DWORD PTR _surface_point_refs$[ebp], edx

; 396  : 	
; 397  : 		point_refs = objects_3d_data[object_index].object_faces_point_plain_list;

  0078c	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00790	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00796	8b 54 01 4c	 mov	 edx, DWORD PTR [ecx+eax+76]
  0079a	89 55 e0	 mov	 DWORD PTR _point_refs$[ebp], edx

; 398  : 	
; 399  : 		for ( surface = 0; surface < objects_3d_data[object_index].number_of_surfaces; surface++ )

  0079d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _surface$[ebp], 0
  007a4	eb 09		 jmp	 SHORT $LN27@parse_wayp
$LN25@parse_wayp:
  007a6	8b 45 fc	 mov	 eax, DWORD PTR _surface$[ebp]
  007a9	83 c0 01	 add	 eax, 1
  007ac	89 45 fc	 mov	 DWORD PTR _surface$[ebp], eax
$LN27@parse_wayp:
  007af	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  007b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  007b9	0f b7 54 01 06	 movzx	 edx, WORD PTR [ecx+eax+6]
  007be	39 55 fc	 cmp	 DWORD PTR _surface$[ebp], edx
  007c1	0f 8d 97 02 00
	00		 jge	 $LN26@parse_wayp

; 400  : 		{
; 401  : 	
; 402  : 			int
; 403  : 				number_of_surface_points;
; 404  : 	
; 405  : 			number_of_surface_points = objects_3d_data[object_index].surfaces[surface].number_of_points;

  007c7	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  007cb	8b 4d fc	 mov	 ecx, DWORD PTR _surface$[ebp]
  007ce	c1 e1 04	 shl	 ecx, 4
  007d1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  007d7	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  007db	0f b6 4c 08 03	 movzx	 ecx, BYTE PTR [eax+ecx+3]
  007e0	89 4d b8	 mov	 DWORD PTR _number_of_surface_points$29[ebp], ecx

; 406  : 	
; 407  : 			if ( number_of_surface_points == 0 )

  007e3	83 7d b8 00	 cmp	 DWORD PTR _number_of_surface_points$29[ebp], 0
  007e7	75 07		 jne	 SHORT $LN75@parse_wayp

; 408  : 			{
; 409  : 	
; 410  : 				number_of_surface_points = 256;

  007e9	c7 45 b8 00 01
	00 00		 mov	 DWORD PTR _number_of_surface_points$29[ebp], 256 ; 00000100H
$LN75@parse_wayp:

; 411  : 			}
; 412  : 	
; 413  : 			for ( count = 0; count < objects_3d_data[object_index].surfaces[surface].number_of_faces; count++ )

  007f0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  007f7	eb 09		 jmp	 SHORT $LN30@parse_wayp
$LN28@parse_wayp:
  007f9	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  007fc	83 c0 01	 add	 eax, 1
  007ff	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN30@parse_wayp:
  00802	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00806	8b 4d fc	 mov	 ecx, DWORD PTR _surface$[ebp]
  00809	c1 e1 04	 shl	 ecx, 4
  0080c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00812	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  00816	0f b7 4c 08 08	 movzx	 ecx, WORD PTR [eax+ecx+8]
  0081b	39 4d f8	 cmp	 DWORD PTR _count$[ebp], ecx
  0081e	0f 8d 29 02 00
	00		 jge	 $LN29@parse_wayp

; 414  : 			{
; 415  : 	
; 416  : 				int
; 417  : 					point0,
; 418  : 					point1,
; 419  : 					add_node_flag,
; 420  : 					parent,
; 421  : 					child;
; 422  : 	
; 423  : 				point0 = surface_point_refs[ point_refs[0].point ].point;

  00824	b8 01 00 00 00	 mov	 eax, 1
  00829	6b c8 00	 imul	 ecx, eax, 0
  0082c	8b 55 e0	 mov	 edx, DWORD PTR _point_refs$[ebp]
  0082f	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00833	8b 4d dc	 mov	 ecx, DWORD PTR _surface_point_refs$[ebp]
  00836	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0083a	89 55 b4	 mov	 DWORD PTR _point0$28[ebp], edx

; 424  : 				point1 = surface_point_refs[ point_refs[1].point ].point;

  0083d	b8 01 00 00 00	 mov	 eax, 1
  00842	c1 e0 00	 shl	 eax, 0
  00845	8b 4d e0	 mov	 ecx, DWORD PTR _point_refs$[ebp]
  00848	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0084c	8b 45 dc	 mov	 eax, DWORD PTR _surface_point_refs$[ebp]
  0084f	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00853	89 4d b0	 mov	 DWORD PTR _point1$27[ebp], ecx

; 425  : 	
; 426  : 				//
; 427  : 				// If one node referenced is in the route system & one isn't - add the one that isn't
; 428  : 				//
; 429  : 	
; 430  : 				add_node_flag = FALSE;

  00856	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _add_node_flag$26[ebp], 0

; 431  : 	
; 432  : 				if ( ( waypoint_nodes[point0].in_route ) && ( !waypoint_nodes[point1].in_route ) )

  0085d	69 45 b4 f8 00
	00 00		 imul	 eax, DWORD PTR _point0$28[ebp], 248
  00864	83 b8 24 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+36], 0
  0086b	74 55		 je	 SHORT $LN76@parse_wayp
  0086d	69 45 b0 f8 00
	00 00		 imul	 eax, DWORD PTR _point1$27[ebp], 248
  00874	83 b8 24 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+36], 0
  0087b	75 45		 jne	 SHORT $LN76@parse_wayp

; 433  : 				{
; 434  : 	
; 435  : 					if (	( ( waypoint_nodes[point0].primary ) || ( waypoint_nodes[point0].start ) ) &&

  0087d	69 45 b4 f8 00
	00 00		 imul	 eax, DWORD PTR _point0$28[ebp], 248
  00884	83 b8 14 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+20], 0
  0088b	75 10		 jne	 SHORT $LN79@parse_wayp
  0088d	69 45 b4 f8 00
	00 00		 imul	 eax, DWORD PTR _point0$28[ebp], 248
  00894	83 b8 18 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+24], 0
  0089b	74 23		 je	 SHORT $LN78@parse_wayp
$LN79@parse_wayp:
  0089d	69 45 b0 f8 00
	00 00		 imul	 eax, DWORD PTR _point1$27[ebp], 248
  008a4	83 b8 14 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+20], 0
  008ab	74 13		 je	 SHORT $LN78@parse_wayp

; 436  : 							( waypoint_nodes[point1].primary ) )
; 437  : 					{
; 438  : 	
; 439  : 						add_node_flag = TRUE;

  008ad	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR _add_node_flag$26[ebp], 1

; 440  : 						parent = point0;

  008b4	8b 45 b4	 mov	 eax, DWORD PTR _point0$28[ebp]
  008b7	89 45 a8	 mov	 DWORD PTR _parent$25[ebp], eax

; 441  : 						child = point1;

  008ba	8b 45 b0	 mov	 eax, DWORD PTR _point1$27[ebp]
  008bd	89 45 a4	 mov	 DWORD PTR _child$24[ebp], eax
$LN78@parse_wayp:

; 442  : 					}
; 443  : 				}

  008c0	eb 63		 jmp	 SHORT $LN81@parse_wayp
$LN76@parse_wayp:

; 444  : 				else if ( ( waypoint_nodes[point1].in_route ) && ( !waypoint_nodes[point0].in_route ) )

  008c2	69 45 b0 f8 00
	00 00		 imul	 eax, DWORD PTR _point1$27[ebp], 248
  008c9	83 b8 24 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+36], 0
  008d0	74 53		 je	 SHORT $LN81@parse_wayp
  008d2	69 45 b4 f8 00
	00 00		 imul	 eax, DWORD PTR _point0$28[ebp], 248
  008d9	83 b8 24 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+36], 0
  008e0	75 43		 jne	 SHORT $LN81@parse_wayp

; 445  : 				{
; 446  : 	
; 447  : 					if (	( ( waypoint_nodes[point1].primary ) || ( waypoint_nodes[point1].start ) ) &&

  008e2	69 45 b0 f8 00
	00 00		 imul	 eax, DWORD PTR _point1$27[ebp], 248
  008e9	83 b8 14 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+20], 0
  008f0	75 10		 jne	 SHORT $LN82@parse_wayp
  008f2	69 45 b0 f8 00
	00 00		 imul	 eax, DWORD PTR _point1$27[ebp], 248
  008f9	83 b8 18 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+24], 0
  00900	74 23		 je	 SHORT $LN81@parse_wayp
$LN82@parse_wayp:
  00902	69 45 b4 f8 00
	00 00		 imul	 eax, DWORD PTR _point0$28[ebp], 248
  00909	83 b8 14 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+20], 0
  00910	74 13		 je	 SHORT $LN81@parse_wayp

; 448  : 							( waypoint_nodes[point0].primary ) )
; 449  : 					{
; 450  : 		
; 451  : 						add_node_flag = TRUE;

  00912	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR _add_node_flag$26[ebp], 1

; 452  : 						parent = point1;

  00919	8b 45 b0	 mov	 eax, DWORD PTR _point1$27[ebp]
  0091c	89 45 a8	 mov	 DWORD PTR _parent$25[ebp], eax

; 453  : 						child = point0;

  0091f	8b 45 b4	 mov	 eax, DWORD PTR _point0$28[ebp]
  00922	89 45 a4	 mov	 DWORD PTR _child$24[ebp], eax
$LN81@parse_wayp:

; 454  : 					}
; 455  : 				}
; 456  : 	
; 457  : 				if ( add_node_flag )

  00925	83 7d ac 00	 cmp	 DWORD PTR _add_node_flag$26[ebp], 0
  00929	0f 84 10 01 00
	00		 je	 $LN83@parse_wayp

; 458  : 				{
; 459  : 	
; 460  : 					int
; 461  : 						number_of_children,
; 462  : 						number_of_parents;
; 463  : 	
; 464  : 					number_of_children = waypoint_nodes[parent].number_of_children;

  0092f	69 45 a8 f8 00
	00 00		 imul	 eax, DWORD PTR _parent$25[ebp], 248
  00936	8b 88 0c 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+12]
  0093c	89 4d a0	 mov	 DWORD PTR _number_of_children$23[ebp], ecx

; 465  : 					number_of_parents = waypoint_nodes[child].number_of_parents;

  0093f	69 45 a4 f8 00
	00 00		 imul	 eax, DWORD PTR _child$24[ebp], 248
  00946	8b 88 10 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+16]
  0094c	89 4d 9c	 mov	 DWORD PTR _number_of_parents$22[ebp], ecx

; 466  : 	
; 467  : 					waypoint_nodes[parent].children[number_of_children] = &waypoint_nodes[child];

  0094f	69 45 a4 f8 00
	00 00		 imul	 eax, DWORD PTR _child$24[ebp], 248
  00956	05 00 00 00 00	 add	 eax, OFFSET ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A ; waypoint_nodes
  0095b	69 4d a8 f8 00
	00 00		 imul	 ecx, DWORD PTR _parent$25[ebp], 248
  00962	8b 55 a0	 mov	 edx, DWORD PTR _number_of_children$23[ebp]
  00965	89 84 91 98 00
	00 00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[ecx+edx*4+152], eax

; 468  : 					waypoint_nodes[parent].number_of_children++;

  0096c	69 45 a8 f8 00
	00 00		 imul	 eax, DWORD PTR _parent$25[ebp], 248
  00973	8b 88 0c 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+12]
  00979	83 c1 01	 add	 ecx, 1
  0097c	69 55 a8 f8 00
	00 00		 imul	 edx, DWORD PTR _parent$25[ebp], 248
  00983	89 8a 0c 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[edx+12], ecx

; 469  : 	
; 470  : 					waypoint_nodes[child].parents[number_of_parents] = &waypoint_nodes[parent];

  00989	69 45 a8 f8 00
	00 00		 imul	 eax, DWORD PTR _parent$25[ebp], 248
  00990	05 00 00 00 00	 add	 eax, OFFSET ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A ; waypoint_nodes
  00995	69 4d a4 f8 00
	00 00		 imul	 ecx, DWORD PTR _child$24[ebp], 248
  0099c	8b 55 9c	 mov	 edx, DWORD PTR _number_of_parents$22[ebp]
  0099f	89 84 91 38 00
	00 00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[ecx+edx*4+56], eax

; 471  : 					waypoint_nodes[child].number_of_parents++;

  009a6	69 45 a4 f8 00
	00 00		 imul	 eax, DWORD PTR _child$24[ebp], 248
  009ad	8b 88 10 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+16]
  009b3	83 c1 01	 add	 ecx, 1
  009b6	69 55 a4 f8 00
	00 00		 imul	 edx, DWORD PTR _child$24[ebp], 248
  009bd	89 8a 10 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[edx+16], ecx

; 472  : 					waypoint_nodes[child].in_route = TRUE;

  009c3	69 45 a4 f8 00
	00 00		 imul	 eax, DWORD PTR _child$24[ebp], 248
  009ca	c7 80 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+36], 1

; 473  : 					waypoint_nodes[child].tree_depth = waypoint_nodes[parent].tree_depth+1;

  009d4	69 45 a8 f8 00
	00 00		 imul	 eax, DWORD PTR _parent$25[ebp], 248
  009db	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax]
  009e1	83 c1 01	 add	 ecx, 1
  009e4	69 55 a4 f8 00
	00 00		 imul	 edx, DWORD PTR _child$24[ebp], 248
  009eb	89 8a 00 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[edx], ecx

; 474  : 					waypoint_nodes[child].tree_number = waypoint_nodes[parent].tree_number;

  009f1	69 45 a8 f8 00
	00 00		 imul	 eax, DWORD PTR _parent$25[ebp], 248
  009f8	69 4d a4 f8 00
	00 00		 imul	 ecx, DWORD PTR _child$24[ebp], 248
  009ff	8b 90 04 00 00
	00		 mov	 edx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+4]
  00a05	89 91 04 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[ecx+4], edx

; 475  : 	
; 476  : 					if ( waypoint_nodes[child].tree_depth > maximum_tree_depth )

  00a0b	69 45 a4 f8 00
	00 00		 imul	 eax, DWORD PTR _child$24[ebp], 248
  00a12	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax]
  00a18	3b 4d e8	 cmp	 ecx, DWORD PTR _maximum_tree_depth$[ebp]
  00a1b	7e 10		 jle	 SHORT $LN84@parse_wayp

; 477  : 					{
; 478  : 	
; 479  : 						maximum_tree_depth = waypoint_nodes[child].tree_depth;

  00a1d	69 45 a4 f8 00
	00 00		 imul	 eax, DWORD PTR _child$24[ebp], 248
  00a24	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax]
  00a2a	89 4d e8	 mov	 DWORD PTR _maximum_tree_depth$[ebp], ecx
$LN84@parse_wayp:

; 480  : 					}
; 481  : 	
; 482  : 					number_of_nodes_left--;

  00a2d	8b 45 f0	 mov	 eax, DWORD PTR _number_of_nodes_left$[ebp]
  00a30	83 e8 01	 sub	 eax, 1
  00a33	89 45 f0	 mov	 DWORD PTR _number_of_nodes_left$[ebp], eax

; 483  : 	
; 484  : 					number_of_primary_nodes_left--;

  00a36	8b 45 ec	 mov	 eax, DWORD PTR _number_of_primary_nodes_left$[ebp]
  00a39	83 e8 01	 sub	 eax, 1
  00a3c	89 45 ec	 mov	 DWORD PTR _number_of_primary_nodes_left$[ebp], eax
$LN83@parse_wayp:

; 485  : 				}
; 486  : 	
; 487  : 				point_refs += 2;

  00a3f	8b 45 e0	 mov	 eax, DWORD PTR _point_refs$[ebp]
  00a42	83 c0 02	 add	 eax, 2
  00a45	89 45 e0	 mov	 DWORD PTR _point_refs$[ebp], eax

; 488  : 			}

  00a48	e9 ac fd ff ff	 jmp	 $LN28@parse_wayp
$LN29@parse_wayp:

; 489  : 
; 490  : 			surface_point_refs += number_of_surface_points;

  00a4d	8b 45 b8	 mov	 eax, DWORD PTR _number_of_surface_points$29[ebp]
  00a50	8b 4d dc	 mov	 ecx, DWORD PTR _surface_point_refs$[ebp]
  00a53	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00a56	89 55 dc	 mov	 DWORD PTR _surface_point_refs$[ebp], edx

; 491  : 		}

  00a59	e9 48 fd ff ff	 jmp	 $LN25@parse_wayp
$LN26@parse_wayp:

; 492  : 	}

  00a5e	e9 0e fd ff ff	 jmp	 $LN21@parse_wayp
$LN24@parse_wayp:

; 493  : 
; 494  : 	//
; 495  : 	// Iteratively add in nodes until we have populated the trees with ALL the nodes
; 496  : 	//
; 497  : 
; 498  : 	while ( number_of_nodes_left )

  00a63	83 7d f0 00	 cmp	 DWORD PTR _number_of_nodes_left$[ebp], 0
  00a67	0f 84 85 02 00
	00		 je	 $LN32@parse_wayp

; 499  : 	{
; 500  : 
; 501  : 		surface_point_refs = objects_3d_data[object_index].surface_points;

  00a6d	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00a71	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00a77	8b 54 01 5c	 mov	 edx, DWORD PTR [ecx+eax+92]
  00a7b	89 55 dc	 mov	 DWORD PTR _surface_point_refs$[ebp], edx

; 502  : 	
; 503  : 		point_refs = objects_3d_data[object_index].object_faces_point_plain_list;

  00a7e	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00a82	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00a88	8b 54 01 4c	 mov	 edx, DWORD PTR [ecx+eax+76]
  00a8c	89 55 e0	 mov	 DWORD PTR _point_refs$[ebp], edx

; 504  : 	
; 505  : 		for ( surface = 0; surface < objects_3d_data[object_index].number_of_surfaces; surface++ )

  00a8f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _surface$[ebp], 0
  00a96	eb 09		 jmp	 SHORT $LN35@parse_wayp
$LN33@parse_wayp:
  00a98	8b 45 fc	 mov	 eax, DWORD PTR _surface$[ebp]
  00a9b	83 c0 01	 add	 eax, 1
  00a9e	89 45 fc	 mov	 DWORD PTR _surface$[ebp], eax
$LN35@parse_wayp:
  00aa1	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00aa5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00aab	0f b7 54 01 06	 movzx	 edx, WORD PTR [ecx+eax+6]
  00ab0	39 55 fc	 cmp	 DWORD PTR _surface$[ebp], edx
  00ab3	0f 8d 34 02 00
	00		 jge	 $LN34@parse_wayp

; 506  : 		{
; 507  : 	
; 508  : 			int
; 509  : 				number_of_surface_points;
; 510  : 	
; 511  : 			number_of_surface_points = objects_3d_data[object_index].surfaces[surface].number_of_points;

  00ab9	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00abd	8b 4d fc	 mov	 ecx, DWORD PTR _surface$[ebp]
  00ac0	c1 e1 04	 shl	 ecx, 4
  00ac3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00ac9	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  00acd	0f b6 4c 08 03	 movzx	 ecx, BYTE PTR [eax+ecx+3]
  00ad2	89 4d 98	 mov	 DWORD PTR _number_of_surface_points$21[ebp], ecx

; 512  : 	
; 513  : 			if ( number_of_surface_points == 0 )

  00ad5	83 7d 98 00	 cmp	 DWORD PTR _number_of_surface_points$21[ebp], 0
  00ad9	75 07		 jne	 SHORT $LN85@parse_wayp

; 514  : 			{
; 515  : 	
; 516  : 				number_of_surface_points = 256;

  00adb	c7 45 98 00 01
	00 00		 mov	 DWORD PTR _number_of_surface_points$21[ebp], 256 ; 00000100H
$LN85@parse_wayp:

; 517  : 			}
; 518  : 	
; 519  : 			for ( count = 0; count < objects_3d_data[object_index].surfaces[surface].number_of_faces; count++ )

  00ae2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00ae9	eb 09		 jmp	 SHORT $LN38@parse_wayp
$LN36@parse_wayp:
  00aeb	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00aee	83 c0 01	 add	 eax, 1
  00af1	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN38@parse_wayp:
  00af4	6b 45 08 68	 imul	 eax, DWORD PTR _object_index$[ebp], 104
  00af8	8b 4d fc	 mov	 ecx, DWORD PTR _surface$[ebp]
  00afb	c1 e1 04	 shl	 ecx, 4
  00afe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?objects_3d_data@@3PAUOBJECT_3D@@A ; objects_3d_data
  00b04	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  00b08	0f b7 4c 08 08	 movzx	 ecx, WORD PTR [eax+ecx+8]
  00b0d	39 4d f8	 cmp	 DWORD PTR _count$[ebp], ecx
  00b10	0f 8d c6 01 00
	00		 jge	 $LN37@parse_wayp

; 520  : 			{
; 521  : 	
; 522  : 				int
; 523  : 					point0,
; 524  : 					point1,
; 525  : 					add_node_flag,
; 526  : 					parent,
; 527  : 					child;
; 528  : 	
; 529  : 				point0 = surface_point_refs[ point_refs[0].point ].point;

  00b16	b8 01 00 00 00	 mov	 eax, 1
  00b1b	6b c8 00	 imul	 ecx, eax, 0
  00b1e	8b 55 e0	 mov	 edx, DWORD PTR _point_refs$[ebp]
  00b21	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00b25	8b 4d dc	 mov	 ecx, DWORD PTR _surface_point_refs$[ebp]
  00b28	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00b2c	89 55 94	 mov	 DWORD PTR _point0$20[ebp], edx

; 530  : 				point1 = surface_point_refs[ point_refs[1].point ].point;

  00b2f	b8 01 00 00 00	 mov	 eax, 1
  00b34	c1 e0 00	 shl	 eax, 0
  00b37	8b 4d e0	 mov	 ecx, DWORD PTR _point_refs$[ebp]
  00b3a	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00b3e	8b 45 dc	 mov	 eax, DWORD PTR _surface_point_refs$[ebp]
  00b41	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00b45	89 4d 90	 mov	 DWORD PTR _point1$19[ebp], ecx

; 531  : 	
; 532  : 				//
; 533  : 				// If one node referenced is in the route system & one isn't - add the one that isn't
; 534  : 				//
; 535  : 	
; 536  : 				add_node_flag = FALSE;

  00b48	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _add_node_flag$18[ebp], 0

; 537  : 	
; 538  : 				if ( ( waypoint_nodes[point0].in_route ) && ( !waypoint_nodes[point1].in_route ) )

  00b4f	69 45 94 f8 00
	00 00		 imul	 eax, DWORD PTR _point0$20[ebp], 248
  00b56	83 b8 24 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+36], 0
  00b5d	74 25		 je	 SHORT $LN86@parse_wayp
  00b5f	69 45 90 f8 00
	00 00		 imul	 eax, DWORD PTR _point1$19[ebp], 248
  00b66	83 b8 24 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+36], 0
  00b6d	75 15		 jne	 SHORT $LN86@parse_wayp

; 539  : 				{
; 540  : 	
; 541  : 					add_node_flag = TRUE;

  00b6f	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _add_node_flag$18[ebp], 1

; 542  : 					parent = point0;

  00b76	8b 45 94	 mov	 eax, DWORD PTR _point0$20[ebp]
  00b79	89 45 88	 mov	 DWORD PTR _parent$17[ebp], eax

; 543  : 					child = point1;

  00b7c	8b 45 90	 mov	 eax, DWORD PTR _point1$19[ebp]
  00b7f	89 45 84	 mov	 DWORD PTR _child$16[ebp], eax
  00b82	eb 33		 jmp	 SHORT $LN88@parse_wayp
$LN86@parse_wayp:

; 544  : 				}
; 545  : 				else if ( ( waypoint_nodes[point1].in_route ) && ( !waypoint_nodes[point0].in_route ) )

  00b84	69 45 90 f8 00
	00 00		 imul	 eax, DWORD PTR _point1$19[ebp], 248
  00b8b	83 b8 24 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+36], 0
  00b92	74 23		 je	 SHORT $LN88@parse_wayp
  00b94	69 45 94 f8 00
	00 00		 imul	 eax, DWORD PTR _point0$20[ebp], 248
  00b9b	83 b8 24 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+36], 0
  00ba2	75 13		 jne	 SHORT $LN88@parse_wayp

; 546  : 				{
; 547  : 	
; 548  : 					add_node_flag = TRUE;

  00ba4	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _add_node_flag$18[ebp], 1

; 549  : 					parent = point1;

  00bab	8b 45 90	 mov	 eax, DWORD PTR _point1$19[ebp]
  00bae	89 45 88	 mov	 DWORD PTR _parent$17[ebp], eax

; 550  : 					child = point0;

  00bb1	8b 45 94	 mov	 eax, DWORD PTR _point0$20[ebp]
  00bb4	89 45 84	 mov	 DWORD PTR _child$16[ebp], eax
$LN88@parse_wayp:

; 551  : 				}
; 552  : 	
; 553  : 				if ( add_node_flag )

  00bb7	83 7d 8c 00	 cmp	 DWORD PTR _add_node_flag$18[ebp], 0
  00bbb	0f 84 0d 01 00
	00		 je	 $LN89@parse_wayp

; 554  : 				{
; 555  : 	
; 556  : 					int
; 557  : 						number_of_children,
; 558  : 						number_of_parents;
; 559  : 	
; 560  : 					number_of_children = waypoint_nodes[parent].number_of_children;

  00bc1	69 45 88 f8 00
	00 00		 imul	 eax, DWORD PTR _parent$17[ebp], 248
  00bc8	8b 88 0c 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+12]
  00bce	89 4d 80	 mov	 DWORD PTR _number_of_children$15[ebp], ecx

; 561  : 					number_of_parents = waypoint_nodes[child].number_of_parents;

  00bd1	69 45 84 f8 00
	00 00		 imul	 eax, DWORD PTR _child$16[ebp], 248
  00bd8	8b 88 10 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+16]
  00bde	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _number_of_parents$14[ebp], ecx

; 562  : 	
; 563  : 					waypoint_nodes[parent].children[number_of_children] = &waypoint_nodes[child];

  00be4	69 45 84 f8 00
	00 00		 imul	 eax, DWORD PTR _child$16[ebp], 248
  00beb	05 00 00 00 00	 add	 eax, OFFSET ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A ; waypoint_nodes
  00bf0	69 4d 88 f8 00
	00 00		 imul	 ecx, DWORD PTR _parent$17[ebp], 248
  00bf7	8b 55 80	 mov	 edx, DWORD PTR _number_of_children$15[ebp]
  00bfa	89 84 91 98 00
	00 00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[ecx+edx*4+152], eax

; 564  : 					waypoint_nodes[parent].number_of_children++;

  00c01	69 45 88 f8 00
	00 00		 imul	 eax, DWORD PTR _parent$17[ebp], 248
  00c08	8b 88 0c 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+12]
  00c0e	83 c1 01	 add	 ecx, 1
  00c11	69 55 88 f8 00
	00 00		 imul	 edx, DWORD PTR _parent$17[ebp], 248
  00c18	89 8a 0c 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[edx+12], ecx

; 565  : 	
; 566  : 					waypoint_nodes[child].parents[number_of_parents] = &waypoint_nodes[parent];

  00c1e	69 45 88 f8 00
	00 00		 imul	 eax, DWORD PTR _parent$17[ebp], 248
  00c25	05 00 00 00 00	 add	 eax, OFFSET ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A ; waypoint_nodes
  00c2a	69 4d 84 f8 00
	00 00		 imul	 ecx, DWORD PTR _child$16[ebp], 248
  00c31	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _number_of_parents$14[ebp]
  00c37	89 84 91 38 00
	00 00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[ecx+edx*4+56], eax

; 567  : 					waypoint_nodes[child].number_of_parents++;

  00c3e	69 45 84 f8 00
	00 00		 imul	 eax, DWORD PTR _child$16[ebp], 248
  00c45	8b 88 10 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+16]
  00c4b	83 c1 01	 add	 ecx, 1
  00c4e	69 55 84 f8 00
	00 00		 imul	 edx, DWORD PTR _child$16[ebp], 248
  00c55	89 8a 10 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[edx+16], ecx

; 568  : 					waypoint_nodes[child].in_route = TRUE;

  00c5b	69 45 84 f8 00
	00 00		 imul	 eax, DWORD PTR _child$16[ebp], 248
  00c62	c7 80 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+36], 1

; 569  : 					waypoint_nodes[child].tree_depth = waypoint_nodes[parent].tree_depth+1;

  00c6c	69 45 88 f8 00
	00 00		 imul	 eax, DWORD PTR _parent$17[ebp], 248
  00c73	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax]
  00c79	83 c1 01	 add	 ecx, 1
  00c7c	69 55 84 f8 00
	00 00		 imul	 edx, DWORD PTR _child$16[ebp], 248
  00c83	89 8a 00 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[edx], ecx

; 570  : 					waypoint_nodes[child].tree_number = waypoint_nodes[parent].tree_number;

  00c89	69 45 88 f8 00
	00 00		 imul	 eax, DWORD PTR _parent$17[ebp], 248
  00c90	69 4d 84 f8 00
	00 00		 imul	 ecx, DWORD PTR _child$16[ebp], 248
  00c97	8b 90 04 00 00
	00		 mov	 edx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+4]
  00c9d	89 91 04 00 00
	00		 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[ecx+4], edx

; 571  : 	
; 572  : 					if ( waypoint_nodes[child].tree_depth > maximum_tree_depth )

  00ca3	69 45 84 f8 00
	00 00		 imul	 eax, DWORD PTR _child$16[ebp], 248
  00caa	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax]
  00cb0	3b 4d e8	 cmp	 ecx, DWORD PTR _maximum_tree_depth$[ebp]
  00cb3	7e 10		 jle	 SHORT $LN90@parse_wayp

; 573  : 					{
; 574  : 	
; 575  : 						maximum_tree_depth = waypoint_nodes[child].tree_depth;

  00cb5	69 45 84 f8 00
	00 00		 imul	 eax, DWORD PTR _child$16[ebp], 248
  00cbc	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax]
  00cc2	89 4d e8	 mov	 DWORD PTR _maximum_tree_depth$[ebp], ecx
$LN90@parse_wayp:

; 576  : 					}
; 577  : 	
; 578  : 					number_of_nodes_left--;

  00cc5	8b 45 f0	 mov	 eax, DWORD PTR _number_of_nodes_left$[ebp]
  00cc8	83 e8 01	 sub	 eax, 1
  00ccb	89 45 f0	 mov	 DWORD PTR _number_of_nodes_left$[ebp], eax
$LN89@parse_wayp:

; 579  : 				}
; 580  : 	
; 581  : 				point_refs += 2;

  00cce	8b 45 e0	 mov	 eax, DWORD PTR _point_refs$[ebp]
  00cd1	83 c0 02	 add	 eax, 2
  00cd4	89 45 e0	 mov	 DWORD PTR _point_refs$[ebp], eax

; 582  : 			}

  00cd7	e9 0f fe ff ff	 jmp	 $LN36@parse_wayp
$LN37@parse_wayp:

; 583  : 
; 584  : 			surface_point_refs += number_of_surface_points;

  00cdc	8b 45 98	 mov	 eax, DWORD PTR _number_of_surface_points$21[ebp]
  00cdf	8b 4d dc	 mov	 ecx, DWORD PTR _surface_point_refs$[ebp]
  00ce2	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00ce5	89 55 dc	 mov	 DWORD PTR _surface_point_refs$[ebp], edx

; 585  : 		}

  00ce8	e9 ab fd ff ff	 jmp	 $LN33@parse_wayp
$LN34@parse_wayp:

; 586  : 	}

  00ced	e9 71 fd ff ff	 jmp	 $LN24@parse_wayp
$LN32@parse_wayp:

; 587  : 
; 588  : 	//
; 589  : 	// Rearrange the starting nodes depending on which one is the primary one
; 590  : 	//
; 591  : 
; 592  : 	for ( count = 0; count < number_of_waypoint_nodes; count++ )

  00cf2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00cf9	eb 09		 jmp	 SHORT $LN41@parse_wayp
$LN39@parse_wayp:
  00cfb	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00cfe	83 c0 01	 add	 eax, 1
  00d01	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN41@parse_wayp:
  00d04	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00d07	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  00d0d	7d 5e		 jge	 SHORT $LN40@parse_wayp

; 593  : 	{
; 594  : 
; 595  : 		if ( waypoint_nodes[count].primary )

  00d0f	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00d16	83 b8 14 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+20], 0
  00d1d	74 4c		 je	 SHORT $LN43@parse_wayp

; 596  : 		{
; 597  : 
; 598  : 			waypoint_node
; 599  : 				*this_node;
; 600  : 
; 601  : 			//
; 602  : 			// Follow route up to top
; 603  : 			//
; 604  : 
; 605  : 			this_node = waypoint_nodes[count].parents[0];

  00d1f	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00d26	b9 04 00 00 00	 mov	 ecx, 4
  00d2b	6b d1 00	 imul	 edx, ecx, 0
  00d2e	8b 84 10 38 00
	00 00		 mov	 eax, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+edx+56]
  00d35	89 85 78 ff ff
	ff		 mov	 DWORD PTR _this_node$13[ebp], eax
$LN42@parse_wayp:

; 606  : 
; 607  : 			while ( this_node )

  00d3b	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR _this_node$13[ebp], 0
  00d42	74 27		 je	 SHORT $LN43@parse_wayp

; 608  : 			{
; 609  : 
; 610  : 				this_node->primary = TRUE;

  00d44	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _this_node$13[ebp]
  00d4a	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [eax+20], 1

; 611  : 
; 612  : 				this_node = this_node->parents[0];

  00d51	b8 04 00 00 00	 mov	 eax, 4
  00d56	6b c8 00	 imul	 ecx, eax, 0
  00d59	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _this_node$13[ebp]
  00d5f	8b 44 0a 38	 mov	 eax, DWORD PTR [edx+ecx+56]
  00d63	89 85 78 ff ff
	ff		 mov	 DWORD PTR _this_node$13[ebp], eax

; 613  : 			}

  00d69	eb d0		 jmp	 SHORT $LN42@parse_wayp
$LN43@parse_wayp:

; 614  : 		}
; 615  : 	}

  00d6b	eb 8e		 jmp	 SHORT $LN39@parse_wayp
$LN40@parse_wayp:

; 616  : 
; 617  : 	if ( !waypoint_starting_nodes[0]->primary )

  00d6d	b8 04 00 00 00	 mov	 eax, 4
  00d72	6b c8 00	 imul	 ecx, eax, 0
  00d75	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[ecx]
  00d7b	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  00d7f	75 7a		 jne	 SHORT $LN92@parse_wayp

; 618  : 	{
; 619  : 
; 620  : 		int
; 621  : 			primary_start_index;
; 622  : 
; 623  : 		waypoint_node
; 624  : 			*tmp;
; 625  : 
; 626  : 		for ( count = 1; count < number_of_waypoint_starting_nodes; count++ )

  00d81	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _count$[ebp], 1
  00d88	eb 09		 jmp	 SHORT $LN46@parse_wayp
$LN44@parse_wayp:
  00d8a	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00d8d	83 c0 01	 add	 eax, 1
  00d90	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN46@parse_wayp:
  00d93	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00d96	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_starting_nodes@@3HA ; number_of_waypoint_starting_nodes
  00d9c	7d 1b		 jge	 SHORT $LN45@parse_wayp

; 627  : 		{
; 628  : 
; 629  : 			if ( waypoint_starting_nodes[count]->primary )

  00d9e	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00da1	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[eax*4]
  00da8	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00dac	74 09		 je	 SHORT $LN93@parse_wayp

; 630  : 			{
; 631  : 
; 632  : 				primary_start_index = count;

  00dae	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00db1	89 85 74 ff ff
	ff		 mov	 DWORD PTR _primary_start_index$12[ebp], eax
$LN93@parse_wayp:

; 633  : 			}
; 634  : 		}

  00db7	eb d1		 jmp	 SHORT $LN44@parse_wayp
$LN45@parse_wayp:

; 635  : 
; 636  : 
; 637  : 		tmp = waypoint_starting_nodes[0];

  00db9	b8 04 00 00 00	 mov	 eax, 4
  00dbe	6b c8 00	 imul	 ecx, eax, 0
  00dc1	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[ecx]
  00dc7	89 95 70 ff ff
	ff		 mov	 DWORD PTR _tmp$11[ebp], edx

; 638  : 		waypoint_starting_nodes[0] = waypoint_starting_nodes[primary_start_index];

  00dcd	b8 04 00 00 00	 mov	 eax, 4
  00dd2	6b c8 00	 imul	 ecx, eax, 0
  00dd5	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _primary_start_index$12[ebp]
  00ddb	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[edx*4]
  00de2	89 81 00 00 00
	00		 mov	 DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[ecx], eax

; 639  : 		waypoint_starting_nodes[primary_start_index] = tmp;

  00de8	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _primary_start_index$12[ebp]
  00dee	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _tmp$11[ebp]
  00df4	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[eax*4], ecx
$LN92@parse_wayp:

; 640  : 	}
; 641  : 
; 642  : 	//
; 643  : 	// Go through each tree setting the main route node index
; 644  : 	//
; 645  : 
; 646  : 	for ( count = 0; count < number_of_waypoint_starting_nodes; count++ )

  00dfb	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00e02	eb 09		 jmp	 SHORT $LN49@parse_wayp
$LN47@parse_wayp:
  00e04	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00e07	83 c0 01	 add	 eax, 1
  00e0a	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN49@parse_wayp:
  00e0d	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00e10	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_starting_nodes@@3HA ; number_of_waypoint_starting_nodes
  00e16	7d 44		 jge	 SHORT $LN48@parse_wayp

; 647  : 	{
; 648  : 
; 649  : 		waypoint_node
; 650  : 			*this_node;
; 651  : 
; 652  : 		this_node = waypoint_starting_nodes[count];

  00e18	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00e1b	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[eax*4]
  00e22	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _this_node$10[ebp], ecx
$LN50@parse_wayp:

; 653  : 
; 654  : 		while ( this_node )

  00e28	83 bd 6c ff ff
	ff 00		 cmp	 DWORD PTR _this_node$10[ebp], 0
  00e2f	74 29		 je	 SHORT $LN51@parse_wayp

; 655  : 		{
; 656  : 
; 657  : 			this_node->node_index = count;

  00e31	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this_node$10[ebp]
  00e37	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  00e3a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 658  : 
; 659  : 			this_node = this_node->children[0];

  00e3d	b8 04 00 00 00	 mov	 eax, 4
  00e42	6b c8 00	 imul	 ecx, eax, 0
  00e45	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _this_node$10[ebp]
  00e4b	8b 84 0a 98 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+152]
  00e52	89 85 6c ff ff
	ff		 mov	 DWORD PTR _this_node$10[ebp], eax

; 660  : 		}

  00e58	eb ce		 jmp	 SHORT $LN50@parse_wayp
$LN51@parse_wayp:

; 661  : 	}

  00e5a	eb a8		 jmp	 SHORT $LN47@parse_wayp
$LN48@parse_wayp:

; 662  : 
; 663  : 	//
; 664  : 	// Set all the other node indices
; 665  : 	//
; 666  : 
; 667  : 	set_node_indices ();

  00e5c	e8 00 00 00 00	 call	 ?set_node_indices@@YGXXZ ; set_node_indices

; 668  : 
; 669  : 	if ( number_of_matching_slots )

  00e61	83 7d 0c 00	 cmp	 DWORD PTR _number_of_matching_slots$[ebp], 0
  00e65	74 11		 je	 SHORT $LN94@parse_wayp

; 670  : 	{
; 671  : 
; 672  : 		match_end_slots ( maximum_tree_depth, number_of_matching_slots, slots );

  00e67	8b 45 10	 mov	 eax, DWORD PTR _slots$[ebp]
  00e6a	50		 push	 eax
  00e6b	8b 4d 0c	 mov	 ecx, DWORD PTR _number_of_matching_slots$[ebp]
  00e6e	51		 push	 ecx
  00e6f	8b 55 e8	 mov	 edx, DWORD PTR _maximum_tree_depth$[ebp]
  00e72	52		 push	 edx
  00e73	e8 00 00 00 00	 call	 ?match_end_slots@@YGXHHPAUVEC3D@@@Z ; match_end_slots
$LN94@parse_wayp:

; 673  : 	}
; 674  : 
; 675  : 	//
; 676  : 	// Construct the table of vec3d stuff
; 677  : 	//
; 678  : 
; 679  : 	number_of_route_waypoint_positions = maximum_tree_depth + 1;

  00e78	8b 45 e8	 mov	 eax, DWORD PTR _maximum_tree_depth$[ebp]
  00e7b	83 c0 01	 add	 eax, 1
  00e7e	a3 00 00 00 00	 mov	 DWORD PTR ?number_of_route_waypoint_positions@@3HA, eax ; number_of_route_waypoint_positions

; 680  : 
; 681  : 	route_waypoint_positions = ( route_waypoint_position * ) safe_malloc ( number_of_route_waypoint_positions * sizeof ( route_waypoint_position ) );

  00e83	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?number_of_route_waypoint_positions@@3HA, 20 ; number_of_route_waypoint_positions
  00e8a	50		 push	 eax
  00e8b	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00e90	a3 00 00 00 00	 mov	 DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A, eax ; route_waypoint_positions

; 682  : 
; 683  : 	memset ( route_waypoint_positions, 0, ( number_of_route_waypoint_positions * sizeof ( route_waypoint_position ) ) );

  00e95	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR ?number_of_route_waypoint_positions@@3HA, 20 ; number_of_route_waypoint_positions
  00e9c	50		 push	 eax
  00e9d	6a 00		 push	 0
  00e9f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  00ea5	51		 push	 ecx
  00ea6	e8 00 00 00 00	 call	 _memset
  00eab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 684  : 
; 685  : 	for ( current_depth = 0; current_depth <= maximum_tree_depth; current_depth++ )

  00eae	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _current_depth$[ebp], 0
  00eb5	eb 09		 jmp	 SHORT $LN54@parse_wayp
$LN52@parse_wayp:
  00eb7	8b 45 e4	 mov	 eax, DWORD PTR _current_depth$[ebp]
  00eba	83 c0 01	 add	 eax, 1
  00ebd	89 45 e4	 mov	 DWORD PTR _current_depth$[ebp], eax
$LN54@parse_wayp:
  00ec0	8b 45 e4	 mov	 eax, DWORD PTR _current_depth$[ebp]
  00ec3	3b 45 e8	 cmp	 eax, DWORD PTR _maximum_tree_depth$[ebp]
  00ec6	0f 8f 71 01 00
	00		 jg	 $LN53@parse_wayp

; 686  : 	{
; 687  : 
; 688  : 		int
; 689  : 			finished,
; 690  : 			number_of_nodes,
; 691  : 			node_index;
; 692  : 
; 693  : 		finished = FALSE;

  00ecc	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _finished$9[ebp], 0

; 694  : 
; 695  : 		node_index = 0;

  00ed6	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _node_index$7[ebp], 0

; 696  : 
; 697  : 		number_of_nodes = get_number_of_nodes_at_depth ( current_depth );

  00ee0	8b 45 e4	 mov	 eax, DWORD PTR _current_depth$[ebp]
  00ee3	50		 push	 eax
  00ee4	e8 00 00 00 00	 call	 ?get_number_of_nodes_at_depth@@YGHH@Z ; get_number_of_nodes_at_depth
  00ee9	89 85 64 ff ff
	ff		 mov	 DWORD PTR _number_of_nodes$8[ebp], eax

; 698  : 
; 699  : 		route_waypoint_positions[current_depth].number_of_positions = number_of_nodes;

  00eef	6b 45 e4 14	 imul	 eax, DWORD PTR _current_depth$[ebp], 20
  00ef3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  00ef9	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _number_of_nodes$8[ebp]
  00eff	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 700  : 
; 701  : 		route_waypoint_positions[current_depth].offsets = ( vec3d * ) safe_malloc ( number_of_nodes * sizeof ( vec3d ) );

  00f02	6b 85 64 ff ff
	ff 0c		 imul	 eax, DWORD PTR _number_of_nodes$8[ebp], 12
  00f09	50		 push	 eax
  00f0a	e8 00 00 00 00	 call	 ?safe_malloc_memory@@YGPAXI@Z ; safe_malloc_memory
  00f0f	6b 4d e4 14	 imul	 ecx, DWORD PTR _current_depth$[ebp], 20
  00f13	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  00f19	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax
$LN55@parse_wayp:

; 702  : 
; 703  : 		while ( number_of_nodes )

  00f1d	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _number_of_nodes$8[ebp], 0
  00f24	0f 84 0e 01 00
	00		 je	 $LN56@parse_wayp

; 704  : 		{
; 705  : 
; 706  : 			for ( count = 0; count < number_of_waypoint_nodes; count++ )

  00f2a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00f31	eb 09		 jmp	 SHORT $LN59@parse_wayp
$LN57@parse_wayp:
  00f33	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00f36	83 c0 01	 add	 eax, 1
  00f39	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN59@parse_wayp:
  00f3c	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00f3f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_waypoint_nodes@@3HA ; number_of_waypoint_nodes
  00f45	0f 8d e8 00 00
	00		 jge	 $LN58@parse_wayp

; 707  : 			{
; 708  : 
; 709  : 				if (	( waypoint_nodes[count].tree_depth == current_depth ) &&
; 710  : 						( waypoint_nodes[count].node_index == node_index ) &&

  00f4b	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00f52	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax]
  00f58	3b 4d e4	 cmp	 ecx, DWORD PTR _current_depth$[ebp]
  00f5b	0f 85 cd 00 00
	00		 jne	 $LN95@parse_wayp
  00f61	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00f68	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+8]
  00f6e	3b 8d 60 ff ff
	ff		 cmp	 ecx, DWORD PTR _node_index$7[ebp]
  00f74	0f 85 b4 00 00
	00		 jne	 $LN95@parse_wayp
  00f7a	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00f81	83 b8 28 00 00
	00 00		 cmp	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+40], 0
  00f88	0f 85 a0 00 00
	00		 jne	 $LN95@parse_wayp

; 711  : 						( !waypoint_nodes[count].processed ) )
; 712  : 				{
; 713  : 
; 714  : 					route_waypoint_positions[current_depth].offsets[node_index].x = waypoint_nodes[count].position.x;

  00f8e	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00f95	6b 4d e4 14	 imul	 ecx, DWORD PTR _current_depth$[ebp], 20
  00f99	6b 95 60 ff ff
	ff 0c		 imul	 edx, DWORD PTR _node_index$7[ebp], 12
  00fa0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  00fa6	8b 4c 0e 10	 mov	 ecx, DWORD PTR [esi+ecx+16]
  00faa	8b 80 2c 00 00
	00		 mov	 eax, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+44]
  00fb0	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 715  : 					route_waypoint_positions[current_depth].offsets[node_index].y = waypoint_nodes[count].position.y;

  00fb3	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00fba	6b 4d e4 14	 imul	 ecx, DWORD PTR _current_depth$[ebp], 20
  00fbe	6b 95 60 ff ff
	ff 0c		 imul	 edx, DWORD PTR _node_index$7[ebp], 12
  00fc5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  00fcb	8b 4c 0e 10	 mov	 ecx, DWORD PTR [esi+ecx+16]
  00fcf	8b 80 30 00 00
	00		 mov	 eax, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+48]
  00fd5	89 44 11 04	 mov	 DWORD PTR [ecx+edx+4], eax

; 716  : 					route_waypoint_positions[current_depth].offsets[node_index].z = waypoint_nodes[count].position.z;

  00fd9	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  00fe0	6b 4d e4 14	 imul	 ecx, DWORD PTR _current_depth$[ebp], 20
  00fe4	6b 95 60 ff ff
	ff 0c		 imul	 edx, DWORD PTR _node_index$7[ebp], 12
  00feb	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  00ff1	8b 4c 0e 10	 mov	 ecx, DWORD PTR [esi+ecx+16]
  00ff5	8b 80 34 00 00
	00		 mov	 eax, DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+52]
  00ffb	89 44 11 08	 mov	 DWORD PTR [ecx+edx+8], eax

; 717  : 
; 718  : 					waypoint_nodes[count].processed = TRUE;

  00fff	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 248
  01006	c7 80 28 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?waypoint_nodes@@3PAUWAYPOINT_NODE@@A[eax+40], 1

; 719  : 
; 720  : 					node_index++;

  01010	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _node_index$7[ebp]
  01016	83 c0 01	 add	 eax, 1
  01019	89 85 60 ff ff
	ff		 mov	 DWORD PTR _node_index$7[ebp], eax

; 721  : 
; 722  : 					number_of_nodes--;

  0101f	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _number_of_nodes$8[ebp]
  01025	83 e8 01	 sub	 eax, 1
  01028	89 85 64 ff ff
	ff		 mov	 DWORD PTR _number_of_nodes$8[ebp], eax
$LN95@parse_wayp:

; 723  : 				}
; 724  : 			}

  0102e	e9 00 ff ff ff	 jmp	 $LN57@parse_wayp
$LN58@parse_wayp:

; 725  : 		}

  01033	e9 e5 fe ff ff	 jmp	 $LN55@parse_wayp
$LN56@parse_wayp:

; 726  : 	}

  01038	e9 7a fe ff ff	 jmp	 $LN52@parse_wayp
$LN53@parse_wayp:

; 727  : 
; 728  : 	//
; 729  : 	// Turn all the offsets to relative positions
; 730  : 	//
; 731  : 
; 732  : 	for ( current_depth = 0; current_depth <= maximum_tree_depth; current_depth++ )

  0103d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _current_depth$[ebp], 0
  01044	eb 09		 jmp	 SHORT $LN62@parse_wayp
$LN60@parse_wayp:
  01046	8b 45 e4	 mov	 eax, DWORD PTR _current_depth$[ebp]
  01049	83 c0 01	 add	 eax, 1
  0104c	89 45 e4	 mov	 DWORD PTR _current_depth$[ebp], eax
$LN62@parse_wayp:
  0104f	8b 45 e4	 mov	 eax, DWORD PTR _current_depth$[ebp]
  01052	3b 45 e8	 cmp	 eax, DWORD PTR _maximum_tree_depth$[ebp]
  01055	0f 8f 26 01 00
	00		 jg	 $LN61@parse_wayp

; 733  : 	{
; 734  : 
; 735  : 		route_waypoint_positions[current_depth].position = route_waypoint_positions[current_depth].offsets[0];

  0105b	6b 45 e4 14	 imul	 eax, DWORD PTR _current_depth$[ebp], 20
  0105f	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  01064	6b d1 00	 imul	 edx, ecx, 0
  01067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  0106d	8b 44 01 10	 mov	 eax, DWORD PTR [ecx+eax+16]
  01071	03 c2		 add	 eax, edx
  01073	6b 4d e4 14	 imul	 ecx, DWORD PTR _current_depth$[ebp], 20
  01077	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  0107d	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  01081	8b 10		 mov	 edx, DWORD PTR [eax]
  01083	89 11		 mov	 DWORD PTR [ecx], edx
  01085	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01088	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0108b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0108e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 736  : 
; 737  : 		for ( count = 0; count < route_waypoint_positions[current_depth].number_of_positions; count++ )

  01091	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  01098	eb 09		 jmp	 SHORT $LN65@parse_wayp
$LN63@parse_wayp:
  0109a	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0109d	83 c0 01	 add	 eax, 1
  010a0	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN65@parse_wayp:
  010a3	6b 45 e4 14	 imul	 eax, DWORD PTR _current_depth$[ebp], 20
  010a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  010ad	8b 55 f8	 mov	 edx, DWORD PTR _count$[ebp]
  010b0	3b 14 01	 cmp	 edx, DWORD PTR [ecx+eax]
  010b3	0f 8d c3 00 00
	00		 jge	 $LN64@parse_wayp

; 738  : 		{
; 739  : 
; 740  : 			route_waypoint_positions[current_depth].offsets[count].x -= route_waypoint_positions[current_depth].position.x;

  010b9	6b 45 e4 14	 imul	 eax, DWORD PTR _current_depth$[ebp], 20
  010bd	6b 4d f8 0c	 imul	 ecx, DWORD PTR _count$[ebp], 12
  010c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  010c7	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  010cb	6b 55 e4 14	 imul	 edx, DWORD PTR _current_depth$[ebp], 20
  010cf	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  010d5	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  010da	f3 0f 5c 44 16
	04		 subss	 xmm0, DWORD PTR [esi+edx+4]
  010e0	6b 45 e4 14	 imul	 eax, DWORD PTR _current_depth$[ebp], 20
  010e4	6b 4d f8 0c	 imul	 ecx, DWORD PTR _count$[ebp], 12
  010e8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  010ee	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  010f2	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 741  : 			route_waypoint_positions[current_depth].offsets[count].y -= route_waypoint_positions[current_depth].position.y;

  010f7	6b 45 e4 14	 imul	 eax, DWORD PTR _current_depth$[ebp], 20
  010fb	6b 4d f8 0c	 imul	 ecx, DWORD PTR _count$[ebp], 12
  010ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  01105	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  01109	6b 55 e4 14	 imul	 edx, DWORD PTR _current_depth$[ebp], 20
  0110d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  01113	f3 0f 10 44 08
	04		 movss	 xmm0, DWORD PTR [eax+ecx+4]
  01119	f3 0f 5c 44 16
	08		 subss	 xmm0, DWORD PTR [esi+edx+8]
  0111f	6b 45 e4 14	 imul	 eax, DWORD PTR _current_depth$[ebp], 20
  01123	6b 4d f8 0c	 imul	 ecx, DWORD PTR _count$[ebp], 12
  01127	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  0112d	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  01131	f3 0f 11 44 08
	04		 movss	 DWORD PTR [eax+ecx+4], xmm0

; 742  : 			route_waypoint_positions[current_depth].offsets[count].z -= route_waypoint_positions[current_depth].position.z;

  01137	6b 45 e4 14	 imul	 eax, DWORD PTR _current_depth$[ebp], 20
  0113b	6b 4d f8 0c	 imul	 ecx, DWORD PTR _count$[ebp], 12
  0113f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  01145	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  01149	6b 55 e4 14	 imul	 edx, DWORD PTR _current_depth$[ebp], 20
  0114d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  01153	f3 0f 10 44 08
	08		 movss	 xmm0, DWORD PTR [eax+ecx+8]
  01159	f3 0f 5c 44 16
	0c		 subss	 xmm0, DWORD PTR [esi+edx+12]
  0115f	6b 45 e4 14	 imul	 eax, DWORD PTR _current_depth$[ebp], 20
  01163	6b 4d f8 0c	 imul	 ecx, DWORD PTR _count$[ebp], 12
  01167	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  0116d	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  01171	f3 0f 11 44 08
	08		 movss	 DWORD PTR [eax+ecx+8], xmm0

; 743  : 		}

  01177	e9 1e ff ff ff	 jmp	 $LN63@parse_wayp
$LN64@parse_wayp:

; 744  : 	}

  0117c	e9 c5 fe ff ff	 jmp	 $LN60@parse_wayp
$LN61@parse_wayp:

; 745  : /*
; 746  : 	for ( current_depth = 0; current_depth < maximum_tree_depth; current_depth++ )
; 747  : 	{
; 748  : 
; 749  : 		debug_log ( "Node %d ( %d ) : %f, %f, %f", current_depth,
; 750  : 							route_waypoint_positions[current_depth].number_of_positions,
; 751  : 							route_waypoint_positions[current_depth].position.x,
; 752  : 							route_waypoint_positions[current_depth].position.y,
; 753  : 							route_waypoint_positions[current_depth].position.z );
; 754  : 
; 755  : 		for ( count = 0; count < route_waypoint_positions[current_depth].number_of_positions; count++ )
; 756  : 		{
; 757  : 
; 758  : 			debug_log ( "%f %f %f",
; 759  : 						route_waypoint_positions[current_depth].offsets[count].x,
; 760  : 						route_waypoint_positions[current_depth].offsets[count].y,
; 761  : 						route_waypoint_positions[current_depth].offsets[count].z );
; 762  : 		}
; 763  : 	}
; 764  : 	*/
; 765  : }

  01181	5f		 pop	 edi
  01182	5e		 pop	 esi
  01183	5b		 pop	 ebx
  01184	8b e5		 mov	 esp, ebp
  01186	5d		 pop	 ebp
  01187	c2 0c 00	 ret	 12			; 0000000cH
?parse_waypoint_routes_from_object@@YGXHHPAUVEC3D@@@Z ENDP ; parse_waypoint_routes_from_object
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\users\nhv90\projects\eech\aphavoc\source\ai\faction\routegen.c
;	COMDAT ?destroy_routegen_waypoint_routes@@YGXXZ
_TEXT	SEGMENT
_count$ = -4						; size = 4
?destroy_routegen_waypoint_routes@@YGXXZ PROC		; destroy_routegen_waypoint_routes, COMDAT

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 157  : 
; 158  : 	int
; 159  : 		count;
; 160  : 
; 161  : 	if ( number_of_route_waypoint_positions )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?number_of_route_waypoint_positions@@3HA, 0 ; number_of_route_waypoint_positions
  00010	74 52		 je	 SHORT $LN8@destroy_ro

; 162  : 	{
; 163  : 
; 164  : 		for ( count = 0; count < number_of_route_waypoint_positions; count++ )

  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00019	eb 09		 jmp	 SHORT $LN4@destroy_ro
$LN2@destroy_ro:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0001e	83 c0 01	 add	 eax, 1
  00021	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN4@destroy_ro:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00027	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?number_of_route_waypoint_positions@@3HA ; number_of_route_waypoint_positions
  0002d	7d 16		 jge	 SHORT $LN3@destroy_ro

; 165  : 		{
; 166  : 
; 167  : 			safe_free ( route_waypoint_positions[count].offsets );

  0002f	6b 45 fc 14	 imul	 eax, DWORD PTR _count$[ebp], 20
  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  00039	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 168  : 		}

  00043	eb d6		 jmp	 SHORT $LN2@destroy_ro
$LN3@destroy_ro:

; 169  : 
; 170  : 		safe_free ( route_waypoint_positions );

  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A ; route_waypoint_positions
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?safe_free@@YGXPAX@Z	; safe_free

; 171  : 
; 172  : 		route_waypoint_positions = NULL;

  00050	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?route_waypoint_positions@@3PAUROUTE_WAYPOINT_POSITION@@A, 0 ; route_waypoint_positions

; 173  : 
; 174  : 		number_of_route_waypoint_positions = 0;

  0005a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?number_of_route_waypoint_positions@@3HA, 0 ; number_of_route_waypoint_positions
$LN8@destroy_ro:

; 175  : 	}
; 176  : 
; 177  : 	number_of_waypoint_starting_nodes = 0;

  00064	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?number_of_waypoint_starting_nodes@@3HA, 0 ; number_of_waypoint_starting_nodes

; 178  : 
; 179  : 	for ( count = 0; count < MAX_WAYPOINT_STARTS; count++ )

  0006e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00075	eb 09		 jmp	 SHORT $LN7@destroy_ro
$LN5@destroy_ro:
  00077	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0007a	83 c0 01	 add	 eax, 1
  0007d	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN7@destroy_ro:
  00080	83 7d fc 18	 cmp	 DWORD PTR _count$[ebp], 24 ; 00000018H
  00084	7d 10		 jge	 SHORT $LN1@destroy_ro

; 180  : 	{
; 181  : 
; 182  : 		waypoint_starting_nodes[count] = NULL;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00089	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?waypoint_starting_nodes@@3PAPAUWAYPOINT_NODE@@A[eax*4], 0

; 183  : 	}

  00094	eb e1		 jmp	 SHORT $LN5@destroy_ro
$LN1@destroy_ro:

; 184  : }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
?destroy_routegen_waypoint_routes@@YGXXZ ENDP		; destroy_routegen_waypoint_routes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?sqrt@@YGMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?sqrt@@YGMM@Z PROC					; sqrt, COMDAT

; 294  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 295  : 	return (_CSTD sqrtf(_Xx));

  00009	51		 push	 ecx
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
  0000f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00014	e8 00 00 00 00	 call	 _sqrtf
  00019	83 c4 04	 add	 esp, 4

; 296  : 	}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?sqrt@@YGMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?fabs@@YGMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?fabs@@YGMM@Z PROC					; fabs, COMDAT

; 112  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 113  : 	return (_CSTD fabsf(_Xx));

  00009	51		 push	 ecx
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
  0000f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00014	e8 00 00 00 00	 call	 _fabsf
  00019	83 c4 04	 add	 esp, 4

; 114  : 	}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?fabs@@YGMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv71 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 759  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 760  :             return (float)sqrt(_X);

  00009	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0000e	83 ec 08	 sub	 esp, 8
  00011	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00016	e8 00 00 00 00	 call	 _sqrt
  0001b	83 c4 08	 add	 esp, 8
  0001e	d9 5d bc	 fstp	 DWORD PTR tv71[ebp]
  00021	d9 45 bc	 fld	 DWORD PTR tv71[ebp]

; 761  :         }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv71 = -68						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 671  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 672  :             return (float)fabs(_X);

  00009	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0000e	83 ec 08	 sub	 esp, 8
  00011	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00016	e8 00 00 00 00	 call	 _fabs
  0001b	83 c4 08	 add	 esp, 8
  0001e	d9 5d bc	 fstp	 DWORD PTR tv71[ebp]
  00021	d9 45 bc	 fld	 DWORD PTR tv71[ebp]

; 673  :         }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
END
